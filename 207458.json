{"path":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    int ps = precisionStep;\n    Query query = null;\n    switch (type) {\n      case INTEGER:\n        query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    int ps = precisionStep;\n    Query query = null;\n    switch (type) {\n      case INTEGER:\n        query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    int ps = precisionStep;\n    Query query = null;\n    switch (type) {\n      case INTEGER:\n        query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    int ps = precisionStep;\n    Query query = null;\n    switch (type) {\n      case INTEGER:\n        query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    int ps = precisionStep;\n    Query query = null;\n    switch (type) {\n      case INTEGER:\n        query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    int ps = precisionStep;\n    Query query = null;\n    switch (type) {\n      case INTEGER:\n        query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ffced88b5e83e2ec0a42723404a647e766d96b8c","date":1361398349,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    int ps = precisionStep;\n    Query query = null;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newIntRange(field.getName(),\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newFloatRange(field.getName(),\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newDoubleRange(field.getName(),\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newLongRange(field.getName(),\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    int ps = precisionStep;\n    Query query = null;\n    switch (type) {\n      case INTEGER:\n        query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":["9274621789ce990dbfef455dabdf026bb3184821","9274621789ce990dbfef455dabdf026bb3184821","9274621789ce990dbfef455dabdf026bb3184821","9274621789ce990dbfef455dabdf026bb3184821","9274621789ce990dbfef455dabdf026bb3184821"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3","date":1361894345,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query = null;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newIntRange(field.getName(),\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newFloatRange(field.getName(),\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newDoubleRange(field.getName(),\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newLongRange(field.getName(),\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    int ps = precisionStep;\n    Query query = null;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newIntRange(field.getName(),\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newFloatRange(field.getName(),\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newDoubleRange(field.getName(),\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newLongRange(field.getName(),\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9274621789ce990dbfef455dabdf026bb3184821","date":1400046684,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query = null;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newIntRange(field.getName(),\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newFloatRange(field.getName(),\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newDoubleRange(field.getName(),\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newLongRange(field.getName(),\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query = null;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newIntRange(field.getName(),\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newFloatRange(field.getName(),\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newDoubleRange(field.getName(),\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newLongRange(field.getName(),\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":["ffced88b5e83e2ec0a42723404a647e766d96b8c"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query = null;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newIntRange(field.getName(),\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newFloatRange(field.getName(),\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newDoubleRange(field.getName(),\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newLongRange(field.getName(),\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query = null;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newIntRange(field.getName(),\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newFloatRange(field.getName(),\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newDoubleRange(field.getName(),\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newLongRange(field.getName(),\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query = null;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newIntRange(field.getName(),\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newFloatRange(field.getName(),\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newDoubleRange(field.getName(),\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newLongRange(field.getName(),\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query = null;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newIntRange(field.getName(),\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newFloatRange(field.getName(),\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newDoubleRange(field.getName(),\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(FieldCacheRangeFilter.newLongRange(field.getName(),\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"484e80062d7ab2729bc82f0311d6a97dd913961a","date":1424450206,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query = null;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) Integer.parseInt(min),\n                max == null ? null : (long) Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) NumericUtils.floatToSortableInt(Float.parseFloat(min)),\n                max == null ? null : (long) NumericUtils.floatToSortableInt(Float.parseFloat(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : NumericUtils.doubleToSortableLong(Double.parseDouble(min)),\n                max == null ? null : NumericUtils.doubleToSortableLong(Double.parseDouble(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query = null;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newIntRange(field.getName(),\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newFloatRange(field.getName(),\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newDoubleRange(field.getName(),\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = new ConstantScoreQuery(DocValuesRangeFilter.newLongRange(field.getName(),\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive));\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0c38a05f7a7b43c2dabbd25f12f9941c64bb2331","date":1437383270,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) Integer.parseInt(min),\n                max == null ? null : (long) Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) NumericUtils.floatToSortableInt(Float.parseFloat(min)),\n                max == null ? null : (long) NumericUtils.floatToSortableInt(Float.parseFloat(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : NumericUtils.doubleToSortableLong(Double.parseDouble(min)),\n                max == null ? null : NumericUtils.doubleToSortableLong(Double.parseDouble(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n                max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n                max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query = null;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) Integer.parseInt(min),\n                max == null ? null : (long) Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) NumericUtils.floatToSortableInt(Float.parseFloat(min)),\n                max == null ? null : (long) NumericUtils.floatToSortableInt(Float.parseFloat(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : NumericUtils.doubleToSortableLong(Double.parseDouble(min)),\n                max == null ? null : NumericUtils.doubleToSortableLong(Double.parseDouble(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : dateField.parseMath(null, min).getTime(),\n                max == null ? null : dateField.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) Integer.parseInt(min),\n                max == null ? null : (long) Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n              min == null ? null : Integer.parseInt(min),\n              max == null ? null : Integer.parseInt(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) LegacyNumericUtils.floatToSortableInt(Float.parseFloat(min)),\n                max == null ? null : (long) LegacyNumericUtils.floatToSortableInt(Float.parseFloat(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n              min == null ? null : Float.parseFloat(min),\n              max == null ? null : Float.parseFloat(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : Long.parseLong(min),\n              max == null ? null : Long.parseLong(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : LegacyNumericUtils.doubleToSortableLong(Double.parseDouble(min)),\n                max == null ? null : LegacyNumericUtils.doubleToSortableLong(Double.parseDouble(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n              min == null ? null : Double.parseDouble(min),\n              max == null ? null : Double.parseDouble(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n                max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n              max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n              minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) Integer.parseInt(min),\n                max == null ? null : (long) Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newIntRange(field.getName(), ps,\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) NumericUtils.floatToSortableInt(Float.parseFloat(min)),\n                max == null ? null : (long) NumericUtils.floatToSortableInt(Float.parseFloat(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newFloatRange(field.getName(), ps,\n                min == null ? null : Float.parseFloat(min),\n                max == null ? null : Float.parseFloat(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : NumericUtils.doubleToSortableLong(Double.parseDouble(min)),\n                max == null ? null : NumericUtils.doubleToSortableLong(Double.parseDouble(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newDoubleRange(field.getName(), ps,\n                min == null ? null : Double.parseDouble(min),\n                max == null ? null : Double.parseDouble(max),\n                minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n                max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = NumericRangeQuery.newLongRange(field.getName(), ps,\n                min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n                max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":["a0e7cdd0facd912df00ec53365f98e7c54d6c9bb","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb","date":1457059932,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) Integer.parseInt(min),\n                max == null ? null : (long) Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n              min == null ? null : Integer.parseInt(min),\n              max == null ? null : Integer.parseInt(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) NumericUtils.floatToSortableInt(Float.parseFloat(min)),\n                max == null ? null : (long) NumericUtils.floatToSortableInt(Float.parseFloat(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n              min == null ? null : Float.parseFloat(min),\n              max == null ? null : Float.parseFloat(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : Long.parseLong(min),\n              max == null ? null : Long.parseLong(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : NumericUtils.doubleToSortableLong(Double.parseDouble(min)),\n                max == null ? null : NumericUtils.doubleToSortableLong(Double.parseDouble(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n              min == null ? null : Double.parseDouble(min),\n              max == null ? null : Double.parseDouble(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n                max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n              max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n              minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) Integer.parseInt(min),\n                max == null ? null : (long) Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n              min == null ? null : Integer.parseInt(min),\n              max == null ? null : Integer.parseInt(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) LegacyNumericUtils.floatToSortableInt(Float.parseFloat(min)),\n                max == null ? null : (long) LegacyNumericUtils.floatToSortableInt(Float.parseFloat(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n              min == null ? null : Float.parseFloat(min),\n              max == null ? null : Float.parseFloat(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : Long.parseLong(min),\n              max == null ? null : Long.parseLong(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : LegacyNumericUtils.doubleToSortableLong(Double.parseDouble(min)),\n                max == null ? null : LegacyNumericUtils.doubleToSortableLong(Double.parseDouble(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n              min == null ? null : Double.parseDouble(min),\n              max == null ? null : Double.parseDouble(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n                max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n              max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n              minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":["770342641f7b505eaa8dccdc666158bff2419109"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) Integer.parseInt(min),\n                max == null ? null : (long) Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n              min == null ? null : Integer.parseInt(min),\n              max == null ? null : Integer.parseInt(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) NumericUtils.floatToSortableInt(Float.parseFloat(min)),\n                max == null ? null : (long) NumericUtils.floatToSortableInt(Float.parseFloat(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n              min == null ? null : Float.parseFloat(min),\n              max == null ? null : Float.parseFloat(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : Long.parseLong(min),\n              max == null ? null : Long.parseLong(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : NumericUtils.doubleToSortableLong(Double.parseDouble(min)),\n                max == null ? null : NumericUtils.doubleToSortableLong(Double.parseDouble(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n              min == null ? null : Double.parseDouble(min),\n              max == null ? null : Double.parseDouble(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n                max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n              max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n              minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) Integer.parseInt(min),\n                max == null ? null : (long) Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n              min == null ? null : Integer.parseInt(min),\n              max == null ? null : Integer.parseInt(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) LegacyNumericUtils.floatToSortableInt(Float.parseFloat(min)),\n                max == null ? null : (long) LegacyNumericUtils.floatToSortableInt(Float.parseFloat(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n              min == null ? null : Float.parseFloat(min),\n              max == null ? null : Float.parseFloat(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : Long.parseLong(min),\n              max == null ? null : Long.parseLong(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : LegacyNumericUtils.doubleToSortableLong(Double.parseDouble(min)),\n                max == null ? null : LegacyNumericUtils.doubleToSortableLong(Double.parseDouble(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n              min == null ? null : Double.parseDouble(min),\n              max == null ? null : Double.parseDouble(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n                max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n              max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n              minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5cc22ce99f9ec86f1d1e55d36aaefac498ada97","date":1458507332,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) Integer.parseInt(min),\n                max == null ? null : (long) Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n              min == null ? null : Integer.parseInt(min),\n              max == null ? null : Integer.parseInt(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          return getRangeQueryForFloatDoubleDocValues(field, min, max, minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n              min == null ? null : Float.parseFloat(min),\n              max == null ? null : Float.parseFloat(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : Long.parseLong(min),\n              max == null ? null : Long.parseLong(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          return getRangeQueryForFloatDoubleDocValues(field, min, max, minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n              min == null ? null : Double.parseDouble(min),\n              max == null ? null : Double.parseDouble(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n                max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n              max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n              minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) Integer.parseInt(min),\n                max == null ? null : (long) Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n              min == null ? null : Integer.parseInt(min),\n              max == null ? null : Integer.parseInt(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) NumericUtils.floatToSortableInt(Float.parseFloat(min)),\n                max == null ? null : (long) NumericUtils.floatToSortableInt(Float.parseFloat(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n              min == null ? null : Float.parseFloat(min),\n              max == null ? null : Float.parseFloat(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : Long.parseLong(min),\n              max == null ? null : Long.parseLong(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : NumericUtils.doubleToSortableLong(Double.parseDouble(min)),\n                max == null ? null : NumericUtils.doubleToSortableLong(Double.parseDouble(max)),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n              min == null ? null : Double.parseDouble(min),\n              max == null ? null : Double.parseDouble(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n                max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n              max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n              minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3f6c7717a0f1decd1668144537943efcc70cd95","date":1459359762,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) Integer.parseInt(min),\n                max == null ? null : (long) Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n              min == null ? null : Integer.parseInt(min),\n              max == null ? null : Integer.parseInt(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          return getRangeQueryForFloatDoubleDocValues(field, min, max, minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n              min == null ? null : Float.parseFloat(min),\n              max == null ? null : Float.parseFloat(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : Long.parseLong(min),\n              max == null ? null : Long.parseLong(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          return getRangeQueryForFloatDoubleDocValues(field, min, max, minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n              min == null ? null : Double.parseDouble(min),\n              max == null ? null : Double.parseDouble(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n                max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n              max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n              minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) Integer.parseInt(min),\n                max == null ? null : (long) Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n              min == null ? null : Integer.parseInt(min),\n              max == null ? null : Integer.parseInt(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          return getRangeQueryForFloatDoubleDocValues(field, min, max, minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n              min == null ? null : Float.parseFloat(min),\n              max == null ? null : Float.parseFloat(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : Long.parseLong(min),\n              max == null ? null : Long.parseLong(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          return getRangeQueryForFloatDoubleDocValues(field, min, max, minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n              min == null ? null : Double.parseDouble(min),\n              max == null ? null : Double.parseDouble(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n                max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : DateFormatUtil.parseMath(null, min).getTime(),\n              max == null ? null : DateFormatUtil.parseMath(null, max).getTime(),\n              minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a412a7808b2815566cb17117ebe6638112b9a31","date":1484916151,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = numericDocValuesRangeQuery(field.getName(),\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n              min == null ? null : Integer.parseInt(min),\n              max == null ? null : Integer.parseInt(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          return getRangeQueryForFloatDoubleDocValues(field, min, max, minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n              min == null ? null : Float.parseFloat(min),\n              max == null ? null : Float.parseFloat(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = numericDocValuesRangeQuery(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : Long.parseLong(min),\n              max == null ? null : Long.parseLong(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          return getRangeQueryForFloatDoubleDocValues(field, min, max, minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n              min == null ? null : Double.parseDouble(min),\n              max == null ? null : Double.parseDouble(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = numericDocValuesRangeQuery(field.getName(),\n                min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n                max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n              max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n              minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) Integer.parseInt(min),\n                max == null ? null : (long) Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n              min == null ? null : Integer.parseInt(min),\n              max == null ? null : Integer.parseInt(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          return getRangeQueryForFloatDoubleDocValues(field, min, max, minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n              min == null ? null : Float.parseFloat(min),\n              max == null ? null : Float.parseFloat(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : Long.parseLong(min),\n              max == null ? null : Long.parseLong(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          return getRangeQueryForFloatDoubleDocValues(field, min, max, minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n              min == null ? null : Double.parseDouble(min),\n              max == null ? null : Double.parseDouble(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n                max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n              max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n              minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cdd24a5b48ffd59f921ccc4f5199fc029f65797","date":1485039431,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n\n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : Integer.parseInt(min),\n            max == null ? null : Integer.parseInt(max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : Float.parseFloat(min),\n            max == null ? null : Float.parseFloat(max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : Long.parseLong(min),\n            max == null ? null : Long.parseLong(max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : Double.parseDouble(min),\n            max == null ? null : Double.parseDouble(max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = numericDocValuesRangeQuery(field.getName(),\n                min == null ? null : Integer.parseInt(min),\n                max == null ? null : Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n              min == null ? null : Integer.parseInt(min),\n              max == null ? null : Integer.parseInt(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          return getRangeQueryForFloatDoubleDocValues(field, min, max, minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n              min == null ? null : Float.parseFloat(min),\n              max == null ? null : Float.parseFloat(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = numericDocValuesRangeQuery(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : Long.parseLong(min),\n              max == null ? null : Long.parseLong(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          return getRangeQueryForFloatDoubleDocValues(field, min, max, minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n              min == null ? null : Double.parseDouble(min),\n              max == null ? null : Double.parseDouble(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = numericDocValuesRangeQuery(field.getName(),\n                min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n                max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n              max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n              minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":["92f8ab19a30ff70981e43b8cc78069cb0941476e","92f8ab19a30ff70981e43b8cc78069cb0941476e","92f8ab19a30ff70981e43b8cc78069cb0941476e","92f8ab19a30ff70981e43b8cc78069cb0941476e","92f8ab19a30ff70981e43b8cc78069cb0941476e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n\n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : Integer.parseInt(min),\n            max == null ? null : Integer.parseInt(max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : Float.parseFloat(min),\n            max == null ? null : Float.parseFloat(max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : Long.parseLong(min),\n            max == null ? null : Long.parseLong(max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : Double.parseDouble(min),\n            max == null ? null : Double.parseDouble(max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    final boolean matchOnly = field.hasDocValues() && !field.indexed();\n    switch (type) {\n      case INTEGER:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : (long) Integer.parseInt(min),\n                max == null ? null : (long) Integer.parseInt(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n              min == null ? null : Integer.parseInt(min),\n              max == null ? null : Integer.parseInt(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case FLOAT:\n        if (matchOnly) {\n          return getRangeQueryForFloatDoubleDocValues(field, min, max, minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n              min == null ? null : Float.parseFloat(min),\n              max == null ? null : Float.parseFloat(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case LONG:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : Long.parseLong(min),\n                max == null ? null : Long.parseLong(max),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : Long.parseLong(min),\n              max == null ? null : Long.parseLong(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DOUBLE:\n        if (matchOnly) {\n          return getRangeQueryForFloatDoubleDocValues(field, min, max, minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n              min == null ? null : Double.parseDouble(min),\n              max == null ? null : Double.parseDouble(max),\n              minInclusive, maxInclusive);\n        }\n        break;\n      case DATE:\n        if (matchOnly) {\n          query = DocValuesRangeQuery.newLongRange(field.getName(),\n                min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n                max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n                minInclusive, maxInclusive);\n        } else {\n          query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n              min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n              max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n              minInclusive, maxInclusive);\n        }\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92f8ab19a30ff70981e43b8cc78069cb0941476e","date":1497374252,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    \n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : parseIntFromUser(field.getName(), min),\n            max == null ? null : parseIntFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : parseFloatFromUser(field.getName(), min),\n            max == null ? null : parseFloatFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : parseLongFromUser(field.getName(), min),\n            max == null ? null : parseLongFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : parseDoubleFromUser(field.getName(), min),\n            max == null ? null : parseDoubleFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n\n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : Integer.parseInt(min),\n            max == null ? null : Integer.parseInt(max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : Float.parseFloat(min),\n            max == null ? null : Float.parseFloat(max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : Long.parseLong(min),\n            max == null ? null : Long.parseLong(max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : Double.parseDouble(min),\n            max == null ? null : Double.parseDouble(max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":["3cdd24a5b48ffd59f921ccc4f5199fc029f65797","6477efb0d5880936e1121e3238a92b586fc51e2d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    \n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : parseIntFromUser(field.getName(), min),\n            max == null ? null : parseIntFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : parseFloatFromUser(field.getName(), min),\n            max == null ? null : parseFloatFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : parseLongFromUser(field.getName(), min),\n            max == null ? null : parseLongFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : parseDoubleFromUser(field.getName(), min),\n            max == null ? null : parseDoubleFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n\n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : Integer.parseInt(min),\n            max == null ? null : Integer.parseInt(max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : Float.parseFloat(min),\n            max == null ? null : Float.parseFloat(max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : Long.parseLong(min),\n            max == null ? null : Long.parseLong(max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : Double.parseDouble(min),\n            max == null ? null : Double.parseDouble(max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    \n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : parseIntFromUser(field.getName(), min),\n            max == null ? null : parseIntFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : parseFloatFromUser(field.getName(), min),\n            max == null ? null : parseFloatFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : parseLongFromUser(field.getName(), min),\n            max == null ? null : parseLongFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : parseDoubleFromUser(field.getName(), min),\n            max == null ? null : parseDoubleFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n\n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : Integer.parseInt(min),\n            max == null ? null : Integer.parseInt(max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : Float.parseFloat(min),\n            max == null ? null : Float.parseFloat(max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : Long.parseLong(min),\n            max == null ? null : Long.parseLong(max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : Double.parseDouble(min),\n            max == null ? null : Double.parseDouble(max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c81907bd971f786e378654d32b80da32b0e950d","date":1578330742,"type":5,"author":"Houston Putman","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSpecializedRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  protected Query getSpecializedRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getSpecializedRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    \n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : parseIntFromUser(field.getName(), min),\n            max == null ? null : parseIntFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : parseFloatFromUser(field.getName(), min),\n            max == null ? null : parseFloatFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : parseLongFromUser(field.getName(), min),\n            max == null ? null : parseLongFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : parseDoubleFromUser(field.getName(), min),\n            max == null ? null : parseDoubleFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    \n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : parseIntFromUser(field.getName(), min),\n            max == null ? null : parseIntFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : parseFloatFromUser(field.getName(), min),\n            max == null ? null : parseFloatFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : parseLongFromUser(field.getName(), min),\n            max == null ? null : parseLongFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : parseDoubleFromUser(field.getName(), min),\n            max == null ? null : parseDoubleFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca62564055241632cd20d65b5ecb8c8e93bd60c4","date":1578383112,"type":5,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSpecializedRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  protected Query getSpecializedRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getSpecializedRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    \n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : parseIntFromUser(field.getName(), min),\n            max == null ? null : parseIntFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : parseFloatFromUser(field.getName(), min),\n            max == null ? null : parseFloatFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : parseLongFromUser(field.getName(), min),\n            max == null ? null : parseLongFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : parseDoubleFromUser(field.getName(), min),\n            max == null ? null : parseDoubleFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    \n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : parseIntFromUser(field.getName(), min),\n            max == null ? null : parseIntFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : parseFloatFromUser(field.getName(), min),\n            max == null ? null : parseFloatFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : parseLongFromUser(field.getName(), min),\n            max == null ? null : parseLongFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : parseDoubleFromUser(field.getName(), min),\n            max == null ? null : parseDoubleFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8381df1a98f2a399bf06d747fc8cea1b2a17ae38","date":1578526395,"type":1,"author":"Houston Putman","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getSpecializedRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    \n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : parseIntFromUser(field.getName(), min),\n            max == null ? null : parseIntFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : parseFloatFromUser(field.getName(), min),\n            max == null ? null : parseFloatFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : parseLongFromUser(field.getName(), min),\n            max == null ? null : parseLongFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : parseDoubleFromUser(field.getName(), min),\n            max == null ? null : parseDoubleFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n    return query;\n  }\n\n","sourceOld":"  @Override\n  protected Query getSpecializedRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getSpecializedRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    \n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : parseIntFromUser(field.getName(), min),\n            max == null ? null : parseIntFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : parseFloatFromUser(field.getName(), min),\n            max == null ? null : parseFloatFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : parseLongFromUser(field.getName(), min),\n            max == null ? null : parseLongFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : parseDoubleFromUser(field.getName(), min),\n            max == null ? null : parseDoubleFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da93834e39ce341a13e42b611d0a83bd3114bba","date":1578567362,"type":1,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getSpecializedRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    \n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : parseIntFromUser(field.getName(), min),\n            max == null ? null : parseIntFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : parseFloatFromUser(field.getName(), min),\n            max == null ? null : parseFloatFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : parseLongFromUser(field.getName(), min),\n            max == null ? null : parseLongFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : parseDoubleFromUser(field.getName(), min),\n            max == null ? null : parseDoubleFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n    return query;\n  }\n\n","sourceOld":"  @Override\n  protected Query getSpecializedRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getSpecializedRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    \n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : parseIntFromUser(field.getName(), min),\n            max == null ? null : parseIntFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : parseFloatFromUser(field.getName(), min),\n            max == null ? null : parseFloatFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : parseLongFromUser(field.getName(), min),\n            max == null ? null : parseLongFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : parseDoubleFromUser(field.getName(), min),\n            max == null ? null : parseDoubleFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c7ba457c7f2595139254fab54362be336c5c355","date":1579734055,"type":5,"author":"Houston Putman","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSpecializedRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  @Override\n  protected Query getSpecializedRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getSpecializedRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    \n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : parseIntFromUser(field.getName(), min),\n            max == null ? null : parseIntFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : parseFloatFromUser(field.getName(), min),\n            max == null ? null : parseFloatFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : parseLongFromUser(field.getName(), min),\n            max == null ? null : parseLongFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : parseDoubleFromUser(field.getName(), min),\n            max == null ? null : parseDoubleFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    if (field.multiValued() && field.hasDocValues() && !field.indexed()) {\n      // for the multi-valued dv-case, the default rangeimpl over toInternal is correct\n      return super.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n    int ps = precisionStep;\n    Query query;\n    \n    if (field.hasDocValues() && !field.indexed()) {\n      return getDocValuesRangeQuery(parser, field, min, max, minInclusive, maxInclusive);\n    }\n\n    switch (type) {\n      case INTEGER:\n        query = LegacyNumericRangeQuery.newIntRange(field.getName(), ps,\n            min == null ? null : parseIntFromUser(field.getName(), min),\n            max == null ? null : parseIntFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case FLOAT:\n        query = LegacyNumericRangeQuery.newFloatRange(field.getName(), ps,\n            min == null ? null : parseFloatFromUser(field.getName(), min),\n            max == null ? null : parseFloatFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case LONG:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : parseLongFromUser(field.getName(), min),\n            max == null ? null : parseLongFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DOUBLE:\n        query = LegacyNumericRangeQuery.newDoubleRange(field.getName(), ps,\n            min == null ? null : parseDoubleFromUser(field.getName(), min),\n            max == null ? null : parseDoubleFromUser(field.getName(), max),\n            minInclusive, maxInclusive);\n        break;\n      case DATE:\n        query = LegacyNumericRangeQuery.newLongRange(field.getName(), ps,\n            min == null ? null : DateMathParser.parseMath(null, min).getTime(),\n            max == null ? null : DateMathParser.parseMath(null, max).getTime(),\n            minInclusive, maxInclusive);\n        break;\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field\");\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3":["ffced88b5e83e2ec0a42723404a647e766d96b8c"],"9274621789ce990dbfef455dabdf026bb3184821":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"1da93834e39ce341a13e42b611d0a83bd3114bba":["ca62564055241632cd20d65b5ecb8c8e93bd60c4","8381df1a98f2a399bf06d747fc8cea1b2a17ae38"],"56572ec06f1407c066d6b7399413178b33176cd8":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3","93dd449115a9247533e44bab47e8429e5dccbc6d"],"ca62564055241632cd20d65b5ecb8c8e93bd60c4":["28288370235ed02234a64753cdbf0c6ec096304a","0c81907bd971f786e378654d32b80da32b0e950d"],"0c38a05f7a7b43c2dabbd25f12f9941c64bb2331":["484e80062d7ab2729bc82f0311d6a97dd913961a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5c7ba457c7f2595139254fab54362be336c5c355":["8381df1a98f2a399bf06d747fc8cea1b2a17ae38"],"5a412a7808b2815566cb17117ebe6638112b9a31":["d3f6c7717a0f1decd1668144537943efcc70cd95"],"3cdd24a5b48ffd59f921ccc4f5199fc029f65797":["5a412a7808b2815566cb17117ebe6638112b9a31"],"8381df1a98f2a399bf06d747fc8cea1b2a17ae38":["0c81907bd971f786e378654d32b80da32b0e950d"],"d3f6c7717a0f1decd1668144537943efcc70cd95":["c5cc22ce99f9ec86f1d1e55d36aaefac498ada97"],"484e80062d7ab2729bc82f0311d6a97dd913961a":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"92f8ab19a30ff70981e43b8cc78069cb0941476e":["3cdd24a5b48ffd59f921ccc4f5199fc029f65797"],"770342641f7b505eaa8dccdc666158bff2419109":["0c38a05f7a7b43c2dabbd25f12f9941c64bb2331"],"28288370235ed02234a64753cdbf0c6ec096304a":["3cdd24a5b48ffd59f921ccc4f5199fc029f65797","92f8ab19a30ff70981e43b8cc78069cb0941476e"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["d3f6c7717a0f1decd1668144537943efcc70cd95","3cdd24a5b48ffd59f921ccc4f5199fc029f65797"],"0c81907bd971f786e378654d32b80da32b0e950d":["28288370235ed02234a64753cdbf0c6ec096304a"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3","9274621789ce990dbfef455dabdf026bb3184821"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["770342641f7b505eaa8dccdc666158bff2419109","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"c5cc22ce99f9ec86f1d1e55d36aaefac498ada97":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"ffced88b5e83e2ec0a42723404a647e766d96b8c":["c26f00b574427b55127e869b935845554afde1fa"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["3cdd24a5b48ffd59f921ccc4f5199fc029f65797","92f8ab19a30ff70981e43b8cc78069cb0941476e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5c7ba457c7f2595139254fab54362be336c5c355"],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["770342641f7b505eaa8dccdc666158bff2419109"]},"commit2Childs":{"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3":["9274621789ce990dbfef455dabdf026bb3184821","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"9274621789ce990dbfef455dabdf026bb3184821":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"c26f00b574427b55127e869b935845554afde1fa":["ffced88b5e83e2ec0a42723404a647e766d96b8c"],"1da93834e39ce341a13e42b611d0a83bd3114bba":[],"56572ec06f1407c066d6b7399413178b33176cd8":[],"ca62564055241632cd20d65b5ecb8c8e93bd60c4":["1da93834e39ce341a13e42b611d0a83bd3114bba"],"0c38a05f7a7b43c2dabbd25f12f9941c64bb2331":["770342641f7b505eaa8dccdc666158bff2419109"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"5c7ba457c7f2595139254fab54362be336c5c355":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5a412a7808b2815566cb17117ebe6638112b9a31":["3cdd24a5b48ffd59f921ccc4f5199fc029f65797"],"3cdd24a5b48ffd59f921ccc4f5199fc029f65797":["92f8ab19a30ff70981e43b8cc78069cb0941476e","28288370235ed02234a64753cdbf0c6ec096304a","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"8381df1a98f2a399bf06d747fc8cea1b2a17ae38":["1da93834e39ce341a13e42b611d0a83bd3114bba","5c7ba457c7f2595139254fab54362be336c5c355"],"d3f6c7717a0f1decd1668144537943efcc70cd95":["5a412a7808b2815566cb17117ebe6638112b9a31","90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"484e80062d7ab2729bc82f0311d6a97dd913961a":["0c38a05f7a7b43c2dabbd25f12f9941c64bb2331"],"92f8ab19a30ff70981e43b8cc78069cb0941476e":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"28288370235ed02234a64753cdbf0c6ec096304a":["ca62564055241632cd20d65b5ecb8c8e93bd60c4","0c81907bd971f786e378654d32b80da32b0e950d"],"770342641f7b505eaa8dccdc666158bff2419109":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"0c81907bd971f786e378654d32b80da32b0e950d":["ca62564055241632cd20d65b5ecb8c8e93bd60c4","8381df1a98f2a399bf06d747fc8cea1b2a17ae38"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","484e80062d7ab2729bc82f0311d6a97dd913961a"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["c5cc22ce99f9ec86f1d1e55d36aaefac498ada97"],"ffced88b5e83e2ec0a42723404a647e766d96b8c":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3"],"c5cc22ce99f9ec86f1d1e55d36aaefac498ada97":["d3f6c7717a0f1decd1668144537943efcc70cd95"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1da93834e39ce341a13e42b611d0a83bd3114bba","56572ec06f1407c066d6b7399413178b33176cd8","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","a258fbb26824fd104ed795e5d9033d2d040049ee","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}