{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","commits":[{"id":"f838187609fee3a1afa5f162f93c796046242c84","date":1406216791,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"    /** Pushes the new term to the top of the stack, and writes new blocks. */\n    private void pushTerm(BytesRef text) throws IOException {\n      int limit = Math.min(lastTerm.length, text.length);\n\n      // Find common prefix between last term and current term:\n      int pos = 0;\n      while (pos < limit && lastTerm.bytes[pos] == text.bytes[text.offset+pos]) {\n        pos++;\n      }\n\n      // if (DEBUG) System.out.println(\"  shared=\" + pos + \"  lastTerm.length=\" + lastTerm.length);\n\n      // Close the \"abandoned\" suffix now:\n      for(int i=lastTerm.length-1;i>=pos;i--) {\n\n        // How many items on top of the stack share the current suffix\n        // we are closing:\n        int prefixTopSize = pending.size() - prefixStarts[i];\n        if (prefixTopSize >= minItemsInBlock) {\n          // if (DEBUG) System.out.println(\"pushTerm i=\" + i + \" prefixTopSize=\" + prefixTopSize + \" minItemsInBlock=\" + minItemsInBlock);\n          writeBlocks(i+1, prefixTopSize);\n          prefixStarts[i] -= prefixTopSize-1;\n        }\n      }\n\n      if (prefixStarts.length < text.length) {\n        prefixStarts = ArrayUtil.grow(prefixStarts, text.length);\n      }\n\n      // Init new tail:\n      for(int i=pos;i<text.length;i++) {\n        prefixStarts[i] = pending.size();\n      }\n\n      lastTerm.copyBytes(text);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","sourceNew":"    /** Pushes the new term to the top of the stack, and writes new blocks. */\n    private void pushTerm(BytesRef text) throws IOException {\n      int limit = Math.min(lastTerm.length(), text.length);\n\n      // Find common prefix between last term and current term:\n      int pos = 0;\n      while (pos < limit && lastTerm.byteAt(pos) == text.bytes[text.offset+pos]) {\n        pos++;\n      }\n\n      // if (DEBUG) System.out.println(\"  shared=\" + pos + \"  lastTerm.length=\" + lastTerm.length);\n\n      // Close the \"abandoned\" suffix now:\n      for(int i=lastTerm.length()-1;i>=pos;i--) {\n\n        // How many items on top of the stack share the current suffix\n        // we are closing:\n        int prefixTopSize = pending.size() - prefixStarts[i];\n        if (prefixTopSize >= minItemsInBlock) {\n          // if (DEBUG) System.out.println(\"pushTerm i=\" + i + \" prefixTopSize=\" + prefixTopSize + \" minItemsInBlock=\" + minItemsInBlock);\n          writeBlocks(i+1, prefixTopSize);\n          prefixStarts[i] -= prefixTopSize-1;\n        }\n      }\n\n      if (prefixStarts.length < text.length) {\n        prefixStarts = ArrayUtil.grow(prefixStarts, text.length);\n      }\n\n      // Init new tail:\n      for(int i=pos;i<text.length;i++) {\n        prefixStarts[i] = pending.size();\n      }\n\n      lastTerm.copyBytes(text);\n    }\n\n","sourceOld":"    /** Pushes the new term to the top of the stack, and writes new blocks. */\n    private void pushTerm(BytesRef text) throws IOException {\n      int limit = Math.min(lastTerm.length, text.length);\n\n      // Find common prefix between last term and current term:\n      int pos = 0;\n      while (pos < limit && lastTerm.bytes[pos] == text.bytes[text.offset+pos]) {\n        pos++;\n      }\n\n      // if (DEBUG) System.out.println(\"  shared=\" + pos + \"  lastTerm.length=\" + lastTerm.length);\n\n      // Close the \"abandoned\" suffix now:\n      for(int i=lastTerm.length-1;i>=pos;i--) {\n\n        // How many items on top of the stack share the current suffix\n        // we are closing:\n        int prefixTopSize = pending.size() - prefixStarts[i];\n        if (prefixTopSize >= minItemsInBlock) {\n          // if (DEBUG) System.out.println(\"pushTerm i=\" + i + \" prefixTopSize=\" + prefixTopSize + \" minItemsInBlock=\" + minItemsInBlock);\n          writeBlocks(i+1, prefixTopSize);\n          prefixStarts[i] -= prefixTopSize-1;\n        }\n      }\n\n      if (prefixStarts.length < text.length) {\n        prefixStarts = ArrayUtil.grow(prefixStarts, text.length);\n      }\n\n      // Init new tail:\n      for(int i=pos;i<text.length;i++) {\n        prefixStarts[i] = pending.size();\n      }\n\n      lastTerm.copyBytes(text);\n    }\n\n","bugFix":["f838187609fee3a1afa5f162f93c796046242c84"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["f838187609fee3a1afa5f162f93c796046242c84"],"f838187609fee3a1afa5f162f93c796046242c84":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f838187609fee3a1afa5f162f93c796046242c84"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f838187609fee3a1afa5f162f93c796046242c84":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}