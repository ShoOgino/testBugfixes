{"path":"lucene/core/src/java/org/apache/lucene/util/FixedLengthBytesRefArray#sort(Comparator[BytesRef]).mjava","commits":[{"id":"ee52259641568741fbc6ecc51284431e2a36475c","date":1459331525,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/FixedLengthBytesRefArray#sort(Comparator[BytesRef]).mjava","pathOld":"/dev/null","sourceNew":"  private int[] sort(final Comparator<BytesRef> comp) {\n    final int[] orderedEntries = new int[size()];\n    for (int i = 0; i < orderedEntries.length; i++) {\n      orderedEntries[i] = i;\n    }\n\n    final BytesRef pivot = new BytesRef();\n    final BytesRef scratch1 = new BytesRef();\n    final BytesRef scratch2 = new BytesRef();\n    pivot.length = valueLength;\n    scratch1.length = valueLength;\n    scratch2.length = valueLength;\n\n    new IntroSorter() {\n\n      @Override\n      protected void swap(int i, int j) {\n        int o = orderedEntries[i];\n        orderedEntries[i] = orderedEntries[j];\n        orderedEntries[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        int index1 = orderedEntries[i];\n        scratch1.bytes = blocks[index1 / valuesPerBlock];\n        scratch1.offset = (index1 % valuesPerBlock) * valueLength;\n\n        int index2 = orderedEntries[j];\n        scratch2.bytes = blocks[index2 / valuesPerBlock];\n        scratch2.offset = (index2 % valuesPerBlock) * valueLength;\n\n        return comp.compare(scratch1, scratch2);\n      }\n      \n      @Override\n      protected void setPivot(int i) {\n        int index = orderedEntries[i];\n        pivot.bytes = blocks[index / valuesPerBlock];\n        pivot.offset = (index % valuesPerBlock) * valueLength;\n      }\n      \n      @Override\n      protected int comparePivot(int j) {\n        final int index = orderedEntries[j];\n        scratch2.bytes = blocks[index / valuesPerBlock];\n        scratch2.offset = (index % valuesPerBlock) * valueLength;\n        return comp.compare(pivot, scratch2);\n      }\n    }.sort(0, size());\n    return orderedEntries;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ad3fdaef92a8e8112ab0f5be5fd95362cf9030e","date":1464596999,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/FixedLengthBytesRefArray#sort(Comparator[BytesRef]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FixedLengthBytesRefArray#sort(Comparator[BytesRef]).mjava","sourceNew":"  private int[] sort(final Comparator<BytesRef> comp) {\n    final int[] orderedEntries = new int[size()];\n    for (int i = 0; i < orderedEntries.length; i++) {\n      orderedEntries[i] = i;\n    }\n\n    if (comp instanceof BytesRefComparator) {\n      BytesRefComparator bComp = (BytesRefComparator) comp;\n      new MSBRadixSorter(bComp.comparedBytesCount) {\n\n        BytesRef scratch;\n\n        {\n          scratch = new BytesRef();\n          scratch.length = valueLength;\n        }\n\n        @Override\n        protected void swap(int i, int j) {\n          int o = orderedEntries[i];\n          orderedEntries[i] = orderedEntries[j];\n          orderedEntries[j] = o;\n        }\n\n        @Override\n        protected int byteAt(int i, int k) {\n          int index1 = orderedEntries[i];\n          scratch.bytes = blocks[index1 / valuesPerBlock];\n          scratch.offset = (index1 % valuesPerBlock) * valueLength;\n          return bComp.byteAt(scratch, k);\n        }\n      }.sort(0, size());\n      return orderedEntries;\n    }\n\n    final BytesRef pivot = new BytesRef();\n    final BytesRef scratch1 = new BytesRef();\n    final BytesRef scratch2 = new BytesRef();\n    pivot.length = valueLength;\n    scratch1.length = valueLength;\n    scratch2.length = valueLength;\n\n    new IntroSorter() {\n\n      @Override\n      protected void swap(int i, int j) {\n        int o = orderedEntries[i];\n        orderedEntries[i] = orderedEntries[j];\n        orderedEntries[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        int index1 = orderedEntries[i];\n        scratch1.bytes = blocks[index1 / valuesPerBlock];\n        scratch1.offset = (index1 % valuesPerBlock) * valueLength;\n\n        int index2 = orderedEntries[j];\n        scratch2.bytes = blocks[index2 / valuesPerBlock];\n        scratch2.offset = (index2 % valuesPerBlock) * valueLength;\n\n        return comp.compare(scratch1, scratch2);\n      }\n      \n      @Override\n      protected void setPivot(int i) {\n        int index = orderedEntries[i];\n        pivot.bytes = blocks[index / valuesPerBlock];\n        pivot.offset = (index % valuesPerBlock) * valueLength;\n      }\n      \n      @Override\n      protected int comparePivot(int j) {\n        final int index = orderedEntries[j];\n        scratch2.bytes = blocks[index / valuesPerBlock];\n        scratch2.offset = (index % valuesPerBlock) * valueLength;\n        return comp.compare(pivot, scratch2);\n      }\n    }.sort(0, size());\n    return orderedEntries;\n  }\n\n","sourceOld":"  private int[] sort(final Comparator<BytesRef> comp) {\n    final int[] orderedEntries = new int[size()];\n    for (int i = 0; i < orderedEntries.length; i++) {\n      orderedEntries[i] = i;\n    }\n\n    final BytesRef pivot = new BytesRef();\n    final BytesRef scratch1 = new BytesRef();\n    final BytesRef scratch2 = new BytesRef();\n    pivot.length = valueLength;\n    scratch1.length = valueLength;\n    scratch2.length = valueLength;\n\n    new IntroSorter() {\n\n      @Override\n      protected void swap(int i, int j) {\n        int o = orderedEntries[i];\n        orderedEntries[i] = orderedEntries[j];\n        orderedEntries[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        int index1 = orderedEntries[i];\n        scratch1.bytes = blocks[index1 / valuesPerBlock];\n        scratch1.offset = (index1 % valuesPerBlock) * valueLength;\n\n        int index2 = orderedEntries[j];\n        scratch2.bytes = blocks[index2 / valuesPerBlock];\n        scratch2.offset = (index2 % valuesPerBlock) * valueLength;\n\n        return comp.compare(scratch1, scratch2);\n      }\n      \n      @Override\n      protected void setPivot(int i) {\n        int index = orderedEntries[i];\n        pivot.bytes = blocks[index / valuesPerBlock];\n        pivot.offset = (index % valuesPerBlock) * valueLength;\n      }\n      \n      @Override\n      protected int comparePivot(int j) {\n        final int index = orderedEntries[j];\n        scratch2.bytes = blocks[index / valuesPerBlock];\n        scratch2.offset = (index % valuesPerBlock) * valueLength;\n        return comp.compare(pivot, scratch2);\n      }\n    }.sort(0, size());\n    return orderedEntries;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da8a02bef7458089240404614139b53c9f875ec7","date":1464597207,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/FixedLengthBytesRefArray#sort(Comparator[BytesRef]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FixedLengthBytesRefArray#sort(Comparator[BytesRef]).mjava","sourceNew":"  private int[] sort(final Comparator<BytesRef> comp) {\n    final int[] orderedEntries = new int[size()];\n    for (int i = 0; i < orderedEntries.length; i++) {\n      orderedEntries[i] = i;\n    }\n\n    if (comp instanceof BytesRefComparator) {\n      BytesRefComparator bComp = (BytesRefComparator) comp;\n      new MSBRadixSorter(bComp.comparedBytesCount) {\n\n        BytesRef scratch;\n\n        {\n          scratch = new BytesRef();\n          scratch.length = valueLength;\n        }\n\n        @Override\n        protected void swap(int i, int j) {\n          int o = orderedEntries[i];\n          orderedEntries[i] = orderedEntries[j];\n          orderedEntries[j] = o;\n        }\n\n        @Override\n        protected int byteAt(int i, int k) {\n          int index1 = orderedEntries[i];\n          scratch.bytes = blocks[index1 / valuesPerBlock];\n          scratch.offset = (index1 % valuesPerBlock) * valueLength;\n          return bComp.byteAt(scratch, k);\n        }\n      }.sort(0, size());\n      return orderedEntries;\n    }\n\n    final BytesRef pivot = new BytesRef();\n    final BytesRef scratch1 = new BytesRef();\n    final BytesRef scratch2 = new BytesRef();\n    pivot.length = valueLength;\n    scratch1.length = valueLength;\n    scratch2.length = valueLength;\n\n    new IntroSorter() {\n\n      @Override\n      protected void swap(int i, int j) {\n        int o = orderedEntries[i];\n        orderedEntries[i] = orderedEntries[j];\n        orderedEntries[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        int index1 = orderedEntries[i];\n        scratch1.bytes = blocks[index1 / valuesPerBlock];\n        scratch1.offset = (index1 % valuesPerBlock) * valueLength;\n\n        int index2 = orderedEntries[j];\n        scratch2.bytes = blocks[index2 / valuesPerBlock];\n        scratch2.offset = (index2 % valuesPerBlock) * valueLength;\n\n        return comp.compare(scratch1, scratch2);\n      }\n      \n      @Override\n      protected void setPivot(int i) {\n        int index = orderedEntries[i];\n        pivot.bytes = blocks[index / valuesPerBlock];\n        pivot.offset = (index % valuesPerBlock) * valueLength;\n      }\n      \n      @Override\n      protected int comparePivot(int j) {\n        final int index = orderedEntries[j];\n        scratch2.bytes = blocks[index / valuesPerBlock];\n        scratch2.offset = (index % valuesPerBlock) * valueLength;\n        return comp.compare(pivot, scratch2);\n      }\n    }.sort(0, size());\n    return orderedEntries;\n  }\n\n","sourceOld":"  private int[] sort(final Comparator<BytesRef> comp) {\n    final int[] orderedEntries = new int[size()];\n    for (int i = 0; i < orderedEntries.length; i++) {\n      orderedEntries[i] = i;\n    }\n\n    final BytesRef pivot = new BytesRef();\n    final BytesRef scratch1 = new BytesRef();\n    final BytesRef scratch2 = new BytesRef();\n    pivot.length = valueLength;\n    scratch1.length = valueLength;\n    scratch2.length = valueLength;\n\n    new IntroSorter() {\n\n      @Override\n      protected void swap(int i, int j) {\n        int o = orderedEntries[i];\n        orderedEntries[i] = orderedEntries[j];\n        orderedEntries[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        int index1 = orderedEntries[i];\n        scratch1.bytes = blocks[index1 / valuesPerBlock];\n        scratch1.offset = (index1 % valuesPerBlock) * valueLength;\n\n        int index2 = orderedEntries[j];\n        scratch2.bytes = blocks[index2 / valuesPerBlock];\n        scratch2.offset = (index2 % valuesPerBlock) * valueLength;\n\n        return comp.compare(scratch1, scratch2);\n      }\n      \n      @Override\n      protected void setPivot(int i) {\n        int index = orderedEntries[i];\n        pivot.bytes = blocks[index / valuesPerBlock];\n        pivot.offset = (index % valuesPerBlock) * valueLength;\n      }\n      \n      @Override\n      protected int comparePivot(int j) {\n        final int index = orderedEntries[j];\n        scratch2.bytes = blocks[index / valuesPerBlock];\n        scratch2.offset = (index % valuesPerBlock) * valueLength;\n        return comp.compare(pivot, scratch2);\n      }\n    }.sort(0, size());\n    return orderedEntries;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b8ee93140fd0efef7e101786e3ed5160a700b5f","date":1464820111,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/FixedLengthBytesRefArray#sort(Comparator[BytesRef]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FixedLengthBytesRefArray#sort(Comparator[BytesRef]).mjava","sourceNew":"  private int[] sort(final Comparator<BytesRef> comp) {\n    final int[] orderedEntries = new int[size()];\n    for (int i = 0; i < orderedEntries.length; i++) {\n      orderedEntries[i] = i;\n    }\n\n    if (comp instanceof BytesRefComparator) {\n      BytesRefComparator bComp = (BytesRefComparator) comp;\n      new MSBRadixSorter(bComp.comparedBytesCount) {\n\n        BytesRef scratch;\n\n        {\n          scratch = new BytesRef();\n          scratch.length = valueLength;\n        }\n\n        @Override\n        protected void swap(int i, int j) {\n          int o = orderedEntries[i];\n          orderedEntries[i] = orderedEntries[j];\n          orderedEntries[j] = o;\n        }\n\n        @Override\n        protected int byteAt(int i, int k) {\n          int index1 = orderedEntries[i];\n          scratch.bytes = blocks[index1 / valuesPerBlock];\n          scratch.offset = (index1 % valuesPerBlock) * valueLength;\n          return bComp.byteAt(scratch, k);\n        }\n      }.sort(0, size());\n      return orderedEntries;\n    }\n\n    final BytesRef pivot = new BytesRef();\n    final BytesRef scratch1 = new BytesRef();\n    final BytesRef scratch2 = new BytesRef();\n    pivot.length = valueLength;\n    scratch1.length = valueLength;\n    scratch2.length = valueLength;\n\n    new IntroSorter() {\n\n      @Override\n      protected void swap(int i, int j) {\n        int o = orderedEntries[i];\n        orderedEntries[i] = orderedEntries[j];\n        orderedEntries[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        int index1 = orderedEntries[i];\n        scratch1.bytes = blocks[index1 / valuesPerBlock];\n        scratch1.offset = (index1 % valuesPerBlock) * valueLength;\n\n        int index2 = orderedEntries[j];\n        scratch2.bytes = blocks[index2 / valuesPerBlock];\n        scratch2.offset = (index2 % valuesPerBlock) * valueLength;\n\n        return comp.compare(scratch1, scratch2);\n      }\n      \n      @Override\n      protected void setPivot(int i) {\n        int index = orderedEntries[i];\n        pivot.bytes = blocks[index / valuesPerBlock];\n        pivot.offset = (index % valuesPerBlock) * valueLength;\n      }\n      \n      @Override\n      protected int comparePivot(int j) {\n        final int index = orderedEntries[j];\n        scratch2.bytes = blocks[index / valuesPerBlock];\n        scratch2.offset = (index % valuesPerBlock) * valueLength;\n        return comp.compare(pivot, scratch2);\n      }\n    }.sort(0, size());\n    return orderedEntries;\n  }\n\n","sourceOld":"  private int[] sort(final Comparator<BytesRef> comp) {\n    final int[] orderedEntries = new int[size()];\n    for (int i = 0; i < orderedEntries.length; i++) {\n      orderedEntries[i] = i;\n    }\n\n    final BytesRef pivot = new BytesRef();\n    final BytesRef scratch1 = new BytesRef();\n    final BytesRef scratch2 = new BytesRef();\n    pivot.length = valueLength;\n    scratch1.length = valueLength;\n    scratch2.length = valueLength;\n\n    new IntroSorter() {\n\n      @Override\n      protected void swap(int i, int j) {\n        int o = orderedEntries[i];\n        orderedEntries[i] = orderedEntries[j];\n        orderedEntries[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        int index1 = orderedEntries[i];\n        scratch1.bytes = blocks[index1 / valuesPerBlock];\n        scratch1.offset = (index1 % valuesPerBlock) * valueLength;\n\n        int index2 = orderedEntries[j];\n        scratch2.bytes = blocks[index2 / valuesPerBlock];\n        scratch2.offset = (index2 % valuesPerBlock) * valueLength;\n\n        return comp.compare(scratch1, scratch2);\n      }\n      \n      @Override\n      protected void setPivot(int i) {\n        int index = orderedEntries[i];\n        pivot.bytes = blocks[index / valuesPerBlock];\n        pivot.offset = (index % valuesPerBlock) * valueLength;\n      }\n      \n      @Override\n      protected int comparePivot(int j) {\n        final int index = orderedEntries[j];\n        scratch2.bytes = blocks[index / valuesPerBlock];\n        scratch2.offset = (index % valuesPerBlock) * valueLength;\n        return comp.compare(pivot, scratch2);\n      }\n    }.sort(0, size());\n    return orderedEntries;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/FixedLengthBytesRefArray#sort(Comparator[BytesRef]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FixedLengthBytesRefArray#sort(Comparator[BytesRef]).mjava","sourceNew":"  private int[] sort(final Comparator<BytesRef> comp) {\n    final int[] orderedEntries = new int[size()];\n    for (int i = 0; i < orderedEntries.length; i++) {\n      orderedEntries[i] = i;\n    }\n\n    if (comp instanceof BytesRefComparator) {\n      BytesRefComparator bComp = (BytesRefComparator) comp;\n      new MSBRadixSorter(bComp.comparedBytesCount) {\n\n        BytesRef scratch;\n\n        {\n          scratch = new BytesRef();\n          scratch.length = valueLength;\n        }\n\n        @Override\n        protected void swap(int i, int j) {\n          int o = orderedEntries[i];\n          orderedEntries[i] = orderedEntries[j];\n          orderedEntries[j] = o;\n        }\n\n        @Override\n        protected int byteAt(int i, int k) {\n          int index1 = orderedEntries[i];\n          scratch.bytes = blocks[index1 / valuesPerBlock];\n          scratch.offset = (index1 % valuesPerBlock) * valueLength;\n          return bComp.byteAt(scratch, k);\n        }\n      }.sort(0, size());\n      return orderedEntries;\n    }\n\n    final BytesRef pivot = new BytesRef();\n    final BytesRef scratch1 = new BytesRef();\n    final BytesRef scratch2 = new BytesRef();\n    pivot.length = valueLength;\n    scratch1.length = valueLength;\n    scratch2.length = valueLength;\n\n    new IntroSorter() {\n\n      @Override\n      protected void swap(int i, int j) {\n        int o = orderedEntries[i];\n        orderedEntries[i] = orderedEntries[j];\n        orderedEntries[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        int index1 = orderedEntries[i];\n        scratch1.bytes = blocks[index1 / valuesPerBlock];\n        scratch1.offset = (index1 % valuesPerBlock) * valueLength;\n\n        int index2 = orderedEntries[j];\n        scratch2.bytes = blocks[index2 / valuesPerBlock];\n        scratch2.offset = (index2 % valuesPerBlock) * valueLength;\n\n        return comp.compare(scratch1, scratch2);\n      }\n      \n      @Override\n      protected void setPivot(int i) {\n        int index = orderedEntries[i];\n        pivot.bytes = blocks[index / valuesPerBlock];\n        pivot.offset = (index % valuesPerBlock) * valueLength;\n      }\n      \n      @Override\n      protected int comparePivot(int j) {\n        final int index = orderedEntries[j];\n        scratch2.bytes = blocks[index / valuesPerBlock];\n        scratch2.offset = (index % valuesPerBlock) * valueLength;\n        return comp.compare(pivot, scratch2);\n      }\n    }.sort(0, size());\n    return orderedEntries;\n  }\n\n","sourceOld":"  private int[] sort(final Comparator<BytesRef> comp) {\n    final int[] orderedEntries = new int[size()];\n    for (int i = 0; i < orderedEntries.length; i++) {\n      orderedEntries[i] = i;\n    }\n\n    final BytesRef pivot = new BytesRef();\n    final BytesRef scratch1 = new BytesRef();\n    final BytesRef scratch2 = new BytesRef();\n    pivot.length = valueLength;\n    scratch1.length = valueLength;\n    scratch2.length = valueLength;\n\n    new IntroSorter() {\n\n      @Override\n      protected void swap(int i, int j) {\n        int o = orderedEntries[i];\n        orderedEntries[i] = orderedEntries[j];\n        orderedEntries[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        int index1 = orderedEntries[i];\n        scratch1.bytes = blocks[index1 / valuesPerBlock];\n        scratch1.offset = (index1 % valuesPerBlock) * valueLength;\n\n        int index2 = orderedEntries[j];\n        scratch2.bytes = blocks[index2 / valuesPerBlock];\n        scratch2.offset = (index2 % valuesPerBlock) * valueLength;\n\n        return comp.compare(scratch1, scratch2);\n      }\n      \n      @Override\n      protected void setPivot(int i) {\n        int index = orderedEntries[i];\n        pivot.bytes = blocks[index / valuesPerBlock];\n        pivot.offset = (index % valuesPerBlock) * valueLength;\n      }\n      \n      @Override\n      protected int comparePivot(int j) {\n        final int index = orderedEntries[j];\n        scratch2.bytes = blocks[index / valuesPerBlock];\n        scratch2.offset = (index % valuesPerBlock) * valueLength;\n        return comp.compare(pivot, scratch2);\n      }\n    }.sort(0, size());\n    return orderedEntries;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"da8a02bef7458089240404614139b53c9f875ec7":["ee52259641568741fbc6ecc51284431e2a36475c","1ad3fdaef92a8e8112ab0f5be5fd95362cf9030e"],"1ad3fdaef92a8e8112ab0f5be5fd95362cf9030e":["ee52259641568741fbc6ecc51284431e2a36475c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ee52259641568741fbc6ecc51284431e2a36475c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":["ee52259641568741fbc6ecc51284431e2a36475c","1ad3fdaef92a8e8112ab0f5be5fd95362cf9030e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["ee52259641568741fbc6ecc51284431e2a36475c","1ad3fdaef92a8e8112ab0f5be5fd95362cf9030e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1ad3fdaef92a8e8112ab0f5be5fd95362cf9030e"]},"commit2Childs":{"da8a02bef7458089240404614139b53c9f875ec7":[],"1ad3fdaef92a8e8112ab0f5be5fd95362cf9030e":["da8a02bef7458089240404614139b53c9f875ec7","5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ee52259641568741fbc6ecc51284431e2a36475c"],"ee52259641568741fbc6ecc51284431e2a36475c":["da8a02bef7458089240404614139b53c9f875ec7","1ad3fdaef92a8e8112ab0f5be5fd95362cf9030e","5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["da8a02bef7458089240404614139b53c9f875ec7","5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}