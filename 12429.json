{"path":"src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","commits":[{"id":"20349324eb18d1565d301e59be543989f38743d3","date":1258494398,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"/dev/null","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    Map<String,Float> phraseFields = U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    Map<String,Float> phraseFields3 = U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        // Only do minimum-match logic\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || phraseFields3.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        Map<String,Float> pf = phraseFields;\n        if (normalClauses.size() >= 2 && pf.size() > 0) {\n          StringBuilder sb = new StringBuilder();\n          for (int i=0; i<normalClauses.size()-1; i++) {\n            sb.append('\"');\n            sb.append(normalClauses.get(i).val);\n            sb.append(' ');\n            sb.append(normalClauses.get(i+1).val);\n            sb.append('\"');\n            sb.append(' ');\n          }\n\n          String userPhraseQuery = sb.toString();\n\n          /* for parsing sloppy phrases using DisjunctionMaxQueries */\n          ExtendedSolrQueryParser pp =\n                  new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n          pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, pf);\n          pp.setPhraseSlop(pslop);\n          pp.makeDismax = false;  // make boolean queries instead\n          pp.setRemoveStopFilter(true);  // remove stop filter and keep stopwords\n          pp.minClauseSize = 2;  // if a stopword is removed, don't add the phrase\n\n          // TODO: perhaps we shouldn't use synonyms either...\n\n          Query phrase = pp.parse(userPhraseQuery);\n          if (phrase != null) {\n            query.add(phrase, BooleanClause.Occur.SHOULD);\n          }\n        }\n\n        pf = phraseFields3;\n        if (normalClauses.size() >= 3 && pf.size() > 0) {\n          StringBuilder sb = new StringBuilder();\n          for (int i=0; i<normalClauses.size()-2; i++) {\n            sb.append('\"');\n            sb.append(normalClauses.get(i).val);\n            sb.append(' ');\n            sb.append(normalClauses.get(i+1).val);\n            sb.append(' ');\n            sb.append(normalClauses.get(i+2).val);\n            sb.append('\"');\n            sb.append(' ');\n          }\n\n          String userPhraseQuery = sb.toString();\n\n          /* for parsing sloppy phrases using DisjunctionMaxQueries */\n          ExtendedSolrQueryParser pp =\n                  new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n          pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, pf);\n          pp.setPhraseSlop(pslop);\n          pp.makeDismax = false;  // make boolean queries instead\n          pp.setRemoveStopFilter(true);  // remove stop filter and keep stopwords\n          pp.minClauseSize = 2;  // keep min phrase size at 2 since stopword could have been removed in middle\n\n          Query phrase = pp.parse(userPhraseQuery);\n          if (phrase != null) {\n            query.add(phrase, BooleanClause.Occur.SHOULD);\n          }\n        }\n\n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if(1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery)f).clauses()) {\n            query.add((BooleanClause)c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for(Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["576a4c26b3d237aa2626e691ea3b4fa016037fe3","576a4c26b3d237aa2626e691ea3b4fa016037fe3","576a4c26b3d237aa2626e691ea3b4fa016037fe3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d84c1e5a4b322241bc356b953d9e539f5b67e9e4","date":1264015470,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        // Only do minimum-match logic\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    Map<String,Float> phraseFields = U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    Map<String,Float> phraseFields3 = U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        // Only do minimum-match logic\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || phraseFields3.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        Map<String,Float> pf = phraseFields;\n        if (normalClauses.size() >= 2 && pf.size() > 0) {\n          StringBuilder sb = new StringBuilder();\n          for (int i=0; i<normalClauses.size()-1; i++) {\n            sb.append('\"');\n            sb.append(normalClauses.get(i).val);\n            sb.append(' ');\n            sb.append(normalClauses.get(i+1).val);\n            sb.append('\"');\n            sb.append(' ');\n          }\n\n          String userPhraseQuery = sb.toString();\n\n          /* for parsing sloppy phrases using DisjunctionMaxQueries */\n          ExtendedSolrQueryParser pp =\n                  new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n          pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, pf);\n          pp.setPhraseSlop(pslop);\n          pp.makeDismax = false;  // make boolean queries instead\n          pp.setRemoveStopFilter(true);  // remove stop filter and keep stopwords\n          pp.minClauseSize = 2;  // if a stopword is removed, don't add the phrase\n\n          // TODO: perhaps we shouldn't use synonyms either...\n\n          Query phrase = pp.parse(userPhraseQuery);\n          if (phrase != null) {\n            query.add(phrase, BooleanClause.Occur.SHOULD);\n          }\n        }\n\n        pf = phraseFields3;\n        if (normalClauses.size() >= 3 && pf.size() > 0) {\n          StringBuilder sb = new StringBuilder();\n          for (int i=0; i<normalClauses.size()-2; i++) {\n            sb.append('\"');\n            sb.append(normalClauses.get(i).val);\n            sb.append(' ');\n            sb.append(normalClauses.get(i+1).val);\n            sb.append(' ');\n            sb.append(normalClauses.get(i+2).val);\n            sb.append('\"');\n            sb.append(' ');\n          }\n\n          String userPhraseQuery = sb.toString();\n\n          /* for parsing sloppy phrases using DisjunctionMaxQueries */\n          ExtendedSolrQueryParser pp =\n                  new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n          pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, pf);\n          pp.setPhraseSlop(pslop);\n          pp.makeDismax = false;  // make boolean queries instead\n          pp.setRemoveStopFilter(true);  // remove stop filter and keep stopwords\n          pp.minClauseSize = 2;  // keep min phrase size at 2 since stopword could have been removed in middle\n\n          Query phrase = pp.parse(userPhraseQuery);\n          if (phrase != null) {\n            query.add(phrase, BooleanClause.Occur.SHOULD);\n          }\n        }\n\n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if(1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery)f).clauses()) {\n            query.add((BooleanClause)c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for(Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b63aae1b4446787889e3e4acf66a8a1190caf9fc","date":1266980445,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        // Only do minimum-match logic\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        // Only do minimum-match logic\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        // Only do minimum-match logic\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        // Only do minimum-match logic\n        String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b63aae1b4446787889e3e4acf66a8a1190caf9fc":["d84c1e5a4b322241bc356b953d9e539f5b67e9e4"],"20349324eb18d1565d301e59be543989f38743d3":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["b63aae1b4446787889e3e4acf66a8a1190caf9fc"],"d84c1e5a4b322241bc356b953d9e539f5b67e9e4":["20349324eb18d1565d301e59be543989f38743d3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b63aae1b4446787889e3e4acf66a8a1190caf9fc":["ad94625fb8d088209f46650c8097196fec67f00c"],"20349324eb18d1565d301e59be543989f38743d3":["d84c1e5a4b322241bc356b953d9e539f5b67e9e4"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["20349324eb18d1565d301e59be543989f38743d3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"d84c1e5a4b322241bc356b953d9e539f5b67e9e4":["b63aae1b4446787889e3e4acf66a8a1190caf9fc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}