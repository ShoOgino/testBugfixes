{"path":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/util/BinaryDictionaryWriter#put(String[]).mjava","commits":[{"id":"05feb7eb5e91cb64742ce32b2ca3f02433530446","date":1561602840,"type":1,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/util/BinaryDictionaryWriter#put(String[]).mjava","pathOld":"lucene/analysis/kuromoji/src/tools/java/org/apache/lucene/analysis/ja/util/BinaryDictionaryWriter#put(String[]).mjava","sourceNew":"  /**\n   * put the entry in map\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n    // build up the POS string\n    for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!\"*\".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    \n    String posData = sb.toString();\n    if (posData.isEmpty()) {\n        throw new IllegalArgumentException(\"POS fields are empty\");\n    }\n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(posData));\n    sb.append(',');\n    if (!\"*\".equals(entry[8])) {\n      sb.append(CSVUtil.quoteEscape(entry[8]));\n    }\n    sb.append(',');\n    if (!\"*\".equals(entry[9])) {\n      sb.append(CSVUtil.quoteEscape(entry[9]));\n    }\n    String fullPOSData = sb.toString();\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case: two short, 3 bytes, and features (all as utf-16)\n    int worstCase = 4 + 3 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    int flags = 0;\n    if (baseForm.isEmpty()) {\n        throw new IllegalArgumentException(\"base form is empty\");\n    }\n    if (!(\"*\".equals(baseForm) || baseForm.equals(entry[0]))) {\n      flags |= BinaryDictionary.HAS_BASEFORM;\n    }\n    if (!reading.equals(toKatakana(entry[0]))) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n    if (!pronunciation.equals(reading)) {\n      flags |= BinaryDictionary.HAS_PRONUNCIATION;\n    }\n\n    if (leftId != rightId) {\n        throw new IllegalArgumentException(\"rightId != leftId: \" + rightId + \" \" +leftId);\n    }\n    if (leftId >= ID_LIMIT) {\n        throw new IllegalArgumentException(\"leftId >= \" + ID_LIMIT + \": \" + leftId);\n    }\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    \n    String existing = posDict.get(leftId);\n    if (existing != null && existing.equals(fullPOSData) == false) {\n        // TODO: test me\n        throw new IllegalArgumentException(\"Multiple entries found for leftID=\" + leftId);\n    }\n    posDict.set(leftId, fullPOSData);\n    \n    buffer.putShort((short)(leftId << 3 | flags));\n    buffer.putShort(wordCost);\n\n    if ((flags & BinaryDictionary.HAS_BASEFORM) != 0) {\n      if (baseForm.length() >= 16) {\n        throw new IllegalArgumentException(\"Length of base form \" + baseForm + \" is >= 16\");\n      }\n      int shared = sharedPrefix(entry[0], baseForm);\n      int suffix = baseForm.length() - shared;\n      buffer.put((byte) (shared << 4 | suffix));\n      for (int i = shared; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_READING) != 0) {\n      if (isKatakana(reading)) {\n        buffer.put((byte) (reading.length() << 1 | 1));\n        writeKatakana(reading);\n      } else {\n        buffer.put((byte) (reading.length() << 1));\n        for (int i = 0; i < reading.length(); i++) {\n          buffer.putChar(reading.charAt(i));\n        }\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_PRONUNCIATION) != 0) {\n      // we can save 150KB here, but it makes the reader a little complicated.\n      // int shared = sharedPrefix(reading, pronunciation);\n      // buffer.put((byte) shared);\n      // pronunciation = pronunciation.substring(shared);\n      if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    return buffer.position();\n  }\n\n","sourceOld":"  /**\n   * put the entry in map\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n    // build up the POS string\n    for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!\"*\".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    \n    String posData = sb.toString();\n    if (posData.isEmpty()) {\n        throw new IllegalArgumentException(\"POS fields are empty\");\n    }\n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(posData));\n    sb.append(',');\n    if (!\"*\".equals(entry[8])) {\n      sb.append(CSVUtil.quoteEscape(entry[8]));\n    }\n    sb.append(',');\n    if (!\"*\".equals(entry[9])) {\n      sb.append(CSVUtil.quoteEscape(entry[9]));\n    }\n    String fullPOSData = sb.toString();\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case: two short, 3 bytes, and features (all as utf-16)\n    int worstCase = 4 + 3 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    int flags = 0;\n    if (baseForm.isEmpty()) {\n        throw new IllegalArgumentException(\"base form is empty\");\n    }\n    if (!(\"*\".equals(baseForm) || baseForm.equals(entry[0]))) {\n      flags |= BinaryDictionary.HAS_BASEFORM;\n    }\n    if (!reading.equals(toKatakana(entry[0]))) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n    if (!pronunciation.equals(reading)) {\n      flags |= BinaryDictionary.HAS_PRONUNCIATION;\n    }\n\n    if (leftId != rightId) {\n        throw new IllegalArgumentException(\"rightId != leftId: \" + rightId + \" \" +leftId);\n    }\n    if (leftId >= ID_LIMIT) {\n        throw new IllegalArgumentException(\"leftId >= \" + ID_LIMIT + \": \" + leftId);\n    }\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    \n    String existing = posDict.get(leftId);\n    if (existing != null && existing.equals(fullPOSData) == false) {\n        // TODO: test me\n        throw new IllegalArgumentException(\"Multiple entries found for leftID=\" + leftId);\n    }\n    posDict.set(leftId, fullPOSData);\n    \n    buffer.putShort((short)(leftId << 3 | flags));\n    buffer.putShort(wordCost);\n\n    if ((flags & BinaryDictionary.HAS_BASEFORM) != 0) {\n      if (baseForm.length() >= 16) {\n        throw new IllegalArgumentException(\"Length of base form \" + baseForm + \" is >= 16\");\n      }\n      int shared = sharedPrefix(entry[0], baseForm);\n      int suffix = baseForm.length() - shared;\n      buffer.put((byte) (shared << 4 | suffix));\n      for (int i = shared; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_READING) != 0) {\n      if (isKatakana(reading)) {\n        buffer.put((byte) (reading.length() << 1 | 1));\n        writeKatakana(reading);\n      } else {\n        buffer.put((byte) (reading.length() << 1));\n        for (int i = 0; i < reading.length(); i++) {\n          buffer.putChar(reading.charAt(i));\n        }\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_PRONUNCIATION) != 0) {\n      // we can save 150KB here, but it makes the reader a little complicated.\n      // int shared = sharedPrefix(reading, pronunciation);\n      // buffer.put((byte) shared);\n      // pronunciation = pronunciation.substring(shared);\n      if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    return buffer.position();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acb8730dbbbb0f88bb8db80769aa6e9b29d817b","date":1583461779,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/util/BinaryDictionaryWriter#put(String[]).mjava","pathOld":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/util/BinaryDictionaryWriter#put(String[]).mjava","sourceNew":"  /**\n   * put the entry in map\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n    // build up the POS string\n    for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!\"*\".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    \n    String posData = sb.toString();\n    if (posData.isEmpty()) {\n        throw new IllegalArgumentException(\"POS fields are empty\");\n    }\n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(posData));\n    sb.append(',');\n    if (!\"*\".equals(entry[8])) {\n      sb.append(CSVUtil.quoteEscape(entry[8]));\n    }\n    sb.append(',');\n    if (!\"*\".equals(entry[9])) {\n      sb.append(CSVUtil.quoteEscape(entry[9]));\n    }\n    String fullPOSData = sb.toString();\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case: two short, 3 bytes, and features (all as utf-16)\n    int worstCase = 4 + 3 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocateDirect(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    int flags = 0;\n    if (baseForm.isEmpty()) {\n        throw new IllegalArgumentException(\"base form is empty\");\n    }\n    if (!(\"*\".equals(baseForm) || baseForm.equals(entry[0]))) {\n      flags |= BinaryDictionary.HAS_BASEFORM;\n    }\n    if (!reading.equals(toKatakana(entry[0]))) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n    if (!pronunciation.equals(reading)) {\n      flags |= BinaryDictionary.HAS_PRONUNCIATION;\n    }\n\n    if (leftId != rightId) {\n        throw new IllegalArgumentException(\"rightId != leftId: \" + rightId + \" \" +leftId);\n    }\n    if (leftId >= ID_LIMIT) {\n        throw new IllegalArgumentException(\"leftId >= \" + ID_LIMIT + \": \" + leftId);\n    }\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    \n    String existing = posDict.get(leftId);\n    if (existing != null && existing.equals(fullPOSData) == false) {\n        // TODO: test me\n        throw new IllegalArgumentException(\"Multiple entries found for leftID=\" + leftId);\n    }\n    posDict.set(leftId, fullPOSData);\n    \n    buffer.putShort((short)(leftId << 3 | flags));\n    buffer.putShort(wordCost);\n\n    if ((flags & BinaryDictionary.HAS_BASEFORM) != 0) {\n      if (baseForm.length() >= 16) {\n        throw new IllegalArgumentException(\"Length of base form \" + baseForm + \" is >= 16\");\n      }\n      int shared = sharedPrefix(entry[0], baseForm);\n      int suffix = baseForm.length() - shared;\n      buffer.put((byte) (shared << 4 | suffix));\n      for (int i = shared; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_READING) != 0) {\n      if (isKatakana(reading)) {\n        buffer.put((byte) (reading.length() << 1 | 1));\n        writeKatakana(reading);\n      } else {\n        buffer.put((byte) (reading.length() << 1));\n        for (int i = 0; i < reading.length(); i++) {\n          buffer.putChar(reading.charAt(i));\n        }\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_PRONUNCIATION) != 0) {\n      // we can save 150KB here, but it makes the reader a little complicated.\n      // int shared = sharedPrefix(reading, pronunciation);\n      // buffer.put((byte) shared);\n      // pronunciation = pronunciation.substring(shared);\n      if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    return buffer.position();\n  }\n\n","sourceOld":"  /**\n   * put the entry in map\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n    // build up the POS string\n    for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!\"*\".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    \n    String posData = sb.toString();\n    if (posData.isEmpty()) {\n        throw new IllegalArgumentException(\"POS fields are empty\");\n    }\n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(posData));\n    sb.append(',');\n    if (!\"*\".equals(entry[8])) {\n      sb.append(CSVUtil.quoteEscape(entry[8]));\n    }\n    sb.append(',');\n    if (!\"*\".equals(entry[9])) {\n      sb.append(CSVUtil.quoteEscape(entry[9]));\n    }\n    String fullPOSData = sb.toString();\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case: two short, 3 bytes, and features (all as utf-16)\n    int worstCase = 4 + 3 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    int flags = 0;\n    if (baseForm.isEmpty()) {\n        throw new IllegalArgumentException(\"base form is empty\");\n    }\n    if (!(\"*\".equals(baseForm) || baseForm.equals(entry[0]))) {\n      flags |= BinaryDictionary.HAS_BASEFORM;\n    }\n    if (!reading.equals(toKatakana(entry[0]))) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n    if (!pronunciation.equals(reading)) {\n      flags |= BinaryDictionary.HAS_PRONUNCIATION;\n    }\n\n    if (leftId != rightId) {\n        throw new IllegalArgumentException(\"rightId != leftId: \" + rightId + \" \" +leftId);\n    }\n    if (leftId >= ID_LIMIT) {\n        throw new IllegalArgumentException(\"leftId >= \" + ID_LIMIT + \": \" + leftId);\n    }\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    \n    String existing = posDict.get(leftId);\n    if (existing != null && existing.equals(fullPOSData) == false) {\n        // TODO: test me\n        throw new IllegalArgumentException(\"Multiple entries found for leftID=\" + leftId);\n    }\n    posDict.set(leftId, fullPOSData);\n    \n    buffer.putShort((short)(leftId << 3 | flags));\n    buffer.putShort(wordCost);\n\n    if ((flags & BinaryDictionary.HAS_BASEFORM) != 0) {\n      if (baseForm.length() >= 16) {\n        throw new IllegalArgumentException(\"Length of base form \" + baseForm + \" is >= 16\");\n      }\n      int shared = sharedPrefix(entry[0], baseForm);\n      int suffix = baseForm.length() - shared;\n      buffer.put((byte) (shared << 4 | suffix));\n      for (int i = shared; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_READING) != 0) {\n      if (isKatakana(reading)) {\n        buffer.put((byte) (reading.length() << 1 | 1));\n        writeKatakana(reading);\n      } else {\n        buffer.put((byte) (reading.length() << 1));\n        for (int i = 0; i < reading.length(); i++) {\n          buffer.putChar(reading.charAt(i));\n        }\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_PRONUNCIATION) != 0) {\n      // we can save 150KB here, but it makes the reader a little complicated.\n      // int shared = sharedPrefix(reading, pronunciation);\n      // buffer.put((byte) shared);\n      // pronunciation = pronunciation.substring(shared);\n      if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    return buffer.position();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"05feb7eb5e91cb64742ce32b2ca3f02433530446":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5acb8730dbbbb0f88bb8db80769aa6e9b29d817b":["05feb7eb5e91cb64742ce32b2ca3f02433530446"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5acb8730dbbbb0f88bb8db80769aa6e9b29d817b"]},"commit2Childs":{"05feb7eb5e91cb64742ce32b2ca3f02433530446":["5acb8730dbbbb0f88bb8db80769aa6e9b29d817b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["05feb7eb5e91cb64742ce32b2ca3f02433530446"],"5acb8730dbbbb0f88bb8db80769aa6e9b29d817b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}