{"path":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","commits":[{"id":"a8c2926456ed45f9af75820d2e85859aed94afe6","date":1496417770,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"/dev/null","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\"+\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:false,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3, \" +\n                  // w/o overrequest and refinement, count for 'A' is lower than it should be\n                  // (we don't see the A from the middle shard)\n                  \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // w/o overrequest, we need refining to get the correct count for 'A'.\n                  \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         // top level facet has a single term\n                         \"  all:{${terms} type:terms, field:all_s, \"+sort_limit_over+\" refine:true, \" +\n                         \"       facet:{  \"+\n                         // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n                         \"         cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // all 3 docs matching base query have same 'all' value in top facet\n                  \"          all:{ buckets:[ { val:all, count:3, \" +\n                  // sub facet has refinement, so count for 'A' should be correct\n                  \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["15b321aed72eecb043f237c490b9afd4e52c25be"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"/dev/null","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\"+\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:false,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3, \" +\n                  // w/o overrequest and refinement, count for 'A' is lower than it should be\n                  // (we don't see the A from the middle shard)\n                  \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // w/o overrequest, we need refining to get the correct count for 'A'.\n                  \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         // top level facet has a single term\n                         \"  all:{${terms} type:terms, field:all_s, \"+sort_limit_over+\" refine:true, \" +\n                         \"       facet:{  \"+\n                         // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n                         \"         cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // all 3 docs matching base query have same 'all' value in top facet\n                  \"          all:{ buckets:[ { val:all, count:3, \" +\n                  // sub facet has refinement, so count for 'A' should be correct\n                  \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1794a0eb180b7d4e51424fbb32694cbb787ebc93","date":1496796881,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // basic refining test through/under a query facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"q1 : { type:query, q:'*:*', facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n            \"}\"\n    );\n\n    // basic refining test through/under a range facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\"+\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:false,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3, \" +\n                  // w/o overrequest and refinement, count for 'A' is lower than it should be\n                  // (we don't see the A from the middle shard)\n                  \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // w/o overrequest, we need refining to get the correct count for 'A'.\n                  \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         // top level facet has a single term\n                         \"  all:{${terms} type:terms, field:all_s, \"+sort_limit_over+\" refine:true, \" +\n                         \"       facet:{  \"+\n                         // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n                         \"         cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // all 3 docs matching base query have same 'all' value in top facet\n                  \"          all:{ buckets:[ { val:all, count:3, \" +\n                  // sub facet has refinement, so count for 'A' should be correct\n                  \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","sourceOld":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\"+\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:false,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3, \" +\n                  // w/o overrequest and refinement, count for 'A' is lower than it should be\n                  // (we don't see the A from the middle shard)\n                  \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // w/o overrequest, we need refining to get the correct count for 'A'.\n                  \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         // top level facet has a single term\n                         \"  all:{${terms} type:terms, field:all_s, \"+sort_limit_over+\" refine:true, \" +\n                         \"       facet:{  \"+\n                         // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n                         \"         cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // all 3 docs matching base query have same 'all' value in top facet\n                  \"          all:{ buckets:[ { val:all, count:3, \" +\n                  // sub facet has refinement, so count for 'A' should be correct\n                  \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","bugFix":null,"bugIntro":["15b321aed72eecb043f237c490b9afd4e52c25be"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f344bb33ca91f48e99c061980115b46fa84fc8f5","date":1496903283,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // basic refining test through/under a query facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"q1 : { type:query, q:'*:*', facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n            \"}\"\n    );\n\n    // basic refining test through/under a range facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\"+\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:false,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3, \" +\n                  // w/o overrequest and refinement, count for 'A' is lower than it should be\n                  // (we don't see the A from the middle shard)\n                  \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // w/o overrequest, we need refining to get the correct count for 'A'.\n                  \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         // top level facet has a single term\n                         \"  all:{${terms} type:terms, field:all_s, \"+sort_limit_over+\" refine:true, \" +\n                         \"       facet:{  \"+\n                         // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n                         \"         cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // all 3 docs matching base query have same 'all' value in top facet\n                  \"          all:{ buckets:[ { val:all, count:3, \" +\n                  // sub facet has refinement, so count for 'A' should be correct\n                  \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","sourceOld":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\"+\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:false,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3, \" +\n                  // w/o overrequest and refinement, count for 'A' is lower than it should be\n                  // (we don't see the A from the middle shard)\n                  \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // w/o overrequest, we need refining to get the correct count for 'A'.\n                  \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         // top level facet has a single term\n                         \"  all:{${terms} type:terms, field:all_s, \"+sort_limit_over+\" refine:true, \" +\n                         \"       facet:{  \"+\n                         // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n                         \"         cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // all 3 docs matching base query have same 'all' value in top facet\n                  \"          all:{ buckets:[ { val:all, count:3, \" +\n                  // sub facet has refinement, so count for 'A' should be correct\n                  \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"39fdbc59d893f5a211736e861fe145798a40b9ff","date":1498161919,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // same as above, but with an integer field instead of a string\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // basic refining test through/under a query facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"q1 : { type:query, q:'*:*', facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n            \"}\"\n    );\n\n    // basic refining test through/under a range facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n        \"json.facet\", \"{\" +\n            \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n            // self join on all_s ensures every doc on every shard included in facets\n            \"        domain: { join: { from:all_s, to:all_s } } }\" +\n            \"}\"\n        )\n        ,\n        \"/response/numFound==3\",\n        \"facets=={ count:3, \" +\n            // w/o overrequest and refinement, count for 'A' is lower than it should be\n            // (we don't see the A from the middle shard)\n            \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n        \"json.facet\", \"{\" +\n            \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n            // self join on all_s ensures every doc on every shard included in facets\n            \"        domain: { join: { from:all_s, to:all_s } } }\" +\n            \"}\"\n        )\n        ,\n        \"/response/numFound==3\",\n        \"facets=={ count:3,\" +\n            // w/o overrequest, we need refining to get the correct count for 'A'.\n            \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n        \"json.facet\", \"{\" +\n            // top level facet has a single term\n            \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n            \"       facet:{  \" +\n            // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n            \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n            \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n            \"}\"\n        )\n        ,\n        \"/response/numFound==3\",\n        \"facets=={ count:3,\" +\n            // all 3 docs matching base query have same 'all' value in top facet\n            \"          all:{ buckets:[ { val:all, count:3, \" +\n            // sub facet has refinement, so count for 'A' should be correct\n            \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","sourceOld":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // same as above, but with an integer field instead of a string\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // basic refining test through/under a query facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"q1 : { type:query, q:'*:*', facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n            \"}\"\n    );\n\n    // basic refining test through/under a range facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\"+\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:false,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3, \" +\n                  // w/o overrequest and refinement, count for 'A' is lower than it should be\n                  // (we don't see the A from the middle shard)\n                  \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // w/o overrequest, we need refining to get the correct count for 'A'.\n                  \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         // top level facet has a single term\n                         \"  all:{${terms} type:terms, field:all_s, \"+sort_limit_over+\" refine:true, \" +\n                         \"       facet:{  \"+\n                         // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n                         \"         cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // all 3 docs matching base query have same 'all' value in top facet\n                  \"          all:{ buckets:[ { val:all, count:3, \" +\n                  // sub facet has refinement, so count for 'A' should be correct\n                  \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","bugFix":null,"bugIntro":["15b321aed72eecb043f237c490b9afd4e52c25be"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6b4e21f270c812affb9d34da7e81113045b05e0","date":1497389490,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // same as above, but with an integer field instead of a string\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // basic refining test through/under a query facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"q1 : { type:query, q:'*:*', facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n            \"}\"\n    );\n\n    // basic refining test through/under a range facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\"+\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:false,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3, \" +\n                  // w/o overrequest and refinement, count for 'A' is lower than it should be\n                  // (we don't see the A from the middle shard)\n                  \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // w/o overrequest, we need refining to get the correct count for 'A'.\n                  \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         // top level facet has a single term\n                         \"  all:{${terms} type:terms, field:all_s, \"+sort_limit_over+\" refine:true, \" +\n                         \"       facet:{  \"+\n                         // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n                         \"         cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // all 3 docs matching base query have same 'all' value in top facet\n                  \"          all:{ buckets:[ { val:all, count:3, \" +\n                  // sub facet has refinement, so count for 'A' should be correct\n                  \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","sourceOld":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // basic refining test through/under a query facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"q1 : { type:query, q:'*:*', facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n            \"}\"\n    );\n\n    // basic refining test through/under a range facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\"+\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:false,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3, \" +\n                  // w/o overrequest and refinement, count for 'A' is lower than it should be\n                  // (we don't see the A from the middle shard)\n                  \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // w/o overrequest, we need refining to get the correct count for 'A'.\n                  \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         // top level facet has a single term\n                         \"  all:{${terms} type:terms, field:all_s, \"+sort_limit_over+\" refine:true, \" +\n                         \"       facet:{  \"+\n                         // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n                         \"         cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // all 3 docs matching base query have same 'all' value in top facet\n                  \"          all:{ buckets:[ { val:all, count:3, \" +\n                  // sub facet has refinement, so count for 'A' should be correct\n                  \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","bugFix":null,"bugIntro":["15b321aed72eecb043f237c490b9afd4e52c25be"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // same as above, but with an integer field instead of a string\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // basic refining test through/under a query facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"q1 : { type:query, q:'*:*', facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n            \"}\"\n    );\n\n    // basic refining test through/under a range facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\"+\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:false,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3, \" +\n                  // w/o overrequest and refinement, count for 'A' is lower than it should be\n                  // (we don't see the A from the middle shard)\n                  \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // w/o overrequest, we need refining to get the correct count for 'A'.\n                  \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         // top level facet has a single term\n                         \"  all:{${terms} type:terms, field:all_s, \"+sort_limit_over+\" refine:true, \" +\n                         \"       facet:{  \"+\n                         // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n                         \"         cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // all 3 docs matching base query have same 'all' value in top facet\n                  \"          all:{ buckets:[ { val:all, count:3, \" +\n                  // sub facet has refinement, so count for 'A' should be correct\n                  \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","sourceOld":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\"+\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:false,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3, \" +\n                  // w/o overrequest and refinement, count for 'A' is lower than it should be\n                  // (we don't see the A from the middle shard)\n                  \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // w/o overrequest, we need refining to get the correct count for 'A'.\n                  \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         // top level facet has a single term\n                         \"  all:{${terms} type:terms, field:all_s, \"+sort_limit_over+\" refine:true, \" +\n                         \"       facet:{  \"+\n                         // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n                         \"         cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // all 3 docs matching base query have same 'all' value in top facet\n                  \"          all:{ buckets:[ { val:all, count:3, \" +\n                  // sub facet has refinement, so count for 'A' should be correct\n                  \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // same as above, but with an integer field instead of a string\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // basic refining test through/under a query facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"q1 : { type:query, q:'*:*', facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n            \"}\"\n    );\n\n    // basic refining test through/under a range facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n        \"json.facet\", \"{\" +\n            \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n            // self join on all_s ensures every doc on every shard included in facets\n            \"        domain: { join: { from:all_s, to:all_s } } }\" +\n            \"}\"\n        )\n        ,\n        \"/response/numFound==3\",\n        \"facets=={ count:3, \" +\n            // w/o overrequest and refinement, count for 'A' is lower than it should be\n            // (we don't see the A from the middle shard)\n            \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n        \"json.facet\", \"{\" +\n            \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n            // self join on all_s ensures every doc on every shard included in facets\n            \"        domain: { join: { from:all_s, to:all_s } } }\" +\n            \"}\"\n        )\n        ,\n        \"/response/numFound==3\",\n        \"facets=={ count:3,\" +\n            // w/o overrequest, we need refining to get the correct count for 'A'.\n            \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n        \"json.facet\", \"{\" +\n            // top level facet has a single term\n            \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n            \"       facet:{  \" +\n            // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n            \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n            \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n            \"}\"\n        )\n        ,\n        \"/response/numFound==3\",\n        \"facets=={ count:3,\" +\n            // all 3 docs matching base query have same 'all' value in top facet\n            \"          all:{ buckets:[ { val:all, count:3, \" +\n            // sub facet has refinement, so count for 'A' should be correct\n            \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","sourceOld":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", cat_i,1, xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", cat_i,2, xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // same as above, but with an integer field instead of a string\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // basic refining test through/under a query facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"q1 : { type:query, q:'*:*', facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n            \"}\"\n    );\n\n    // basic refining test through/under a range facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\"+\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:false,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3, \" +\n                  // w/o overrequest and refinement, count for 'A' is lower than it should be\n                  // (we don't see the A from the middle shard)\n                  \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         \"  cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // w/o overrequest, we need refining to get the correct count for 'A'.\n                  \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         // top level facet has a single term\n                         \"  all:{${terms} type:terms, field:all_s, \"+sort_limit_over+\" refine:true, \" +\n                         \"       facet:{  \"+\n                         // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n                         \"         cat0:{${terms} type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // all 3 docs matching base query have same 'all' value in top facet\n                  \"          all:{ buckets:[ { val:all, count:3, \" +\n                  // sub facet has refinement, so count for 'A' should be correct\n                  \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"/dev/null","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // same as above, but with an integer field instead of a string\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // basic refining test through/under a query facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"q1 : { type:query, q:'*:*', facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n            \"}\"\n    );\n\n    // basic refining test through/under a range facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n        \"json.facet\", \"{\" +\n            \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n            // self join on all_s ensures every doc on every shard included in facets\n            \"        domain: { join: { from:all_s, to:all_s } } }\" +\n            \"}\"\n        )\n        ,\n        \"/response/numFound==3\",\n        \"facets=={ count:3, \" +\n            // w/o overrequest and refinement, count for 'A' is lower than it should be\n            // (we don't see the A from the middle shard)\n            \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n        \"json.facet\", \"{\" +\n            \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n            // self join on all_s ensures every doc on every shard included in facets\n            \"        domain: { join: { from:all_s, to:all_s } } }\" +\n            \"}\"\n        )\n        ,\n        \"/response/numFound==3\",\n        \"facets=={ count:3,\" +\n            // w/o overrequest, we need refining to get the correct count for 'A'.\n            \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n        \"json.facet\", \"{\" +\n            // top level facet has a single term\n            \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n            \"       facet:{  \" +\n            // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n            \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n            \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n            \"}\"\n        )\n        ,\n        \"/response/numFound==3\",\n        \"facets=={ count:3,\" +\n            // all 3 docs matching base query have same 'all' value in top facet\n            \"          all:{ buckets:[ { val:all, count:3, \" +\n            // sub facet has refinement, so count for 'A' should be correct\n            \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15b321aed72eecb043f237c490b9afd4e52c25be","date":1525894978,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n    String date = p.get(\"date\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n    for (String method : new String[]{\"\",\"dvhash\",\"stream\",\"uif\",\"enum\",\"stream\",\"smart\"}) {\n      if (method.equals(\"\")) {\n        p.remove(\"terms\");\n      } else {\n        p.set(\"terms\", \"method:\" + method+\", \");\n      }\n\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n              \"}\"\n      );\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with an integer field instead of a string\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with a date field\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${date}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:'2001-01-01T01:01:01Z',count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // basic refining test through/under a query facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"q1 : { type:query, q:'*:*', facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n              \"}\"\n      );\n\n      // basic refining test through/under a range facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n              \"}\"\n      );\n\n      // test that basic stats work for refinement\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n              \"}\"\n      );\n\n      // test sorting buckets by a different stat\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n              \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n              \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n              \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n              \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n              \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n              \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n              \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n              \", sum1:2.0\" +\n              \"}\"\n      );\n\n      // test partial buckets (field facet within field facet)\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",cd:{${terms} type:terms, field:${cat_i}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",ef:{${terms} type:terms, field:${date},  limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n              \", cd:{ buckets:[  {val:1, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (int type)\n              \", ef:{ buckets:[  {val:'2001-01-01T01:01:01Z', count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (date type)\n              \"}\"\n      );\n\n      // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \"}\"\n      );\n\n      // test refining under the special \"missing\" bucket of a field facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n              \"}\"\n      );\n\n      // test filling in \"missing\" bucket for partially refined facets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              // test all values missing in sub-facet\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n              // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n              \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n              \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n              \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n              \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n              \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing \"allBuckets\"\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n              \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n              \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n              \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing numBuckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n              \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n              \"}\"\n      );\n\n      final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n      // simplistic join domain testing: no refinement == low count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3, \" +\n              // w/o overrequest and refinement, count for 'A' is lower than it should be\n              // (we don't see the A from the middle shard)\n              \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n      // simplistic join domain testing: refinement == correct count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // w/o overrequest, we need refining to get the correct count for 'A'.\n              \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n      // contrived join domain + refinement (at second level) + testing\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              // top level facet has a single term\n              \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n              \"       facet:{  \" +\n              // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n              \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // all 3 docs matching base query have same 'all' value in top facet\n              \"          all:{ buckets:[ { val:all, count:3, \" +\n              // sub facet has refinement, so count for 'A' should be correct\n              \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n    } // end method loop\n  }\n\n","sourceOld":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // same as above, but with an integer field instead of a string\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // basic refining test through/under a query facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"q1 : { type:query, q:'*:*', facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n            \"}\"\n    );\n\n    // basic refining test through/under a range facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n        \"json.facet\", \"{\" +\n            \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n            // self join on all_s ensures every doc on every shard included in facets\n            \"        domain: { join: { from:all_s, to:all_s } } }\" +\n            \"}\"\n        )\n        ,\n        \"/response/numFound==3\",\n        \"facets=={ count:3, \" +\n            // w/o overrequest and refinement, count for 'A' is lower than it should be\n            // (we don't see the A from the middle shard)\n            \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n        \"json.facet\", \"{\" +\n            \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n            // self join on all_s ensures every doc on every shard included in facets\n            \"        domain: { join: { from:all_s, to:all_s } } }\" +\n            \"}\"\n        )\n        ,\n        \"/response/numFound==3\",\n        \"facets=={ count:3,\" +\n            // w/o overrequest, we need refining to get the correct count for 'A'.\n            \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n        \"json.facet\", \"{\" +\n            // top level facet has a single term\n            \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n            \"       facet:{  \" +\n            // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n            \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n            \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n            \"}\"\n        )\n        ,\n        \"/response/numFound==3\",\n        \"facets=={ count:3,\" +\n            // all 3 docs matching base query have same 'all' value in top facet\n            \"          all:{ buckets:[ { val:all, count:3, \" +\n            // sub facet has refinement, so count for 'A' should be correct\n            \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","bugFix":["39fdbc59d893f5a211736e861fe145798a40b9ff","a8c2926456ed45f9af75820d2e85859aed94afe6","1794a0eb180b7d4e51424fbb32694cbb787ebc93","a6b4e21f270c812affb9d34da7e81113045b05e0"],"bugIntro":["dd5179c53ace95be1691b13506e7f43ebf92a114","c05b634713ca09b2267477408773904d4c69dd9d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c705a0d590cf911e7c942df49563ca2ea176e22","date":1526916174,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n    String date = p.get(\"date\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n    for (String method : new String[]{\"\",\"dvhash\",\"stream\",\"uif\",\"enum\",\"stream\",\"smart\"}) {\n      if (method.equals(\"\")) {\n        p.remove(\"terms\");\n      } else {\n        p.set(\"terms\", \"method:\" + method+\", \");\n      }\n\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n              \"}\"\n      );\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with an integer field instead of a string\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with a date field\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${date}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:'2001-01-01T01:01:01Z',count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // basic refining test through/under a query facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"q1 : { type:query, q:'*:*', facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n              \"}\"\n      );\n\n      // basic refining test through/under a range facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n              \"}\"\n      );\n\n      // test that basic stats work for refinement\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n              \"}\"\n      );\n\n      // test sorting buckets by a different stat\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n              \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n              \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n              \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n              \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n              \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n              \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n              \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n              \", sum1:2.0\" +\n              \"}\"\n      );\n\n      // test that SKG stat reflects merged refinement\n      client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                           \"json.facet\", \"{\"\n                           + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                           + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                           + \"          facet:{ s:'relatedness($fore,$back)'} } }\")\n                    , \"facets=={ count:8, cat0:{ buckets:[ \"\n                    + \"   { val:A, count:4, \"\n                    + \"     s : { relatedness: 0.00496, \"\n                    //+ \"           foreground_count: 3, \"\n                    //+ \"           foreground_size: 5, \"\n                    //+ \"           background_count: 2, \"\n                    //+ \"           background_size: 4, \"\n                    + \"           foreground_popularity: 0.75, \"\n                    + \"           background_popularity: 0.5, \"\n                    + \"         } } ] }\" +\n                    \"}\"\n                    );\n      \n      // SKG under nested facet where some terms only exist on one shard\n      { \n        // sub-bucket order should change as sort direction changes\n        final String jsonFacet = \"\"\n          + \"{ processEmpty:true, \"\n          + \" cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n          + \"        sort:'count desc', limit:1, overrequest:0, refine:true, \"\n          + \"        facet:{ processEmpty:true, \"\n          + \"                qw1: { ${terms} type:terms, field: ${qw_s}, mincount:0, \"\n          + \"                       sort:'${skg_sort}', limit:100, overrequest:0, refine:true, \"\n          + \"                       facet:{ processEmpty:true, skg:'relatedness($fore,$back)' } } } } }\";\n        final String bucketQ = \"\"\n          + \"             { val:Q, count:1, \"\n          + \"               skg : { relatedness: 1.0, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.0, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 0, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        final String bucketW = \"\"\n          + \"             { val:W, count:1, \"\n          + \"               skg : { relatedness: 0.0037, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.25, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 1, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        \n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg desc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketQ\n                      + bucketW\n                      + \"  ] } } ] } }\");\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg asc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketW\n                      + bucketQ\n                      + \"  ] } } ] } }\");\n      }\n    \n      // test partial buckets (field facet within field facet)\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",cd:{${terms} type:terms, field:${cat_i}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",ef:{${terms} type:terms, field:${date},  limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n              \", cd:{ buckets:[  {val:1, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (int type)\n              \", ef:{ buckets:[  {val:'2001-01-01T01:01:01Z', count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (date type)\n              \"}\"\n      );\n\n      // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \"}\"\n      );\n\n      // test refining under the special \"missing\" bucket of a field facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n              \"}\"\n      );\n\n      // test filling in \"missing\" bucket for partially refined facets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              // test all values missing in sub-facet\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n              // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n              \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n              \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n              \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n              \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n              \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing \"allBuckets\"\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n              \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n              \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n              \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing numBuckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n              \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n              \"}\"\n      );\n\n      final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n      // simplistic join domain testing: no refinement == low count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3, \" +\n              // w/o overrequest and refinement, count for 'A' is lower than it should be\n              // (we don't see the A from the middle shard)\n              \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n      // simplistic join domain testing: refinement == correct count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // w/o overrequest, we need refining to get the correct count for 'A'.\n              \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n      // contrived join domain + refinement (at second level) + testing\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              // top level facet has a single term\n              \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n              \"       facet:{  \" +\n              // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n              \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // all 3 docs matching base query have same 'all' value in top facet\n              \"          all:{ buckets:[ { val:all, count:3, \" +\n              // sub facet has refinement, so count for 'A' should be correct\n              \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n    } // end method loop\n  }\n\n","sourceOld":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n    String date = p.get(\"date\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n    for (String method : new String[]{\"\",\"dvhash\",\"stream\",\"uif\",\"enum\",\"stream\",\"smart\"}) {\n      if (method.equals(\"\")) {\n        p.remove(\"terms\");\n      } else {\n        p.set(\"terms\", \"method:\" + method+\", \");\n      }\n\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n              \"}\"\n      );\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with an integer field instead of a string\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with a date field\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${date}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:'2001-01-01T01:01:01Z',count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // basic refining test through/under a query facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"q1 : { type:query, q:'*:*', facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n              \"}\"\n      );\n\n      // basic refining test through/under a range facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n              \"}\"\n      );\n\n      // test that basic stats work for refinement\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n              \"}\"\n      );\n\n      // test sorting buckets by a different stat\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n              \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n              \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n              \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n              \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n              \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n              \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n              \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n              \", sum1:2.0\" +\n              \"}\"\n      );\n\n      // test partial buckets (field facet within field facet)\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",cd:{${terms} type:terms, field:${cat_i}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",ef:{${terms} type:terms, field:${date},  limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n              \", cd:{ buckets:[  {val:1, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (int type)\n              \", ef:{ buckets:[  {val:'2001-01-01T01:01:01Z', count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (date type)\n              \"}\"\n      );\n\n      // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \"}\"\n      );\n\n      // test refining under the special \"missing\" bucket of a field facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n              \"}\"\n      );\n\n      // test filling in \"missing\" bucket for partially refined facets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              // test all values missing in sub-facet\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n              // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n              \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n              \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n              \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n              \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n              \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing \"allBuckets\"\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n              \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n              \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n              \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing numBuckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n              \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n              \"}\"\n      );\n\n      final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n      // simplistic join domain testing: no refinement == low count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3, \" +\n              // w/o overrequest and refinement, count for 'A' is lower than it should be\n              // (we don't see the A from the middle shard)\n              \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n      // simplistic join domain testing: refinement == correct count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // w/o overrequest, we need refining to get the correct count for 'A'.\n              \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n      // contrived join domain + refinement (at second level) + testing\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              // top level facet has a single term\n              \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n              \"       facet:{  \" +\n              // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n              \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // all 3 docs matching base query have same 'all' value in top facet\n              \"          all:{ buckets:[ { val:all, count:3, \" +\n              // sub facet has refinement, so count for 'A' should be correct\n              \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n    } // end method loop\n  }\n\n","bugFix":null,"bugIntro":["22d2c45da6e47ff0ada29a8f98566b76f0b278de"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c05b634713ca09b2267477408773904d4c69dd9d","date":1530894845,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n    String date = p.get(\"date\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n    for (String method : new String[]{\"\",\"dvhash\",\"stream\",\"uif\",\"enum\",\"stream\",\"smart\"}) {\n      if (method.equals(\"\")) {\n        p.remove(\"terms\");\n      } else {\n        p.set(\"terms\", \"method:\" + method+\", \");\n      }\n\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n              \"}\"\n      );\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with an integer field instead of a string\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with a date field\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${date}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:'2001-01-01T01:01:01Z',count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // basic refining test through/under a query facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"q1 : { type:query, q:'*:*', facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n              \"}\"\n      );\n\n      // basic refining test through/under a range facet\n      for (String end : Arrays.asList(// all of these end+hardened options should produce the same buckets\n                                      \"end:20, hardend:true\", // evenly divisible so shouldn't matter\n                                      \"end:20, hardend:false\", \"end:20\", // defaults to hardened:false\n                                      \"end:5, hardend:false\", \"end:5\")) {\n        // since the gap divides the start/end divide eveningly, \n        // all of these hardend params should we should produce identical results\n        String sub = \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\";\n\n        // single bucket, all 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:all, start:-20, gap:40, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      + \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }],\"\n                      + \"       before:{count:0}, after:{count:0}\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n        // multiple buckets, only one 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:between, start:-20, gap:20, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      // NOTE: in both buckets A & B are tied, but index order should break tie\n                      + \", r1:{ buckets:[{val:-20.0, count:4,  cat0:{buckets:[{val:A,count:2}]} },\"\n                      + \"                {val:  0.0, count:4,  cat0:{buckets:[{val:A,count:2}]} } ],\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n      }\n\n      // test that basic stats work for refinement\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n              \"}\"\n      );\n\n      // test sorting buckets by a different stat\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n              \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n              \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n              \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n              \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n              \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n              \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n              \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n              \", sum1:2.0\" +\n              \"}\"\n      );\n\n      // test that SKG stat reflects merged refinement\n      client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                           \"json.facet\", \"{\"\n                           + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                           + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                           + \"          facet:{ s:'relatedness($fore,$back)'} } }\")\n                    , \"facets=={ count:8, cat0:{ buckets:[ \"\n                    + \"   { val:A, count:4, \"\n                    + \"     s : { relatedness: 0.00496, \"\n                    //+ \"           foreground_count: 3, \"\n                    //+ \"           foreground_size: 5, \"\n                    //+ \"           background_count: 2, \"\n                    //+ \"           background_size: 4, \"\n                    + \"           foreground_popularity: 0.75, \"\n                    + \"           background_popularity: 0.5, \"\n                    + \"         } } ] }\" +\n                    \"}\"\n                    );\n      \n      // SKG under nested facet where some terms only exist on one shard\n      { \n        // sub-bucket order should change as sort direction changes\n        final String jsonFacet = \"\"\n          + \"{ processEmpty:true, \"\n          + \" cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n          + \"        sort:'count desc', limit:1, overrequest:0, refine:true, \"\n          + \"        facet:{ processEmpty:true, \"\n          + \"                qw1: { ${terms} type:terms, field: ${qw_s}, mincount:0, \"\n          + \"                       sort:'${skg_sort}', limit:100, overrequest:0, refine:true, \"\n          + \"                       facet:{ processEmpty:true, skg:'relatedness($fore,$back)' } } } } }\";\n        final String bucketQ = \"\"\n          + \"             { val:Q, count:1, \"\n          + \"               skg : { relatedness: 1.0, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.0, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 0, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        final String bucketW = \"\"\n          + \"             { val:W, count:1, \"\n          + \"               skg : { relatedness: 0.0037, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.25, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 1, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        \n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg desc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketQ\n                      + bucketW\n                      + \"  ] } } ] } }\");\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg asc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketW\n                      + bucketQ\n                      + \"  ] } } ] } }\");\n      }\n    \n      // test partial buckets (field facet within field facet)\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",cd:{${terms} type:terms, field:${cat_i}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",ef:{${terms} type:terms, field:${date},  limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n              \", cd:{ buckets:[  {val:1, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (int type)\n              \", ef:{ buckets:[  {val:'2001-01-01T01:01:01Z', count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (date type)\n              \"}\"\n      );\n\n      // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \"}\"\n      );\n\n      // test refining under the special \"missing\" bucket of a field facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n              \"}\"\n      );\n\n      // test filling in \"missing\" bucket for partially refined facets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              // test all values missing in sub-facet\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n              // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n              \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n              \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n              \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n              \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n              \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing \"allBuckets\"\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n              \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n              \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n              \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing numBuckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n              \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n              \"}\"\n      );\n\n      final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n      // simplistic join domain testing: no refinement == low count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3, \" +\n              // w/o overrequest and refinement, count for 'A' is lower than it should be\n              // (we don't see the A from the middle shard)\n              \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n      // simplistic join domain testing: refinement == correct count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // w/o overrequest, we need refining to get the correct count for 'A'.\n              \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n      // contrived join domain + refinement (at second level) + testing\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              // top level facet has a single term\n              \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n              \"       facet:{  \" +\n              // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n              \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // all 3 docs matching base query have same 'all' value in top facet\n              \"          all:{ buckets:[ { val:all, count:3, \" +\n              // sub facet has refinement, so count for 'A' should be correct\n              \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n    } // end method loop\n  }\n\n","sourceOld":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n    String date = p.get(\"date\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n    for (String method : new String[]{\"\",\"dvhash\",\"stream\",\"uif\",\"enum\",\"stream\",\"smart\"}) {\n      if (method.equals(\"\")) {\n        p.remove(\"terms\");\n      } else {\n        p.set(\"terms\", \"method:\" + method+\", \");\n      }\n\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n              \"}\"\n      );\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with an integer field instead of a string\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with a date field\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${date}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:'2001-01-01T01:01:01Z',count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // basic refining test through/under a query facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"q1 : { type:query, q:'*:*', facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n              \"}\"\n      );\n\n      // basic refining test through/under a range facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n              \"}\"\n      );\n\n      // test that basic stats work for refinement\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n              \"}\"\n      );\n\n      // test sorting buckets by a different stat\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n              \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n              \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n              \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n              \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n              \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n              \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n              \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n              \", sum1:2.0\" +\n              \"}\"\n      );\n\n      // test that SKG stat reflects merged refinement\n      client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                           \"json.facet\", \"{\"\n                           + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                           + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                           + \"          facet:{ s:'relatedness($fore,$back)'} } }\")\n                    , \"facets=={ count:8, cat0:{ buckets:[ \"\n                    + \"   { val:A, count:4, \"\n                    + \"     s : { relatedness: 0.00496, \"\n                    //+ \"           foreground_count: 3, \"\n                    //+ \"           foreground_size: 5, \"\n                    //+ \"           background_count: 2, \"\n                    //+ \"           background_size: 4, \"\n                    + \"           foreground_popularity: 0.75, \"\n                    + \"           background_popularity: 0.5, \"\n                    + \"         } } ] }\" +\n                    \"}\"\n                    );\n      \n      // SKG under nested facet where some terms only exist on one shard\n      { \n        // sub-bucket order should change as sort direction changes\n        final String jsonFacet = \"\"\n          + \"{ processEmpty:true, \"\n          + \" cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n          + \"        sort:'count desc', limit:1, overrequest:0, refine:true, \"\n          + \"        facet:{ processEmpty:true, \"\n          + \"                qw1: { ${terms} type:terms, field: ${qw_s}, mincount:0, \"\n          + \"                       sort:'${skg_sort}', limit:100, overrequest:0, refine:true, \"\n          + \"                       facet:{ processEmpty:true, skg:'relatedness($fore,$back)' } } } } }\";\n        final String bucketQ = \"\"\n          + \"             { val:Q, count:1, \"\n          + \"               skg : { relatedness: 1.0, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.0, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 0, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        final String bucketW = \"\"\n          + \"             { val:W, count:1, \"\n          + \"               skg : { relatedness: 0.0037, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.25, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 1, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        \n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg desc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketQ\n                      + bucketW\n                      + \"  ] } } ] } }\");\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg asc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketW\n                      + bucketQ\n                      + \"  ] } } ] } }\");\n      }\n    \n      // test partial buckets (field facet within field facet)\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",cd:{${terms} type:terms, field:${cat_i}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",ef:{${terms} type:terms, field:${date},  limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n              \", cd:{ buckets:[  {val:1, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (int type)\n              \", ef:{ buckets:[  {val:'2001-01-01T01:01:01Z', count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (date type)\n              \"}\"\n      );\n\n      // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \"}\"\n      );\n\n      // test refining under the special \"missing\" bucket of a field facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n              \"}\"\n      );\n\n      // test filling in \"missing\" bucket for partially refined facets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              // test all values missing in sub-facet\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n              // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n              \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n              \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n              \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n              \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n              \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing \"allBuckets\"\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n              \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n              \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n              \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing numBuckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n              \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n              \"}\"\n      );\n\n      final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n      // simplistic join domain testing: no refinement == low count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3, \" +\n              // w/o overrequest and refinement, count for 'A' is lower than it should be\n              // (we don't see the A from the middle shard)\n              \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n      // simplistic join domain testing: refinement == correct count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // w/o overrequest, we need refining to get the correct count for 'A'.\n              \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n      // contrived join domain + refinement (at second level) + testing\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              // top level facet has a single term\n              \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n              \"       facet:{  \" +\n              // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n              \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // all 3 docs matching base query have same 'all' value in top facet\n              \"          all:{ buckets:[ { val:all, count:3, \" +\n              // sub facet has refinement, so count for 'A' should be correct\n              \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n    } // end method loop\n  }\n\n","bugFix":["15b321aed72eecb043f237c490b9afd4e52c25be"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n    String date = p.get(\"date\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n    for (String method : new String[]{\"\",\"dvhash\",\"stream\",\"uif\",\"enum\",\"stream\",\"smart\"}) {\n      if (method.equals(\"\")) {\n        p.remove(\"terms\");\n      } else {\n        p.set(\"terms\", \"method:\" + method+\", \");\n      }\n\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n              \"}\"\n      );\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with an integer field instead of a string\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with a date field\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${date}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:'2001-01-01T01:01:01Z',count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // basic refining test through/under a query facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"q1 : { type:query, q:'*:*', facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n              \"}\"\n      );\n\n      // basic refining test through/under a range facet\n      for (String end : Arrays.asList(// all of these end+hardened options should produce the same buckets\n                                      \"end:20, hardend:true\", // evenly divisible so shouldn't matter\n                                      \"end:20, hardend:false\", \"end:20\", // defaults to hardened:false\n                                      \"end:5, hardend:false\", \"end:5\")) {\n        // since the gap divides the start/end divide eveningly, \n        // all of these hardend params should we should produce identical results\n        String sub = \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\";\n\n        // single bucket, all 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:all, start:-20, gap:40, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      + \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }],\"\n                      + \"       before:{count:0}, after:{count:0}\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n        // multiple buckets, only one 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:between, start:-20, gap:20, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      // NOTE: in both buckets A & B are tied, but index order should break tie\n                      + \", r1:{ buckets:[{val:-20.0, count:4,  cat0:{buckets:[{val:A,count:2}]} },\"\n                      + \"                {val:  0.0, count:4,  cat0:{buckets:[{val:A,count:2}]} } ],\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n      }\n\n      // test that basic stats work for refinement\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n              \"}\"\n      );\n\n      // test sorting buckets by a different stat\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n              \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n              \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n              \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n              \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n              \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n              \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n              \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n              \", sum1:2.0\" +\n              \"}\"\n      );\n\n      // test that SKG stat reflects merged refinement\n      client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                           \"json.facet\", \"{\"\n                           + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                           + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                           + \"          facet:{ s:'relatedness($fore,$back)'} } }\")\n                    , \"facets=={ count:8, cat0:{ buckets:[ \"\n                    + \"   { val:A, count:4, \"\n                    + \"     s : { relatedness: 0.00496, \"\n                    //+ \"           foreground_count: 3, \"\n                    //+ \"           foreground_size: 5, \"\n                    //+ \"           background_count: 2, \"\n                    //+ \"           background_size: 4, \"\n                    + \"           foreground_popularity: 0.75, \"\n                    + \"           background_popularity: 0.5, \"\n                    + \"         } } ] }\" +\n                    \"}\"\n                    );\n      \n      // SKG under nested facet where some terms only exist on one shard\n      { \n        // sub-bucket order should change as sort direction changes\n        final String jsonFacet = \"\"\n          + \"{ processEmpty:true, \"\n          + \" cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n          + \"        sort:'count desc', limit:1, overrequest:0, refine:true, \"\n          + \"        facet:{ processEmpty:true, \"\n          + \"                qw1: { ${terms} type:terms, field: ${qw_s}, mincount:0, \"\n          + \"                       sort:'${skg_sort}', limit:100, overrequest:0, refine:true, \"\n          + \"                       facet:{ processEmpty:true, skg:'relatedness($fore,$back)' } } } } }\";\n        final String bucketQ = \"\"\n          + \"             { val:Q, count:1, \"\n          + \"               skg : { relatedness: 1.0, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.0, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 0, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        final String bucketW = \"\"\n          + \"             { val:W, count:1, \"\n          + \"               skg : { relatedness: 0.0037, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.25, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 1, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        \n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg desc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketQ\n                      + bucketW\n                      + \"  ] } } ] } }\");\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg asc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketW\n                      + bucketQ\n                      + \"  ] } } ] } }\");\n      }\n    \n      // test partial buckets (field facet within field facet)\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",cd:{${terms} type:terms, field:${cat_i}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",ef:{${terms} type:terms, field:${date},  limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n              \", cd:{ buckets:[  {val:1, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (int type)\n              \", ef:{ buckets:[  {val:'2001-01-01T01:01:01Z', count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (date type)\n              \"}\"\n      );\n\n      // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \"}\"\n      );\n\n      // test refining under the special \"missing\" bucket of a field facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n              \"}\"\n      );\n\n      // test filling in \"missing\" bucket for partially refined facets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              // test all values missing in sub-facet\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n              // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n              \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n              \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n              \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n              \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n              \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing \"allBuckets\"\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n              \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n              \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n              \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing numBuckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n              \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n              \"}\"\n      );\n\n      final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n      // simplistic join domain testing: no refinement == low count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3, \" +\n              // w/o overrequest and refinement, count for 'A' is lower than it should be\n              // (we don't see the A from the middle shard)\n              \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n      // simplistic join domain testing: refinement == correct count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // w/o overrequest, we need refining to get the correct count for 'A'.\n              \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n      // contrived join domain + refinement (at second level) + testing\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              // top level facet has a single term\n              \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n              \"       facet:{  \" +\n              // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n              \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // all 3 docs matching base query have same 'all' value in top facet\n              \"          all:{ buckets:[ { val:all, count:3, \" +\n              // sub facet has refinement, so count for 'A' should be correct\n              \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n    } // end method loop\n  }\n\n","sourceOld":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n    String date = p.get(\"date\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n    for (String method : new String[]{\"\",\"dvhash\",\"stream\",\"uif\",\"enum\",\"stream\",\"smart\"}) {\n      if (method.equals(\"\")) {\n        p.remove(\"terms\");\n      } else {\n        p.set(\"terms\", \"method:\" + method+\", \");\n      }\n\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n              \"}\"\n      );\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with an integer field instead of a string\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with a date field\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${date}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:'2001-01-01T01:01:01Z',count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // basic refining test through/under a query facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"q1 : { type:query, q:'*:*', facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n              \"}\"\n      );\n\n      // basic refining test through/under a range facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n              \"}\"\n      );\n\n      // test that basic stats work for refinement\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n              \"}\"\n      );\n\n      // test sorting buckets by a different stat\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n              \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n              \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n              \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n              \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n              \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n              \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n              \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n              \", sum1:2.0\" +\n              \"}\"\n      );\n\n      // test that SKG stat reflects merged refinement\n      client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                           \"json.facet\", \"{\"\n                           + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                           + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                           + \"          facet:{ s:'relatedness($fore,$back)'} } }\")\n                    , \"facets=={ count:8, cat0:{ buckets:[ \"\n                    + \"   { val:A, count:4, \"\n                    + \"     s : { relatedness: 0.00496, \"\n                    //+ \"           foreground_count: 3, \"\n                    //+ \"           foreground_size: 5, \"\n                    //+ \"           background_count: 2, \"\n                    //+ \"           background_size: 4, \"\n                    + \"           foreground_popularity: 0.75, \"\n                    + \"           background_popularity: 0.5, \"\n                    + \"         } } ] }\" +\n                    \"}\"\n                    );\n      \n      // SKG under nested facet where some terms only exist on one shard\n      { \n        // sub-bucket order should change as sort direction changes\n        final String jsonFacet = \"\"\n          + \"{ processEmpty:true, \"\n          + \" cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n          + \"        sort:'count desc', limit:1, overrequest:0, refine:true, \"\n          + \"        facet:{ processEmpty:true, \"\n          + \"                qw1: { ${terms} type:terms, field: ${qw_s}, mincount:0, \"\n          + \"                       sort:'${skg_sort}', limit:100, overrequest:0, refine:true, \"\n          + \"                       facet:{ processEmpty:true, skg:'relatedness($fore,$back)' } } } } }\";\n        final String bucketQ = \"\"\n          + \"             { val:Q, count:1, \"\n          + \"               skg : { relatedness: 1.0, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.0, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 0, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        final String bucketW = \"\"\n          + \"             { val:W, count:1, \"\n          + \"               skg : { relatedness: 0.0037, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.25, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 1, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        \n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg desc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketQ\n                      + bucketW\n                      + \"  ] } } ] } }\");\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg asc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketW\n                      + bucketQ\n                      + \"  ] } } ] } }\");\n      }\n    \n      // test partial buckets (field facet within field facet)\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",cd:{${terms} type:terms, field:${cat_i}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",ef:{${terms} type:terms, field:${date},  limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n              \", cd:{ buckets:[  {val:1, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (int type)\n              \", ef:{ buckets:[  {val:'2001-01-01T01:01:01Z', count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (date type)\n              \"}\"\n      );\n\n      // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \"}\"\n      );\n\n      // test refining under the special \"missing\" bucket of a field facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n              \"}\"\n      );\n\n      // test filling in \"missing\" bucket for partially refined facets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              // test all values missing in sub-facet\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n              // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n              \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n              \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n              \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n              \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n              \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing \"allBuckets\"\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n              \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n              \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n              \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing numBuckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n              \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n              \"}\"\n      );\n\n      final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n      // simplistic join domain testing: no refinement == low count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3, \" +\n              // w/o overrequest and refinement, count for 'A' is lower than it should be\n              // (we don't see the A from the middle shard)\n              \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n      // simplistic join domain testing: refinement == correct count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // w/o overrequest, we need refining to get the correct count for 'A'.\n              \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n      // contrived join domain + refinement (at second level) + testing\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              // top level facet has a single term\n              \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n              \"       facet:{  \" +\n              // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n              \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // all 3 docs matching base query have same 'all' value in top facet\n              \"          all:{ buckets:[ { val:all, count:3, \" +\n              // sub facet has refinement, so count for 'A' should be correct\n              \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n    } // end method loop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n    String date = p.get(\"date\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n    for (String method : new String[]{\"\",\"dvhash\",\"stream\",\"uif\",\"enum\",\"stream\",\"smart\"}) {\n      if (method.equals(\"\")) {\n        p.remove(\"terms\");\n      } else {\n        p.set(\"terms\", \"method:\" + method+\", \");\n      }\n\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n              \"}\"\n      );\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with an integer field instead of a string\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with a date field\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${date}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:'2001-01-01T01:01:01Z',count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // basic refining test through/under a query facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"q1 : { type:query, q:'*:*', facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n              \"}\"\n      );\n\n      // basic refining test through/under a range facet\n      for (String end : Arrays.asList(// all of these end+hardened options should produce the same buckets\n                                      \"end:20, hardend:true\", // evenly divisible so shouldn't matter\n                                      \"end:20, hardend:false\", \"end:20\", // defaults to hardened:false\n                                      \"end:5, hardend:false\", \"end:5\")) {\n        // since the gap divides the start/end divide eveningly, \n        // all of these hardend params should we should produce identical results\n        String sub = \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\";\n\n        // single bucket, all 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:all, start:-20, gap:40, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      + \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }],\"\n                      + \"       before:{count:0}, after:{count:0}\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n        // multiple buckets, only one 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:between, start:-20, gap:20, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      // NOTE: in both buckets A & B are tied, but index order should break tie\n                      + \", r1:{ buckets:[{val:-20.0, count:4,  cat0:{buckets:[{val:A,count:2}]} },\"\n                      + \"                {val:  0.0, count:4,  cat0:{buckets:[{val:A,count:2}]} } ],\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n      }\n\n      // test that basic stats work for refinement\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n              \"}\"\n      );\n\n      // test sorting buckets by a different stat\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n              \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n              \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n              \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n              \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n              \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n              \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n              \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n              \", sum1:2.0\" +\n              \"}\"\n      );\n\n      // test that SKG stat reflects merged refinement\n      client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                           \"json.facet\", \"{\"\n                           + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                           + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                           + \"          facet:{ s:'relatedness($fore,$back)'} } }\")\n                    , \"facets=={ count:8, cat0:{ buckets:[ \"\n                    + \"   { val:A, count:4, \"\n                    + \"     s : { relatedness: 0.00496, \"\n                    //+ \"           foreground_count: 3, \"\n                    //+ \"           foreground_size: 5, \"\n                    //+ \"           background_count: 2, \"\n                    //+ \"           background_size: 4, \"\n                    + \"           foreground_popularity: 0.75, \"\n                    + \"           background_popularity: 0.5, \"\n                    + \"         } } ] }\" +\n                    \"}\"\n                    );\n      \n      // SKG under nested facet where some terms only exist on one shard\n      { \n        // sub-bucket order should change as sort direction changes\n        final String jsonFacet = \"\"\n          + \"{ processEmpty:true, \"\n          + \" cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n          + \"        sort:'count desc', limit:1, overrequest:0, refine:true, \"\n          + \"        facet:{ processEmpty:true, \"\n          + \"                qw1: { ${terms} type:terms, field: ${qw_s}, mincount:0, \"\n          + \"                       sort:'${skg_sort}', limit:100, overrequest:0, refine:true, \"\n          + \"                       facet:{ processEmpty:true, skg:'relatedness($fore,$back)' } } } } }\";\n        final String bucketQ = \"\"\n          + \"             { val:Q, count:1, \"\n          + \"               skg : { relatedness: 1.0, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.0, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 0, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        final String bucketW = \"\"\n          + \"             { val:W, count:1, \"\n          + \"               skg : { relatedness: 0.0037, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.25, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 1, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        \n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg desc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketQ\n                      + bucketW\n                      + \"  ] } } ] } }\");\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg asc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketW\n                      + bucketQ\n                      + \"  ] } } ] } }\");\n      }\n    \n      // test partial buckets (field facet within field facet)\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",cd:{${terms} type:terms, field:${cat_i}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",ef:{${terms} type:terms, field:${date},  limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n              \", cd:{ buckets:[  {val:1, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (int type)\n              \", ef:{ buckets:[  {val:'2001-01-01T01:01:01Z', count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (date type)\n              \"}\"\n      );\n\n      // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \"}\"\n      );\n\n      // test refining under the special \"missing\" bucket of a field facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n              \"}\"\n      );\n\n      // test filling in \"missing\" bucket for partially refined facets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              // test all values missing in sub-facet\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n              // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n              \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n              \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n              \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n              \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n              \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing \"allBuckets\"\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n              \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n              \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n              \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing numBuckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n              \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n              \"}\"\n      );\n\n      final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n      // simplistic join domain testing: no refinement == low count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3, \" +\n              // w/o overrequest and refinement, count for 'A' is lower than it should be\n              // (we don't see the A from the middle shard)\n              \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n      // simplistic join domain testing: refinement == correct count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // w/o overrequest, we need refining to get the correct count for 'A'.\n              \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n      // contrived join domain + refinement (at second level) + testing\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              // top level facet has a single term\n              \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n              \"       facet:{  \" +\n              // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n              \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // all 3 docs matching base query have same 'all' value in top facet\n              \"          all:{ buckets:[ { val:all, count:3, \" +\n              // sub facet has refinement, so count for 'A' should be correct\n              \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n    } // end method loop\n  }\n\n","sourceOld":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n    String date = p.get(\"date\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n    for (String method : new String[]{\"\",\"dvhash\",\"stream\",\"uif\",\"enum\",\"stream\",\"smart\"}) {\n      if (method.equals(\"\")) {\n        p.remove(\"terms\");\n      } else {\n        p.set(\"terms\", \"method:\" + method+\", \");\n      }\n\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n              \"}\"\n      );\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with an integer field instead of a string\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with a date field\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${date}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:'2001-01-01T01:01:01Z',count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // basic refining test through/under a query facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"q1 : { type:query, q:'*:*', facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n              \"}\"\n      );\n\n      // basic refining test through/under a range facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"r1 : { type:range, field:${num_d} start:-20, end:20, gap:40   , facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }]   }\" +\n              \"}\"\n      );\n\n      // test that basic stats work for refinement\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n              \"}\"\n      );\n\n      // test sorting buckets by a different stat\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n              \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n              \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n              \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n              \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n              \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n              \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n              \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n              \", sum1:2.0\" +\n              \"}\"\n      );\n\n      // test that SKG stat reflects merged refinement\n      client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                           \"json.facet\", \"{\"\n                           + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                           + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                           + \"          facet:{ s:'relatedness($fore,$back)'} } }\")\n                    , \"facets=={ count:8, cat0:{ buckets:[ \"\n                    + \"   { val:A, count:4, \"\n                    + \"     s : { relatedness: 0.00496, \"\n                    //+ \"           foreground_count: 3, \"\n                    //+ \"           foreground_size: 5, \"\n                    //+ \"           background_count: 2, \"\n                    //+ \"           background_size: 4, \"\n                    + \"           foreground_popularity: 0.75, \"\n                    + \"           background_popularity: 0.5, \"\n                    + \"         } } ] }\" +\n                    \"}\"\n                    );\n      \n      // SKG under nested facet where some terms only exist on one shard\n      { \n        // sub-bucket order should change as sort direction changes\n        final String jsonFacet = \"\"\n          + \"{ processEmpty:true, \"\n          + \" cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n          + \"        sort:'count desc', limit:1, overrequest:0, refine:true, \"\n          + \"        facet:{ processEmpty:true, \"\n          + \"                qw1: { ${terms} type:terms, field: ${qw_s}, mincount:0, \"\n          + \"                       sort:'${skg_sort}', limit:100, overrequest:0, refine:true, \"\n          + \"                       facet:{ processEmpty:true, skg:'relatedness($fore,$back)' } } } } }\";\n        final String bucketQ = \"\"\n          + \"             { val:Q, count:1, \"\n          + \"               skg : { relatedness: 1.0, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.0, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 0, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        final String bucketW = \"\"\n          + \"             { val:W, count:1, \"\n          + \"               skg : { relatedness: 0.0037, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.25, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 1, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        \n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg desc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketQ\n                      + bucketW\n                      + \"  ] } } ] } }\");\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg asc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketW\n                      + bucketQ\n                      + \"  ] } } ] } }\");\n      }\n    \n      // test partial buckets (field facet within field facet)\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",cd:{${terms} type:terms, field:${cat_i}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",ef:{${terms} type:terms, field:${date},  limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n              \", cd:{ buckets:[  {val:1, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (int type)\n              \", ef:{ buckets:[  {val:'2001-01-01T01:01:01Z', count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (date type)\n              \"}\"\n      );\n\n      // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \"}\"\n      );\n\n      // test refining under the special \"missing\" bucket of a field facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n              \"}\"\n      );\n\n      // test filling in \"missing\" bucket for partially refined facets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              // test all values missing in sub-facet\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n              // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n              \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n              \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n              \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n              \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n              \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing \"allBuckets\"\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n              \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n              \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n              \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing numBuckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n              \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n              \"}\"\n      );\n\n      final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n      // simplistic join domain testing: no refinement == low count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3, \" +\n              // w/o overrequest and refinement, count for 'A' is lower than it should be\n              // (we don't see the A from the middle shard)\n              \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n      // simplistic join domain testing: refinement == correct count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // w/o overrequest, we need refining to get the correct count for 'A'.\n              \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n      // contrived join domain + refinement (at second level) + testing\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              // top level facet has a single term\n              \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n              \"       facet:{  \" +\n              // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n              \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // all 3 docs matching base query have same 'all' value in top facet\n              \"          all:{ buckets:[ { val:all, count:3, \" +\n              // sub facet has refinement, so count for 'A' should be correct\n              \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n    } // end method loop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"42009f1fefcc8f4d9e07b158e9415cbd6ca7247c","date":1532538390,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n    \n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n    \n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n    String date = p.get(\"date\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n    for (String method : new String[]{\"\",\"dvhash\",\"stream\",\"uif\",\"enum\",\"stream\",\"smart\"}) {\n      if (method.equals(\"\")) {\n        p.remove(\"terms\");\n      } else {\n        p.set(\"terms\", \"method:\" + method+\", \");\n      }\n      \n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n              \"}\"\n      );\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with an integer field instead of a string\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with a date field\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${date}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:'2001-01-01T01:01:01Z',count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // basic refining test through/under a query facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"q1 : { type:query, q:'*:*', facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n              \"}\"\n      );\n\n      // basic refining test through/under a range facet\n      for (String end : Arrays.asList(// all of these end+hardened options should produce the same buckets\n                                      \"end:20, hardend:true\", // evenly divisible so shouldn't matter\n                                      \"end:20, hardend:false\", \"end:20\", // defaults to hardened:false\n                                      \"end:5, hardend:false\", \"end:5\")) {\n        // since the gap divides the start/end divide eveningly, \n        // all of these hardend params should we should produce identical results\n        String sub = \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\";\n\n        // single bucket, all 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:all, start:-20, gap:40, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      + \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }],\"\n                      + \"       before:{count:0}, after:{count:0}\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n        // multiple buckets, only one 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:between, start:-20, gap:20, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      // NOTE: in both buckets A & B are tied, but index order should break tie\n                      + \", r1:{ buckets:[{val:-20.0, count:4,  cat0:{buckets:[{val:A,count:2}]} },\"\n                      + \"                {val:  0.0, count:4,  cat0:{buckets:[{val:A,count:2}]} } ],\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n      }\n\n      // test that basic stats work for refinement\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n              \"}\"\n      );\n\n      // test sorting buckets by a different stat\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n              \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n              \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n              \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n              \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n              \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n              \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n              \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n              \", sum1:2.0\" +\n              \"}\"\n      );\n\n      // test that SKG stat reflects merged refinement\n      // results shouldn't care if we use the short or long syntax, or if we have a low min_pop\n      for (String s : Arrays.asList(\"'relatedness($fore,$back)'\",\n                                    \"{ type:func, func:'relatedness($fore,$back)' }\",\n                                    \"{ type:func, func:'relatedness($fore,$back)', min_popularity:0.2 }\")) {\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"json.facet\", \"{\"\n                             + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                             + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                             + \"          facet:{ s:\"+s+\"} } }\")\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     s : { relatedness: 0.00496, \"\n                      //+ \"           foreground_count: 3, \"\n                      //+ \"           foreground_size: 5, \"\n                      //+ \"           background_count: 2, \"\n                      //+ \"           background_size: 4, \"\n                      + \"           foreground_popularity: 0.75, \"\n                      + \"           background_popularity: 0.5, \"\n                      + \"         } } ] }\" +\n                      \"}\"\n                      );\n      }\n      // same query with a high min_pop should result in a -Infinity relatedness score\n      client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                           \"json.facet\", \"{\"\n                           + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                           + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                           + \"          facet:{ s:{ type:func, func:'relatedness($fore,$back)', \"\n                           + \"                      min_popularity:0.6 } } } }\")\n                    , \"facets=={ count:8, cat0:{ buckets:[ \"\n                    + \"   { val:A, count:4, \"\n                    + \"     s : { relatedness: '-Infinity', \"\n                    //+ \"           foreground_count: 3, \"\n                    //+ \"           foreground_size: 5, \"\n                    //+ \"           background_count: 2, \"\n                    //+ \"           background_size: 4, \"\n                    + \"           foreground_popularity: 0.75, \"\n                    + \"           background_popularity: 0.5, \"\n                    + \"         } } ] }\" +\n                    \"}\"\n                    );\n\n      // SKG under nested facet where some terms only exist on one shard\n      { \n        // sub-bucket order should change as sort direction changes\n        final String jsonFacet = \"\"\n          + \"{ processEmpty:true, \"\n          + \" cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n          + \"        sort:'count desc', limit:1, overrequest:0, refine:true, \"\n          + \"        facet:{ processEmpty:true, \"\n          + \"                qw1: { ${terms} type:terms, field: ${qw_s}, mincount:0, \"\n          + \"                       sort:'${skg_sort}', limit:100, overrequest:0, refine:true, \"\n          + \"                       facet:{ processEmpty:true, skg:'relatedness($fore,$back)' } } } } }\";\n        final String bucketQ = \"\"\n          + \"             { val:Q, count:1, \"\n          + \"               skg : { relatedness: 1.0, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.0, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 0, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        final String bucketW = \"\"\n          + \"             { val:W, count:1, \"\n          + \"               skg : { relatedness: 0.0037, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.25, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 1, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        \n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg desc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketQ\n                      + bucketW\n                      + \"  ] } } ] } }\");\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg asc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketW\n                      + bucketQ\n                      + \"  ] } } ] } }\");\n      }\n    \n      // test partial buckets (field facet within field facet)\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",cd:{${terms} type:terms, field:${cat_i}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",ef:{${terms} type:terms, field:${date},  limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n              \", cd:{ buckets:[  {val:1, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (int type)\n              \", ef:{ buckets:[  {val:'2001-01-01T01:01:01Z', count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (date type)\n              \"}\"\n      );\n\n      // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \"}\"\n      );\n\n      // test refining under the special \"missing\" bucket of a field facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n              \"}\"\n      );\n\n      // test filling in \"missing\" bucket for partially refined facets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              // test all values missing in sub-facet\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n              // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n              \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n              \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n              \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n              \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n              \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing \"allBuckets\"\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n              \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n              \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n              \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing numBuckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n              \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n              \"}\"\n      );\n\n      final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n      // simplistic join domain testing: no refinement == low count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3, \" +\n              // w/o overrequest and refinement, count for 'A' is lower than it should be\n              // (we don't see the A from the middle shard)\n              \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n      // simplistic join domain testing: refinement == correct count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // w/o overrequest, we need refining to get the correct count for 'A'.\n              \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n      // contrived join domain + refinement (at second level) + testing\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              // top level facet has a single term\n              \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n              \"       facet:{  \" +\n              // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n              \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // all 3 docs matching base query have same 'all' value in top facet\n              \"          all:{ buckets:[ { val:all, count:3, \" +\n              // sub facet has refinement, so count for 'A' should be correct\n              \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n    } // end method loop\n  }\n\n","sourceOld":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n    String date = p.get(\"date\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n    for (String method : new String[]{\"\",\"dvhash\",\"stream\",\"uif\",\"enum\",\"stream\",\"smart\"}) {\n      if (method.equals(\"\")) {\n        p.remove(\"terms\");\n      } else {\n        p.set(\"terms\", \"method:\" + method+\", \");\n      }\n\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n              \"}\"\n      );\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with an integer field instead of a string\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with a date field\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${date}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:'2001-01-01T01:01:01Z',count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // basic refining test through/under a query facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"q1 : { type:query, q:'*:*', facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n              \"}\"\n      );\n\n      // basic refining test through/under a range facet\n      for (String end : Arrays.asList(// all of these end+hardened options should produce the same buckets\n                                      \"end:20, hardend:true\", // evenly divisible so shouldn't matter\n                                      \"end:20, hardend:false\", \"end:20\", // defaults to hardened:false\n                                      \"end:5, hardend:false\", \"end:5\")) {\n        // since the gap divides the start/end divide eveningly, \n        // all of these hardend params should we should produce identical results\n        String sub = \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\";\n\n        // single bucket, all 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:all, start:-20, gap:40, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      + \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }],\"\n                      + \"       before:{count:0}, after:{count:0}\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n        // multiple buckets, only one 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:between, start:-20, gap:20, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      // NOTE: in both buckets A & B are tied, but index order should break tie\n                      + \", r1:{ buckets:[{val:-20.0, count:4,  cat0:{buckets:[{val:A,count:2}]} },\"\n                      + \"                {val:  0.0, count:4,  cat0:{buckets:[{val:A,count:2}]} } ],\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n      }\n\n      // test that basic stats work for refinement\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n              \"}\"\n      );\n\n      // test sorting buckets by a different stat\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n              \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n              \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n              \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n              \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n              \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n              \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n              \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n              \", sum1:2.0\" +\n              \"}\"\n      );\n\n      // test that SKG stat reflects merged refinement\n      client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                           \"json.facet\", \"{\"\n                           + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                           + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                           + \"          facet:{ s:'relatedness($fore,$back)'} } }\")\n                    , \"facets=={ count:8, cat0:{ buckets:[ \"\n                    + \"   { val:A, count:4, \"\n                    + \"     s : { relatedness: 0.00496, \"\n                    //+ \"           foreground_count: 3, \"\n                    //+ \"           foreground_size: 5, \"\n                    //+ \"           background_count: 2, \"\n                    //+ \"           background_size: 4, \"\n                    + \"           foreground_popularity: 0.75, \"\n                    + \"           background_popularity: 0.5, \"\n                    + \"         } } ] }\" +\n                    \"}\"\n                    );\n      \n      // SKG under nested facet where some terms only exist on one shard\n      { \n        // sub-bucket order should change as sort direction changes\n        final String jsonFacet = \"\"\n          + \"{ processEmpty:true, \"\n          + \" cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n          + \"        sort:'count desc', limit:1, overrequest:0, refine:true, \"\n          + \"        facet:{ processEmpty:true, \"\n          + \"                qw1: { ${terms} type:terms, field: ${qw_s}, mincount:0, \"\n          + \"                       sort:'${skg_sort}', limit:100, overrequest:0, refine:true, \"\n          + \"                       facet:{ processEmpty:true, skg:'relatedness($fore,$back)' } } } } }\";\n        final String bucketQ = \"\"\n          + \"             { val:Q, count:1, \"\n          + \"               skg : { relatedness: 1.0, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.0, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 0, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        final String bucketW = \"\"\n          + \"             { val:W, count:1, \"\n          + \"               skg : { relatedness: 0.0037, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.25, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 1, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        \n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg desc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketQ\n                      + bucketW\n                      + \"  ] } } ] } }\");\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg asc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketW\n                      + bucketQ\n                      + \"  ] } } ] } }\");\n      }\n    \n      // test partial buckets (field facet within field facet)\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",cd:{${terms} type:terms, field:${cat_i}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",ef:{${terms} type:terms, field:${date},  limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n              \", cd:{ buckets:[  {val:1, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (int type)\n              \", ef:{ buckets:[  {val:'2001-01-01T01:01:01Z', count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (date type)\n              \"}\"\n      );\n\n      // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \"}\"\n      );\n\n      // test refining under the special \"missing\" bucket of a field facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n              \"}\"\n      );\n\n      // test filling in \"missing\" bucket for partially refined facets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              // test all values missing in sub-facet\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n              // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n              \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n              \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n              \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n              \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n              \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing \"allBuckets\"\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n              \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n              \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n              \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing numBuckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n              \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n              \"}\"\n      );\n\n      final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n      // simplistic join domain testing: no refinement == low count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3, \" +\n              // w/o overrequest and refinement, count for 'A' is lower than it should be\n              // (we don't see the A from the middle shard)\n              \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n      // simplistic join domain testing: refinement == correct count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // w/o overrequest, we need refining to get the correct count for 'A'.\n              \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n      // contrived join domain + refinement (at second level) + testing\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              // top level facet has a single term\n              \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n              \"       facet:{  \" +\n              // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n              \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // all 3 docs matching base query have same 'all' value in top facet\n              \"          all:{ buckets:[ { val:all, count:3, \" +\n              // sub facet has refinement, so count for 'A' should be correct\n              \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n    } // end method loop\n  }\n\n","bugFix":null,"bugIntro":["22d2c45da6e47ff0ada29a8f98566b76f0b278de"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dd5179c53ace95be1691b13506e7f43ebf92a114","date":1591200586,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n    \n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n    \n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n    String date = p.get(\"date\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n    for (String method : new String[]{\"\",\"dv\", \"dvhash\",\"stream\",\"uif\",\"enum\",\"stream\",\"smart\"}) {\n      if (method.equals(\"\")) {\n        p.remove(\"terms\");\n      } else {\n        p.set(\"terms\", \"method:\" + method+\", \");\n      }\n      \n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n              \"}\"\n      );\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with an integer field instead of a string\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with a date field\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${date}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:'2001-01-01T01:01:01Z',count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // basic refining test through/under a query facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"q1 : { type:query, q:'*:*', facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n              \"}\"\n      );\n\n      // basic refining test through/under a range facet\n      for (String end : Arrays.asList(// all of these end+hardened options should produce the same buckets\n                                      \"end:20, hardend:true\", // evenly divisible so shouldn't matter\n                                      \"end:20, hardend:false\", \"end:20\", // defaults to hardened:false\n                                      \"end:5, hardend:false\", \"end:5\")) {\n        // since the gap divides the start/end divide eveningly, \n        // all of these hardend params should we should produce identical results\n        String sub = \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\";\n\n        // single bucket, all 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:all, start:-20, gap:40, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      + \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }],\"\n                      + \"       before:{count:0}, after:{count:0}\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n        // multiple buckets, only one 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:between, start:-20, gap:20, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      // NOTE: in both buckets A & B are tied, but index order should break tie\n                      + \", r1:{ buckets:[{val:-20.0, count:4,  cat0:{buckets:[{val:A,count:2}]} },\"\n                      + \"                {val:  0.0, count:4,  cat0:{buckets:[{val:A,count:2}]} } ],\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n      }\n\n      // test that basic stats work for refinement\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n              \"}\"\n      );\n\n      // test sorting buckets by a different stat\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n              \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n              \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n              \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n              \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n              \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n              \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n              \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n              \", sum1:2.0\" +\n              \"}\"\n      );\n\n      // test that SKG stat reflects merged refinement\n      // results shouldn't care if we use the short or long syntax, or if we have a low min_pop\n      for (String s : Arrays.asList(\"'relatedness($fore,$back)'\",\n                                    \"{ type:func, func:'relatedness($fore,$back)' }\",\n                                    \"{ type:func, func:'relatedness($fore,$back)', min_popularity:0.2 }\")) {\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"json.facet\", \"{\"\n                             + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                             + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                             + \"          facet:{ s:\"+s+\"} } }\")\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     s : { relatedness: 0.00496, \"\n                      //+ \"           foreground_count: 3, \"\n                      //+ \"           foreground_size: 5, \"\n                      //+ \"           background_count: 2, \"\n                      //+ \"           background_size: 4, \"\n                      + \"           foreground_popularity: 0.75, \"\n                      + \"           background_popularity: 0.5, \"\n                      + \"         } } ] }\" +\n                      \"}\"\n                      );\n      }\n      // same query with a high min_pop should result in a -Infinity relatedness score\n      client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                           \"json.facet\", \"{\"\n                           + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                           + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                           + \"          facet:{ s:{ type:func, func:'relatedness($fore,$back)', \"\n                           + \"                      min_popularity:0.6 } } } }\")\n                    , \"facets=={ count:8, cat0:{ buckets:[ \"\n                    + \"   { val:A, count:4, \"\n                    + \"     s : { relatedness: '-Infinity', \"\n                    //+ \"           foreground_count: 3, \"\n                    //+ \"           foreground_size: 5, \"\n                    //+ \"           background_count: 2, \"\n                    //+ \"           background_size: 4, \"\n                    + \"           foreground_popularity: 0.75, \"\n                    + \"           background_popularity: 0.5, \"\n                    + \"         } } ] }\" +\n                    \"}\"\n                    );\n\n      // SKG under nested facet where some terms only exist on one shard\n      { \n        // sub-bucket order should change as sort direction changes\n        final String jsonFacet = \"\"\n          + \"{ processEmpty:true, \"\n          + \" cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n          + \"        sort:'count desc', limit:1, overrequest:0, refine:true, \"\n          + \"        facet:{ processEmpty:true, \"\n          + \"                qw1: { ${terms} type:terms, field: ${qw_s}, mincount:0, \"\n          + \"                       sort:'${skg_sort}', limit:100, overrequest:0, refine:true, \"\n          + \"                       facet:{ processEmpty:true, skg:'relatedness($fore,$back)' } } } } }\";\n        final String bucketQ = \"\"\n          + \"             { val:Q, count:1, \"\n          + \"               skg : { relatedness: 1.0, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.0, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 0, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        final String bucketW = \"\"\n          + \"             { val:W, count:1, \"\n          + \"               skg : { relatedness: 0.0037, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.25, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 1, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        \n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg desc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketQ\n                      + bucketW\n                      + \"  ] } } ] } }\");\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg asc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketW\n                      + bucketQ\n                      + \"  ] } } ] } }\");\n      }\n    \n      // test partial buckets (field facet within field facet)\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",cd:{${terms} type:terms, field:${cat_i}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",ef:{${terms} type:terms, field:${date},  limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n              \", cd:{ buckets:[  {val:1, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (int type)\n              \", ef:{ buckets:[  {val:'2001-01-01T01:01:01Z', count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (date type)\n              \"}\"\n      );\n\n      // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \"}\"\n      );\n\n      // test refining under the special \"missing\" bucket of a field facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n              \"}\"\n      );\n\n      // test filling in \"missing\" bucket for partially refined facets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              // test all values missing in sub-facet\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n              // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n              \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n              \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n              \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n              \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n              \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing \"allBuckets\"\n      client.testJQ(params(p, \"q\", \"*:*\", \n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n              \", cat1:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true, allBuckets:true, sort:'min asc', facet:{  min:'min(${num_d})' }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n              \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{sum:'sum(${num_d})'}   }  }  }\" +\n              \", cat4:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , sort:'sum asc', facet:{sum:'sum(${num_d})'}   }  }  }\" +\n              // using overrefine only so we aren't fooled by 'local maximum' and ask all shards for 'B'\n              \", cat5:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true, overrefine:2, allBuckets:true,  sort:'min desc' facet:{  min:'min(${num_d})', xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true, facet:{sum:'sum(${num_d})'}   }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \",cat0:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n              \",cat1:{ allBuckets:{count:8, min:-19.0 }, buckets:[  {val:A, count:4, min:-19.0 }]  }\" +\n              \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n              \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, sum:23.0}], allBuckets:{count:4, sum:4.0}}}]  }\" +\n              \",cat4:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:1, val:Y, sum:-19.0}], allBuckets:{count:4, sum:4.0}}}]  }\" +\n              \",cat5:{ allBuckets:{count:8, min:-19.0 }, buckets:[  {val:B, count:4, min:-11.0, xy:{buckets:[{count:2, val:X, sum:6.0}], allBuckets:{count:4, sum:-2.0}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing numBuckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n              \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n              \"}\"\n      );\n\n      final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n      // simplistic join domain testing: no refinement == low count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3, \" +\n              // w/o overrequest and refinement, count for 'A' is lower than it should be\n              // (we don't see the A from the middle shard)\n              \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n      // simplistic join domain testing: refinement == correct count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // w/o overrequest, we need refining to get the correct count for 'A'.\n              \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n      // contrived join domain + refinement (at second level) + testing\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              // top level facet has a single term\n              \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n              \"       facet:{  \" +\n              // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n              \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // all 3 docs matching base query have same 'all' value in top facet\n              \"          all:{ buckets:[ { val:all, count:3, \" +\n              // sub facet has refinement, so count for 'A' should be correct\n              \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n    } // end method loop\n  }\n\n","sourceOld":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n    \n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n    \n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n    String date = p.get(\"date\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n    for (String method : new String[]{\"\",\"dvhash\",\"stream\",\"uif\",\"enum\",\"stream\",\"smart\"}) {\n      if (method.equals(\"\")) {\n        p.remove(\"terms\");\n      } else {\n        p.set(\"terms\", \"method:\" + method+\", \");\n      }\n      \n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n              \"}\"\n      );\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with an integer field instead of a string\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with a date field\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${date}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:'2001-01-01T01:01:01Z',count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // basic refining test through/under a query facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"q1 : { type:query, q:'*:*', facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n              \"}\"\n      );\n\n      // basic refining test through/under a range facet\n      for (String end : Arrays.asList(// all of these end+hardened options should produce the same buckets\n                                      \"end:20, hardend:true\", // evenly divisible so shouldn't matter\n                                      \"end:20, hardend:false\", \"end:20\", // defaults to hardened:false\n                                      \"end:5, hardend:false\", \"end:5\")) {\n        // since the gap divides the start/end divide eveningly, \n        // all of these hardend params should we should produce identical results\n        String sub = \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\";\n\n        // single bucket, all 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:all, start:-20, gap:40, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      + \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }],\"\n                      + \"       before:{count:0}, after:{count:0}\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n        // multiple buckets, only one 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:between, start:-20, gap:20, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      // NOTE: in both buckets A & B are tied, but index order should break tie\n                      + \", r1:{ buckets:[{val:-20.0, count:4,  cat0:{buckets:[{val:A,count:2}]} },\"\n                      + \"                {val:  0.0, count:4,  cat0:{buckets:[{val:A,count:2}]} } ],\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n      }\n\n      // test that basic stats work for refinement\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n              \"}\"\n      );\n\n      // test sorting buckets by a different stat\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n              \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n              \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n              \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n              \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n              \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n              \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n              \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n              \", sum1:2.0\" +\n              \"}\"\n      );\n\n      // test that SKG stat reflects merged refinement\n      // results shouldn't care if we use the short or long syntax, or if we have a low min_pop\n      for (String s : Arrays.asList(\"'relatedness($fore,$back)'\",\n                                    \"{ type:func, func:'relatedness($fore,$back)' }\",\n                                    \"{ type:func, func:'relatedness($fore,$back)', min_popularity:0.2 }\")) {\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"json.facet\", \"{\"\n                             + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                             + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                             + \"          facet:{ s:\"+s+\"} } }\")\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     s : { relatedness: 0.00496, \"\n                      //+ \"           foreground_count: 3, \"\n                      //+ \"           foreground_size: 5, \"\n                      //+ \"           background_count: 2, \"\n                      //+ \"           background_size: 4, \"\n                      + \"           foreground_popularity: 0.75, \"\n                      + \"           background_popularity: 0.5, \"\n                      + \"         } } ] }\" +\n                      \"}\"\n                      );\n      }\n      // same query with a high min_pop should result in a -Infinity relatedness score\n      client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                           \"json.facet\", \"{\"\n                           + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                           + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                           + \"          facet:{ s:{ type:func, func:'relatedness($fore,$back)', \"\n                           + \"                      min_popularity:0.6 } } } }\")\n                    , \"facets=={ count:8, cat0:{ buckets:[ \"\n                    + \"   { val:A, count:4, \"\n                    + \"     s : { relatedness: '-Infinity', \"\n                    //+ \"           foreground_count: 3, \"\n                    //+ \"           foreground_size: 5, \"\n                    //+ \"           background_count: 2, \"\n                    //+ \"           background_size: 4, \"\n                    + \"           foreground_popularity: 0.75, \"\n                    + \"           background_popularity: 0.5, \"\n                    + \"         } } ] }\" +\n                    \"}\"\n                    );\n\n      // SKG under nested facet where some terms only exist on one shard\n      { \n        // sub-bucket order should change as sort direction changes\n        final String jsonFacet = \"\"\n          + \"{ processEmpty:true, \"\n          + \" cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n          + \"        sort:'count desc', limit:1, overrequest:0, refine:true, \"\n          + \"        facet:{ processEmpty:true, \"\n          + \"                qw1: { ${terms} type:terms, field: ${qw_s}, mincount:0, \"\n          + \"                       sort:'${skg_sort}', limit:100, overrequest:0, refine:true, \"\n          + \"                       facet:{ processEmpty:true, skg:'relatedness($fore,$back)' } } } } }\";\n        final String bucketQ = \"\"\n          + \"             { val:Q, count:1, \"\n          + \"               skg : { relatedness: 1.0, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.0, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 0, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        final String bucketW = \"\"\n          + \"             { val:W, count:1, \"\n          + \"               skg : { relatedness: 0.0037, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.25, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 1, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        \n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg desc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketQ\n                      + bucketW\n                      + \"  ] } } ] } }\");\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg asc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketW\n                      + bucketQ\n                      + \"  ] } } ] } }\");\n      }\n    \n      // test partial buckets (field facet within field facet)\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",cd:{${terms} type:terms, field:${cat_i}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",ef:{${terms} type:terms, field:${date},  limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n              \", cd:{ buckets:[  {val:1, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (int type)\n              \", ef:{ buckets:[  {val:'2001-01-01T01:01:01Z', count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (date type)\n              \"}\"\n      );\n\n      // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \"}\"\n      );\n\n      // test refining under the special \"missing\" bucket of a field facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n              \"}\"\n      );\n\n      // test filling in \"missing\" bucket for partially refined facets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              // test all values missing in sub-facet\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n              // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n              \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n              \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n              \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n              \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n              \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing \"allBuckets\"\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n              \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n              \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n              \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing numBuckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n              \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n              \"}\"\n      );\n\n      final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n      // simplistic join domain testing: no refinement == low count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3, \" +\n              // w/o overrequest and refinement, count for 'A' is lower than it should be\n              // (we don't see the A from the middle shard)\n              \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n      // simplistic join domain testing: refinement == correct count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // w/o overrequest, we need refining to get the correct count for 'A'.\n              \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n      // contrived join domain + refinement (at second level) + testing\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              // top level facet has a single term\n              \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n              \"       facet:{  \" +\n              // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n              \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // all 3 docs matching base query have same 'all' value in top facet\n              \"          all:{ buckets:[ { val:all, count:3, \" +\n              // sub facet has refinement, so count for 'A' should be correct\n              \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n    } // end method loop\n  }\n\n","bugFix":["15b321aed72eecb043f237c490b9afd4e52c25be"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"22d2c45da6e47ff0ada29a8f98566b76f0b278de","date":1591372739,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#doBasicRefinement(ModifiableSolrParams).mjava","sourceNew":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n    \n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n    \n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n    String date = p.get(\"date\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n    for (String method : new String[]{\"\",\"dv\", \"dvhash\",\"stream\",\"uif\",\"enum\",\"stream\",\"smart\"}) {\n      if (method.equals(\"\")) {\n        p.remove(\"terms\");\n      } else {\n        p.set(\"terms\", \"method:\" + method+\", \");\n      }\n      \n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n              \"}\"\n      );\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with an integer field instead of a string\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with a date field\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${date}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:'2001-01-01T01:01:01Z',count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // basic refining test through/under a query facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"q1 : { type:query, q:'*:*', facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n              \"}\"\n      );\n\n      // basic refining test through/under a range facet\n      for (String end : Arrays.asList(// all of these end+hardened options should produce the same buckets\n                                      \"end:20, hardend:true\", // evenly divisible so shouldn't matter\n                                      \"end:20, hardend:false\", \"end:20\", // defaults to hardened:false\n                                      \"end:5, hardend:false\", \"end:5\")) {\n        // since the gap divides the start/end divide eveningly, \n        // all of these hardend params should we should produce identical results\n        String sub = \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\";\n\n        // single bucket, all 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:all, start:-20, gap:40, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      + \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }],\"\n                      + \"       before:{count:0}, after:{count:0}\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n        // multiple buckets, only one 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:between, start:-20, gap:20, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      // NOTE: in both buckets A & B are tied, but index order should break tie\n                      + \", r1:{ buckets:[{val:-20.0, count:4,  cat0:{buckets:[{val:A,count:2}]} },\"\n                      + \"                {val:  0.0, count:4,  cat0:{buckets:[{val:A,count:2}]} } ],\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n      }\n\n      // test that basic stats work for refinement\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n              \"}\"\n      );\n\n      // test sorting buckets by a different stat\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n              \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n              \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n              \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n              \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n              \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n              \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n              \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n              \", sum1:2.0\" +\n              \"}\"\n      );\n\n      // test that SKG stat reflects merged refinement\n      // results shouldn't care if we use the short or long syntax, or if we have a low min_pop\n      for (String s : Arrays.asList(\"'relatedness($fore,$back)'\",\n                                    \"{ type:func, func:'relatedness($fore,$back)' }\",\n                                    \"{ type:func, func:'relatedness($fore,$back)', min_popularity:0.2 }\")) {\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"json.facet\", \"{\"\n                             + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, allBuckets:true, \"\n                             + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                             + \"          facet:{ s:\"+s+\"} } }\")\n                      , \"facets=={ count:8, cat0:{ \"\n                      // 's' key must not exist in the allBuckets bucket\n                      + \"   allBuckets: { count:8 }\"\n                      + \"   buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     s : { relatedness: 0.00496, \"\n                      //+ \"           foreground_count: 3, \"\n                      //+ \"           foreground_size: 5, \"\n                      //+ \"           background_count: 2, \"\n                      //+ \"           background_size: 4, \"\n                      + \"           foreground_popularity: 0.75, \"\n                      + \"           background_popularity: 0.5, \"\n                      + \"         } } ] }\" +\n                      \"}\"\n                      );\n      }\n      // same query with a high min_pop should result in a -Infinity relatedness score\n      client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                           \"json.facet\", \"{\"\n                           + \"   cat0:{ ${terms} type:terms, field: ${cat_s},  allBuckets:true,\"\n                           + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                           + \"          facet:{ s:{ type:func, func:'relatedness($fore,$back)', \"\n                           + \"                      min_popularity:0.6 } } } }\")\n                    , \"facets=={ count:8, cat0:{ \"\n                    // 's' key must not exist in the allBuckets bucket\n                    + \"   allBuckets: { count:8 }\"\n                    + \"   buckets:[ \"\n                    + \"   { val:A, count:4, \"\n                    + \"     s : { relatedness: '-Infinity', \"\n                    //+ \"           foreground_count: 3, \"\n                    //+ \"           foreground_size: 5, \"\n                    //+ \"           background_count: 2, \"\n                    //+ \"           background_size: 4, \"\n                    + \"           foreground_popularity: 0.75, \"\n                    + \"           background_popularity: 0.5, \"\n                    + \"         } } ] }\" +\n                    \"}\"\n                    );\n\n      // really special case: allBuckets when there are no regular buckets...\n      for (String refine : Arrays.asList(\"\", \"refine: true,\", \"refine:false,\")) {\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"json.facet\", \"{\"\n                             + \"   cat0:{ ${terms} type:terms, field: bogus_field_s, allBuckets:true, \"\n                             + refine\n                             + \"          facet:{ s:{ type:func, func:'relatedness($fore,$back)' } } } }\")\n                      , \"facets=={ count:8, cat0:{ \"\n                      // 's' key must not exist in the allBuckets bucket\n                      + \"    allBuckets: { count:0 }\"\n                      + \"    buckets:[ ]\"\n                      + \"} }\"\n                      );\n      }\n\n\n      // SKG under nested facet where some terms only exist on one shard\n      { \n        // sub-bucket order should change as sort direction changes\n        final String jsonFacet = \"\"\n          + \"{ processEmpty:true, \"\n          + \" cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n          + \"        sort:'count desc', limit:1, overrequest:0, refine:true, \"\n          + \"        facet:{ processEmpty:true, \"\n          + \"                qw1: { ${terms} type:terms, field: ${qw_s}, mincount:0, \"\n          + \"                       sort:'${skg_sort}', limit:100, overrequest:0, refine:true, \"\n          + \"                       facet:{ processEmpty:true, skg:'relatedness($fore,$back)' } } } } }\";\n        final String bucketQ = \"\"\n          + \"             { val:Q, count:1, \"\n          + \"               skg : { relatedness: 1.0, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.0, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 0, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        final String bucketW = \"\"\n          + \"             { val:W, count:1, \"\n          + \"               skg : { relatedness: 0.0037, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.25, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 1, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        \n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg desc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketQ\n                      + bucketW\n                      + \"  ] } } ] } }\");\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg asc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketW\n                      + bucketQ\n                      + \"  ] } } ] } }\");\n      }\n    \n      // test partial buckets (field facet within field facet)\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",cd:{${terms} type:terms, field:${cat_i}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",ef:{${terms} type:terms, field:${date},  limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n              \", cd:{ buckets:[  {val:1, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (int type)\n              \", ef:{ buckets:[  {val:'2001-01-01T01:01:01Z', count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (date type)\n              \"}\"\n      );\n\n      // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \"}\"\n      );\n\n      // test refining under the special \"missing\" bucket of a field facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n              \"}\"\n      );\n\n      // test filling in \"missing\" bucket for partially refined facets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              // test all values missing in sub-facet\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n              // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n              \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n              \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n              \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n              \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n              \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing \"allBuckets\"\n      client.testJQ(params(p, \"q\", \"*:*\", \n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n              \", cat1:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true, allBuckets:true, sort:'min asc', facet:{  min:'min(${num_d})' }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n              \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{sum:'sum(${num_d})'}   }  }  }\" +\n              \", cat4:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , sort:'sum asc', facet:{sum:'sum(${num_d})'}   }  }  }\" +\n              // using overrefine only so we aren't fooled by 'local maximum' and ask all shards for 'B'\n              \", cat5:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true, overrefine:2, allBuckets:true,  sort:'min desc' facet:{  min:'min(${num_d})', xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true, facet:{sum:'sum(${num_d})'}   }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \",cat0:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n              \",cat1:{ allBuckets:{count:8, min:-19.0 }, buckets:[  {val:A, count:4, min:-19.0 }]  }\" +\n              \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n              \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, sum:23.0}], allBuckets:{count:4, sum:4.0}}}]  }\" +\n              \",cat4:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:1, val:Y, sum:-19.0}], allBuckets:{count:4, sum:4.0}}}]  }\" +\n              \",cat5:{ allBuckets:{count:8, min:-19.0 }, buckets:[  {val:B, count:4, min:-11.0, xy:{buckets:[{count:2, val:X, sum:6.0}], allBuckets:{count:4, sum:-2.0}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing numBuckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n              \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n              \"}\"\n      );\n\n      final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n      // simplistic join domain testing: no refinement == low count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3, \" +\n              // w/o overrequest and refinement, count for 'A' is lower than it should be\n              // (we don't see the A from the middle shard)\n              \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n      // simplistic join domain testing: refinement == correct count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // w/o overrequest, we need refining to get the correct count for 'A'.\n              \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n      // contrived join domain + refinement (at second level) + testing\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              // top level facet has a single term\n              \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n              \"       facet:{  \" +\n              // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n              \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // all 3 docs matching base query have same 'all' value in top facet\n              \"          all:{ buckets:[ { val:all, count:3, \" +\n              // sub facet has refinement, so count for 'A' should be correct\n              \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n    } // end method loop\n  }\n\n","sourceOld":"  public void doBasicRefinement(ModifiableSolrParams p) throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n    \n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n    \n    client.deleteByQuery(\"*:*\", null);\n\n    String cat_s = p.get(\"cat_s\");\n    String cat_i = p.get(\"cat_i\"); // just like cat_s, but a number\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n    String date = p.get(\"date\");\n\n    clients.get(0).add(sdoc(\"id\", \"01\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, -1, qw_s, \"Q\", er_s, \"E\")); // A wins count tie\n    clients.get(0).add(sdoc(\"id\", \"02\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, 3));\n\n    clients.get(1).add(sdoc(\"id\", \"11\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, -5, er_s, \"E\")); // B highest count\n    clients.get(1).add(sdoc(\"id\", \"12\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"));\n    clients.get(1).add(sdoc(\"id\", \"13\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 7, er_s, \"R\"));       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add(sdoc(\"id\", \"21\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"X\", num_d, 17, qw_s, \"W\", er_s, \"E\")); // A highest count\n    clients.get(2).add(sdoc(\"id\", \"22\", \"all_s\", \"all\", cat_s, \"A\", cat_i, 1, date, \"2001-01-01T01:01:01Z\", xy_s, \"Y\", num_d, -19));\n    clients.get(2).add(sdoc(\"id\", \"23\", \"all_s\", \"all\", cat_s, \"B\", cat_i, 2, date, \"2002-02-02T02:02:02Z\", xy_s, \"X\", num_d, 11));\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n     // fake a refinement request... good for development/debugging\n     assertJQ(clients.get(1),\n     params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n     \"json.facet\", \"{\" +\n     \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n     \"}\"\n     )\n     , \"facets=={foo:555}\"\n     );\n     ****/\n    for (String method : new String[]{\"\",\"dv\", \"dvhash\",\"stream\",\"uif\",\"enum\",\"stream\",\"smart\"}) {\n      if (method.equals(\"\")) {\n        p.remove(\"terms\");\n      } else {\n        p.set(\"terms\", \"method:\" + method+\", \");\n      }\n      \n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n              \"}\"\n      );\n\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with an integer field instead of a string\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_i}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:1,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // same as above, but with a date field\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${date}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:'2001-01-01T01:01:01Z',count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n              \"}\"\n      );\n\n      // basic refining test through/under a query facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"q1 : { type:query, q:'*:*', facet:{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n              \"}}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", q1:{ count:8, cat0:{ buckets:[ {val:A,count:4} ] }   }\" +\n              \"}\"\n      );\n\n      // basic refining test through/under a range facet\n      for (String end : Arrays.asList(// all of these end+hardened options should produce the same buckets\n                                      \"end:20, hardend:true\", // evenly divisible so shouldn't matter\n                                      \"end:20, hardend:false\", \"end:20\", // defaults to hardened:false\n                                      \"end:5, hardend:false\", \"end:5\")) {\n        // since the gap divides the start/end divide eveningly, \n        // all of these hardend params should we should produce identical results\n        String sub = \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\";\n\n        // single bucket, all 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:all, start:-20, gap:40, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      + \", r1:{ buckets:[{val:-20.0,count:8,  cat0:{buckets:[{val:A,count:4}]}  }],\"\n                      + \"       before:{count:0}, after:{count:0}\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n        // multiple buckets, only one 'other' buckets\n        client.testJQ(params(p, \"q\", \"*:*\", \"json.facet\"\n                             , \"{ r1 : { type:range, field:${num_d} other:between, start:-20, gap:20, \" + end\n                             + \"         , facet:{\" + sub + \"}}}\")\n                      , \"facets=={ count:8\"\n                      // NOTE: in both buckets A & B are tied, but index order should break tie\n                      + \", r1:{ buckets:[{val:-20.0, count:4,  cat0:{buckets:[{val:A,count:2}]} },\"\n                      + \"                {val:  0.0, count:4,  cat0:{buckets:[{val:A,count:2}]} } ],\"\n                      + \"       between:{count:8, cat0:{buckets:[{val:A,count:4}]}}\"\n                      + \"}}\");\n      }\n\n      // test that basic stats work for refinement\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"cat0:{${terms} type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n              \"}\"\n      );\n\n      // test sorting buckets by a different stat\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" cat0:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n              \",cat1:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n              \",qfacet:{type:query, q:'*:*', facet:{  cat2:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n              \",allf:{${terms} type:terms, field:all_s,  facet:{  cat3:{${terms} type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n              \",sum1:'sum(${num_d})'\" +  // make sure that root bucket stats aren't affected by refinement\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n              \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n              \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n              \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n              \", sum1:2.0\" +\n              \"}\"\n      );\n\n      // test that SKG stat reflects merged refinement\n      // results shouldn't care if we use the short or long syntax, or if we have a low min_pop\n      for (String s : Arrays.asList(\"'relatedness($fore,$back)'\",\n                                    \"{ type:func, func:'relatedness($fore,$back)' }\",\n                                    \"{ type:func, func:'relatedness($fore,$back)', min_popularity:0.2 }\")) {\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"json.facet\", \"{\"\n                             + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                             + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                             + \"          facet:{ s:\"+s+\"} } }\")\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     s : { relatedness: 0.00496, \"\n                      //+ \"           foreground_count: 3, \"\n                      //+ \"           foreground_size: 5, \"\n                      //+ \"           background_count: 2, \"\n                      //+ \"           background_size: 4, \"\n                      + \"           foreground_popularity: 0.75, \"\n                      + \"           background_popularity: 0.5, \"\n                      + \"         } } ] }\" +\n                      \"}\"\n                      );\n      }\n      // same query with a high min_pop should result in a -Infinity relatedness score\n      client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                           \"json.facet\", \"{\"\n                           + \"   cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n                           + \"          sort:'count desc', limit:1, overrequest:0, refine:true, \"\n                           + \"          facet:{ s:{ type:func, func:'relatedness($fore,$back)', \"\n                           + \"                      min_popularity:0.6 } } } }\")\n                    , \"facets=={ count:8, cat0:{ buckets:[ \"\n                    + \"   { val:A, count:4, \"\n                    + \"     s : { relatedness: '-Infinity', \"\n                    //+ \"           foreground_count: 3, \"\n                    //+ \"           foreground_size: 5, \"\n                    //+ \"           background_count: 2, \"\n                    //+ \"           background_size: 4, \"\n                    + \"           foreground_popularity: 0.75, \"\n                    + \"           background_popularity: 0.5, \"\n                    + \"         } } ] }\" +\n                    \"}\"\n                    );\n\n      // SKG under nested facet where some terms only exist on one shard\n      { \n        // sub-bucket order should change as sort direction changes\n        final String jsonFacet = \"\"\n          + \"{ processEmpty:true, \"\n          + \" cat0:{ ${terms} type:terms, field: ${cat_s}, \"\n          + \"        sort:'count desc', limit:1, overrequest:0, refine:true, \"\n          + \"        facet:{ processEmpty:true, \"\n          + \"                qw1: { ${terms} type:terms, field: ${qw_s}, mincount:0, \"\n          + \"                       sort:'${skg_sort}', limit:100, overrequest:0, refine:true, \"\n          + \"                       facet:{ processEmpty:true, skg:'relatedness($fore,$back)' } } } } }\";\n        final String bucketQ = \"\"\n          + \"             { val:Q, count:1, \"\n          + \"               skg : { relatedness: 1.0, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.0, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 0, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        final String bucketW = \"\"\n          + \"             { val:W, count:1, \"\n          + \"               skg : { relatedness: 0.0037, \"\n          + \"                       foreground_popularity: 0.25, \"\n          + \"                       background_popularity: 0.25, \"\n          // + \"                       foreground_count: 1, \"\n          // + \"                       foreground_size: 3, \"\n          // + \"                       background_count: 1, \"\n          // + \"                       background_size: 4, \"\n          + \"               } },\";\n        \n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg desc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketQ\n                      + bucketW\n                      + \"  ] } } ] } }\");\n        client.testJQ(params(p, \"rows\", \"0\", \"q\", \"*:*\", \"fore\", \"${xy_s}:X\", \"back\", \"${num_d}:[0 TO 100]\",\n                             \"skg_sort\", \"skg asc\", \"json.facet\", jsonFacet)\n                      , \"facets=={ count:8, cat0:{ buckets:[ \"\n                      + \"   { val:A, count:4, \"\n                      + \"     qw1 : { buckets:[\"\n                      + bucketW\n                      + bucketQ\n                      + \"  ] } } ] } }\");\n      }\n    \n      // test partial buckets (field facet within field facet)\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",cd:{${terms} type:terms, field:${cat_i}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \",ef:{${terms} type:terms, field:${date},  limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n              \", cd:{ buckets:[  {val:1, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (int type)\n              \", ef:{ buckets:[  {val:'2001-01-01T01:01:01Z', count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet (date type)\n              \"}\"\n      );\n\n      // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \",allf :{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n              \",allf2:{${terms} type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n              \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n              \"}\"\n      );\n\n      // test refining under the special \"missing\" bucket of a field facet\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"f:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n              \"}\"\n      );\n\n      // test filling in \"missing\" bucket for partially refined facets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              // test all values missing in sub-facet\n              \" ab :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n              \",ab2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{${terms} type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n              // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n              \", cd :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n              \", cd2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{${terms} type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n              \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n              \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n              \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing \"allBuckets\"\n      client.testJQ(params(p, \"q\", \"*:*\", \n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n              \", cat1:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true, allBuckets:true, sort:'min asc', facet:{  min:'min(${num_d})' }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n              \", cat3:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{sum:'sum(${num_d})'}   }  }  }\" +\n              \", cat4:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , sort:'sum asc', facet:{sum:'sum(${num_d})'}   }  }  }\" +\n              // using overrefine only so we aren't fooled by 'local maximum' and ask all shards for 'B'\n              \", cat5:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true, overrefine:2, allBuckets:true,  sort:'min desc' facet:{  min:'min(${num_d})', xy:{${terms} type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true, facet:{sum:'sum(${num_d})'}   }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \",cat0:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n              \",cat1:{ allBuckets:{count:8, min:-19.0 }, buckets:[  {val:A, count:4, min:-19.0 }]  }\" +\n              \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n              \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, sum:23.0}], allBuckets:{count:4, sum:4.0}}}]  }\" +\n              \",cat4:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:1, val:Y, sum:-19.0}], allBuckets:{count:4, sum:4.0}}}]  }\" +\n              \",cat5:{ allBuckets:{count:8, min:-19.0 }, buckets:[  {val:B, count:4, min:-11.0, xy:{buckets:[{count:2, val:X, sum:6.0}], allBuckets:{count:4, sum:-2.0}}}]  }\" +\n              \"}\"\n      );\n\n      // test filling in missing numBuckets\n      client.testJQ(params(p, \"q\", \"*:*\",\n          \"json.facet\", \"{\" +\n              \"  cat :{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n              \", cat2:{${terms} type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{${terms} type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n              \"}\"\n          )\n          , \"facets=={ count:8\" +\n              \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n              \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n              \"}\"\n      );\n\n      final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n      // simplistic join domain testing: no refinement == low count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:false,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3, \" +\n              // w/o overrequest and refinement, count for 'A' is lower than it should be\n              // (we don't see the A from the middle shard)\n              \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n      // simplistic join domain testing: refinement == correct count\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              \"  cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              // self join on all_s ensures every doc on every shard included in facets\n              \"        domain: { join: { from:all_s, to:all_s } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // w/o overrequest, we need refining to get the correct count for 'A'.\n              \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n      // contrived join domain + refinement (at second level) + testing\n      client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n          \"json.facet\", \"{\" +\n              // top level facet has a single term\n              \"  all:{${terms} type:terms, field:all_s, \" + sort_limit_over + \" refine:true, \" +\n              \"       facet:{  \" +\n              // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n              \"         cat0:{${terms} type:terms, field:${cat_s}, \" + sort_limit_over + \" refine:true,\" +\n              \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n              \"}\"\n          )\n          ,\n          \"/response/numFound==3\",\n          \"facets=={ count:3,\" +\n              // all 3 docs matching base query have same 'all' value in top facet\n              \"          all:{ buckets:[ { val:all, count:3, \" +\n              // sub facet has refinement, so count for 'A' should be correct\n              \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n    } // end method loop\n  }\n\n","bugFix":["42009f1fefcc8f4d9e07b158e9415cbd6ca7247c","2c705a0d590cf911e7c942df49563ca2ea176e22"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1794a0eb180b7d4e51424fbb32694cbb787ebc93":["a8c2926456ed45f9af75820d2e85859aed94afe6"],"a8c2926456ed45f9af75820d2e85859aed94afe6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"39fdbc59d893f5a211736e861fe145798a40b9ff":["a6b4e21f270c812affb9d34da7e81113045b05e0"],"42009f1fefcc8f4d9e07b158e9415cbd6ca7247c":["c05b634713ca09b2267477408773904d4c69dd9d"],"a6b4e21f270c812affb9d34da7e81113045b05e0":["f344bb33ca91f48e99c061980115b46fa84fc8f5"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["a8c2926456ed45f9af75820d2e85859aed94afe6","1794a0eb180b7d4e51424fbb32694cbb787ebc93"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","39fdbc59d893f5a211736e861fe145798a40b9ff"],"c05b634713ca09b2267477408773904d4c69dd9d":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"15b321aed72eecb043f237c490b9afd4e52c25be":["28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","39fdbc59d893f5a211736e861fe145798a40b9ff"],"2c705a0d590cf911e7c942df49563ca2ea176e22":["15b321aed72eecb043f237c490b9afd4e52c25be"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a8c2926456ed45f9af75820d2e85859aed94afe6"],"22d2c45da6e47ff0ada29a8f98566b76f0b278de":["dd5179c53ace95be1691b13506e7f43ebf92a114"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["2c705a0d590cf911e7c942df49563ca2ea176e22","c05b634713ca09b2267477408773904d4c69dd9d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dd5179c53ace95be1691b13506e7f43ebf92a114":["42009f1fefcc8f4d9e07b158e9415cbd6ca7247c"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["e9017cf144952056066919f1ebc7897ff9bd71b1","a6b4e21f270c812affb9d34da7e81113045b05e0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["22d2c45da6e47ff0ada29a8f98566b76f0b278de"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["2c705a0d590cf911e7c942df49563ca2ea176e22","c05b634713ca09b2267477408773904d4c69dd9d"]},"commit2Childs":{"1794a0eb180b7d4e51424fbb32694cbb787ebc93":["f344bb33ca91f48e99c061980115b46fa84fc8f5"],"a8c2926456ed45f9af75820d2e85859aed94afe6":["1794a0eb180b7d4e51424fbb32694cbb787ebc93","f344bb33ca91f48e99c061980115b46fa84fc8f5","e9017cf144952056066919f1ebc7897ff9bd71b1"],"39fdbc59d893f5a211736e861fe145798a40b9ff":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"42009f1fefcc8f4d9e07b158e9415cbd6ca7247c":["dd5179c53ace95be1691b13506e7f43ebf92a114"],"a6b4e21f270c812affb9d34da7e81113045b05e0":["39fdbc59d893f5a211736e861fe145798a40b9ff","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["a6b4e21f270c812affb9d34da7e81113045b05e0"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"c05b634713ca09b2267477408773904d4c69dd9d":["42009f1fefcc8f4d9e07b158e9415cbd6ca7247c","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"15b321aed72eecb043f237c490b9afd4e52c25be":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"28288370235ed02234a64753cdbf0c6ec096304a":["15b321aed72eecb043f237c490b9afd4e52c25be"],"2c705a0d590cf911e7c942df49563ca2ea176e22":["c05b634713ca09b2267477408773904d4c69dd9d","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"22d2c45da6e47ff0ada29a8f98566b76f0b278de":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a8c2926456ed45f9af75820d2e85859aed94afe6","28288370235ed02234a64753cdbf0c6ec096304a","e9017cf144952056066919f1ebc7897ff9bd71b1"],"dd5179c53ace95be1691b13506e7f43ebf92a114":["22d2c45da6e47ff0ada29a8f98566b76f0b278de"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}