{"path":"contrib/miscellaneous/src/java/org/apache/lucene/index/TermVectorAccessor#build(IndexReader,String,TermVectorMapper,int).mjava","commits":[{"id":"a56158a9862832b67c76de543de1da36596a1133","date":1219676540,"type":0,"author":"Karl-Johan Wettin","isMerge":false,"pathNew":"contrib/miscellaneous/src/java/org/apache/lucene/index/TermVectorAccessor#build(IndexReader,String,TermVectorMapper,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Populates the mapper with terms available for the given field in a document\n   * by resolving the inverted index.\n   *\n   * @param indexReader\n   * @param field interned field name\n   * @param mapper\n   * @param documentNumber\n   * @throws IOException\n   */\n  private void build(IndexReader indexReader, String field, TermVectorMapper mapper, int documentNumber) throws IOException {\n\n    if (tokens == null) {\n      tokens = new ArrayList/*<String>*/(500);\n      positions = new ArrayList/*<int[]>*/(500);\n      frequencies = new ArrayList/*<Integer>*/(500);\n    } else {\n      tokens.clear();\n      frequencies.clear();\n      positions.clear();\n    }\n\n    TermEnum termEnum = indexReader.terms();\n    if (termEnum.skipTo(new Term(field, \"\"))) {\n\n      while (termEnum.term().field() == field) {\n        TermPositions termPositions = indexReader.termPositions(termEnum.term());\n        if (termPositions.skipTo(documentNumber)) {\n\n          frequencies.add(new Integer(termPositions.freq()));\n          tokens.add(termEnum.term().text());\n\n\n          if (!mapper.isIgnoringPositions()) {\n            int[] positions = new int[termPositions.freq()];\n            for (int i = 0; i < positions.length; i++) {\n              positions[i] = termPositions.nextPosition();\n            }\n            this.positions.add(positions);\n          } else {\n            positions.add(null);\n          }\n        }\n        termPositions.close();\n        if (!termEnum.next()) {\n          break;\n        }\n      }\n\n      mapper.setDocumentNumber(documentNumber);\n      mapper.setExpectations(field, tokens.size(), false, !mapper.isIgnoringPositions());\n      for (int i = 0; i < tokens.size(); i++) {\n        mapper.map((String) tokens.get(i), ((Integer) frequencies.get(i)).intValue(), (TermVectorOffsetInfo[]) null, (int[]) positions.get(i));\n      }\n\n    }\n    termEnum.close();\n\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"48bedd31c61edafb8baaff4bcbcac19449fb7c3a","date":1251468037,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/misc/src/java/org/apache/lucene/index/TermVectorAccessor#build(IndexReader,String,TermVectorMapper,int).mjava","pathOld":"contrib/miscellaneous/src/java/org/apache/lucene/index/TermVectorAccessor#build(IndexReader,String,TermVectorMapper,int).mjava","sourceNew":"  /**\n   * Populates the mapper with terms available for the given field in a document\n   * by resolving the inverted index.\n   *\n   * @param indexReader\n   * @param field interned field name\n   * @param mapper\n   * @param documentNumber\n   * @throws IOException\n   */\n  private void build(IndexReader indexReader, String field, TermVectorMapper mapper, int documentNumber) throws IOException {\n\n    if (tokens == null) {\n      tokens = new ArrayList/*<String>*/(500);\n      positions = new ArrayList/*<int[]>*/(500);\n      frequencies = new ArrayList/*<Integer>*/(500);\n    } else {\n      tokens.clear();\n      frequencies.clear();\n      positions.clear();\n    }\n\n    TermEnum termEnum = indexReader.terms();\n    if (termEnum.skipTo(new Term(field, \"\"))) {\n\n      while (termEnum.term().field() == field) {\n        TermPositions termPositions = indexReader.termPositions(termEnum.term());\n        if (termPositions.skipTo(documentNumber)) {\n\n          frequencies.add(new Integer(termPositions.freq()));\n          tokens.add(termEnum.term().text());\n\n\n          if (!mapper.isIgnoringPositions()) {\n            int[] positions = new int[termPositions.freq()];\n            for (int i = 0; i < positions.length; i++) {\n              positions[i] = termPositions.nextPosition();\n            }\n            this.positions.add(positions);\n          } else {\n            positions.add(null);\n          }\n        }\n        termPositions.close();\n        if (!termEnum.next()) {\n          break;\n        }\n      }\n\n      mapper.setDocumentNumber(documentNumber);\n      mapper.setExpectations(field, tokens.size(), false, !mapper.isIgnoringPositions());\n      for (int i = 0; i < tokens.size(); i++) {\n        mapper.map((String) tokens.get(i), ((Integer) frequencies.get(i)).intValue(), (TermVectorOffsetInfo[]) null, (int[]) positions.get(i));\n      }\n\n    }\n    termEnum.close();\n\n\n  }\n\n","sourceOld":"  /**\n   * Populates the mapper with terms available for the given field in a document\n   * by resolving the inverted index.\n   *\n   * @param indexReader\n   * @param field interned field name\n   * @param mapper\n   * @param documentNumber\n   * @throws IOException\n   */\n  private void build(IndexReader indexReader, String field, TermVectorMapper mapper, int documentNumber) throws IOException {\n\n    if (tokens == null) {\n      tokens = new ArrayList/*<String>*/(500);\n      positions = new ArrayList/*<int[]>*/(500);\n      frequencies = new ArrayList/*<Integer>*/(500);\n    } else {\n      tokens.clear();\n      frequencies.clear();\n      positions.clear();\n    }\n\n    TermEnum termEnum = indexReader.terms();\n    if (termEnum.skipTo(new Term(field, \"\"))) {\n\n      while (termEnum.term().field() == field) {\n        TermPositions termPositions = indexReader.termPositions(termEnum.term());\n        if (termPositions.skipTo(documentNumber)) {\n\n          frequencies.add(new Integer(termPositions.freq()));\n          tokens.add(termEnum.term().text());\n\n\n          if (!mapper.isIgnoringPositions()) {\n            int[] positions = new int[termPositions.freq()];\n            for (int i = 0; i < positions.length; i++) {\n              positions[i] = termPositions.nextPosition();\n            }\n            this.positions.add(positions);\n          } else {\n            positions.add(null);\n          }\n        }\n        termPositions.close();\n        if (!termEnum.next()) {\n          break;\n        }\n      }\n\n      mapper.setDocumentNumber(documentNumber);\n      mapper.setExpectations(field, tokens.size(), false, !mapper.isIgnoringPositions());\n      for (int i = 0; i < tokens.size(); i++) {\n        mapper.map((String) tokens.get(i), ((Integer) frequencies.get(i)).intValue(), (TermVectorOffsetInfo[]) null, (int[]) positions.get(i));\n      }\n\n    }\n    termEnum.close();\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"48bedd31c61edafb8baaff4bcbcac19449fb7c3a":["a56158a9862832b67c76de543de1da36596a1133"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a56158a9862832b67c76de543de1da36596a1133":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["48bedd31c61edafb8baaff4bcbcac19449fb7c3a"]},"commit2Childs":{"48bedd31c61edafb8baaff4bcbcac19449fb7c3a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a56158a9862832b67c76de543de1da36596a1133"],"a56158a9862832b67c76de543de1da36596a1133":["48bedd31c61edafb8baaff4bcbcac19449fb7c3a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}