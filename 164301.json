{"path":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","commits":[{"id":"d74a843adda3407ffb154bb97dcbb7dffae25582","date":1282418303,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method does can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir, true);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        Field sid = doc.getField(SNAPSHOTS_ID);\n        if (sid == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (Fieldable f : doc.getFields()) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method does can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir, true);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        Field sid = doc.getField(SNAPSHOTS_ID);\n        if (sid == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (Fieldable f : doc.getFields()) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"435c7fca8d9d4e96fdc2b59f3392b08ef46725e7","date":1306320383,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","sourceNew":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir, true);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        Field sid = doc.getField(SNAPSHOTS_ID);\n        if (sid == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (Fieldable f : doc.getFields()) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","sourceOld":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method does can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir, true);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        Field sid = doc.getField(SNAPSHOTS_ID);\n        if (sid == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (Fieldable f : doc.getFields()) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","sourceNew":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir, true);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        Field sid = doc.getField(SNAPSHOTS_ID);\n        if (sid == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (Fieldable f : doc.getFields()) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","sourceOld":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method does can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir, true);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        Field sid = doc.getField(SNAPSHOTS_ID);\n        if (sid == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (Fieldable f : doc.getFields()) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","sourceNew":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir, true);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        Field sid = doc.getField(SNAPSHOTS_ID);\n        if (sid == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (Fieldable f : doc.getFields()) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","sourceOld":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method does can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir, true);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        Field sid = doc.getField(SNAPSHOTS_ID);\n        if (sid == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (Fieldable f : doc.getFields()) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","sourceNew":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir, true);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        if (doc.getField(SNAPSHOTS_ID) == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (IndexableField f : doc) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","sourceOld":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir, true);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        Field sid = doc.getField(SNAPSHOTS_ID);\n        if (sid == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (Fieldable f : doc.getFields()) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1c5b026d03cbbb03ca4c0b97d14e9839682281dc","date":1323049298,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","sourceNew":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        if (doc.getField(SNAPSHOTS_ID) == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (IndexableField f : doc) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","sourceOld":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir, true);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        if (doc.getField(SNAPSHOTS_ID) == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (IndexableField f : doc) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3615ce4a1f785ae1b779244de52c6a7d99227e60","date":1323422019,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","sourceNew":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        if (doc.getField(SNAPSHOTS_ID) == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (IndexableField f : doc) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","sourceOld":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir, true);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        if (doc.getField(SNAPSHOTS_ID) == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (IndexableField f : doc) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","date":1323437438,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","sourceNew":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        if (doc.getField(SNAPSHOTS_ID) == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (IndexableField f : doc) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","sourceOld":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir, true);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        if (doc.getField(SNAPSHOTS_ID) == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (IndexableField f : doc) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"893d07555f01912f57b453a320e4d46363a31b50","date":1327312526,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","sourceNew":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = DirectoryReader.open(dir);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        if (doc.getField(SNAPSHOTS_ID) == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (IndexableField f : doc) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","sourceOld":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        if (doc.getField(SNAPSHOTS_ID) == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (IndexableField f : doc) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","sourceNew":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = DirectoryReader.open(dir);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        if (doc.getField(SNAPSHOTS_ID) == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (IndexableField f : doc) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","sourceOld":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = IndexReader.open(dir);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        if (doc.getField(SNAPSHOTS_ID) == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (IndexableField f : doc) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#readSnapshotsInfo(Directory).mjava","sourceNew":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = DirectoryReader.open(dir);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        if (doc.getField(SNAPSHOTS_ID) == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (IndexableField f : doc) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","sourceOld":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  public static Map<String, String> readSnapshotsInfo(Directory dir) throws IOException {\n    IndexReader r = DirectoryReader.open(dir);\n    Map<String, String> snapshots = new HashMap<String, String>();\n    try {\n      int numDocs = r.numDocs();\n      // index is allowed to have exactly one document or 0.\n      if (numDocs == 1) {\n        Document doc = r.document(r.maxDoc() - 1);\n        if (doc.getField(SNAPSHOTS_ID) == null) {\n          throw new IllegalStateException(\"directory is not a valid snapshots store!\");\n        }\n        doc.removeField(SNAPSHOTS_ID);\n        for (IndexableField f : doc) {\n          snapshots.put(f.name(), f.stringValue());\n        }\n      } else if (numDocs != 0) {\n        throw new IllegalStateException(\n            \"should be at most 1 document in the snapshots directory: \" + numDocs);\n      }\n    } finally {\n      r.close();\n    }\n    return snapshots;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":["1509f151d7692d84fae414b2b799ac06ba60fcb4","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"1c5b026d03cbbb03ca4c0b97d14e9839682281dc":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d74a843adda3407ffb154bb97dcbb7dffae25582"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3615ce4a1f785ae1b779244de52c6a7d99227e60","893d07555f01912f57b453a320e4d46363a31b50"],"435c7fca8d9d4e96fdc2b59f3392b08ef46725e7":["d74a843adda3407ffb154bb97dcbb7dffae25582"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["d74a843adda3407ffb154bb97dcbb7dffae25582","435c7fca8d9d4e96fdc2b59f3392b08ef46725e7"],"d74a843adda3407ffb154bb97dcbb7dffae25582":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"893d07555f01912f57b453a320e4d46363a31b50":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["1509f151d7692d84fae414b2b799ac06ba60fcb4","1c5b026d03cbbb03ca4c0b97d14e9839682281dc"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["435c7fca8d9d4e96fdc2b59f3392b08ef46725e7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["d74a843adda3407ffb154bb97dcbb7dffae25582","435c7fca8d9d4e96fdc2b59f3392b08ef46725e7"]},"commit2Childs":{"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1c5b026d03cbbb03ca4c0b97d14e9839682281dc":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"435c7fca8d9d4e96fdc2b59f3392b08ef46725e7":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","1509f151d7692d84fae414b2b799ac06ba60fcb4","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d74a843adda3407ffb154bb97dcbb7dffae25582"],"d74a843adda3407ffb154bb97dcbb7dffae25582":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","435c7fca8d9d4e96fdc2b59f3392b08ef46725e7","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"893d07555f01912f57b453a320e4d46363a31b50":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","5cab9a86bd67202d20b6adc463008c8e982b070a","893d07555f01912f57b453a320e4d46363a31b50"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","1c5b026d03cbbb03ca4c0b97d14e9839682281dc","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}