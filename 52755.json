{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","commits":[{"id":"505bff044e47a553f461b6f4484d1d08faf4ac85","date":1420728783,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[LeafReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","sourceNew":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n  }\n\n","sourceOld":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<LeafReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    // validate incoming readers\n    for (LeafReader reader : readers) {\n      if ((reader instanceof SegmentReader) == false) {\n        // We only validate foreign readers up front: each index component\n        // calls .checkIntegrity itself for each incoming producer\n        reader.checkIntegrity();\n      }\n    }\n\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ad56fe9e068c425e8ac38f2263714e167490c2","date":1462704115,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","sourceNew":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      if (segmentInfo.getIndexSort() != null) {\n        mergeState.infoStream.message(\"SM\", \"index sort during merge: \" + segmentInfo.getIndexSort());\n      }\n    }\n  }\n\n","sourceOld":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","sourceNew":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      if (segmentInfo.getIndexSort() != null) {\n        mergeState.infoStream.message(\"SM\", \"index sort during merge: \" + segmentInfo.getIndexSort());\n      }\n    }\n  }\n\n","sourceOld":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","sourceNew":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      if (segmentInfo.getIndexSort() != null) {\n        mergeState.infoStream.message(\"SM\", \"index sort during merge: \" + segmentInfo.getIndexSort());\n      }\n    }\n  }\n\n","sourceOld":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","sourceNew":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      if (segmentInfo.getIndexSort() != null) {\n        mergeState.infoStream.message(\"SM\", \"index sort during merge: \" + segmentInfo.getIndexSort());\n      }\n    }\n  }\n\n","sourceOld":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","sourceNew":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      if (segmentInfo.getIndexSort() != null) {\n        mergeState.infoStream.message(\"SM\", \"index sort during merge: \" + segmentInfo.getIndexSort());\n      }\n    }\n  }\n\n","sourceOld":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31741cf1390044e38a2ec3127cf302ba841bfd75","date":1491292636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","sourceNew":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n    Version minVersion = Version.LATEST;\n    for (CodecReader reader : readers) {\n      Version leafMinVersion = reader.getMetaData().getMinVersion();\n      if (leafMinVersion == null) {\n        minVersion = null;\n        break;\n      }\n      if (minVersion.onOrAfter(leafMinVersion)) {\n        minVersion = leafMinVersion;\n      }\n    }\n    assert segmentInfo.minVersion == null : \"The min version should be set by SegmentMerger for merged segments\";\n    segmentInfo.minVersion = minVersion;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      if (segmentInfo.getIndexSort() != null) {\n        mergeState.infoStream.message(\"SM\", \"index sort during merge: \" + segmentInfo.getIndexSort());\n      }\n    }\n  }\n\n","sourceOld":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      if (segmentInfo.getIndexSort() != null) {\n        mergeState.infoStream.message(\"SM\", \"index sort during merge: \" + segmentInfo.getIndexSort());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92212fd254551a0b1156aafc3a1a6ed1a43932ad","date":1491296431,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","sourceNew":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n    Version minVersion = Version.LATEST;\n    for (CodecReader reader : readers) {\n      Version leafMinVersion = reader.getMetaData().getMinVersion();\n      if (leafMinVersion == null) {\n        minVersion = null;\n        break;\n      }\n      if (minVersion.onOrAfter(leafMinVersion)) {\n        minVersion = leafMinVersion;\n      }\n    }\n    assert segmentInfo.minVersion == null : \"The min version should be set by SegmentMerger for merged segments\";\n    segmentInfo.minVersion = minVersion;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      if (segmentInfo.getIndexSort() != null) {\n        mergeState.infoStream.message(\"SM\", \"index sort during merge: \" + segmentInfo.getIndexSort());\n      }\n    }\n  }\n\n","sourceOld":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      if (segmentInfo.getIndexSort() != null) {\n        mergeState.infoStream.message(\"SM\", \"index sort during merge: \" + segmentInfo.getIndexSort());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f2203cb8ae87188877cfbf6ad170c5738a0aad5","date":1528117512,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","sourceNew":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n    Version minVersion = Version.LATEST;\n    for (CodecReader reader : readers) {\n      Version leafMinVersion = reader.getMetaData().getMinVersion();\n      if (leafMinVersion == null) {\n        minVersion = null;\n        break;\n      }\n      if (minVersion.onOrAfter(leafMinVersion)) {\n        minVersion = leafMinVersion;\n      }\n\n    }\n    assert segmentInfo.minVersion == null : \"The min version should be set by SegmentMerger for merged segments\";\n    segmentInfo.minVersion = minVersion;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      if (segmentInfo.getIndexSort() != null) {\n        mergeState.infoStream.message(\"SM\", \"index sort during merge: \" + segmentInfo.getIndexSort());\n      }\n    }\n  }\n\n","sourceOld":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n    Version minVersion = Version.LATEST;\n    for (CodecReader reader : readers) {\n      Version leafMinVersion = reader.getMetaData().getMinVersion();\n      if (leafMinVersion == null) {\n        minVersion = null;\n        break;\n      }\n      if (minVersion.onOrAfter(leafMinVersion)) {\n        minVersion = leafMinVersion;\n      }\n    }\n    assert segmentInfo.minVersion == null : \"The min version should be set by SegmentMerger for merged segments\";\n    segmentInfo.minVersion = minVersion;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      if (segmentInfo.getIndexSort() != null) {\n        mergeState.infoStream.message(\"SM\", \"index sort during merge: \" + segmentInfo.getIndexSort());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","sourceNew":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n    Version minVersion = Version.LATEST;\n    for (CodecReader reader : readers) {\n      Version leafMinVersion = reader.getMetaData().getMinVersion();\n      if (leafMinVersion == null) {\n        minVersion = null;\n        break;\n      }\n      if (minVersion.onOrAfter(leafMinVersion)) {\n        minVersion = leafMinVersion;\n      }\n\n    }\n    assert segmentInfo.minVersion == null : \"The min version should be set by SegmentMerger for merged segments\";\n    segmentInfo.minVersion = minVersion;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      if (segmentInfo.getIndexSort() != null) {\n        mergeState.infoStream.message(\"SM\", \"index sort during merge: \" + segmentInfo.getIndexSort());\n      }\n    }\n  }\n\n","sourceOld":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n    Version minVersion = Version.LATEST;\n    for (CodecReader reader : readers) {\n      Version leafMinVersion = reader.getMetaData().getMinVersion();\n      if (leafMinVersion == null) {\n        minVersion = null;\n        break;\n      }\n      if (minVersion.onOrAfter(leafMinVersion)) {\n        minVersion = leafMinVersion;\n      }\n    }\n    assert segmentInfo.minVersion == null : \"The min version should be set by SegmentMerger for merged segments\";\n    segmentInfo.minVersion = minVersion;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      if (segmentInfo.getIndexSort() != null) {\n        mergeState.infoStream.message(\"SM\", \"index sort during merge: \" + segmentInfo.getIndexSort());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#SegmentMerger(List[CodecReader],SegmentInfo,InfoStream,Directory,FieldInfos.FieldNumbers,IOContext).mjava","sourceNew":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n    Version minVersion = Version.LATEST;\n    for (CodecReader reader : readers) {\n      Version leafMinVersion = reader.getMetaData().getMinVersion();\n      if (leafMinVersion == null) {\n        minVersion = null;\n        break;\n      }\n      if (minVersion.onOrAfter(leafMinVersion)) {\n        minVersion = leafMinVersion;\n      }\n\n    }\n    assert segmentInfo.minVersion == null : \"The min version should be set by SegmentMerger for merged segments\";\n    segmentInfo.minVersion = minVersion;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      if (segmentInfo.getIndexSort() != null) {\n        mergeState.infoStream.message(\"SM\", \"index sort during merge: \" + segmentInfo.getIndexSort());\n      }\n    }\n  }\n\n","sourceOld":"  // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!\n  SegmentMerger(List<CodecReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,\n                FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {\n    if (context.context != IOContext.Context.MERGE) {\n      throw new IllegalArgumentException(\"IOContext.context should be MERGE; got: \" + context.context);\n    }\n    mergeState = new MergeState(readers, segmentInfo, infoStream);\n    directory = dir;\n    this.codec = segmentInfo.getCodec();\n    this.context = context;\n    this.fieldInfosBuilder = new FieldInfos.Builder(fieldNumbers);\n    Version minVersion = Version.LATEST;\n    for (CodecReader reader : readers) {\n      Version leafMinVersion = reader.getMetaData().getMinVersion();\n      if (leafMinVersion == null) {\n        minVersion = null;\n        break;\n      }\n      if (minVersion.onOrAfter(leafMinVersion)) {\n        minVersion = leafMinVersion;\n      }\n    }\n    assert segmentInfo.minVersion == null : \"The min version should be set by SegmentMerger for merged segments\";\n    segmentInfo.minVersion = minVersion;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      if (segmentInfo.getIndexSort() != null) {\n        mergeState.infoStream.message(\"SM\", \"index sort during merge: \" + segmentInfo.getIndexSort());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0ad30c6a479e764150a3316e57263319775f1df2":["505bff044e47a553f461b6f4484d1d08faf4ac85","3d33e731a93d4b57e662ff094f64f94a745422d4"],"505bff044e47a553f461b6f4484d1d08faf4ac85":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["505bff044e47a553f461b6f4484d1d08faf4ac85","d470c8182e92b264680e34081b75e70a9f2b3c89"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["505bff044e47a553f461b6f4484d1d08faf4ac85","0ad30c6a479e764150a3316e57263319775f1df2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["31741cf1390044e38a2ec3127cf302ba841bfd75","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["31741cf1390044e38a2ec3127cf302ba841bfd75"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["505bff044e47a553f461b6f4484d1d08faf4ac85","a8ad56fe9e068c425e8ac38f2263714e167490c2"],"a8ad56fe9e068c425e8ac38f2263714e167490c2":["505bff044e47a553f461b6f4484d1d08faf4ac85"],"f592209545c71895260367152601e9200399776d":["31741cf1390044e38a2ec3127cf302ba841bfd75","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8f2203cb8ae87188877cfbf6ad170c5738a0aad5"]},"commit2Childs":{"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"505bff044e47a553f461b6f4484d1d08faf4ac85":["0ad30c6a479e764150a3316e57263319775f1df2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","3d33e731a93d4b57e662ff094f64f94a745422d4","a8ad56fe9e068c425e8ac38f2263714e167490c2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","31741cf1390044e38a2ec3127cf302ba841bfd75","92212fd254551a0b1156aafc3a1a6ed1a43932ad"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["b70042a8a492f7054d480ccdd2be9796510d4327","8f2203cb8ae87188877cfbf6ad170c5738a0aad5","f592209545c71895260367152601e9200399776d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["505bff044e47a553f461b6f4484d1d08faf4ac85"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":[],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a8ad56fe9e068c425e8ac38f2263714e167490c2":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"f592209545c71895260367152601e9200399776d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","b70042a8a492f7054d480ccdd2be9796510d4327","92212fd254551a0b1156aafc3a1a6ed1a43932ad","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}