{"path":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Set[String]],List[String],CoreContainer,ClusterState).mjava","commits":[{"id":"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe","date":1430750405,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Set[String]],List[String],CoreContainer,ClusterState).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Set<String>> shardVsNodes,\n                         List<String> liveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.liveNodes = new ArrayList<>(liveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      for (String s : clusterState.getCollections()) {\n        DocCollection coll = clusterState.getCollection(s);\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132","bf98283bf93e06ee092a158798e6a9d53bb4c747"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec4fc24ecd353171e03bd016c1681cd97476015f","date":1432214672,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Set[String]],List[String],CoreContainer,ClusterState).mjava","sourceNew":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> liveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.liveNodes = new ArrayList<>(liveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      for (String s : clusterState.getCollections()) {\n        DocCollection coll = clusterState.getCollection(s);\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Set<String>> shardVsNodes,\n                         List<String> liveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.liveNodes = new ArrayList<>(liveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      for (String s : clusterState.getCollections()) {\n        DocCollection coll = clusterState.getCollection(s);\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"ec4fc24ecd353171e03bd016c1681cd97476015f":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ec4fc24ecd353171e03bd016c1681cd97476015f"]},"commit2Childs":{"ec4fc24ecd353171e03bd016c1681cd97476015f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["ec4fc24ecd353171e03bd016c1681cd97476015f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}