{"path":"solr/core/src/java/org/apache/solr/spelling/PossibilityIterator#compatible(List[SpellCheckCorrection],int).mjava","commits":[{"id":"0ad9ec888e587ca9a3279368245cdf00aabdc108","date":1338832525,"type":0,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/PossibilityIterator#compatible(List[SpellCheckCorrection],int).mjava","pathOld":"/dev/null","sourceNew":"  private List<SpellCheckCorrection> compatible(List<SpellCheckCorrection> all,\n      int pos) {\n    List<SpellCheckCorrection> priorPassCompatibles = null;\n    {\n      List<SpellCheckCorrection> firstPassCompatibles = new ArrayList<SpellCheckCorrection>(\n          all.size());\n      SpellCheckCorrection sacred = all.get(pos);\n      firstPassCompatibles.add(sacred);\n      int index = pos;\n      boolean gotOne = false;\n      for (int i = 0; i < all.size() - 1; i++) {\n        index++;\n        if (index == all.size()) {\n          index = 0;\n        }\n        SpellCheckCorrection disposable = all.get(index);\n        if (!conflicts(sacred, disposable)) {\n          firstPassCompatibles.add(disposable);\n          gotOne = true;\n        }\n      }\n      if (!gotOne) {\n        return firstPassCompatibles;\n      }\n      priorPassCompatibles = firstPassCompatibles;\n    }\n    \n    {\n      pos = 1;\n      while (true) {\n        if (pos == priorPassCompatibles.size() - 1) {\n          return priorPassCompatibles;\n        }\n        List<SpellCheckCorrection> subsequentPassCompatibles = new ArrayList<SpellCheckCorrection>(\n            priorPassCompatibles.size());\n        SpellCheckCorrection sacred = null;\n        for (int i = 0; i <= pos; i++) {\n          sacred = priorPassCompatibles.get(i);\n          subsequentPassCompatibles.add(sacred);\n        }\n        int index = pos;\n        boolean gotOne = false;\n        for (int i = 0; i < priorPassCompatibles.size() - 1; i++) {\n          index++;\n          if (index == priorPassCompatibles.size()) {\n            break;\n          }\n          SpellCheckCorrection disposable = priorPassCompatibles.get(index);\n          if (!conflicts(sacred, disposable)) {\n            subsequentPassCompatibles.add(disposable);\n            gotOne = true;\n          }\n        }\n        if (!gotOne || pos == priorPassCompatibles.size() - 1) {\n          return subsequentPassCompatibles;\n        }\n        priorPassCompatibles = subsequentPassCompatibles;\n        pos++;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/PossibilityIterator#compatible(List[SpellCheckCorrection],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/PossibilityIterator#compatible(List[SpellCheckCorrection],int).mjava","sourceNew":"  private List<SpellCheckCorrection> compatible(List<SpellCheckCorrection> all,\n      int pos) {\n    List<SpellCheckCorrection> priorPassCompatibles = null;\n    {\n      List<SpellCheckCorrection> firstPassCompatibles = new ArrayList<>(\n          all.size());\n      SpellCheckCorrection sacred = all.get(pos);\n      firstPassCompatibles.add(sacred);\n      int index = pos;\n      boolean gotOne = false;\n      for (int i = 0; i < all.size() - 1; i++) {\n        index++;\n        if (index == all.size()) {\n          index = 0;\n        }\n        SpellCheckCorrection disposable = all.get(index);\n        if (!conflicts(sacred, disposable)) {\n          firstPassCompatibles.add(disposable);\n          gotOne = true;\n        }\n      }\n      if (!gotOne) {\n        return firstPassCompatibles;\n      }\n      priorPassCompatibles = firstPassCompatibles;\n    }\n    \n    {\n      pos = 1;\n      while (true) {\n        if (pos == priorPassCompatibles.size() - 1) {\n          return priorPassCompatibles;\n        }\n        List<SpellCheckCorrection> subsequentPassCompatibles = new ArrayList<>(\n            priorPassCompatibles.size());\n        SpellCheckCorrection sacred = null;\n        for (int i = 0; i <= pos; i++) {\n          sacred = priorPassCompatibles.get(i);\n          subsequentPassCompatibles.add(sacred);\n        }\n        int index = pos;\n        boolean gotOne = false;\n        for (int i = 0; i < priorPassCompatibles.size() - 1; i++) {\n          index++;\n          if (index == priorPassCompatibles.size()) {\n            break;\n          }\n          SpellCheckCorrection disposable = priorPassCompatibles.get(index);\n          if (!conflicts(sacred, disposable)) {\n            subsequentPassCompatibles.add(disposable);\n            gotOne = true;\n          }\n        }\n        if (!gotOne || pos == priorPassCompatibles.size() - 1) {\n          return subsequentPassCompatibles;\n        }\n        priorPassCompatibles = subsequentPassCompatibles;\n        pos++;\n      }\n    }\n  }\n\n","sourceOld":"  private List<SpellCheckCorrection> compatible(List<SpellCheckCorrection> all,\n      int pos) {\n    List<SpellCheckCorrection> priorPassCompatibles = null;\n    {\n      List<SpellCheckCorrection> firstPassCompatibles = new ArrayList<SpellCheckCorrection>(\n          all.size());\n      SpellCheckCorrection sacred = all.get(pos);\n      firstPassCompatibles.add(sacred);\n      int index = pos;\n      boolean gotOne = false;\n      for (int i = 0; i < all.size() - 1; i++) {\n        index++;\n        if (index == all.size()) {\n          index = 0;\n        }\n        SpellCheckCorrection disposable = all.get(index);\n        if (!conflicts(sacred, disposable)) {\n          firstPassCompatibles.add(disposable);\n          gotOne = true;\n        }\n      }\n      if (!gotOne) {\n        return firstPassCompatibles;\n      }\n      priorPassCompatibles = firstPassCompatibles;\n    }\n    \n    {\n      pos = 1;\n      while (true) {\n        if (pos == priorPassCompatibles.size() - 1) {\n          return priorPassCompatibles;\n        }\n        List<SpellCheckCorrection> subsequentPassCompatibles = new ArrayList<SpellCheckCorrection>(\n            priorPassCompatibles.size());\n        SpellCheckCorrection sacred = null;\n        for (int i = 0; i <= pos; i++) {\n          sacred = priorPassCompatibles.get(i);\n          subsequentPassCompatibles.add(sacred);\n        }\n        int index = pos;\n        boolean gotOne = false;\n        for (int i = 0; i < priorPassCompatibles.size() - 1; i++) {\n          index++;\n          if (index == priorPassCompatibles.size()) {\n            break;\n          }\n          SpellCheckCorrection disposable = priorPassCompatibles.get(index);\n          if (!conflicts(sacred, disposable)) {\n            subsequentPassCompatibles.add(disposable);\n            gotOne = true;\n          }\n        }\n        if (!gotOne || pos == priorPassCompatibles.size() - 1) {\n          return subsequentPassCompatibles;\n        }\n        priorPassCompatibles = subsequentPassCompatibles;\n        pos++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0ad9ec888e587ca9a3279368245cdf00aabdc108"],"0ad9ec888e587ca9a3279368245cdf00aabdc108":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0ad9ec888e587ca9a3279368245cdf00aabdc108":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad9ec888e587ca9a3279368245cdf00aabdc108"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}