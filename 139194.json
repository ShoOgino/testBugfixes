{"path":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","commits":[{"id":"91109046a59c58ee0ee5d0d2767b08d1f30d6702","date":1000830588,"type":0,"author":"Jason van Zyl","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","pathOld":"/dev/null","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = mergeFactor;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n\tSegmentInfo si = segmentInfos.info(minSegment);\n\tif (si.docCount >= targetMergeDocs)\n\t  break;\n\tmergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n\tmergeSegments(minSegment+1);\n      else\n\tbreak;\n      \n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1507a324c1f939ed71e01297733a49b9c36e5688"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8ac4052920fcd27b00a09b0f354a72da109d5d01","date":1049855256,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = mergeFactor;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n\tSegmentInfo si = segmentInfos.info(minSegment);\n\tif (si.docCount >= targetMergeDocs)\n\t  break;\n\tmergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n\tmergeSegments(minSegment+1);\n      else\n\tbreak;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = mergeFactor;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n\tSegmentInfo si = segmentInfos.info(minSegment);\n\tif (si.docCount >= targetMergeDocs)\n\t  break;\n\tmergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n\tmergeSegments(minSegment+1);\n      else\n\tbreak;\n      \n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fb95844e4ba5160067c64c5eb1cd8a09f7a94f1","date":1064527311,"type":3,"author":"Dmitry Serebrennikov","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = mergeFactor;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n        mergeSegments(minSegment+1);\n      else\n        break;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = mergeFactor;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n\tSegmentInfo si = segmentInfos.info(minSegment);\n\tif (si.docCount >= targetMergeDocs)\n\t  break;\n\tmergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n\tmergeSegments(minSegment+1);\n      else\n\tbreak;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"13083fa89ff763555f7904d4048bbd4d34674836","date":1069156699,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = minMergeDocs;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n        mergeSegments(minSegment+1);\n      else\n        break;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = mergeFactor;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n        mergeSegments(minSegment+1);\n      else\n        break;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2873952b26e625309b50b6d99fb5b4b963cff030","date":1138229385,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = minMergeDocs;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount > targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n        mergeSegments(minSegment+1);\n      else\n        break;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = minMergeDocs;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n        mergeSegments(minSegment+1);\n      else\n        break;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d88b840642a1a2b6100c70abf822281914ca249","date":1140964805,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = minMergeDocs;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n        mergeSegments(minSegment+1);\n      else\n        break;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = minMergeDocs;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount > targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n        mergeSegments(minSegment+1);\n      else\n        break;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a34f23ad863179f1a3d973f561d76331e5dce92","date":1155457213,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    /**\n     *  do not bother checking the segment details to determine\n     *  if we should merge, but instead honour the maxBufferedDocs(minMergeDocs)\n     *  property to ensure we do not spend time checking for merge conditions\n     *  \n     */\n    if(bufferedDocCount<minMergeDocs) {\n        return;\n    }\n    long targetMergeDocs = minMergeDocs;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n        mergeSegments(minSegment+1);\n      else\n        break;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = minMergeDocs;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n        mergeSegments(minSegment+1);\n      else\n        break;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7cf920bc70a57dc75d59acb55a7d893cc2924ad","date":1155538722,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = minMergeDocs;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n        mergeSegments(minSegment+1);\n      else\n        break;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    /**\n     *  do not bother checking the segment details to determine\n     *  if we should merge, but instead honour the maxBufferedDocs(minMergeDocs)\n     *  property to ensure we do not spend time checking for merge conditions\n     *  \n     */\n    if(bufferedDocCount<minMergeDocs) {\n        return;\n    }\n    long targetMergeDocs = minMergeDocs;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n        mergeSegments(minSegment+1);\n      else\n        break;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1507a324c1f939ed71e01297733a49b9c36e5688","date":1155783141,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = minMergeDocs;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size() - singleDocSegmentsCount; // top 1-doc segments are taken for sure\n      int mergeDocs = singleDocSegmentsCount;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t{\t  // found a merge to do\n        mergeSegments(minSegment+1);\n        singleDocSegmentsCount = 0;\n      } else {\n        break;\n      }\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = minMergeDocs;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size();\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t\t  // found a merge to do\n        mergeSegments(minSegment+1);\n      else\n        break;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","bugFix":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92bc0e1d83efa4bc1167ba6f8498b065d3d8ce37","date":1155907996,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = minMergeDocs;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size() - singleDocSegmentsCount; // top 1-doc segments are taken for sure\n      int mergeDocs = singleDocSegmentsCount;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t \t  // found a merge to do\n        mergeSegments(minSegment+1);\n      else\n        break;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = minMergeDocs;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size() - singleDocSegmentsCount; // top 1-doc segments are taken for sure\n      int mergeDocs = singleDocSegmentsCount;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t{\t  // found a merge to do\n        mergeSegments(minSegment+1);\n        singleDocSegmentsCount = 0;\n      } else {\n        break;\n      }\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d7052f725a053aa55424f966831826f61b798bf1","date":1158258681,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long lowerBound = 0;\n    long upperBound = minMergeDocs;\n\n    while (upperBound * mergeFactor <= maxMergeDocs) {\n      int minSegment = segmentInfos.size();\n      int maxSegment = -1;\n\n      // find merge-worthy segments\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n\n        if (maxSegment == -1 && si.docCount > lowerBound && si.docCount <= upperBound) {\n          // start from the rightmost* segment whose doc count is in bounds\n          maxSegment = minSegment;\n        } else if (si.docCount > upperBound) {\n          // until the segment whose doc count exceeds upperBound\n          break;\n        }\n      }\n\n      minSegment++;\n      maxSegment++;\n      int numSegments = maxSegment - minSegment;\n\n      if (numSegments < mergeFactor) {\n        break;\n      } else {\n        boolean exceedsUpperLimit = false;\n\n        // number of merge-worthy segments may exceed mergeFactor when\n        // mergeFactor and/or maxBufferedDocs change(s)\n        while (numSegments >= mergeFactor) {\n          // merge the leftmost* mergeFactor segments\n          int docCount = mergeSegments(segmentInfos, minSegment, minSegment + mergeFactor);\n          numSegments -= mergeFactor;\n\n          if (docCount > upperBound) {\n            // continue to merge the rest of the worthy segments on this level\n            minSegment++;\n            exceedsUpperLimit = true;\n          } else if (docCount > 0) {\n            // if the merged segment does not exceed upperBound, consider\n            // this segment for further merges on this same level\n            numSegments++;\n          }\n        }\n\n        if (!exceedsUpperLimit) {\n          // if none of the merged segments exceed upperBound, done\n          break;\n        }\n      }\n\n      lowerBound = upperBound;\n      upperBound *= mergeFactor;\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long targetMergeDocs = minMergeDocs;\n    while (targetMergeDocs <= maxMergeDocs) {\n      // find segments smaller than current target size\n      int minSegment = segmentInfos.size() - singleDocSegmentsCount; // top 1-doc segments are taken for sure\n      int mergeDocs = singleDocSegmentsCount;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs)\n          break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs)\t \t  // found a merge to do\n        mergeSegments(minSegment+1);\n      else\n        break;\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db98d4535286b6e306e0cf1d1d4bfff5933fdc3c","date":1158614762,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long lowerBound = -1;\n    long upperBound = minMergeDocs;\n\n    while (upperBound * mergeFactor <= maxMergeDocs) {\n      int minSegment = segmentInfos.size();\n      int maxSegment = -1;\n\n      // find merge-worthy segments\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n\n        if (maxSegment == -1 && si.docCount > lowerBound && si.docCount <= upperBound) {\n          // start from the rightmost* segment whose doc count is in bounds\n          maxSegment = minSegment;\n        } else if (si.docCount > upperBound) {\n          // until the segment whose doc count exceeds upperBound\n          break;\n        }\n      }\n\n      minSegment++;\n      maxSegment++;\n      int numSegments = maxSegment - minSegment;\n\n      if (numSegments < mergeFactor) {\n        break;\n      } else {\n        boolean exceedsUpperLimit = false;\n\n        // number of merge-worthy segments may exceed mergeFactor when\n        // mergeFactor and/or maxBufferedDocs change(s)\n        while (numSegments >= mergeFactor) {\n          // merge the leftmost* mergeFactor segments\n          int docCount = mergeSegments(segmentInfos, minSegment, minSegment + mergeFactor);\n          numSegments -= mergeFactor;\n\n          if (docCount > upperBound) {\n            // continue to merge the rest of the worthy segments on this level\n            minSegment++;\n            exceedsUpperLimit = true;\n          } else {\n            // if the merged segment does not exceed upperBound, consider\n            // this segment for further merges on this same level\n            numSegments++;\n          }\n        }\n\n        if (!exceedsUpperLimit) {\n          // if none of the merged segments exceed upperBound, done\n          break;\n        }\n      }\n\n      lowerBound = upperBound;\n      upperBound *= mergeFactor;\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long lowerBound = 0;\n    long upperBound = minMergeDocs;\n\n    while (upperBound * mergeFactor <= maxMergeDocs) {\n      int minSegment = segmentInfos.size();\n      int maxSegment = -1;\n\n      // find merge-worthy segments\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n\n        if (maxSegment == -1 && si.docCount > lowerBound && si.docCount <= upperBound) {\n          // start from the rightmost* segment whose doc count is in bounds\n          maxSegment = minSegment;\n        } else if (si.docCount > upperBound) {\n          // until the segment whose doc count exceeds upperBound\n          break;\n        }\n      }\n\n      minSegment++;\n      maxSegment++;\n      int numSegments = maxSegment - minSegment;\n\n      if (numSegments < mergeFactor) {\n        break;\n      } else {\n        boolean exceedsUpperLimit = false;\n\n        // number of merge-worthy segments may exceed mergeFactor when\n        // mergeFactor and/or maxBufferedDocs change(s)\n        while (numSegments >= mergeFactor) {\n          // merge the leftmost* mergeFactor segments\n          int docCount = mergeSegments(segmentInfos, minSegment, minSegment + mergeFactor);\n          numSegments -= mergeFactor;\n\n          if (docCount > upperBound) {\n            // continue to merge the rest of the worthy segments on this level\n            minSegment++;\n            exceedsUpperLimit = true;\n          } else if (docCount > 0) {\n            // if the merged segment does not exceed upperBound, consider\n            // this segment for further merges on this same level\n            numSegments++;\n          }\n        }\n\n        if (!exceedsUpperLimit) {\n          // if none of the merged segments exceed upperBound, done\n          break;\n        }\n      }\n\n      lowerBound = upperBound;\n      upperBound *= mergeFactor;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"938d1493cf2f269d3b9e66e932c07ee784e00022","date":1161902835,"type":5,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments(int startUpperBound) throws IOException {\n    long lowerBound = -1;\n    long upperBound = startUpperBound;\n\n    while (upperBound < maxMergeDocs) {\n      int minSegment = segmentInfos.size();\n      int maxSegment = -1;\n\n      // find merge-worthy segments\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n\n        if (maxSegment == -1 && si.docCount > lowerBound && si.docCount <= upperBound) {\n          // start from the rightmost* segment whose doc count is in bounds\n          maxSegment = minSegment;\n        } else if (si.docCount > upperBound) {\n          // until the segment whose doc count exceeds upperBound\n          break;\n        }\n      }\n\n      minSegment++;\n      maxSegment++;\n      int numSegments = maxSegment - minSegment;\n\n      if (numSegments < mergeFactor) {\n        break;\n      } else {\n        boolean exceedsUpperLimit = false;\n\n        // number of merge-worthy segments may exceed mergeFactor when\n        // mergeFactor and/or maxBufferedDocs change(s)\n        while (numSegments >= mergeFactor) {\n          // merge the leftmost* mergeFactor segments\n          int docCount = mergeSegments(segmentInfos, minSegment, minSegment + mergeFactor);\n          numSegments -= mergeFactor;\n\n          if (docCount > upperBound) {\n            // continue to merge the rest of the worthy segments on this level\n            minSegment++;\n            exceedsUpperLimit = true;\n          } else {\n            // if the merged segment does not exceed upperBound, consider\n            // this segment for further merges on this same level\n            numSegments++;\n          }\n        }\n\n        if (!exceedsUpperLimit) {\n          // if none of the merged segments exceed upperBound, done\n          break;\n        }\n      }\n\n      lowerBound = upperBound;\n      upperBound *= mergeFactor;\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long lowerBound = -1;\n    long upperBound = minMergeDocs;\n\n    while (upperBound * mergeFactor <= maxMergeDocs) {\n      int minSegment = segmentInfos.size();\n      int maxSegment = -1;\n\n      // find merge-worthy segments\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n\n        if (maxSegment == -1 && si.docCount > lowerBound && si.docCount <= upperBound) {\n          // start from the rightmost* segment whose doc count is in bounds\n          maxSegment = minSegment;\n        } else if (si.docCount > upperBound) {\n          // until the segment whose doc count exceeds upperBound\n          break;\n        }\n      }\n\n      minSegment++;\n      maxSegment++;\n      int numSegments = maxSegment - minSegment;\n\n      if (numSegments < mergeFactor) {\n        break;\n      } else {\n        boolean exceedsUpperLimit = false;\n\n        // number of merge-worthy segments may exceed mergeFactor when\n        // mergeFactor and/or maxBufferedDocs change(s)\n        while (numSegments >= mergeFactor) {\n          // merge the leftmost* mergeFactor segments\n          int docCount = mergeSegments(segmentInfos, minSegment, minSegment + mergeFactor);\n          numSegments -= mergeFactor;\n\n          if (docCount > upperBound) {\n            // continue to merge the rest of the worthy segments on this level\n            minSegment++;\n            exceedsUpperLimit = true;\n          } else {\n            // if the merged segment does not exceed upperBound, consider\n            // this segment for further merges on this same level\n            numSegments++;\n          }\n        }\n\n        if (!exceedsUpperLimit) {\n          // if none of the merged segments exceed upperBound, done\n          break;\n        }\n      }\n\n      lowerBound = upperBound;\n      upperBound *= mergeFactor;\n    }\n  }\n\n","bugFix":null,"bugIntro":["1b54a9bc667895a2095a886184bf69a3179e63df"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"d7052f725a053aa55424f966831826f61b798bf1":["92bc0e1d83efa4bc1167ba6f8498b065d3d8ce37"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"db98d4535286b6e306e0cf1d1d4bfff5933fdc3c":["d7052f725a053aa55424f966831826f61b798bf1"],"8fb95844e4ba5160067c64c5eb1cd8a09f7a94f1":["8ac4052920fcd27b00a09b0f354a72da109d5d01"],"1a34f23ad863179f1a3d973f561d76331e5dce92":["1d88b840642a1a2b6100c70abf822281914ca249"],"2873952b26e625309b50b6d99fb5b4b963cff030":["13083fa89ff763555f7904d4048bbd4d34674836"],"8ac4052920fcd27b00a09b0f354a72da109d5d01":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"1507a324c1f939ed71e01297733a49b9c36e5688":["c7cf920bc70a57dc75d59acb55a7d893cc2924ad"],"13083fa89ff763555f7904d4048bbd4d34674836":["8fb95844e4ba5160067c64c5eb1cd8a09f7a94f1"],"938d1493cf2f269d3b9e66e932c07ee784e00022":["db98d4535286b6e306e0cf1d1d4bfff5933fdc3c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"92bc0e1d83efa4bc1167ba6f8498b065d3d8ce37":["1507a324c1f939ed71e01297733a49b9c36e5688"],"c7cf920bc70a57dc75d59acb55a7d893cc2924ad":["1a34f23ad863179f1a3d973f561d76331e5dce92"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["938d1493cf2f269d3b9e66e932c07ee784e00022"],"1d88b840642a1a2b6100c70abf822281914ca249":["2873952b26e625309b50b6d99fb5b4b963cff030"]},"commit2Childs":{"d7052f725a053aa55424f966831826f61b798bf1":["db98d4535286b6e306e0cf1d1d4bfff5933fdc3c"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["8ac4052920fcd27b00a09b0f354a72da109d5d01"],"db98d4535286b6e306e0cf1d1d4bfff5933fdc3c":["938d1493cf2f269d3b9e66e932c07ee784e00022"],"8fb95844e4ba5160067c64c5eb1cd8a09f7a94f1":["13083fa89ff763555f7904d4048bbd4d34674836"],"1a34f23ad863179f1a3d973f561d76331e5dce92":["c7cf920bc70a57dc75d59acb55a7d893cc2924ad"],"2873952b26e625309b50b6d99fb5b4b963cff030":["1d88b840642a1a2b6100c70abf822281914ca249"],"8ac4052920fcd27b00a09b0f354a72da109d5d01":["8fb95844e4ba5160067c64c5eb1cd8a09f7a94f1"],"13083fa89ff763555f7904d4048bbd4d34674836":["2873952b26e625309b50b6d99fb5b4b963cff030"],"1507a324c1f939ed71e01297733a49b9c36e5688":["92bc0e1d83efa4bc1167ba6f8498b065d3d8ce37"],"938d1493cf2f269d3b9e66e932c07ee784e00022":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"92bc0e1d83efa4bc1167ba6f8498b065d3d8ce37":["d7052f725a053aa55424f966831826f61b798bf1"],"c7cf920bc70a57dc75d59acb55a7d893cc2924ad":["1507a324c1f939ed71e01297733a49b9c36e5688"],"1d88b840642a1a2b6100c70abf822281914ca249":["1a34f23ad863179f1a3d973f561d76331e5dce92"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}