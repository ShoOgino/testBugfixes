{"path":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","commits":[{"id":"91109046a59c58ee0ee5d0d2767b08d1f30d6702","date":1000830588,"type":0,"author":"Jason van Zyl","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"/dev/null","sourceNew":"  public final void write(Directory directory) throws IOException {\n    OutputStream output = directory.createFile(\"segments.new\");\n    try {\n      output.writeInt(counter);\t\t\t  // write counter\n      output.writeInt(size());\t\t\t  // write infos\n      for (int i = 0; i < size(); i++) {\n\tSegmentInfo si = info(i);\n\toutput.writeString(si.name);\n\toutput.writeInt(si.docCount);\n      }\n    } finally {\n      output.close();\n    }\n\n    // install new segment info\n    directory.renameFile(\"segments.new\", \"segments\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2cbfa4afac663762cc089553b02cd40096d8ac6","date":1069155357,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  public final void write(Directory directory) throws IOException {\n    OutputStream output = directory.createFile(\"segments.new\");\n    try {\n      output.writeInt(counter);\t\t\t  // write counter\n      output.writeInt(size());\t\t\t  // write infos\n      for (int i = 0; i < size(); i++) {\n        SegmentInfo si = info(i);\n        output.writeString(si.name);\n        output.writeInt(si.docCount);\n      }\n    } finally {\n      output.close();\n    }\n\n    // install new segment info\n    directory.renameFile(\"segments.new\", \"segments\");\n  }\n\n","sourceOld":"  public final void write(Directory directory) throws IOException {\n    OutputStream output = directory.createFile(\"segments.new\");\n    try {\n      output.writeInt(counter);\t\t\t  // write counter\n      output.writeInt(size());\t\t\t  // write infos\n      for (int i = 0; i < size(); i++) {\n\tSegmentInfo si = info(i);\n\toutput.writeString(si.name);\n\toutput.writeInt(si.docCount);\n      }\n    } finally {\n      output.close();\n    }\n\n    // install new segment info\n    directory.renameFile(\"segments.new\", \"segments\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c1c4d5b9a1f3631a80687ab505cbb0debfe7cc6","date":1069355441,"type":3,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  public final void write(Directory directory) throws IOException {\n    OutputStream output = directory.createFile(\"segments.new\");\n    try {\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        SegmentInfo si = info(i);\n        output.writeString(si.name);\n        output.writeInt(si.docCount);\n      }\n      output.writeLong(++version); // every write changes the index         \n    }\n    finally {\n      output.close();\n    }\n\n    // install new segment info\n    directory.renameFile(\"segments.new\", \"segments\");\n  }\n\n","sourceOld":"  public final void write(Directory directory) throws IOException {\n    OutputStream output = directory.createFile(\"segments.new\");\n    try {\n      output.writeInt(counter);\t\t\t  // write counter\n      output.writeInt(size());\t\t\t  // write infos\n      for (int i = 0; i < size(); i++) {\n        SegmentInfo si = info(i);\n        output.writeString(si.name);\n        output.writeInt(si.docCount);\n      }\n    } finally {\n      output.close();\n    }\n\n    // install new segment info\n    directory.renameFile(\"segments.new\", \"segments\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5080735f27287ee9a86441cfca7da3af146ee8d7","date":1081415599,"type":3,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  public final void write(Directory directory) throws IOException {\n    OutputStream output = directory.createFile(\"segments.new\");\n    try {\n      output.writeInt(FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        SegmentInfo si = info(i);\n        output.writeString(si.name);\n        output.writeInt(si.docCount);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    // install new segment info\n    directory.renameFile(\"segments.new\", \"segments\");\n  }\n\n","sourceOld":"  public final void write(Directory directory) throws IOException {\n    OutputStream output = directory.createFile(\"segments.new\");\n    try {\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        SegmentInfo si = info(i);\n        output.writeString(si.name);\n        output.writeInt(si.docCount);\n      }\n      output.writeLong(++version); // every write changes the index         \n    }\n    finally {\n      output.close();\n    }\n\n    // install new segment info\n    directory.renameFile(\"segments.new\", \"segments\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dda77265180d41bf85c84c995e25eda7b8e1b74d","date":1096395352,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  public final void write(Directory directory) throws IOException {\n    IndexOutput output = directory.createOutput(\"segments.new\");\n    try {\n      output.writeInt(FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        SegmentInfo si = info(i);\n        output.writeString(si.name);\n        output.writeInt(si.docCount);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    // install new segment info\n    directory.renameFile(\"segments.new\", \"segments\");\n  }\n\n","sourceOld":"  public final void write(Directory directory) throws IOException {\n    OutputStream output = directory.createFile(\"segments.new\");\n    try {\n      output.writeInt(FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        SegmentInfo si = info(i);\n        output.writeString(si.name);\n        output.writeInt(si.docCount);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    // install new segment info\n    directory.renameFile(\"segments.new\", \"segments\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd6eb8b1d71f36e7d134adc278a3d27c2559414c","date":1118080332,"type":3,"author":"Bernhard Messer","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  public final void write(Directory directory) throws IOException {\n    IndexOutput output = directory.createOutput(\"segments.new\");\n    try {\n      output.writeInt(FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        SegmentInfo si = info(i);\n        output.writeString(si.name);\n        output.writeInt(si.docCount);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    // install new segment info\n    directory.renameFile(\"segments.new\", Constants.INDEX_SEGMENTS_FILENAME);\n  }\n\n","sourceOld":"  public final void write(Directory directory) throws IOException {\n    IndexOutput output = directory.createOutput(\"segments.new\");\n    try {\n      output.writeInt(FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        SegmentInfo si = info(i);\n        output.writeString(si.name);\n        output.writeInt(si.docCount);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    // install new segment info\n    directory.renameFile(\"segments.new\", \"segments\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24157515079eea65faeec4e1dbb01fea58444c8e","date":1118343636,"type":3,"author":"Bernhard Messer","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  public final void write(Directory directory) throws IOException {\n    IndexOutput output = directory.createOutput(\"segments.new\");\n    try {\n      output.writeInt(FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        SegmentInfo si = info(i);\n        output.writeString(si.name);\n        output.writeInt(si.docCount);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    // install new segment info\n    directory.renameFile(\"segments.new\", IndexFileNames.SEGMENTS);\n  }\n\n","sourceOld":"  public final void write(Directory directory) throws IOException {\n    IndexOutput output = directory.createOutput(\"segments.new\");\n    try {\n      output.writeInt(FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        SegmentInfo si = info(i);\n        output.writeString(si.name);\n        output.writeInt(si.docCount);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    // install new segment info\n    directory.renameFile(\"segments.new\", Constants.INDEX_SEGMENTS_FILENAME);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"284c1d3c8b19931bf6f312fae7470487f5d9e580","date":1163805527,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  public final void write(Directory directory) throws IOException {\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    String segmentFileName = getCurrentSegmentFileName();\n    IndexOutput output = directory.createOutput(segmentFileName);\n\n    try {\n      output.writeInt(FORMAT_LOCKLESS); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        SegmentInfo si = info(i);\n        si.write(output);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    try {\n      output = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      output.writeInt(FORMAT_LOCKLESS);\n      output.writeLong(generation);\n      output.writeLong(generation);\n      output.close();\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n  }\n\n","sourceOld":"  public final void write(Directory directory) throws IOException {\n    IndexOutput output = directory.createOutput(\"segments.new\");\n    try {\n      output.writeInt(FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        SegmentInfo si = info(i);\n        output.writeString(si.name);\n        output.writeInt(si.docCount);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    // install new segment info\n    directory.renameFile(\"segments.new\", IndexFileNames.SEGMENTS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eeefd99c477417e5c7c574228461ebafe92469d4","date":1166460329,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  public final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    IndexOutput output = directory.createOutput(segmentFileName);\n\n    try {\n      output.writeInt(FORMAT_LOCKLESS); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    try {\n      output = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      output.writeInt(FORMAT_LOCKLESS);\n      output.writeLong(generation);\n      output.writeLong(generation);\n      output.close();\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n    \n    lastGeneration = generation;\n  }\n\n","sourceOld":"  public final void write(Directory directory) throws IOException {\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    String segmentFileName = getCurrentSegmentFileName();\n    IndexOutput output = directory.createOutput(segmentFileName);\n\n    try {\n      output.writeInt(FORMAT_LOCKLESS); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        SegmentInfo si = info(i);\n        si.write(output);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    try {\n      output = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      output.writeInt(FORMAT_LOCKLESS);\n      output.writeLong(generation);\n      output.writeLong(generation);\n      output.close();\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1bc734e51cf4404bd08aa7799a7ff025214031e","date":1166545055,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  public final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    IndexOutput output = directory.createOutput(segmentFileName);\n\n    try {\n      output.writeInt(FORMAT_LOCKLESS); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    try {\n      output = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      try {\n        output.writeInt(FORMAT_LOCKLESS);\n        output.writeLong(generation);\n        output.writeLong(generation);\n      } finally {\n        output.close();\n      }\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n    \n    lastGeneration = generation;\n  }\n\n","sourceOld":"  public final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    IndexOutput output = directory.createOutput(segmentFileName);\n\n    try {\n      output.writeInt(FORMAT_LOCKLESS); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    try {\n      output = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      output.writeInt(FORMAT_LOCKLESS);\n      output.writeLong(generation);\n      output.writeLong(generation);\n      output.close();\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n    \n    lastGeneration = generation;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a5cfde941b2f8208d739344fef3821381885618","date":1168979092,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  public final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    IndexOutput output = directory.createOutput(segmentFileName);\n\n    try {\n      output.writeInt(FORMAT_SINGLE_NORM_FILE); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    try {\n      output = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      try {\n        output.writeInt(FORMAT_LOCKLESS);\n        output.writeLong(generation);\n        output.writeLong(generation);\n      } finally {\n        output.close();\n      }\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n    \n    lastGeneration = generation;\n  }\n\n","sourceOld":"  public final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    IndexOutput output = directory.createOutput(segmentFileName);\n\n    try {\n      output.writeInt(FORMAT_LOCKLESS); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    try {\n      output = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      try {\n        output.writeInt(FORMAT_LOCKLESS);\n        output.writeLong(generation);\n        output.writeLong(generation);\n      } finally {\n        output.close();\n      }\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n    \n    lastGeneration = generation;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b6187898fc4413ccd18229711786550a280383c","date":1173776782,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  public final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    IndexOutput output = directory.createOutput(segmentFileName);\n\n    boolean success = false;\n\n    try {\n      output.writeInt(FORMAT_SINGLE_NORM_FILE); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }         \n    }\n    finally {\n      try {\n        output.close();\n        success = true;\n      } finally {\n        if (!success) {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        }\n      }\n    }\n\n    try {\n      output = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      try {\n        output.writeInt(FORMAT_LOCKLESS);\n        output.writeLong(generation);\n        output.writeLong(generation);\n      } finally {\n        output.close();\n      }\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n    \n    lastGeneration = generation;\n  }\n\n","sourceOld":"  public final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    IndexOutput output = directory.createOutput(segmentFileName);\n\n    try {\n      output.writeInt(FORMAT_SINGLE_NORM_FILE); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }         \n    }\n    finally {\n      output.close();\n    }\n\n    try {\n      output = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      try {\n        output.writeInt(FORMAT_LOCKLESS);\n        output.writeLong(generation);\n        output.writeLong(generation);\n      } finally {\n        output.close();\n      }\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n    \n    lastGeneration = generation;\n  }\n\n","bugFix":null,"bugIntro":["3ead7b8e9b4934446f7a00ad0e81e3aa4d587ab6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4ee8d31906e3001783889a491e55f218013a190","date":1173949687,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  public final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    IndexOutput output = directory.createOutput(segmentFileName);\n\n    boolean success = false;\n\n    try {\n      output.writeInt(CURRENT_FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }         \n    }\n    finally {\n      try {\n        output.close();\n        success = true;\n      } finally {\n        if (!success) {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        }\n      }\n    }\n\n    try {\n      output = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      try {\n        output.writeInt(FORMAT_LOCKLESS);\n        output.writeLong(generation);\n        output.writeLong(generation);\n      } finally {\n        output.close();\n      }\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n    \n    lastGeneration = generation;\n  }\n\n","sourceOld":"  public final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    IndexOutput output = directory.createOutput(segmentFileName);\n\n    boolean success = false;\n\n    try {\n      output.writeInt(FORMAT_SINGLE_NORM_FILE); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }         \n    }\n    finally {\n      try {\n        output.close();\n        success = true;\n      } finally {\n        if (!success) {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        }\n      }\n    }\n\n    try {\n      output = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      try {\n        output.writeInt(FORMAT_LOCKLESS);\n        output.writeLong(generation);\n        output.writeLong(generation);\n      } finally {\n        output.close();\n      }\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n    \n    lastGeneration = generation;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e82780afe6097066eb5befb86e9432f077667e3d","date":1202756169,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    ChecksumIndexOutput output = new ChecksumIndexOutput(directory.createOutput(segmentFileName));\n\n    boolean success = false;\n\n    try {\n      output.writeInt(CURRENT_FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }\n      final long checksum = output.getChecksum();\n      output.writeLong(checksum);\n      success = true;\n    } finally {\n      boolean success2 = false;\n      try {\n        output.close();\n        success2 = true;\n      } finally {\n        if (!success || !success2)\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n      }\n    }\n\n    try {\n      IndexOutput genOutput = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      try {\n        genOutput.writeInt(FORMAT_LOCKLESS);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n      }\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n    \n    lastGeneration = generation;\n  }\n\n","sourceOld":"  public final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    IndexOutput output = directory.createOutput(segmentFileName);\n\n    boolean success = false;\n\n    try {\n      output.writeInt(CURRENT_FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }         \n    }\n    finally {\n      try {\n        output.close();\n        success = true;\n      } finally {\n        if (!success) {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        }\n      }\n    }\n\n    try {\n      output = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      try {\n        output.writeInt(FORMAT_LOCKLESS);\n        output.writeLong(generation);\n        output.writeLong(generation);\n      } finally {\n        output.close();\n      }\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n    \n    lastGeneration = generation;\n  }\n\n","bugFix":null,"bugIntro":["3ead7b8e9b4934446f7a00ad0e81e3aa4d587ab6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3ead7b8e9b4934446f7a00ad0e81e3aa4d587ab6","date":1205349797,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    ChecksumIndexOutput output = new ChecksumIndexOutput(directory.createOutput(segmentFileName));\n\n    boolean success = false;\n\n    try {\n      output.writeInt(CURRENT_FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }\n      final long checksum = output.getChecksum();\n      output.writeLong(checksum);\n      success = true;\n    } finally {\n      boolean success2 = false;\n      try {\n        if (!success) {\n          // We hit an exception above; try to close the file\n          // but suppress any exception:\n          try {\n            output.close();\n            success2 = true;\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        } else {\n          output.close();\n          success2 = true;\n        }\n      } finally {\n        if (!success || !success2) {\n          try {\n            // Try not to leave a truncated segments_N file in\n            // the index:\n            directory.deleteFile(segmentFileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n      }\n    }\n\n    try {\n      IndexOutput genOutput = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      try {\n        genOutput.writeInt(FORMAT_LOCKLESS);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n      }\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n    \n    lastGeneration = generation;\n  }\n\n","sourceOld":"  private final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    ChecksumIndexOutput output = new ChecksumIndexOutput(directory.createOutput(segmentFileName));\n\n    boolean success = false;\n\n    try {\n      output.writeInt(CURRENT_FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }\n      final long checksum = output.getChecksum();\n      output.writeLong(checksum);\n      success = true;\n    } finally {\n      boolean success2 = false;\n      try {\n        output.close();\n        success2 = true;\n      } finally {\n        if (!success || !success2)\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n      }\n    }\n\n    try {\n      IndexOutput genOutput = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      try {\n        genOutput.writeInt(FORMAT_LOCKLESS);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n      }\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n    \n    lastGeneration = generation;\n  }\n\n","bugFix":["8b6187898fc4413ccd18229711786550a280383c","e82780afe6097066eb5befb86e9432f077667e3d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"455aeff4fef915340c5b19d71d5e147034e83093","date":1210099270,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    ChecksumIndexOutput output = new ChecksumIndexOutput(directory.createOutput(segmentFileName));\n\n    boolean success = false;\n\n    try {\n      output.writeInt(CURRENT_FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }\n      output.prepareCommit();\n      success = true;\n      pendingOutput = output;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        try {\n          output.close();\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    ChecksumIndexOutput output = new ChecksumIndexOutput(directory.createOutput(segmentFileName));\n\n    boolean success = false;\n\n    try {\n      output.writeInt(CURRENT_FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }\n      final long checksum = output.getChecksum();\n      output.writeLong(checksum);\n      success = true;\n    } finally {\n      boolean success2 = false;\n      try {\n        if (!success) {\n          // We hit an exception above; try to close the file\n          // but suppress any exception:\n          try {\n            output.close();\n            success2 = true;\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        } else {\n          output.close();\n          success2 = true;\n        }\n      } finally {\n        if (!success || !success2) {\n          try {\n            // Try not to leave a truncated segments_N file in\n            // the index:\n            directory.deleteFile(segmentFileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n      }\n    }\n\n    try {\n      IndexOutput genOutput = directory.createOutput(IndexFileNames.SEGMENTS_GEN);\n      try {\n        genOutput.writeInt(FORMAT_LOCKLESS);\n        genOutput.writeLong(generation);\n        genOutput.writeLong(generation);\n      } finally {\n        genOutput.close();\n      }\n    } catch (IOException e) {\n      // It's OK if we fail to write this file since it's\n      // used only as one of the retry fallbacks.\n    }\n    \n    lastGeneration = generation;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b1444275c93a8051a6fe6158639467a144ae0a4","date":1224502393,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    ChecksumIndexOutput output = new ChecksumIndexOutput(directory.createOutput(segmentFileName));\n\n    boolean success = false;\n\n    try {\n      output.writeInt(CURRENT_FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }\n      if (userData == null)\n        output.writeByte((byte) 0);\n      else {\n        output.writeByte((byte) 1);\n        output.writeString(userData);\n      }\n      output.prepareCommit();\n      success = true;\n      pendingOutput = output;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        try {\n          output.close();\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    ChecksumIndexOutput output = new ChecksumIndexOutput(directory.createOutput(segmentFileName));\n\n    boolean success = false;\n\n    try {\n      output.writeInt(CURRENT_FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }\n      output.prepareCommit();\n      success = true;\n      pendingOutput = output;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        try {\n          output.close();\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae5e4fc9fa92e2ee7a5606c11dd854d923c59cc5","date":1242273429,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    ChecksumIndexOutput segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName));\n\n    boolean success = false;\n\n    try {\n      segnOutput.writeInt(CURRENT_FORMAT); // write FORMAT\n      segnOutput.writeLong(++version); // every write changes\n                                   // the index\n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(segnOutput);\n      }\n      if (userData == null)\n        segnOutput.writeByte((byte) 0);\n      else {\n        segnOutput.writeByte((byte) 1);\n        segnOutput.writeString(userData);\n      }\n      segnOutput.prepareCommit();\n      success = true;\n      pendingSegnOutput = segnOutput;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        try {\n          segnOutput.close();\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    ChecksumIndexOutput output = new ChecksumIndexOutput(directory.createOutput(segmentFileName));\n\n    boolean success = false;\n\n    try {\n      output.writeInt(CURRENT_FORMAT); // write FORMAT\n      output.writeLong(++version); // every write changes\n                                   // the index\n      output.writeInt(counter); // write counter\n      output.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(output);\n      }\n      if (userData == null)\n        output.writeByte((byte) 0);\n      else {\n        output.writeByte((byte) 1);\n        output.writeString(userData);\n      }\n      output.prepareCommit();\n      success = true;\n      pendingOutput = output;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        try {\n          output.close();\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3ab91f3bb602daf6393fa7f78b11afd3400d669","date":1243282044,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    ChecksumIndexOutput segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName));\n\n    boolean success = false;\n\n    try {\n      segnOutput.writeInt(CURRENT_FORMAT); // write FORMAT\n      segnOutput.writeLong(++version); // every write changes\n                                   // the index\n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(segnOutput);\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.prepareCommit();\n      success = true;\n      pendingSegnOutput = segnOutput;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        try {\n          segnOutput.close();\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    ChecksumIndexOutput segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName));\n\n    boolean success = false;\n\n    try {\n      segnOutput.writeInt(CURRENT_FORMAT); // write FORMAT\n      segnOutput.writeLong(++version); // every write changes\n                                   // the index\n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(segnOutput);\n      }\n      if (userData == null)\n        segnOutput.writeByte((byte) 0);\n      else {\n        segnOutput.writeByte((byte) 1);\n        segnOutput.writeString(userData);\n      }\n      segnOutput.prepareCommit();\n      success = true;\n      pendingSegnOutput = segnOutput;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        try {\n          segnOutput.close();\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    ChecksumIndexOutput segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName));\n\n    boolean success = false;\n\n    try {\n      segnOutput.writeInt(CURRENT_FORMAT); // write FORMAT\n      segnOutput.writeLong(++version); // every write changes\n                                   // the index\n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(segnOutput);\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.prepareCommit();\n      success = true;\n      pendingSegnOutput = segnOutput;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        try {\n          segnOutput.close();\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private final void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n\n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n\n    ChecksumIndexOutput segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName));\n\n    boolean success = false;\n\n    try {\n      segnOutput.writeInt(CURRENT_FORMAT); // write FORMAT\n      segnOutput.writeLong(++version); // every write changes\n                                   // the index\n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (int i = 0; i < size(); i++) {\n        info(i).write(segnOutput);\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.prepareCommit();\n      success = true;\n      pendingSegnOutput = segnOutput;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        try {\n          segnOutput.close();\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3ead7b8e9b4934446f7a00ad0e81e3aa4d587ab6":["e82780afe6097066eb5befb86e9432f077667e3d"],"24157515079eea65faeec4e1dbb01fea58444c8e":["fd6eb8b1d71f36e7d134adc278a3d27c2559414c"],"4b1444275c93a8051a6fe6158639467a144ae0a4":["455aeff4fef915340c5b19d71d5e147034e83093"],"455aeff4fef915340c5b19d71d5e147034e83093":["3ead7b8e9b4934446f7a00ad0e81e3aa4d587ab6"],"c4ee8d31906e3001783889a491e55f218013a190":["8b6187898fc4413ccd18229711786550a280383c"],"fd6eb8b1d71f36e7d134adc278a3d27c2559414c":["dda77265180d41bf85c84c995e25eda7b8e1b74d"],"ae5e4fc9fa92e2ee7a5606c11dd854d923c59cc5":["4b1444275c93a8051a6fe6158639467a144ae0a4"],"8a5cfde941b2f8208d739344fef3821381885618":["d1bc734e51cf4404bd08aa7799a7ff025214031e"],"eeefd99c477417e5c7c574228461ebafe92469d4":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["24157515079eea65faeec4e1dbb01fea58444c8e"],"dda77265180d41bf85c84c995e25eda7b8e1b74d":["5080735f27287ee9a86441cfca7da3af146ee8d7"],"d3ab91f3bb602daf6393fa7f78b11afd3400d669":["ae5e4fc9fa92e2ee7a5606c11dd854d923c59cc5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d1bc734e51cf4404bd08aa7799a7ff025214031e":["eeefd99c477417e5c7c574228461ebafe92469d4"],"e82780afe6097066eb5befb86e9432f077667e3d":["c4ee8d31906e3001783889a491e55f218013a190"],"8b6187898fc4413ccd18229711786550a280383c":["8a5cfde941b2f8208d739344fef3821381885618"],"6c1c4d5b9a1f3631a80687ab505cbb0debfe7cc6":["c2cbfa4afac663762cc089553b02cd40096d8ac6"],"c2cbfa4afac663762cc089553b02cd40096d8ac6":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["d3ab91f3bb602daf6393fa7f78b11afd3400d669"],"5080735f27287ee9a86441cfca7da3af146ee8d7":["6c1c4d5b9a1f3631a80687ab505cbb0debfe7cc6"]},"commit2Childs":{"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["c2cbfa4afac663762cc089553b02cd40096d8ac6"],"3ead7b8e9b4934446f7a00ad0e81e3aa4d587ab6":["455aeff4fef915340c5b19d71d5e147034e83093"],"24157515079eea65faeec4e1dbb01fea58444c8e":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"4b1444275c93a8051a6fe6158639467a144ae0a4":["ae5e4fc9fa92e2ee7a5606c11dd854d923c59cc5"],"455aeff4fef915340c5b19d71d5e147034e83093":["4b1444275c93a8051a6fe6158639467a144ae0a4"],"c4ee8d31906e3001783889a491e55f218013a190":["e82780afe6097066eb5befb86e9432f077667e3d"],"fd6eb8b1d71f36e7d134adc278a3d27c2559414c":["24157515079eea65faeec4e1dbb01fea58444c8e"],"ae5e4fc9fa92e2ee7a5606c11dd854d923c59cc5":["d3ab91f3bb602daf6393fa7f78b11afd3400d669"],"8a5cfde941b2f8208d739344fef3821381885618":["8b6187898fc4413ccd18229711786550a280383c"],"eeefd99c477417e5c7c574228461ebafe92469d4":["d1bc734e51cf4404bd08aa7799a7ff025214031e"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["eeefd99c477417e5c7c574228461ebafe92469d4"],"dda77265180d41bf85c84c995e25eda7b8e1b74d":["fd6eb8b1d71f36e7d134adc278a3d27c2559414c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"d3ab91f3bb602daf6393fa7f78b11afd3400d669":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"d1bc734e51cf4404bd08aa7799a7ff025214031e":["8a5cfde941b2f8208d739344fef3821381885618"],"e82780afe6097066eb5befb86e9432f077667e3d":["3ead7b8e9b4934446f7a00ad0e81e3aa4d587ab6"],"8b6187898fc4413ccd18229711786550a280383c":["c4ee8d31906e3001783889a491e55f218013a190"],"6c1c4d5b9a1f3631a80687ab505cbb0debfe7cc6":["5080735f27287ee9a86441cfca7da3af146ee8d7"],"c2cbfa4afac663762cc089553b02cd40096d8ac6":["6c1c4d5b9a1f3631a80687ab505cbb0debfe7cc6"],"5080735f27287ee9a86441cfca7da3af146ee8d7":["dda77265180d41bf85c84c995e25eda7b8e1b74d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}