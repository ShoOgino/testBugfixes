{"path":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", StringField.TYPE_UNSTORED,\"0\");\n    Field f2 = new Field(\"f2\", StringField.TYPE_UNSTORED,\"0\");\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e4db59c6b6c10e25322cfb41c4c19d78b4298bd","date":1317197236,"type":3,"author":"Christopher John Male","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", StringField.TYPE_UNSTORED,\"0\");\n    Field f2 = new Field(\"f2\", StringField.TYPE_UNSTORED,\"0\");\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6620df8541b174097b1133a4fc370adb2e570524","date":1319544675,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader.maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3a0403b45dfe384fae4a1b6e96c3265d000c498","date":1321445981,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader.maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader.maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e7c2454a6a8237bfd0e953f5b940838408c9055","date":1323649300,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader.maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader.maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader.maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader.maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96d207426bd26fa5c1014e26d21d87603aea68b7","date":1327944562,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader.maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader.maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a78a90fc9701e511308346ea29f4f5e548bb39fe","date":1329489995,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":["8be74b6364187be2db818003ff6f492fce9a08b0","a897aed74aaf1975eb9bbaf2e11a470b285ca88b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\", \"0\", StringField.TYPE_UNSTORED);\n    Field f2 = new Field(\"f2\", \"0\", StringField.TYPE_UNSTORED);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":["7e4db59c6b6c10e25322cfb41c4c19d78b4298bd"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":["ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":["6620df8541b174097b1133a4fc370adb2e570524"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ced66195b26fdb1f77ee00e2a77ec6918dedd766","date":1344948886,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.getSequentialSubReaders().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae73da626f97850c922c42736f808d0378e165f0","date":1396625460,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.shutdown();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa71ac98a8994b246ea3366e4aa282329a55e1a3","date":1400007327,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.shutdown();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.shutdown();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.shutdown();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.shutdown();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.shutdown();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.shutdown();\n\n\n      DirectoryReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff4227bb146f97aabae888091c19e48c88dbb0db","date":1406758576,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.shutdown();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.shutdown();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cdab62f058ea765dd33deb05b4f19b7d626c801","date":1406803479,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.shutdown();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.shutdown();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"379db3ad24c4f0214f30a122265a6d6be003a99d","date":1407537768,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.shutdown();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.shutdown();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.shutdown();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(AtomicReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6","date":1424027250,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc","date":1424799790,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new FilteredQuery(new MatchAllDocsQuery(), filt), myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1db68e96dd908fcd79ef809095822736aa601d08","date":1434630596,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(new FilteredQuery(new MatchAllDocsQuery(), filt), myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          @Override\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e7bc21595222ae4f75509300fbb7726691f387f","date":1464078795,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70052d44b40be0028db94b4cffeb9aaa5468055e","date":1505151510,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":["a897aed74aaf1975eb9bbaf2e11a470b285ca88b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ffb85feece8645a035c02443a625f5af15e1106b","date":1505219692,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"685bd38810c206c93e9058f3c2cfa9827c086c27","date":1505751821,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"404d1ab7f6f396235047017c88d545fec15dafb7","date":1511975378,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, true);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, true);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, true);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, true);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, true);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, true);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04c370507e5521b2eb998530736f1c19b851ed5a","date":1531911305,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, trackScores, true);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, true);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d3f7ab1a502671bbdb03bcced21e764d2483221","date":1532329609,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, trackScores, true);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe3c6364bed04a73ad0884b05401d80ce96027a9","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, Integer.MAX_VALUE);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d77dafd89756a5161d244985903e3487ca109182","date":1548679743,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new ByteBuffersDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, Integer.MAX_VALUE);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, Integer.MAX_VALUE);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new ByteBuffersDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, Integer.MAX_VALUE);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos {}\\n\\tsortMissingFirst={} sortMissingLast={} reverse={}\\n\\tEXPECTED={}\"\n                , j, sortMissingFirst, sortMissingLast, reverse, collectedDocs\n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new ByteBuffersDirectory();\n    Field f = new StringField(\"f\", \"0\", Field.Store.NO);\n    Field f2 = new StringField(\"f2\", \"0\", Field.Store.NO);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(new SimpleAnalyzer()).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setStringValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setStringValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n      mapping.put(\"f\", UninvertingReader.Type.SORTED);\n      mapping.put(\"f2\", UninvertingReader.Type.SORTED);\n\n      DirectoryReader reader = UninvertingReader.wrap(DirectoryReader.open(dir), mapping);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(reader.leaves().size() > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {\n            return BitsFilteredDocIdSet.wrap(randSet(context.reader().maxDoc()), acceptDocs);\n          }\n          @Override\n          public String toString(String field) {\n            return \"TestSortFilter\";\n          }\n\n          @Override\n          public boolean equals(Object other) {\n            return other == this;\n          }\n          \n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }          \n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, Integer.MAX_VALUE);\n\n        final List<MyDoc> collectedDocs = new ArrayList<>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new FilterCollector(topCollector) {\n\n          @Override\n          public LeafCollector getLeafCollector(LeafReaderContext context)\n              throws IOException {\n            final int docBase = context.docBase;\n            return new FilterLeafCollector(super.getLeafCollector(context)) {\n              @Override\n              public void collect(int doc) throws IOException {\n                super.collect(doc);\n                collectedDocs.add(mydocs[docBase + doc]);\n              }\n            };\n          }\n\n        };\n\n        searcher.search(filt, myCollector);\n\n        Collections.sort(collectedDocs, (o1, o2) -> {\n          String v1 = o1.val == null ? nullRep : o1.val;\n          String v2 = o2.val == null ? nullRep : o2.val;\n          int cmp = v1.compareTo(v2);\n          if (reverse) cmp = -cmp;\n          if (cmp != 0) return cmp;\n\n          if (secondary) {\n            v1 = o1.val2 == null ? nullRep2 : o1.val2;\n            v2 = o2.val2 == null ? nullRep2 : o2.val2;\n            cmp = v1.compareTo(v2);\n            if (reverse2) cmp = -cmp;\n          }\n\n          cmp = cmp == 0 ? o1.doc - o2.doc : cmp;\n          return cmp;\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      reader.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["fe33227f6805edab2036cbb80645cc4e2d1fa424","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"96d207426bd26fa5c1014e26d21d87603aea68b7":["0e7c2454a6a8237bfd0e953f5b940838408c9055"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["7530de27b87b961b51f01bd1299b7004d46e8823"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["d77dafd89756a5161d244985903e3487ca109182"],"fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"1db68e96dd908fcd79ef809095822736aa601d08":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["1aad05eeff7818b0833c02ac6b743aa72054963b","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["a3a0403b45dfe384fae4a1b6e96c3265d000c498"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6"],"379db3ad24c4f0214f30a122265a6d6be003a99d":["5cdab62f058ea765dd33deb05b4f19b7d626c801"],"a3a0403b45dfe384fae4a1b6e96c3265d000c498":["6620df8541b174097b1133a4fc370adb2e570524"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["ae73da626f97850c922c42736f808d0378e165f0"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["c26f00b574427b55127e869b935845554afde1fa"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"d77dafd89756a5161d244985903e3487ca109182":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"3a0c04b71951333291abc7f317109a6a5957bd28":["1db68e96dd908fcd79ef809095822736aa601d08"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["04c370507e5521b2eb998530736f1c19b851ed5a"],"fa71ac98a8994b246ea3366e4aa282329a55e1a3":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"ae73da626f97850c922c42736f808d0378e165f0":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"7530de27b87b961b51f01bd1299b7004d46e8823":["ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["ced66195b26fdb1f77ee00e2a77ec6918dedd766","7530de27b87b961b51f01bd1299b7004d46e8823"],"ff4227bb146f97aabae888091c19e48c88dbb0db":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"6620df8541b174097b1133a4fc370adb2e570524":["7e4db59c6b6c10e25322cfb41c4c19d78b4298bd"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["a3a0403b45dfe384fae4a1b6e96c3265d000c498","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"04c370507e5521b2eb998530736f1c19b851ed5a":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"56572ec06f1407c066d6b7399413178b33176cd8":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","93dd449115a9247533e44bab47e8429e5dccbc6d"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["ffb85feece8645a035c02443a625f5af15e1106b","404d1ab7f6f396235047017c88d545fec15dafb7"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","ae73da626f97850c922c42736f808d0378e165f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"5cdab62f058ea765dd33deb05b4f19b7d626c801":["ff4227bb146f97aabae888091c19e48c88dbb0db"],"ced66195b26fdb1f77ee00e2a77ec6918dedd766":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"7e4db59c6b6c10e25322cfb41c4c19d78b4298bd":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"ffb85feece8645a035c02443a625f5af15e1106b":["0e7bc21595222ae4f75509300fbb7726691f387f","70052d44b40be0028db94b4cffeb9aaa5468055e"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["7530de27b87b961b51f01bd1299b7004d46e8823","19275ba31e621f6da1b83bf13af75233876fd3d4"],"404d1ab7f6f396235047017c88d545fec15dafb7":["ffb85feece8645a035c02443a625f5af15e1106b"],"70052d44b40be0028db94b4cffeb9aaa5468055e":["0e7bc21595222ae4f75509300fbb7726691f387f"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["0e7c2454a6a8237bfd0e953f5b940838408c9055","96d207426bd26fa5c1014e26d21d87603aea68b7"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3a0c04b71951333291abc7f317109a6a5957bd28","0e7bc21595222ae4f75509300fbb7726691f387f"],"685bd38810c206c93e9058f3c2cfa9827c086c27":["0e7bc21595222ae4f75509300fbb7726691f387f","ffb85feece8645a035c02443a625f5af15e1106b"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","fa71ac98a8994b246ea3366e4aa282329a55e1a3"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"0e7bc21595222ae4f75509300fbb7726691f387f":["3a0c04b71951333291abc7f317109a6a5957bd28"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["379db3ad24c4f0214f30a122265a6d6be003a99d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"96d207426bd26fa5c1014e26d21d87603aea68b7":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"1db68e96dd908fcd79ef809095822736aa601d08":["3a0c04b71951333291abc7f317109a6a5957bd28"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["96d207426bd26fa5c1014e26d21d87603aea68b7","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","5cab9a86bd67202d20b6adc463008c8e982b070a"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["1db68e96dd908fcd79ef809095822736aa601d08"],"379db3ad24c4f0214f30a122265a6d6be003a99d":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"a3a0403b45dfe384fae4a1b6e96c3265d000c498":["0e7c2454a6a8237bfd0e953f5b940838408c9055","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["fa71ac98a8994b246ea3366e4aa282329a55e1a3","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["7e4db59c6b6c10e25322cfb41c4c19d78b4298bd"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"d77dafd89756a5161d244985903e3487ca109182":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"3a0c04b71951333291abc7f317109a6a5957bd28":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0e7bc21595222ae4f75509300fbb7726691f387f"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"fa71ac98a8994b246ea3366e4aa282329a55e1a3":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"ae73da626f97850c922c42736f808d0378e165f0":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","15e323346eac5e4685c0a9f2df85eb96b4239bbb"],"7530de27b87b961b51f01bd1299b7004d46e8823":["19275ba31e621f6da1b83bf13af75233876fd3d4","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"ff4227bb146f97aabae888091c19e48c88dbb0db":["5cdab62f058ea765dd33deb05b4f19b7d626c801"],"6620df8541b174097b1133a4fc370adb2e570524":["a3a0403b45dfe384fae4a1b6e96c3265d000c498"],"c26f00b574427b55127e869b935845554afde1fa":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"04c370507e5521b2eb998530736f1c19b851ed5a":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"56572ec06f1407c066d6b7399413178b33176cd8":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["fe33227f6805edab2036cbb80645cc4e2d1fa424","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"5cdab62f058ea765dd33deb05b4f19b7d626c801":["379db3ad24c4f0214f30a122265a6d6be003a99d"],"ced66195b26fdb1f77ee00e2a77ec6918dedd766":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","7530de27b87b961b51f01bd1299b7004d46e8823","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["d77dafd89756a5161d244985903e3487ca109182"],"7e4db59c6b6c10e25322cfb41c4c19d78b4298bd":["6620df8541b174097b1133a4fc370adb2e570524"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ae73da626f97850c922c42736f808d0378e165f0","15e323346eac5e4685c0a9f2df85eb96b4239bbb"],"ffb85feece8645a035c02443a625f5af15e1106b":["1aad05eeff7818b0833c02ac6b743aa72054963b","404d1ab7f6f396235047017c88d545fec15dafb7","685bd38810c206c93e9058f3c2cfa9827c086c27"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"404d1ab7f6f396235047017c88d545fec15dafb7":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"70052d44b40be0028db94b4cffeb9aaa5468055e":["ffb85feece8645a035c02443a625f5af15e1106b"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"685bd38810c206c93e9058f3c2cfa9827c086c27":[],"93dd449115a9247533e44bab47e8429e5dccbc6d":["ff4227bb146f97aabae888091c19e48c88dbb0db","56572ec06f1407c066d6b7399413178b33176cd8"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"0e7bc21595222ae4f75509300fbb7726691f387f":["ffb85feece8645a035c02443a625f5af15e1106b","70052d44b40be0028db94b4cffeb9aaa5468055e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","685bd38810c206c93e9058f3c2cfa9827c086c27"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","04c370507e5521b2eb998530736f1c19b851ed5a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","56572ec06f1407c066d6b7399413178b33176cd8","15e323346eac5e4685c0a9f2df85eb96b4239bbb","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","685bd38810c206c93e9058f3c2cfa9827c086c27","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}