{"path":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","commits":[{"id":"069d686c3ab4d51d0d217cff30aad53b2b70ece0","date":1484748426,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","pathOld":"/dev/null","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues, true);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    assertEquals((actualMaxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(3, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(3, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"302d34f2c66e8d489ee13078305c330cbf67b226","date":1484754357,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","pathOld":"/dev/null","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues, true);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    assertEquals((actualMaxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(3, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(3, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c41b8f27c38769b3119dae57878901ba30ff6fcf","date":1484852538,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues, true);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    assertEquals((actualMaxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(numBytesPerDim, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(numBytesPerDim, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues, true);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    assertEquals((actualMaxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(3, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(3, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2a31e0fc759eb44faad7a1421dccebcfd10e391","date":1485162499,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues, true);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (StringHelper.compare(numBytesPerDim, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n            StringHelper.compare(numBytesPerDim, uniquePointValue, 0, minPackedValue, 0) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues, true);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    assertEquals((actualMaxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(numBytesPerDim, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(numBytesPerDim, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues, true);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (StringHelper.compare(numBytesPerDim, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n            StringHelper.compare(numBytesPerDim, uniquePointValue, 0, minPackedValue, 0) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues, true);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    assertEquals((actualMaxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(3, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(3, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41f60ea1802fda42d3c91d023406066d00ddb5f8","date":1535615991,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues, true);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (FutureArrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, maxPackedValue, 0, numBytesPerDim) > 0 ||\n            FutureArrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, minPackedValue, 0, numBytesPerDim) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues, true);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (StringHelper.compare(numBytesPerDim, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n            StringHelper.compare(numBytesPerDim, uniquePointValue, 0, minPackedValue, 0) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues, true);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (FutureArrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, maxPackedValue, 0, numBytesPerDim) > 0 ||\n            FutureArrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, minPackedValue, 0, numBytesPerDim) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues, true);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (FutureArrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, maxPackedValue, 0, numBytesPerDim) > 0 ||\n            FutureArrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, minPackedValue, 0, numBytesPerDim) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78bdc7d6906146edb12a1a6c1f765ba680ed5124","date":1549523533,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (FutureArrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, maxPackedValue, 0, numBytesPerDim) > 0 ||\n            FutureArrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, minPackedValue, 0, numBytesPerDim) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues, true);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (FutureArrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, maxPackedValue, 0, numBytesPerDim) > 0 ||\n            FutureArrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, minPackedValue, 0, numBytesPerDim) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, maxPackedValue, 0, numBytesPerDim) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, minPackedValue, 0, numBytesPerDim) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (FutureArrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, maxPackedValue, 0, numBytesPerDim) > 0 ||\n            FutureArrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, minPackedValue, 0, numBytesPerDim) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7","date":1588412059,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    int numLeaves = numValues / maxPointsInLeafNode;\n    if (numValues % maxPointsInLeafNode != 0) {\n      numLeaves++;\n    }\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, maxPackedValue, 0, numBytesPerDim) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, minPackedValue, 0, numBytesPerDim) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    int actualMaxPointsInLeafNode = numValues;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numValues - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, maxPackedValue, 0, numBytesPerDim) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, minPackedValue, 0, numBytesPerDim) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      Runnable finalizer = w.finish(out, out, out);\n      indexFP = out.getFilePointer();\n      finalizer.run();\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn, pointsIn, pointsIn);\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    int numLeaves = numValues / maxPointsInLeafNode;\n    if (numValues % maxPointsInLeafNode != 0) {\n      numLeaves++;\n    }\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, maxPackedValue, 0, numBytesPerDim) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, minPackedValue, 0, numBytesPerDim) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    int numLeaves = numValues / maxPointsInLeafNode;\n    if (numValues % maxPointsInLeafNode != 0) {\n      numLeaves++;\n    }\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, maxPackedValue, 0, numBytesPerDim) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, minPackedValue, 0, numBytesPerDim) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", new BKDConfig(1, 1, numBytesPerDim, maxPointsInLeafNode),\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      Runnable finalizer = w.finish(out, out, out);\n      indexFP = out.getFilePointer();\n      finalizer.run();\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn, pointsIn, pointsIn);\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    int numLeaves = numValues / maxPointsInLeafNode;\n    if (numValues % maxPointsInLeafNode != 0) {\n      numLeaves++;\n    }\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, maxPackedValue, 0, numBytesPerDim) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, minPackedValue, 0, numBytesPerDim) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(10000); // make sure to have multiple leaves\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final byte[] pointValue = new byte[numBytesPerDim];\n    final byte[] uniquePointValue = new byte[numBytesPerDim];\n    random().nextBytes(uniquePointValue);\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_temp\", 1, 1, numBytesPerDim, maxPointsInLeafNode,\n        BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, numValues);\n    for (int i = 0; i < numValues; ++i) {\n      if (i == numValues / 2) {\n        w.add(uniquePointValue, i);\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        w.add(pointValue, i);\n      }\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      Runnable finalizer = w.finish(out, out, out);\n      indexFP = out.getFilePointer();\n      finalizer.run();\n      w.close();\n    }\n    \n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn, pointsIn, pointsIn);\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    int numLeaves = numValues / maxPointsInLeafNode;\n    if (numValues % maxPointsInLeafNode != 0) {\n      numLeaves++;\n    }\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, maxPackedValue, 0, numBytesPerDim) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, numBytesPerDim, minPackedValue, 0, numBytesPerDim) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c41b8f27c38769b3119dae57878901ba30ff6fcf":["069d686c3ab4d51d0d217cff30aad53b2b70ece0"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"f6652c943595e92c187ee904c382863013eae28f":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"d2a31e0fc759eb44faad7a1421dccebcfd10e391":["c41b8f27c38769b3119dae57878901ba30ff6fcf"],"069d686c3ab4d51d0d217cff30aad53b2b70ece0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["f6652c943595e92c187ee904c382863013eae28f"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["302d34f2c66e8d489ee13078305c330cbf67b226","d2a31e0fc759eb44faad7a1421dccebcfd10e391"],"302d34f2c66e8d489ee13078305c330cbf67b226":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","069d686c3ab4d51d0d217cff30aad53b2b70ece0"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["d2a31e0fc759eb44faad7a1421dccebcfd10e391"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7"],"d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"c41b8f27c38769b3119dae57878901ba30ff6fcf":["d2a31e0fc759eb44faad7a1421dccebcfd10e391"],"069d686c3ab4d51d0d217cff30aad53b2b70ece0":["c41b8f27c38769b3119dae57878901ba30ff6fcf","302d34f2c66e8d489ee13078305c330cbf67b226"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"d2a31e0fc759eb44faad7a1421dccebcfd10e391":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","41f60ea1802fda42d3c91d023406066d00ddb5f8"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"302d34f2c66e8d489ee13078305c330cbf67b226":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["f6652c943595e92c187ee904c382863013eae28f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["069d686c3ab4d51d0d217cff30aad53b2b70ece0","302d34f2c66e8d489ee13078305c330cbf67b226"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}