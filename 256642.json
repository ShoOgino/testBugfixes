{"path":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","commits":[{"id":"5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4","date":1291128345,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean).mjava","sourceNew":"  // TODO -- i shouldn't have to specify fixed? can\n  // track itself & do the write thing at write time?\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed) throws IOException {\n\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":"  // TODO -- i shouldn't have to specify fixed? can\n  // track itself & do the write thing at write time?\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize) throws IOException {\n\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16dc5aef9648bb8fedce2ef55874f52e62c2766d","date":1293994163,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":"  // TODO -- i shouldn't have to specify fixed? can\n  // track itself & do the write thing at write time?\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed) throws IOException {\n\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e8d7ba2175f47e280231533f7d3016249cea88b","date":1307711934,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"639c36565ce03aed5b0fce7c9e4448e53a1f7efd","date":1308580104,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed)\n      throws IOException {\n    //nocommit this and all the blow need an IOContext too\n\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b7a068f550e13e49517c6899cc3b94c8eeb72e5","date":1309354772,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6f9be74ca7baaef11857ad002cad40419979516","date":1309449808,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed, IOContext context)\n      throws IOException {\n\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, context);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed)\n      throws IOException {\n    //nocommit this and all the blow need an IOContext too\n\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @param context \n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed, IOContext context)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @param context \n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed, IOContext context)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2e8d7ba2175f47e280231533f7d3016249cea88b"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","16dc5aef9648bb8fedce2ef55874f52e62c2766d"],"3b7a068f550e13e49517c6899cc3b94c8eeb72e5":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b6f9be74ca7baaef11857ad002cad40419979516":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["817d8435e9135b756f08ce6710ab0baac51bdf88","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"16dc5aef9648bb8fedce2ef55874f52e62c2766d":["5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["3b7a068f550e13e49517c6899cc3b94c8eeb72e5","b6f9be74ca7baaef11857ad002cad40419979516"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","3b7a068f550e13e49517c6899cc3b94c8eeb72e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ddc4c914be86e34b54f70023f45a60fa7f04e929"]},"commit2Childs":{"5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4":["16dc5aef9648bb8fedce2ef55874f52e62c2766d"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","3b7a068f550e13e49517c6899cc3b94c8eeb72e5","639c36565ce03aed5b0fce7c9e4448e53a1f7efd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4","a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","2e8d7ba2175f47e280231533f7d3016249cea88b"],"3b7a068f550e13e49517c6899cc3b94c8eeb72e5":["ddc4c914be86e34b54f70023f45a60fa7f04e929","817d8435e9135b756f08ce6710ab0baac51bdf88"],"b6f9be74ca7baaef11857ad002cad40419979516":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["b6f9be74ca7baaef11857ad002cad40419979516"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"16dc5aef9648bb8fedce2ef55874f52e62c2766d":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["5d004d0e0b3f65bb40da76d476d659d7888270e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}