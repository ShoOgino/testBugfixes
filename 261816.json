{"path":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetSKGEquiv#testBespoke().mjava","commits":[{"id":"c5ec3c464e62e57df598ba20e010313bf6d5d7b4","date":1589998565,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetSKGEquiv#testBespoke().mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n    { // two trivial single level facets\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"str\", new TermFacet(multiStrField(9), UNIQUE_FIELD_VALS, 0, null, null));\n      facets.put(\"int\", new TermFacet(multiIntField(9), UNIQUE_FIELD_VALS, 0, null, null));\n      assertFacetSKGsAreConsistent(facets, multiStrField(7)+\":11\", multiStrField(5)+\":9\", \"*:*\");\n    }\n    \n    { // trivial single level facet w/sorting on skg and refinement explicitly disabled\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"xxx\", new TermFacet(multiStrField(9), UNIQUE_FIELD_VALS, 0, \"skg desc\", false));\n      assertFacetSKGsAreConsistent(facets, multiStrField(7)+\":11\", multiStrField(5)+\":9\", \"*:*\");\n    }\n    \n    { // trivial single level facet w/ perSeg\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"xxx\", new TermFacet(multiStrField(9),\n                                      map(\"perSeg\", true)));\n      \n      assertFacetSKGsAreConsistent(facets, multiStrField(7)+\":11\", multiStrField(5)+\":9\", \"*:*\");\n    }\n    \n    { // trivial single level facet w/ prefix \n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"xxx\", new TermFacet(multiStrField(9),\n                                      map(\"prefix\", \"2\")));\n      \n      \n      assertFacetSKGsAreConsistent(facets, multiStrField(7)+\":11\", multiStrField(5)+\":9\", \"*:*\");\n    }\n    \n    { // trivial single level facet w/ 2 diff ways to request \"limit = (effectively) Infinite\"\n      // to sanity check refinement of buckets missing from other shard in both cases\n      \n      // NOTE that these two queries & facets *should* effectively identical given that the\n      // very large limit value is big enough no shard will ever return that may terms,\n      // but the \"limit=-1\" case it actaully triggers slightly different code paths\n      // because it causes FacetField.returnsPartial() to be \"true\"\n      for (int limit : new int[] { 999999999, -1 }) {\n        Map<String,TermFacet> facets = new LinkedHashMap<>();\n        facets.put(\"top_facet_limit__\" + limit, new TermFacet(multiStrField(9), limit, 0, \"skg desc\", true));\n        assertFacetSKGsAreConsistent(facets, multiStrField(7)+\":11\", multiStrField(5)+\":9\", \"*:*\");\n      }\n    }\n    \n    { // multi-valued facet field w/infinite limit and an extra (non-SKG) stat\n      final TermFacet xxx = new TermFacet(multiStrField(12), -1, 0, \"count asc\", false);\n      xxx.subFacets.put(\"sum\", new SumFacet(multiIntField(4)));\n      final Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"xxx\", xxx);\n      assertFacetSKGsAreConsistent(facets,\n                                   buildORQuery(multiStrField(13) + \":26\",\n                                                multiStrField(6) + \":33\",\n                                                multiStrField(9) + \":24\"),\n                                   buildORQuery(multiStrField(4) + \":27\",\n                                                multiStrField(12) + \":18\",\n                                                multiStrField(2) + \":28\",\n                                                multiStrField(13) + \":50\"),\n                                   \"*:*\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2f9e4bd10604489b5817ee29e35ac96a3148cbec","date":1594345357,"type":3,"author":"Michael Gibney","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetSKGEquiv#testBespoke().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetSKGEquiv#testBespoke().mjava","sourceNew":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n    { // two trivial single level facets\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"str\", new TermFacet(multiStrField(9), UNIQUE_FIELD_VALS, 0, null, null));\n      facets.put(\"int\", new TermFacet(multiIntField(9), UNIQUE_FIELD_VALS, 0, null, null));\n      assertFacetSKGsAreConsistent(facets, multiStrField(7)+\":11\", multiStrField(5)+\":9\", \"*:*\");\n    }\n    \n    { // trivial single level facet w/sorting on skg and refinement explicitly disabled\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"xxx\", new TermFacet(multiStrField(9), UNIQUE_FIELD_VALS, 0, \"skg desc\", false));\n      assertFacetSKGsAreConsistent(facets, multiStrField(7)+\":11\", multiStrField(5)+\":9\", \"*:*\");\n    }\n    \n    { // trivial single level facet w/ perSeg\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"xxx\", new TermFacet(multiStrField(9),\n                                      map(\"perSeg\", true)));\n      \n      assertFacetSKGsAreConsistent(facets, multiStrField(7)+\":11\", multiStrField(5)+\":9\", \"*:*\");\n    }\n    \n    { // trivial single level facet w/ prefix \n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"xxx\", new TermFacet(multiStrField(9),\n                                      map(\"prefix\", \"2\")));\n      \n      \n      assertFacetSKGsAreConsistent(facets, multiStrField(7)+\":11\", multiStrField(5)+\":9\", \"*:*\");\n    }\n    \n    { // trivial single level facet w/ 2 diff ways to request \"limit = (effectively) Infinite\"\n      // to sanity check refinement of buckets missing from other shard in both cases\n      \n      // NOTE that these two queries & facets *should* effectively identical given that the\n      // very large limit value is big enough no shard will ever return that may terms,\n      // but the \"limit=-1\" case it actaully triggers slightly different code paths\n      // because it causes FacetField.returnsPartial() to be \"true\"\n      for (int limit : new int[] { 999999999, -1 }) {\n        Map<String,TermFacet> facets = new LinkedHashMap<>();\n        facets.put(\"top_facet_limit__\" + limit, new TermFacet(multiStrField(9), limit, 0, \"skg desc\", true));\n        assertFacetSKGsAreConsistent(facets, multiStrField(7)+\":11\", multiStrField(5)+\":9\", \"*:*\");\n      }\n    }\n    \n    { // multi-valued facet field w/infinite limit and an extra (non-SKG / non-sweeping) stat\n      final TermFacet xxx = new TermFacet(multiStrField(12), -1, 0, \"count asc\", false);\n      xxx.subFacets.put(\"sum\", new SumFacet(multiIntField(4)));\n      final Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"xxx\", xxx);\n      assertFacetSKGsAreConsistent(facets,\n                                   buildORQuery(multiStrField(13) + \":26\",\n                                                multiStrField(6) + \":33\",\n                                                multiStrField(9) + \":24\"),\n                                   buildORQuery(multiStrField(4) + \":27\",\n                                                multiStrField(12) + \":18\",\n                                                multiStrField(2) + \":28\",\n                                                multiStrField(13) + \":50\"),\n                                   \"*:*\");\n    }\n  }\n\n","sourceOld":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n    { // two trivial single level facets\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"str\", new TermFacet(multiStrField(9), UNIQUE_FIELD_VALS, 0, null, null));\n      facets.put(\"int\", new TermFacet(multiIntField(9), UNIQUE_FIELD_VALS, 0, null, null));\n      assertFacetSKGsAreConsistent(facets, multiStrField(7)+\":11\", multiStrField(5)+\":9\", \"*:*\");\n    }\n    \n    { // trivial single level facet w/sorting on skg and refinement explicitly disabled\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"xxx\", new TermFacet(multiStrField(9), UNIQUE_FIELD_VALS, 0, \"skg desc\", false));\n      assertFacetSKGsAreConsistent(facets, multiStrField(7)+\":11\", multiStrField(5)+\":9\", \"*:*\");\n    }\n    \n    { // trivial single level facet w/ perSeg\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"xxx\", new TermFacet(multiStrField(9),\n                                      map(\"perSeg\", true)));\n      \n      assertFacetSKGsAreConsistent(facets, multiStrField(7)+\":11\", multiStrField(5)+\":9\", \"*:*\");\n    }\n    \n    { // trivial single level facet w/ prefix \n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"xxx\", new TermFacet(multiStrField(9),\n                                      map(\"prefix\", \"2\")));\n      \n      \n      assertFacetSKGsAreConsistent(facets, multiStrField(7)+\":11\", multiStrField(5)+\":9\", \"*:*\");\n    }\n    \n    { // trivial single level facet w/ 2 diff ways to request \"limit = (effectively) Infinite\"\n      // to sanity check refinement of buckets missing from other shard in both cases\n      \n      // NOTE that these two queries & facets *should* effectively identical given that the\n      // very large limit value is big enough no shard will ever return that may terms,\n      // but the \"limit=-1\" case it actaully triggers slightly different code paths\n      // because it causes FacetField.returnsPartial() to be \"true\"\n      for (int limit : new int[] { 999999999, -1 }) {\n        Map<String,TermFacet> facets = new LinkedHashMap<>();\n        facets.put(\"top_facet_limit__\" + limit, new TermFacet(multiStrField(9), limit, 0, \"skg desc\", true));\n        assertFacetSKGsAreConsistent(facets, multiStrField(7)+\":11\", multiStrField(5)+\":9\", \"*:*\");\n      }\n    }\n    \n    { // multi-valued facet field w/infinite limit and an extra (non-SKG) stat\n      final TermFacet xxx = new TermFacet(multiStrField(12), -1, 0, \"count asc\", false);\n      xxx.subFacets.put(\"sum\", new SumFacet(multiIntField(4)));\n      final Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"xxx\", xxx);\n      assertFacetSKGsAreConsistent(facets,\n                                   buildORQuery(multiStrField(13) + \":26\",\n                                                multiStrField(6) + \":33\",\n                                                multiStrField(9) + \":24\"),\n                                   buildORQuery(multiStrField(4) + \":27\",\n                                                multiStrField(12) + \":18\",\n                                                multiStrField(2) + \":28\",\n                                                multiStrField(13) + \":50\"),\n                                   \"*:*\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c5ec3c464e62e57df598ba20e010313bf6d5d7b4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2f9e4bd10604489b5817ee29e35ac96a3148cbec":["c5ec3c464e62e57df598ba20e010313bf6d5d7b4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2f9e4bd10604489b5817ee29e35ac96a3148cbec"]},"commit2Childs":{"c5ec3c464e62e57df598ba20e010313bf6d5d7b4":["2f9e4bd10604489b5817ee29e35ac96a3148cbec"],"2f9e4bd10604489b5817ee29e35ac96a3148cbec":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c5ec3c464e62e57df598ba20e010313bf6d5d7b4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}