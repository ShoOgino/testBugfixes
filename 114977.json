{"path":"sandbox/contributions/similarity/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","commits":[{"id":"0d57805a939f8923b86ca8202ccef1f7cf548098","date":1105995946,"type":0,"author":"David Spencer","isMerge":false,"pathNew":"sandbox/contributions/similarity/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","pathOld":"/dev/null","sourceNew":"\t/**\n     * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t *\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t *\n\t \n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucenes scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * \n\t * \n\t *\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\torg.apache.lucene.analysis.Token t;\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet already = new HashSet(); // ignore dups\n\t\twhile ( (t = ts.next()) != null)\n\t\t{\n\t\t\tString word = t.termText();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, false, false);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa8dcd4adc562c6e8da67c42872ef9194f8598fa","date":1108145465,"type":5,"author":"Erik Hatcher","isMerge":false,"pathNew":"contrib/similarity/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","pathOld":"sandbox/contributions/similarity/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","sourceNew":"\t/**\n     * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t *\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t *\n\t \n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucenes scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * \n\t * \n\t *\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\torg.apache.lucene.analysis.Token t;\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet already = new HashSet(); // ignore dups\n\t\twhile ( (t = ts.next()) != null)\n\t\t{\n\t\t\tString word = t.termText();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, false, false);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","sourceOld":"\t/**\n     * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t *\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t *\n\t \n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucenes scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * \n\t * \n\t *\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\torg.apache.lucene.analysis.Token t;\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet already = new HashSet(); // ignore dups\n\t\twhile ( (t = ts.next()) != null)\n\t\t{\n\t\t\tString word = t.termText();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, false, false);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0d57805a939f8923b86ca8202ccef1f7cf548098":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aa8dcd4adc562c6e8da67c42872ef9194f8598fa":["0d57805a939f8923b86ca8202ccef1f7cf548098"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa8dcd4adc562c6e8da67c42872ef9194f8598fa"]},"commit2Childs":{"0d57805a939f8923b86ca8202ccef1f7cf548098":["aa8dcd4adc562c6e8da67c42872ef9194f8598fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d57805a939f8923b86ca8202ccef1f7cf548098"],"aa8dcd4adc562c6e8da67c42872ef9194f8598fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}