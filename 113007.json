{"path":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","commits":[{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          SortedDocValues v = readers.get(i).getSortedDocValues(sortField.getField());\n          if (v == null) {\n            v = DocValues.emptySorted();\n          }\n          values[i] = v;\n        }\n        MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return reverseMul * (int) globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n          \n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * (int) values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Double.longBitsToDouble(values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          SortedDocValues v = readers.get(i).getSortedDocValues(sortField.getField());\n          if (v == null) {\n            v = DocValues.emptySorted();\n          }\n          values[i] = v;\n        }\n        MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return reverseMul * (int) globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n          \n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * (int) values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Double.longBitsToDouble(values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          SortedDocValues v = readers.get(i).getSortedDocValues(sortField.getField());\n          if (v == null) {\n            v = DocValues.emptySorted();\n          }\n          values[i] = v;\n        }\n        MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return reverseMul * (int) globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n          \n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * (int) values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Double.longBitsToDouble(values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e065cebbdee472a02bde38052717a8cd7ee8ab3b","date":1479244971,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","sourceNew":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n    final int reverseMul = sortField.getReverse() ? -1 : 1;\n    final SortField.Type sortType = Sorter.getSortFieldType(sortField);\n\n    switch(sortType) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          final SortedDocValues sorted = Sorter.getOrWrapSorted(readers.get(i), sortField);\n          values[i] = sorted;\n        }\n        MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = sortField.getReverse() ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        } else {\n          missingOrd = sortField.getReverse() ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return reverseMul * (int) globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * (int) values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Double.longBitsToDouble(values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","sourceOld":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          SortedDocValues v = readers.get(i).getSortedDocValues(sortField.getField());\n          if (v == null) {\n            v = DocValues.emptySorted();\n          }\n          values[i] = v;\n        }\n        MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return reverseMul * (int) globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n          \n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * (int) values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Double.longBitsToDouble(values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1ef55e1fff7ff44354432770ad8bc19be1fcc75","date":1479266056,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","sourceNew":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n    final int reverseMul = sortField.getReverse() ? -1 : 1;\n    final SortField.Type sortType = Sorter.getSortFieldType(sortField);\n\n    switch(sortType) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          final SortedDocValues sorted = Sorter.getOrWrapSorted(readers.get(i), sortField);\n          values[i] = sorted;\n        }\n        MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = sortField.getReverse() ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        } else {\n          missingOrd = sortField.getReverse() ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return reverseMul * (int) globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * (int) values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Double.longBitsToDouble(values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","sourceOld":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          SortedDocValues v = readers.get(i).getSortedDocValues(sortField.getField());\n          if (v == null) {\n            v = DocValues.emptySorted();\n          }\n          values[i] = v;\n        }\n        MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return reverseMul * (int) globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n          \n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * (int) values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Double.longBitsToDouble(values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = DocValues.getNumeric(readers.get(readerIndex), sortField.getField());\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"957c610636f393a85a38f1af670540028db13e6b","date":1500044517,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","sourceNew":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n    final int reverseMul = sortField.getReverse() ? -1 : 1;\n    final SortField.Type sortType = Sorter.getSortFieldType(sortField);\n\n    switch(sortType) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          final SortedDocValues sorted = Sorter.getOrWrapSorted(readers.get(i), sortField);\n          values[i] = sorted;\n        }\n        OrdinalMap ordinalMap = OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = sortField.getReverse() ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        } else {\n          missingOrd = sortField.getReverse() ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return reverseMul * (int) globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * (int) values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Double.longBitsToDouble(values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","sourceOld":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n    final int reverseMul = sortField.getReverse() ? -1 : 1;\n    final SortField.Type sortType = Sorter.getSortFieldType(sortField);\n\n    switch(sortType) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          final SortedDocValues sorted = Sorter.getOrWrapSorted(readers.get(i), sortField);\n          values[i] = sorted;\n        }\n        MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = sortField.getReverse() ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        } else {\n          missingOrd = sortField.getReverse() ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return reverseMul * (int) globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * (int) values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Double.longBitsToDouble(values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","sourceNew":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n    final int reverseMul = sortField.getReverse() ? -1 : 1;\n    final SortField.Type sortType = Sorter.getSortFieldType(sortField);\n\n    switch(sortType) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          final SortedDocValues sorted = Sorter.getOrWrapSorted(readers.get(i), sortField);\n          values[i] = sorted;\n        }\n        OrdinalMap ordinalMap = OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = sortField.getReverse() ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        } else {\n          missingOrd = sortField.getReverse() ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return reverseMul * (int) globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * (int) values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Double.longBitsToDouble(values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","sourceOld":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n    final int reverseMul = sortField.getReverse() ? -1 : 1;\n    final SortField.Type sortType = Sorter.getSortFieldType(sortField);\n\n    switch(sortType) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          final SortedDocValues sorted = Sorter.getOrWrapSorted(readers.get(i), sortField);\n          values[i] = sorted;\n        }\n        MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = sortField.getReverse() ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        } else {\n          missingOrd = sortField.getReverse() ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return reverseMul * (int) globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * (int) values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Double.longBitsToDouble(values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"67d866889b0c200f91ef946ae758a42d324216da","date":1544206319,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","sourceNew":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n    final SortField.Type sortType = Sorter.getSortFieldType(sortField);\n\n    switch(sortType) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          final SortedDocValues sorted = Sorter.getOrWrapSorted(readers.get(i), sortField);\n          values[i] = sorted;\n        }\n        OrdinalMap ordinalMap = OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return Math.toIntExact(globalOrds.get(readerValues.ordValue()));\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return (int) values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return Double.longBitsToDouble(values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","sourceOld":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n    final int reverseMul = sortField.getReverse() ? -1 : 1;\n    final SortField.Type sortType = Sorter.getSortFieldType(sortField);\n\n    switch(sortType) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          final SortedDocValues sorted = Sorter.getOrWrapSorted(readers.get(i), sortField);\n          values[i] = sorted;\n        }\n        OrdinalMap ordinalMap = OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = sortField.getReverse() ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        } else {\n          missingOrd = sortField.getReverse() ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return reverseMul * (int) globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * (int) values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Double.longBitsToDouble(values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66dc286cff642f0c485052d838cfba579b3f84d3","date":1544206544,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","sourceNew":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n    final int reverseMul = sortField.getReverse() ? -1 : 1;\n    final SortField.Type sortType = Sorter.getSortFieldType(sortField);\n\n    switch(sortType) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          final SortedDocValues sorted = Sorter.getOrWrapSorted(readers.get(i), sortField);\n          values[i] = sorted;\n        }\n        OrdinalMap ordinalMap = OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = sortField.getReverse() ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        } else {\n          missingOrd = sortField.getReverse() ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return reverseMul * (int) globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * (int) values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Double.longBitsToDouble(values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","sourceOld":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n    final SortField.Type sortType = Sorter.getSortFieldType(sortField);\n\n    switch(sortType) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          final SortedDocValues sorted = Sorter.getOrWrapSorted(readers.get(i), sortField);\n          values[i] = sorted;\n        }\n        OrdinalMap ordinalMap = OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return Math.toIntExact(globalOrds.get(readerValues.ordValue()));\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return (int) values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return Double.longBitsToDouble(values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76b2395079a51ec9c99b4d38c3967f035ab47cdb","date":1544206602,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","sourceNew":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n    final SortField.Type sortType = Sorter.getSortFieldType(sortField);\n\n    switch(sortType) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          final SortedDocValues sorted = Sorter.getOrWrapSorted(readers.get(i), sortField);\n          values[i] = sorted;\n        }\n        OrdinalMap ordinalMap = OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return Math.toIntExact(globalOrds.get(readerValues.ordValue()));\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return (int) values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return Double.longBitsToDouble(values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","sourceOld":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n    final int reverseMul = sortField.getReverse() ? -1 : 1;\n    final SortField.Type sortType = Sorter.getSortFieldType(sortField);\n\n    switch(sortType) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          final SortedDocValues sorted = Sorter.getOrWrapSorted(readers.get(i), sortField);\n          values[i] = sorted;\n        }\n        OrdinalMap ordinalMap = OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = sortField.getReverse() ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        } else {\n          missingOrd = sortField.getReverse() ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return reverseMul * (int) globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * (int) values.longValue();\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Double.longBitsToDouble(values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return reverseMul * Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return reverseMul * missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2458e2941e732b29b4129f7f42cf4f46e4b1f7","date":1562681927,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","sourceNew":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n    final SortField.Type sortType = Sorter.getSortFieldType(sortField);\n\n    switch(sortType) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          final SortedDocValues sorted = Sorter.getOrWrapSorted(readers.get(i), sortField);\n          values[i] = sorted;\n        }\n        OrdinalMap ordinalMap = OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              @Override\n              public long getAsComparableLong(int docID) throws IOException {\n                if (readerValues.advanceExact(docID)) {\n                  // translate segment's ord to global ord space:\n                  return globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n    case INT:\n      {\n        final long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = ((Number) sortField.getMissingValue()).longValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              @Override\n              public long getAsComparableLong(int docID) throws IOException {\n                if (values.advanceExact(docID)) {\n                  return values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              @Override\n              public long getAsComparableLong(int docID) throws IOException {\n                double value = missingValue;\n                if (values.advanceExact(docID)) {\n                  value = Double.longBitsToDouble(values.longValue());\n                }\n                return NumericUtils.doubleToSortableLong(value);\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              @Override\n              public long getAsComparableLong(int docID) throws IOException {\n                float value = missingValue;\n                if (values.advanceExact(docID)) {\n                  value = Float.intBitsToFloat((int) values.longValue());\n                }\n                return NumericUtils.floatToSortableInt(value);\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","sourceOld":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n    final SortField.Type sortType = Sorter.getSortFieldType(sortField);\n\n    switch(sortType) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          final SortedDocValues sorted = Sorter.getOrWrapSorted(readers.get(i), sortField);\n          values[i] = sorted;\n        }\n        OrdinalMap ordinalMap = OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = readerValues.docID();\n                if (readerDocID < docID) {\n                  readerDocID = readerValues.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  // translate segment's ord to global ord space:\n                  return Math.toIntExact(globalOrds.get(readerValues.ordValue()));\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n      {\n        final Long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case INT:\n      {\n        final Integer missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return (int) values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final Double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return Double.longBitsToDouble(values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final Float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              // used only by assert:\n              int lastDocID = -1;\n              private boolean docsInOrder(int docID) {\n                if (docID < lastDocID) {\n                  throw new AssertionError(\"docs must be sent in order, but lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n                }\n                lastDocID = docID;\n                return true;\n              }\n              \n              @Override\n              public Comparable getComparable(int docID) throws IOException {\n                assert docsInOrder(docID);\n                int readerDocID = values.docID();\n                if (readerDocID < docID) {\n                  readerDocID = values.advance(docID);\n                }\n                if (readerDocID == docID) {\n                  return Float.intBitsToFloat((int) values.longValue());\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"773bf150032d3ef6c95997a154fb914b82875cb8","date":1590150786,"type":4,"author":"Alan Woodward","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparableProviders(List[CodecReader],SortField).mjava","sourceNew":null,"sourceOld":"  /** Returns {@code ComparableProvider}s for the provided readers to represent the requested {@link SortField} sort order. */\n  private static ComparableProvider[] getComparableProviders(List<CodecReader> readers, SortField sortField) throws IOException {\n\n    ComparableProvider[] providers = new ComparableProvider[readers.size()];\n    final SortField.Type sortType = Sorter.getSortFieldType(sortField);\n\n    switch(sortType) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        final SortedDocValues[] values = new SortedDocValues[readers.size()];\n        for(int i=0;i<readers.size();i++) {\n          final SortedDocValues sorted = Sorter.getOrWrapSorted(readers.get(i), sortField);\n          values[i] = sorted;\n        }\n        OrdinalMap ordinalMap = OrdinalMap.build(null, values, PackedInts.DEFAULT);\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final SortedDocValues readerValues = values[readerIndex];\n          final LongValues globalOrds = ordinalMap.getGlobalOrds(readerIndex);\n          providers[readerIndex] = new ComparableProvider() {\n              @Override\n              public long getAsComparableLong(int docID) throws IOException {\n                if (readerValues.advanceExact(docID)) {\n                  // translate segment's ord to global ord space:\n                  return globalOrds.get(readerValues.ordValue());\n                } else {\n                  return missingOrd;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case LONG:\n    case INT:\n      {\n        final long missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = ((Number) sortField.getMissingValue()).longValue();\n        } else {\n          missingValue = 0L;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              @Override\n              public long getAsComparableLong(int docID) throws IOException {\n                if (values.advanceExact(docID)) {\n                  return values.longValue();\n                } else {\n                  return missingValue;\n                }\n              }\n            };\n        }\n      }\n      break;\n\n    case DOUBLE:\n      {\n        final double missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              @Override\n              public long getAsComparableLong(int docID) throws IOException {\n                double value = missingValue;\n                if (values.advanceExact(docID)) {\n                  value = Double.longBitsToDouble(values.longValue());\n                }\n                return NumericUtils.doubleToSortableLong(value);\n              }\n            };\n        }\n      }\n      break;\n\n    case FLOAT:\n      {\n        final float missingValue;\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        for(int readerIndex=0;readerIndex<readers.size();readerIndex++) {\n          final NumericDocValues values = Sorter.getOrWrapNumeric(readers.get(readerIndex), sortField);\n\n          providers[readerIndex] = new ComparableProvider() {\n              @Override\n              public long getAsComparableLong(int docID) throws IOException {\n                float value = missingValue;\n                if (values.advanceExact(docID)) {\n                  value = Float.intBitsToFloat((int) values.longValue());\n                }\n                return NumericUtils.floatToSortableInt(value);\n              }\n            };\n        }\n      }\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n\n    return providers;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"66dc286cff642f0c485052d838cfba579b3f84d3":["67d866889b0c200f91ef946ae758a42d324216da"],"957c610636f393a85a38f1af670540028db13e6b":["e065cebbdee472a02bde38052717a8cd7ee8ab3b"],"e065cebbdee472a02bde38052717a8cd7ee8ab3b":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"76b2395079a51ec9c99b4d38c3967f035ab47cdb":["66dc286cff642f0c485052d838cfba579b3f84d3"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"67d866889b0c200f91ef946ae758a42d324216da":["957c610636f393a85a38f1af670540028db13e6b"],"aa2458e2941e732b29b4129f7f42cf4f46e4b1f7":["76b2395079a51ec9c99b4d38c3967f035ab47cdb"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["e065cebbdee472a02bde38052717a8cd7ee8ab3b","957c610636f393a85a38f1af670540028db13e6b"],"773bf150032d3ef6c95997a154fb914b82875cb8":["aa2458e2941e732b29b4129f7f42cf4f46e4b1f7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a1ef55e1fff7ff44354432770ad8bc19be1fcc75":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e065cebbdee472a02bde38052717a8cd7ee8ab3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["773bf150032d3ef6c95997a154fb914b82875cb8"]},"commit2Childs":{"66dc286cff642f0c485052d838cfba579b3f84d3":["76b2395079a51ec9c99b4d38c3967f035ab47cdb"],"957c610636f393a85a38f1af670540028db13e6b":["67d866889b0c200f91ef946ae758a42d324216da","aaf90fc29510e72665ac7934f34c3d1c25efad64"],"e065cebbdee472a02bde38052717a8cd7ee8ab3b":["957c610636f393a85a38f1af670540028db13e6b","aaf90fc29510e72665ac7934f34c3d1c25efad64","a1ef55e1fff7ff44354432770ad8bc19be1fcc75"],"76b2395079a51ec9c99b4d38c3967f035ab47cdb":["aa2458e2941e732b29b4129f7f42cf4f46e4b1f7"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a1ef55e1fff7ff44354432770ad8bc19be1fcc75"],"67d866889b0c200f91ef946ae758a42d324216da":["66dc286cff642f0c485052d838cfba579b3f84d3"],"aa2458e2941e732b29b4129f7f42cf4f46e4b1f7":["773bf150032d3ef6c95997a154fb914b82875cb8"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["e065cebbdee472a02bde38052717a8cd7ee8ab3b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"773bf150032d3ef6c95997a154fb914b82875cb8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a1ef55e1fff7ff44354432770ad8bc19be1fcc75":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aaf90fc29510e72665ac7934f34c3d1c25efad64","a1ef55e1fff7ff44354432770ad8bc19be1fcc75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}