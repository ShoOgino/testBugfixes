{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,CloudConfig,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","commits":[{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,CloudConfig,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","sourceNew":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException, KeeperException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            CollectionAdminParams.SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, cloudConfig, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!skipCreateReplicaInClusterState) {\n      ZkNodeProps props = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n          ZkStateReader.COLLECTION_PROP, collectionName,\n          ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n          ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n          ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n          ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n          ZkStateReader.NODE_NAME_PROP, createReplica.node,\n          ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n      if (createReplica.coreNodeName != null) {\n        props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n      }\n      try {\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n      }\n    }\n    params.set(CoreAdminParams.CORE_NODE_NAME,\n        ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","sourceOld":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException, KeeperException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            CollectionAdminParams.SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!skipCreateReplicaInClusterState) {\n      ZkNodeProps props = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n          ZkStateReader.COLLECTION_PROP, collectionName,\n          ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n          ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n          ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n          ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n          ZkStateReader.NODE_NAME_PROP, createReplica.node,\n          ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n      if (createReplica.coreNodeName != null) {\n        props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n      }\n      try {\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n      }\n    }\n    params.set(CoreAdminParams.CORE_NODE_NAME,\n        ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,CloudConfig,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","sourceNew":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException, KeeperException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            CollectionAdminParams.SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!skipCreateReplicaInClusterState) {\n      ZkNodeProps props = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n          ZkStateReader.COLLECTION_PROP, collectionName,\n          ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n          ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n          ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n          ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n          ZkStateReader.NODE_NAME_PROP, createReplica.node,\n          ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n      if (createReplica.coreNodeName != null) {\n        props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n      }\n      try {\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n      }\n    }\n    params.set(CoreAdminParams.CORE_NODE_NAME,\n        ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","sourceOld":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException, KeeperException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            CollectionAdminParams.SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, cloudConfig, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!skipCreateReplicaInClusterState) {\n      ZkNodeProps props = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n          ZkStateReader.COLLECTION_PROP, collectionName,\n          ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n          ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n          ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n          ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n          ZkStateReader.NODE_NAME_PROP, createReplica.node,\n          ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n      if (createReplica.coreNodeName != null) {\n        props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n      }\n      try {\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n      }\n    }\n    params.set(CoreAdminParams.CORE_NODE_NAME,\n        ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"c526352db87264a72a7a9ad68c1b769b81e54305":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c526352db87264a72a7a9ad68c1b769b81e54305"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}