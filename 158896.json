{"path":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","commits":[{"id":"f18d4e1cdc7330101ca433af5e8564dfd894f2bf","date":1379041877,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","pathOld":"/dev/null","sourceNew":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        JavascriptFunction method = JavascriptFunction.getMethod(call, arguments);\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        methodVisitor.visitMethodInsn(INVOKESTATIC, method.klass, method.method, method.signature);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsList.size();\n          externalsList.add(text);\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        \n        switch (index) {\n          case 0:\n            methodVisitor.visitInsn(ICONST_0);\n            break;\n          case 1:\n            methodVisitor.visitInsn(ICONST_1);\n            break;\n          case 2:\n            methodVisitor.visitInsn(ICONST_2);\n            break;\n          case 3:\n            methodVisitor.visitInsn(ICONST_3);\n            break;\n          case 4:\n            methodVisitor.visitInsn(ICONST_4);\n            break;\n          case 5:\n            methodVisitor.visitInsn(ICONST_5);\n            break;\n          default:\n            if (index < 128) {\n              methodVisitor.visitIntInsn(BIPUSH, index);\n            } else if (index < 16384) {\n              methodVisitor.visitIntInsn(SIPUSH, index);\n            } else {\n              methodVisitor.visitLdcInsn(index);\n            }\n            \n            break;\n        }\n        \n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, FUNCTION_VALUES_INTERNAL, \"doubleVal\", \"(I)D\");\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        \n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        \n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        \n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        \n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        \n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        \n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        \n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0661274bae2ed2e5f007817e91d19791dfc7f9c4","date":1379067699,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","sourceNew":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        JavascriptFunction method = JavascriptFunction.getMethod(call, arguments);\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        methodVisitor.visitMethodInsn(INVOKESTATIC, method.klass, method.method, method.signature);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsList.size();\n          externalsList.add(text);\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        \n        switch (index) {\n          case 0:\n            methodVisitor.visitInsn(ICONST_0);\n            break;\n          case 1:\n            methodVisitor.visitInsn(ICONST_1);\n            break;\n          case 2:\n            methodVisitor.visitInsn(ICONST_2);\n            break;\n          case 3:\n            methodVisitor.visitInsn(ICONST_3);\n            break;\n          case 4:\n            methodVisitor.visitInsn(ICONST_4);\n            break;\n          case 5:\n            methodVisitor.visitInsn(ICONST_5);\n            break;\n          default:\n            if (index < 128) {\n              methodVisitor.visitIntInsn(BIPUSH, index);\n            } else if (index < 16384) {\n              methodVisitor.visitIntInsn(SIPUSH, index);\n            } else {\n              methodVisitor.visitLdcInsn(index);\n            }\n            \n            break;\n        }\n        \n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, FUNCTION_VALUES_TYPE.getInternalName(), \"doubleVal\", DOUBLE_VAL_METHOD_DESC);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        \n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        \n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        \n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        \n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        \n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        \n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        \n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        JavascriptFunction method = JavascriptFunction.getMethod(call, arguments);\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        methodVisitor.visitMethodInsn(INVOKESTATIC, method.klass, method.method, method.signature);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsList.size();\n          externalsList.add(text);\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        \n        switch (index) {\n          case 0:\n            methodVisitor.visitInsn(ICONST_0);\n            break;\n          case 1:\n            methodVisitor.visitInsn(ICONST_1);\n            break;\n          case 2:\n            methodVisitor.visitInsn(ICONST_2);\n            break;\n          case 3:\n            methodVisitor.visitInsn(ICONST_3);\n            break;\n          case 4:\n            methodVisitor.visitInsn(ICONST_4);\n            break;\n          case 5:\n            methodVisitor.visitInsn(ICONST_5);\n            break;\n          default:\n            if (index < 128) {\n              methodVisitor.visitIntInsn(BIPUSH, index);\n            } else if (index < 16384) {\n              methodVisitor.visitIntInsn(SIPUSH, index);\n            } else {\n              methodVisitor.visitLdcInsn(index);\n            }\n            \n            break;\n        }\n        \n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, FUNCTION_VALUES_INTERNAL, \"doubleVal\", \"(I)D\");\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        \n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        \n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        \n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        \n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        \n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        \n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        \n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec67ff97c3c57929891e4aa3bfba1094ef497d68","date":1379085761,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","sourceNew":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        JavascriptFunction method = JavascriptFunction.getMethod(call, arguments);\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        methodVisitor.visitMethodInsn(INVOKESTATIC, method.klass, method.method, method.signature);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        \n        switch (index) {\n          case 0:\n            methodVisitor.visitInsn(ICONST_0);\n            break;\n          case 1:\n            methodVisitor.visitInsn(ICONST_1);\n            break;\n          case 2:\n            methodVisitor.visitInsn(ICONST_2);\n            break;\n          case 3:\n            methodVisitor.visitInsn(ICONST_3);\n            break;\n          case 4:\n            methodVisitor.visitInsn(ICONST_4);\n            break;\n          case 5:\n            methodVisitor.visitInsn(ICONST_5);\n            break;\n          default:\n            if (index < 128) {\n              methodVisitor.visitIntInsn(BIPUSH, index);\n            } else if (index < 16384) {\n              methodVisitor.visitIntInsn(SIPUSH, index);\n            } else {\n              methodVisitor.visitLdcInsn(index);\n            }\n            \n            break;\n        }\n        \n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, FUNCTION_VALUES_TYPE.getInternalName(), \"doubleVal\", DOUBLE_VAL_METHOD_DESC);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        \n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        \n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        \n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        \n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        \n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        \n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        \n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        JavascriptFunction method = JavascriptFunction.getMethod(call, arguments);\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        methodVisitor.visitMethodInsn(INVOKESTATIC, method.klass, method.method, method.signature);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsList.size();\n          externalsList.add(text);\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        \n        switch (index) {\n          case 0:\n            methodVisitor.visitInsn(ICONST_0);\n            break;\n          case 1:\n            methodVisitor.visitInsn(ICONST_1);\n            break;\n          case 2:\n            methodVisitor.visitInsn(ICONST_2);\n            break;\n          case 3:\n            methodVisitor.visitInsn(ICONST_3);\n            break;\n          case 4:\n            methodVisitor.visitInsn(ICONST_4);\n            break;\n          case 5:\n            methodVisitor.visitInsn(ICONST_5);\n            break;\n          default:\n            if (index < 128) {\n              methodVisitor.visitIntInsn(BIPUSH, index);\n            } else if (index < 16384) {\n              methodVisitor.visitIntInsn(SIPUSH, index);\n            } else {\n              methodVisitor.visitLdcInsn(index);\n            }\n            \n            break;\n        }\n        \n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, FUNCTION_VALUES_TYPE.getInternalName(), \"doubleVal\", DOUBLE_VAL_METHOD_DESC);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        \n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        \n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        \n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        \n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        \n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        \n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        \n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f38d01d46ec13a9d72d6e3c8dabc8bd9f54c3dd2","date":1379091773,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","sourceNew":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        JavascriptFunction method = JavascriptFunction.getMethod(call, arguments);\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        methodVisitor.visitMethodInsn(INVOKESTATIC, method.klass, method.method, method.signature);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        \n        switch (index) {\n          case 0:\n            methodVisitor.visitInsn(ICONST_0);\n            break;\n          case 1:\n            methodVisitor.visitInsn(ICONST_1);\n            break;\n          case 2:\n            methodVisitor.visitInsn(ICONST_2);\n            break;\n          case 3:\n            methodVisitor.visitInsn(ICONST_3);\n            break;\n          case 4:\n            methodVisitor.visitInsn(ICONST_4);\n            break;\n          case 5:\n            methodVisitor.visitInsn(ICONST_5);\n            break;\n          default:\n            if (index < 128) {\n              methodVisitor.visitIntInsn(BIPUSH, index);\n            } else if (index < 16384) {\n              methodVisitor.visitIntInsn(SIPUSH, index);\n            } else {\n              methodVisitor.visitLdcInsn(index);\n            }\n            \n            break;\n        }\n        \n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, FUNCTION_VALUES_TYPE.getInternalName(), \"doubleVal\", DOUBLE_VAL_METHOD_DESC);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        JavascriptFunction method = JavascriptFunction.getMethod(call, arguments);\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        methodVisitor.visitMethodInsn(INVOKESTATIC, method.klass, method.method, method.signature);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        \n        switch (index) {\n          case 0:\n            methodVisitor.visitInsn(ICONST_0);\n            break;\n          case 1:\n            methodVisitor.visitInsn(ICONST_1);\n            break;\n          case 2:\n            methodVisitor.visitInsn(ICONST_2);\n            break;\n          case 3:\n            methodVisitor.visitInsn(ICONST_3);\n            break;\n          case 4:\n            methodVisitor.visitInsn(ICONST_4);\n            break;\n          case 5:\n            methodVisitor.visitInsn(ICONST_5);\n            break;\n          default:\n            if (index < 128) {\n              methodVisitor.visitIntInsn(BIPUSH, index);\n            } else if (index < 16384) {\n              methodVisitor.visitIntInsn(SIPUSH, index);\n            } else {\n              methodVisitor.visitLdcInsn(index);\n            }\n            \n            break;\n        }\n        \n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, FUNCTION_VALUES_TYPE.getInternalName(), \"doubleVal\", DOUBLE_VAL_METHOD_DESC);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        \n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        \n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        \n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        \n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        \n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        \n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        \n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        \n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"389085f24478bf7aa178002b4e4907aeda9bc56f","date":1379108316,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","sourceNew":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        JavascriptFunction method = JavascriptFunction.getMethod(call, arguments);\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        methodVisitor.visitMethodInsn(INVOKESTATIC, method.klass, method.method, method.descriptor);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        \n        switch (index) {\n          case 0:\n            methodVisitor.visitInsn(ICONST_0);\n            break;\n          case 1:\n            methodVisitor.visitInsn(ICONST_1);\n            break;\n          case 2:\n            methodVisitor.visitInsn(ICONST_2);\n            break;\n          case 3:\n            methodVisitor.visitInsn(ICONST_3);\n            break;\n          case 4:\n            methodVisitor.visitInsn(ICONST_4);\n            break;\n          case 5:\n            methodVisitor.visitInsn(ICONST_5);\n            break;\n          default:\n            if (index < 128) {\n              methodVisitor.visitIntInsn(BIPUSH, index);\n            } else if (index < 16384) {\n              methodVisitor.visitIntInsn(SIPUSH, index);\n            } else {\n              methodVisitor.visitLdcInsn(index);\n            }\n            \n            break;\n        }\n        \n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, FUNCTION_VALUES_TYPE.getInternalName(), \"doubleVal\", DOUBLE_VAL_METHOD_DESC);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        JavascriptFunction method = JavascriptFunction.getMethod(call, arguments);\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        methodVisitor.visitMethodInsn(INVOKESTATIC, method.klass, method.method, method.signature);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        \n        switch (index) {\n          case 0:\n            methodVisitor.visitInsn(ICONST_0);\n            break;\n          case 1:\n            methodVisitor.visitInsn(ICONST_1);\n            break;\n          case 2:\n            methodVisitor.visitInsn(ICONST_2);\n            break;\n          case 3:\n            methodVisitor.visitInsn(ICONST_3);\n            break;\n          case 4:\n            methodVisitor.visitInsn(ICONST_4);\n            break;\n          case 5:\n            methodVisitor.visitInsn(ICONST_5);\n            break;\n          default:\n            if (index < 128) {\n              methodVisitor.visitIntInsn(BIPUSH, index);\n            } else if (index < 16384) {\n              methodVisitor.visitIntInsn(SIPUSH, index);\n            } else {\n              methodVisitor.visitLdcInsn(index);\n            }\n            \n            break;\n        }\n        \n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, FUNCTION_VALUES_TYPE.getInternalName(), \"doubleVal\", DOUBLE_VAL_METHOD_DESC);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db39d89549f02471cd1655286175cdb23de346b","date":1379183393,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","sourceNew":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity && arity != -1) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        String klass = Type.getInternalName(method.getDeclaringClass());\n        String name = method.getName();\n        String descriptor = Type.getMethodDescriptor(method);\n        methodVisitor.visitMethodInsn(INVOKESTATIC, klass, name, descriptor);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        \n        switch (index) {\n          case 0:\n            methodVisitor.visitInsn(ICONST_0);\n            break;\n          case 1:\n            methodVisitor.visitInsn(ICONST_1);\n            break;\n          case 2:\n            methodVisitor.visitInsn(ICONST_2);\n            break;\n          case 3:\n            methodVisitor.visitInsn(ICONST_3);\n            break;\n          case 4:\n            methodVisitor.visitInsn(ICONST_4);\n            break;\n          case 5:\n            methodVisitor.visitInsn(ICONST_5);\n            break;\n          default:\n            if (index < 128) {\n              methodVisitor.visitIntInsn(BIPUSH, index);\n            } else if (index < 16384) {\n              methodVisitor.visitIntInsn(SIPUSH, index);\n            } else {\n              methodVisitor.visitLdcInsn(index);\n            }\n            \n            break;\n        }\n        \n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, FUNCTION_VALUES_TYPE.getInternalName(), \"doubleVal\", DOUBLE_VAL_METHOD_DESC);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        JavascriptFunction method = JavascriptFunction.getMethod(call, arguments);\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        methodVisitor.visitMethodInsn(INVOKESTATIC, method.klass, method.method, method.descriptor);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        \n        switch (index) {\n          case 0:\n            methodVisitor.visitInsn(ICONST_0);\n            break;\n          case 1:\n            methodVisitor.visitInsn(ICONST_1);\n            break;\n          case 2:\n            methodVisitor.visitInsn(ICONST_2);\n            break;\n          case 3:\n            methodVisitor.visitInsn(ICONST_3);\n            break;\n          case 4:\n            methodVisitor.visitInsn(ICONST_4);\n            break;\n          case 5:\n            methodVisitor.visitInsn(ICONST_5);\n            break;\n          default:\n            if (index < 128) {\n              methodVisitor.visitIntInsn(BIPUSH, index);\n            } else if (index < 16384) {\n              methodVisitor.visitIntInsn(SIPUSH, index);\n            } else {\n              methodVisitor.visitLdcInsn(index);\n            }\n            \n            break;\n        }\n        \n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, FUNCTION_VALUES_TYPE.getInternalName(), \"doubleVal\", DOUBLE_VAL_METHOD_DESC);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bebe57114573283e7d95baf0705274e4ed445048","date":1379192623,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","sourceNew":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        String klass = Type.getInternalName(method.getDeclaringClass());\n        String name = method.getName();\n        String descriptor = Type.getMethodDescriptor(method);\n        methodVisitor.visitMethodInsn(INVOKESTATIC, klass, name, descriptor);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        \n        switch (index) {\n          case 0:\n            methodVisitor.visitInsn(ICONST_0);\n            break;\n          case 1:\n            methodVisitor.visitInsn(ICONST_1);\n            break;\n          case 2:\n            methodVisitor.visitInsn(ICONST_2);\n            break;\n          case 3:\n            methodVisitor.visitInsn(ICONST_3);\n            break;\n          case 4:\n            methodVisitor.visitInsn(ICONST_4);\n            break;\n          case 5:\n            methodVisitor.visitInsn(ICONST_5);\n            break;\n          default:\n            if (index < 128) {\n              methodVisitor.visitIntInsn(BIPUSH, index);\n            } else if (index < 16384) {\n              methodVisitor.visitIntInsn(SIPUSH, index);\n            } else {\n              methodVisitor.visitLdcInsn(index);\n            }\n            break;\n        }\n        \n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, FUNCTION_VALUES_TYPE.getInternalName(), \"doubleVal\", DOUBLE_VAL_METHOD_DESC);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity && arity != -1) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        String klass = Type.getInternalName(method.getDeclaringClass());\n        String name = method.getName();\n        String descriptor = Type.getMethodDescriptor(method);\n        methodVisitor.visitMethodInsn(INVOKESTATIC, klass, name, descriptor);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        \n        switch (index) {\n          case 0:\n            methodVisitor.visitInsn(ICONST_0);\n            break;\n          case 1:\n            methodVisitor.visitInsn(ICONST_1);\n            break;\n          case 2:\n            methodVisitor.visitInsn(ICONST_2);\n            break;\n          case 3:\n            methodVisitor.visitInsn(ICONST_3);\n            break;\n          case 4:\n            methodVisitor.visitInsn(ICONST_4);\n            break;\n          case 5:\n            methodVisitor.visitInsn(ICONST_5);\n            break;\n          default:\n            if (index < 128) {\n              methodVisitor.visitIntInsn(BIPUSH, index);\n            } else if (index < 16384) {\n              methodVisitor.visitIntInsn(SIPUSH, index);\n            } else {\n              methodVisitor.visitLdcInsn(index);\n            }\n            \n            break;\n        }\n        \n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, FUNCTION_VALUES_TYPE.getInternalName(), \"doubleVal\", DOUBLE_VAL_METHOD_DESC);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec14abb95dd61220ff7c6288edd61b69e5db80f9","date":1379197290,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","sourceNew":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        methodVisitor.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        methodVisitor.push(index);\n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        String klass = Type.getInternalName(method.getDeclaringClass());\n        String name = method.getName();\n        String descriptor = Type.getMethodDescriptor(method);\n        methodVisitor.visitMethodInsn(INVOKESTATIC, klass, name, descriptor);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        \n        switch (index) {\n          case 0:\n            methodVisitor.visitInsn(ICONST_0);\n            break;\n          case 1:\n            methodVisitor.visitInsn(ICONST_1);\n            break;\n          case 2:\n            methodVisitor.visitInsn(ICONST_2);\n            break;\n          case 3:\n            methodVisitor.visitInsn(ICONST_3);\n            break;\n          case 4:\n            methodVisitor.visitInsn(ICONST_4);\n            break;\n          case 5:\n            methodVisitor.visitInsn(ICONST_5);\n            break;\n          default:\n            if (index < 128) {\n              methodVisitor.visitIntInsn(BIPUSH, index);\n            } else if (index < 16384) {\n              methodVisitor.visitIntInsn(SIPUSH, index);\n            } else {\n              methodVisitor.visitLdcInsn(index);\n            }\n            break;\n        }\n        \n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, FUNCTION_VALUES_TYPE.getInternalName(), \"doubleVal\", DOUBLE_VAL_METHOD_DESC);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b89f9365dec76fdc0fc53acb3664f3502497a07","date":1379201945,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","sourceNew":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        methodVisitor.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.loadArg(1);\n        methodVisitor.push(index);\n        methodVisitor.arrayLoad(FUNCTION_VALUES_TYPE);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        \n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == Type.INT_TYPE) {\n          methodVisitor.push((int)hex);\n        } else if (expected == Type.LONG_TYPE) {\n          methodVisitor.push(hex);\n        } else {\n          methodVisitor.push((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == Type.INT_TYPE) {\n          methodVisitor.push((int)octal);\n        } else if (expected == Type.LONG_TYPE) {\n          methodVisitor.push(octal);\n        } else {\n          methodVisitor.push((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.push(decimal);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DNEG);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DADD);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DSUB);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DDIV);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DREM);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LSHL);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LSHR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LUSHR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LAND);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LXOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        methodVisitor.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        methodVisitor.push(index);\n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"389085f24478bf7aa178002b4e4907aeda9bc56f":["f38d01d46ec13a9d72d6e3c8dabc8bd9f54c3dd2"],"f18d4e1cdc7330101ca433af5e8564dfd894f2bf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ec14abb95dd61220ff7c6288edd61b69e5db80f9":["bebe57114573283e7d95baf0705274e4ed445048"],"f38d01d46ec13a9d72d6e3c8dabc8bd9f54c3dd2":["ec67ff97c3c57929891e4aa3bfba1094ef497d68"],"0661274bae2ed2e5f007817e91d19791dfc7f9c4":["f18d4e1cdc7330101ca433af5e8564dfd894f2bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bebe57114573283e7d95baf0705274e4ed445048":["0db39d89549f02471cd1655286175cdb23de346b"],"ec67ff97c3c57929891e4aa3bfba1094ef497d68":["0661274bae2ed2e5f007817e91d19791dfc7f9c4"],"3b89f9365dec76fdc0fc53acb3664f3502497a07":["ec14abb95dd61220ff7c6288edd61b69e5db80f9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0db39d89549f02471cd1655286175cdb23de346b":["389085f24478bf7aa178002b4e4907aeda9bc56f"]},"commit2Childs":{"389085f24478bf7aa178002b4e4907aeda9bc56f":["0db39d89549f02471cd1655286175cdb23de346b"],"f18d4e1cdc7330101ca433af5e8564dfd894f2bf":["0661274bae2ed2e5f007817e91d19791dfc7f9c4"],"f38d01d46ec13a9d72d6e3c8dabc8bd9f54c3dd2":["389085f24478bf7aa178002b4e4907aeda9bc56f"],"ec14abb95dd61220ff7c6288edd61b69e5db80f9":["3b89f9365dec76fdc0fc53acb3664f3502497a07"],"0661274bae2ed2e5f007817e91d19791dfc7f9c4":["ec67ff97c3c57929891e4aa3bfba1094ef497d68"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f18d4e1cdc7330101ca433af5e8564dfd894f2bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bebe57114573283e7d95baf0705274e4ed445048":["ec14abb95dd61220ff7c6288edd61b69e5db80f9"],"ec67ff97c3c57929891e4aa3bfba1094ef497d68":["f38d01d46ec13a9d72d6e3c8dabc8bd9f54c3dd2"],"3b89f9365dec76fdc0fc53acb3664f3502497a07":[],"0db39d89549f02471cd1655286175cdb23de346b":["bebe57114573283e7d95baf0705274e4ed445048"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3b89f9365dec76fdc0fc53acb3664f3502497a07","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}