{"path":"solr/core/src/test/org/apache/solr/cloud/ZkSolrClientTest#testMultipleWatchesAsync().mjava","commits":[{"id":"8650ae4e5d74a324411f8b7dd6201774f2b6fb2e","date":1406603075,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ZkSolrClientTest#testMultipleWatchesAsync().mjava","pathOld":"/dev/null","sourceNew":"  public void testMultipleWatchesAsync() throws Exception {\n    try (ZkConnection conn = new ZkConnection ()) {\n      final SolrZkClient zkClient = conn.getClient();\n      zkClient.makePath(\"/collections\", true);\n\n      final int numColls = random().nextInt(100);\n      final CountDownLatch latch = new CountDownLatch(numColls);\n\n      for (int i = 1; i <= numColls; i ++) {\n        String collPath = \"/collections/collection\" + i;\n        zkClient.makePath(collPath, true);\n        zkClient.getChildren(collPath, new Watcher() {\n          @Override\n          public void process(WatchedEvent event) {\n            latch.countDown();\n            try {\n              Thread.sleep(1000);\n            }\n            catch (InterruptedException e) {}\n          }\n        }, true);\n      }\n\n      for (int i = 1; i <= numColls; i ++) {\n        String shardsPath = \"/collections/collection\" + i + \"/shards\";\n        zkClient.makePath(shardsPath, true);\n      }\n\n      assertTrue(latch.await(1000, TimeUnit.MILLISECONDS));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["335a420352f1e2c71baac3a1dad95f40cf415da8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ff5e25fb60ccc8574bcbd65396786ae9163f0149","date":1519706112,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ZkSolrClientTest#testMultipleWatchesAsync().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ZkSolrClientTest#testMultipleWatchesAsync().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testMultipleWatchesAsync() throws Exception {\n    try (ZkConnection conn = new ZkConnection ()) {\n      final SolrZkClient zkClient = conn.getClient();\n      zkClient.makePath(\"/collections\", true);\n\n      final int numColls = random().nextInt(100);\n      final CountDownLatch latch = new CountDownLatch(numColls);\n\n      for (int i = 1; i <= numColls; i ++) {\n        String collPath = \"/collections/collection\" + i;\n        zkClient.makePath(collPath, true);\n        zkClient.getChildren(collPath, new Watcher() {\n          @Override\n          public void process(WatchedEvent event) {\n            latch.countDown();\n            try {\n              Thread.sleep(1000);\n            }\n            catch (InterruptedException e) {}\n          }\n        }, true);\n      }\n\n      for (int i = 1; i <= numColls; i ++) {\n        String shardsPath = \"/collections/collection\" + i + \"/shards\";\n        zkClient.makePath(shardsPath, true);\n      }\n\n      assertTrue(latch.await(1000, TimeUnit.MILLISECONDS));\n    }\n  }\n\n","sourceOld":"  public void testMultipleWatchesAsync() throws Exception {\n    try (ZkConnection conn = new ZkConnection ()) {\n      final SolrZkClient zkClient = conn.getClient();\n      zkClient.makePath(\"/collections\", true);\n\n      final int numColls = random().nextInt(100);\n      final CountDownLatch latch = new CountDownLatch(numColls);\n\n      for (int i = 1; i <= numColls; i ++) {\n        String collPath = \"/collections/collection\" + i;\n        zkClient.makePath(collPath, true);\n        zkClient.getChildren(collPath, new Watcher() {\n          @Override\n          public void process(WatchedEvent event) {\n            latch.countDown();\n            try {\n              Thread.sleep(1000);\n            }\n            catch (InterruptedException e) {}\n          }\n        }, true);\n      }\n\n      for (int i = 1; i <= numColls; i ++) {\n        String shardsPath = \"/collections/collection\" + i + \"/shards\";\n        zkClient.makePath(shardsPath, true);\n      }\n\n      assertTrue(latch.await(1000, TimeUnit.MILLISECONDS));\n    }\n  }\n\n","bugFix":null,"bugIntro":["335a420352f1e2c71baac3a1dad95f40cf415da8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"335a420352f1e2c71baac3a1dad95f40cf415da8","date":1522207262,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ZkSolrClientTest#testMultipleWatchesAsync().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ZkSolrClientTest#testMultipleWatchesAsync().mjava","sourceNew":"  @Test\n  public void testMultipleWatchesAsync() throws Exception {\n    try (ZkConnection conn = new ZkConnection()) {\n      final SolrZkClient zkClient = conn.getClient();\n      zkClient.makePath(\"/collections\", true);\n\n      final int numColls = random().nextInt(100);\n      final CountDownLatch latch = new CountDownLatch(numColls);\n      final CountDownLatch watchesDone = new CountDownLatch(numColls);\n      final Set<String> collectionsInProgress = new HashSet<>(numColls);\n      AtomicInteger maxCollectionsInProgress = new AtomicInteger();\n\n      for (int i = 1; i <= numColls; i ++) {\n        String collPath = \"/collections/collection\" + i;\n        zkClient.makePath(collPath, true);\n        zkClient.getChildren(collPath, new Watcher() {\n          @Override\n          public void process(WatchedEvent event) {\n            synchronized (collectionsInProgress) {\n              collectionsInProgress.add(event.getPath()); // Will be something like /collections/collection##\n              maxCollectionsInProgress.set(Math.max(maxCollectionsInProgress.get(), collectionsInProgress.size()));\n            }\n            latch.countDown();\n            try {\n              latch.await(10000, TimeUnit.MILLISECONDS);\n            }\n            catch (InterruptedException e) {}\n            synchronized (collectionsInProgress) {\n              collectionsInProgress.remove(event.getPath());\n            }\n            watchesDone.countDown();\n          }\n        }, true);\n      }\n\n      for (int i = 1; i <= numColls; i ++) {\n        String shardsPath = \"/collections/collection\" + i + \"/shards\";\n        zkClient.makePath(shardsPath, true);\n      }\n\n      assertTrue(latch.await(10000, TimeUnit.MILLISECONDS));\n      assertEquals(\"All collections should have been processed in parallel\", numColls, maxCollectionsInProgress.get());\n      \n      // just as sanity check for the test:\n      assertTrue(watchesDone.await(10000, TimeUnit.MILLISECONDS));\n      synchronized (collectionsInProgress) {\n        assertEquals(0, collectionsInProgress.size());\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testMultipleWatchesAsync() throws Exception {\n    try (ZkConnection conn = new ZkConnection ()) {\n      final SolrZkClient zkClient = conn.getClient();\n      zkClient.makePath(\"/collections\", true);\n\n      final int numColls = random().nextInt(100);\n      final CountDownLatch latch = new CountDownLatch(numColls);\n\n      for (int i = 1; i <= numColls; i ++) {\n        String collPath = \"/collections/collection\" + i;\n        zkClient.makePath(collPath, true);\n        zkClient.getChildren(collPath, new Watcher() {\n          @Override\n          public void process(WatchedEvent event) {\n            latch.countDown();\n            try {\n              Thread.sleep(1000);\n            }\n            catch (InterruptedException e) {}\n          }\n        }, true);\n      }\n\n      for (int i = 1; i <= numColls; i ++) {\n        String shardsPath = \"/collections/collection\" + i + \"/shards\";\n        zkClient.makePath(shardsPath, true);\n      }\n\n      assertTrue(latch.await(1000, TimeUnit.MILLISECONDS));\n    }\n  }\n\n","bugFix":["8650ae4e5d74a324411f8b7dd6201774f2b6fb2e","ff5e25fb60ccc8574bcbd65396786ae9163f0149"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43564cbb30b064675027cfb569564e8531096e97","date":1522334265,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ZkSolrClientTest#testMultipleWatchesAsync().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ZkSolrClientTest#testMultipleWatchesAsync().mjava","sourceNew":"  @Test\n  public void testMultipleWatchesAsync() throws Exception {\n    try (ZkConnection conn = new ZkConnection()) {\n      final SolrZkClient zkClient = conn.getClient();\n      zkClient.makePath(\"/collections\", true);\n\n      final int numColls = random().nextInt(100);\n      final CountDownLatch latch = new CountDownLatch(numColls);\n      final CountDownLatch watchesDone = new CountDownLatch(numColls);\n      final Set<String> collectionsInProgress = new HashSet<>(numColls);\n      AtomicInteger maxCollectionsInProgress = new AtomicInteger();\n\n      for (int i = 1; i <= numColls; i ++) {\n        String collPath = \"/collections/collection\" + i;\n        zkClient.makePath(collPath, true);\n        zkClient.getChildren(collPath, new Watcher() {\n          @Override\n          public void process(WatchedEvent event) {\n            synchronized (collectionsInProgress) {\n              collectionsInProgress.add(event.getPath()); // Will be something like /collections/collection##\n              maxCollectionsInProgress.set(Math.max(maxCollectionsInProgress.get(), collectionsInProgress.size()));\n            }\n            latch.countDown();\n            try {\n              latch.await(10000, TimeUnit.MILLISECONDS);\n            }\n            catch (InterruptedException e) {}\n            synchronized (collectionsInProgress) {\n              collectionsInProgress.remove(event.getPath());\n            }\n            watchesDone.countDown();\n          }\n        }, true);\n      }\n\n      for (int i = 1; i <= numColls; i ++) {\n        String shardsPath = \"/collections/collection\" + i + \"/shards\";\n        zkClient.makePath(shardsPath, true);\n      }\n\n      assertTrue(latch.await(10000, TimeUnit.MILLISECONDS));\n      assertEquals(\"All collections should have been processed in parallel\", numColls, maxCollectionsInProgress.get());\n      \n      // just as sanity check for the test:\n      assertTrue(watchesDone.await(10000, TimeUnit.MILLISECONDS));\n      synchronized (collectionsInProgress) {\n        assertEquals(0, collectionsInProgress.size());\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testMultipleWatchesAsync() throws Exception {\n    try (ZkConnection conn = new ZkConnection ()) {\n      final SolrZkClient zkClient = conn.getClient();\n      zkClient.makePath(\"/collections\", true);\n\n      final int numColls = random().nextInt(100);\n      final CountDownLatch latch = new CountDownLatch(numColls);\n\n      for (int i = 1; i <= numColls; i ++) {\n        String collPath = \"/collections/collection\" + i;\n        zkClient.makePath(collPath, true);\n        zkClient.getChildren(collPath, new Watcher() {\n          @Override\n          public void process(WatchedEvent event) {\n            latch.countDown();\n            try {\n              Thread.sleep(1000);\n            }\n            catch (InterruptedException e) {}\n          }\n        }, true);\n      }\n\n      for (int i = 1; i <= numColls; i ++) {\n        String shardsPath = \"/collections/collection\" + i + \"/shards\";\n        zkClient.makePath(shardsPath, true);\n      }\n\n      assertTrue(latch.await(1000, TimeUnit.MILLISECONDS));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ZkSolrClientTest#testMultipleWatchesAsync().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ZkSolrClientTest#testMultipleWatchesAsync().mjava","sourceNew":"  @Test\n  @SuppressWarnings({\"try\"})\n  public void testMultipleWatchesAsync() throws Exception {\n    try (ZkConnection conn = new ZkConnection()) {\n      final SolrZkClient zkClient = conn.getClient();\n      zkClient.makePath(\"/collections\", true);\n\n      final int numColls = random().nextInt(100);\n      final CountDownLatch latch = new CountDownLatch(numColls);\n      final CountDownLatch watchesDone = new CountDownLatch(numColls);\n      final Set<String> collectionsInProgress = new HashSet<>(numColls);\n      AtomicInteger maxCollectionsInProgress = new AtomicInteger();\n\n      for (int i = 1; i <= numColls; i ++) {\n        String collPath = \"/collections/collection\" + i;\n        zkClient.makePath(collPath, true);\n        zkClient.getChildren(collPath, new Watcher() {\n          @Override\n          public void process(WatchedEvent event) {\n            synchronized (collectionsInProgress) {\n              collectionsInProgress.add(event.getPath()); // Will be something like /collections/collection##\n              maxCollectionsInProgress.set(Math.max(maxCollectionsInProgress.get(), collectionsInProgress.size()));\n            }\n            latch.countDown();\n            try {\n              latch.await(10000, TimeUnit.MILLISECONDS);\n            }\n            catch (InterruptedException e) {}\n            synchronized (collectionsInProgress) {\n              collectionsInProgress.remove(event.getPath());\n            }\n            watchesDone.countDown();\n          }\n        }, true);\n      }\n\n      for (int i = 1; i <= numColls; i ++) {\n        String shardsPath = \"/collections/collection\" + i + \"/shards\";\n        zkClient.makePath(shardsPath, true);\n      }\n\n      assertTrue(latch.await(10000, TimeUnit.MILLISECONDS));\n      assertEquals(\"All collections should have been processed in parallel\", numColls, maxCollectionsInProgress.get());\n      \n      // just as sanity check for the test:\n      assertTrue(watchesDone.await(10000, TimeUnit.MILLISECONDS));\n      synchronized (collectionsInProgress) {\n        assertEquals(0, collectionsInProgress.size());\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testMultipleWatchesAsync() throws Exception {\n    try (ZkConnection conn = new ZkConnection()) {\n      final SolrZkClient zkClient = conn.getClient();\n      zkClient.makePath(\"/collections\", true);\n\n      final int numColls = random().nextInt(100);\n      final CountDownLatch latch = new CountDownLatch(numColls);\n      final CountDownLatch watchesDone = new CountDownLatch(numColls);\n      final Set<String> collectionsInProgress = new HashSet<>(numColls);\n      AtomicInteger maxCollectionsInProgress = new AtomicInteger();\n\n      for (int i = 1; i <= numColls; i ++) {\n        String collPath = \"/collections/collection\" + i;\n        zkClient.makePath(collPath, true);\n        zkClient.getChildren(collPath, new Watcher() {\n          @Override\n          public void process(WatchedEvent event) {\n            synchronized (collectionsInProgress) {\n              collectionsInProgress.add(event.getPath()); // Will be something like /collections/collection##\n              maxCollectionsInProgress.set(Math.max(maxCollectionsInProgress.get(), collectionsInProgress.size()));\n            }\n            latch.countDown();\n            try {\n              latch.await(10000, TimeUnit.MILLISECONDS);\n            }\n            catch (InterruptedException e) {}\n            synchronized (collectionsInProgress) {\n              collectionsInProgress.remove(event.getPath());\n            }\n            watchesDone.countDown();\n          }\n        }, true);\n      }\n\n      for (int i = 1; i <= numColls; i ++) {\n        String shardsPath = \"/collections/collection\" + i + \"/shards\";\n        zkClient.makePath(shardsPath, true);\n      }\n\n      assertTrue(latch.await(10000, TimeUnit.MILLISECONDS));\n      assertEquals(\"All collections should have been processed in parallel\", numColls, maxCollectionsInProgress.get());\n      \n      // just as sanity check for the test:\n      assertTrue(watchesDone.await(10000, TimeUnit.MILLISECONDS));\n      synchronized (collectionsInProgress) {\n        assertEquals(0, collectionsInProgress.size());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["43564cbb30b064675027cfb569564e8531096e97"],"ff5e25fb60ccc8574bcbd65396786ae9163f0149":["8650ae4e5d74a324411f8b7dd6201774f2b6fb2e"],"43564cbb30b064675027cfb569564e8531096e97":["ff5e25fb60ccc8574bcbd65396786ae9163f0149","335a420352f1e2c71baac3a1dad95f40cf415da8"],"8650ae4e5d74a324411f8b7dd6201774f2b6fb2e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"335a420352f1e2c71baac3a1dad95f40cf415da8":["ff5e25fb60ccc8574bcbd65396786ae9163f0149"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"]},"commit2Childs":{"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"43564cbb30b064675027cfb569564e8531096e97":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"ff5e25fb60ccc8574bcbd65396786ae9163f0149":["43564cbb30b064675027cfb569564e8531096e97","335a420352f1e2c71baac3a1dad95f40cf415da8"],"8650ae4e5d74a324411f8b7dd6201774f2b6fb2e":["ff5e25fb60ccc8574bcbd65396786ae9163f0149"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8650ae4e5d74a324411f8b7dd6201774f2b6fb2e"],"335a420352f1e2c71baac3a1dad95f40cf415da8":["43564cbb30b064675027cfb569564e8531096e97"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}