{"path":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#preemptiveAsync(Runnable).mjava","commits":[{"id":"849083f8095b1ffaff05a66e0b1e024617b9968d","date":1536291524,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#preemptiveAsync(Runnable).mjava","pathOld":"/dev/null","sourceNew":"  private void preemptiveAsync(Runnable r) {\n    // Note: creating an executor and throwing it away is slightly expensive, but this is only likely to happen\n    // once per hour/day/week (depending on time slice size for the TRA). If the executor were retained, it\n    // would need to be shut down in a close hook to avoid test failures due to thread leaks in tests which is slightly\n    // more complicated from a code maintenance and readability stand point. An executor must used instead of a\n    // thread to ensure we pick up the proper MDC logging stuff from ExecutorUtil.\n    DefaultSolrThreadFactory threadFactory = new DefaultSolrThreadFactory(\"TRA-preemptive-creation\");\n    preemptiveCreationExecutor = newMDCAwareSingleThreadExecutor(threadFactory);\n    preemptiveCreationExecutor.execute(() -> {\n      r.run();\n      preemptiveCreationExecutor.shutdown();\n      preemptiveCreationExecutor = null;\n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98b0091cfdf4ea4fd1e69c120a6dd42cefb7afeb","date":1543645563,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#preemptiveAsync(Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#preemptiveAsync(Runnable).mjava","sourceNew":"  private void preemptiveAsync(Runnable r) {\n    // Note: creating an executor and throwing it away is slightly expensive, but this is only likely to happen\n    // once per hour/day/week (depending on time slice size for the TRA). If the executor were retained, it\n    // would need to be shut down in a close hook to avoid test failures due to thread leaks in tests which is slightly\n    // more complicated from a code maintenance and readability stand point. An executor must used instead of a\n    // thread to ensure we pick up the proper MDC logging stuff from ExecutorUtil.\n    executorRunning  = true;\n    DefaultSolrThreadFactory threadFactory = new DefaultSolrThreadFactory(\"TRA-preemptive-creation\");\n    ExecutorService preemptiveCreationExecutor = newMDCAwareSingleThreadExecutor(threadFactory);\n\n    preemptiveCreationExecutor.execute(() -> {\n      r.run();\n      preemptiveCreationExecutor.shutdown();\n      executorRunning = false;\n    });\n    \n    preemptiveCreationWaitExecutor.submit(() -> ExecutorUtil.awaitTermination(preemptiveCreationExecutor));\n  }\n\n","sourceOld":"  private void preemptiveAsync(Runnable r) {\n    // Note: creating an executor and throwing it away is slightly expensive, but this is only likely to happen\n    // once per hour/day/week (depending on time slice size for the TRA). If the executor were retained, it\n    // would need to be shut down in a close hook to avoid test failures due to thread leaks in tests which is slightly\n    // more complicated from a code maintenance and readability stand point. An executor must used instead of a\n    // thread to ensure we pick up the proper MDC logging stuff from ExecutorUtil.\n    DefaultSolrThreadFactory threadFactory = new DefaultSolrThreadFactory(\"TRA-preemptive-creation\");\n    preemptiveCreationExecutor = newMDCAwareSingleThreadExecutor(threadFactory);\n    preemptiveCreationExecutor.execute(() -> {\n      r.run();\n      preemptiveCreationExecutor.shutdown();\n      preemptiveCreationExecutor = null;\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ff8a68c1177ac430ec03832a6e1c969b8a5b902","date":1543786480,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#preemptiveAsync(Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#preemptiveAsync(Runnable).mjava","sourceNew":"  private void preemptiveAsync(Runnable r) {\n    // Note: creating an executor and throwing it away is slightly expensive, but this is only likely to happen\n    // once per hour/day/week (depending on time slice size for the TRA). If the executor were retained, it\n    // would need to be shut down in a close hook to avoid test failures due to thread leaks in tests which is slightly\n    // more complicated from a code maintenance and readability stand point. An executor must used instead of a\n    // thread to ensure we pick up the proper MDC logging stuff from ExecutorUtil.\n    DefaultSolrThreadFactory threadFactory = new DefaultSolrThreadFactory(\"TRA-preemptive-creation\");\n    preemptiveCreationExecutor = newMDCAwareSingleThreadExecutor(threadFactory);\n    preemptiveCreationExecutor.execute(() -> {\n      r.run();\n      preemptiveCreationExecutor.shutdown();\n      preemptiveCreationExecutor = null;\n    });\n  }\n\n","sourceOld":"  private void preemptiveAsync(Runnable r) {\n    // Note: creating an executor and throwing it away is slightly expensive, but this is only likely to happen\n    // once per hour/day/week (depending on time slice size for the TRA). If the executor were retained, it\n    // would need to be shut down in a close hook to avoid test failures due to thread leaks in tests which is slightly\n    // more complicated from a code maintenance and readability stand point. An executor must used instead of a\n    // thread to ensure we pick up the proper MDC logging stuff from ExecutorUtil.\n    executorRunning  = true;\n    DefaultSolrThreadFactory threadFactory = new DefaultSolrThreadFactory(\"TRA-preemptive-creation\");\n    ExecutorService preemptiveCreationExecutor = newMDCAwareSingleThreadExecutor(threadFactory);\n\n    preemptiveCreationExecutor.execute(() -> {\n      r.run();\n      preemptiveCreationExecutor.shutdown();\n      executorRunning = false;\n    });\n    \n    preemptiveCreationWaitExecutor.submit(() -> ExecutorUtil.awaitTermination(preemptiveCreationExecutor));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6","date":1547236077,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#preemptiveAsync(Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#preemptiveAsync(Runnable).mjava","sourceNew":"  private void preemptiveAsync(Runnable r) {\n    preemptiveCreateOnceAlready = true;\n    req.getCore().runAsync(r);\n  }\n\n","sourceOld":"  private void preemptiveAsync(Runnable r) {\n    // Note: creating an executor and throwing it away is slightly expensive, but this is only likely to happen\n    // once per hour/day/week (depending on time slice size for the TRA). If the executor were retained, it\n    // would need to be shut down in a close hook to avoid test failures due to thread leaks in tests which is slightly\n    // more complicated from a code maintenance and readability stand point. An executor must used instead of a\n    // thread to ensure we pick up the proper MDC logging stuff from ExecutorUtil.\n    DefaultSolrThreadFactory threadFactory = new DefaultSolrThreadFactory(\"TRA-preemptive-creation\");\n    preemptiveCreationExecutor = newMDCAwareSingleThreadExecutor(threadFactory);\n    preemptiveCreationExecutor.execute(() -> {\n      r.run();\n      preemptiveCreationExecutor.shutdown();\n      preemptiveCreationExecutor = null;\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":5,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#preemptiveAsync(Runnable,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#preemptiveAsync(Runnable).mjava","sourceNew":"  private void preemptiveAsync(Runnable r, SolrCore core) {\n    preemptiveCreateOnceAlready = true;\n    core.runAsync(r);\n  }\n\n","sourceOld":"  private void preemptiveAsync(Runnable r) {\n    preemptiveCreateOnceAlready = true;\n    req.getCore().runAsync(r);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"849083f8095b1ffaff05a66e0b1e024617b9968d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b627755385655c7cd3fb296f17593658805cf4d5":["11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6"],"5ff8a68c1177ac430ec03832a6e1c969b8a5b902":["98b0091cfdf4ea4fd1e69c120a6dd42cefb7afeb"],"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6":["5ff8a68c1177ac430ec03832a6e1c969b8a5b902"],"98b0091cfdf4ea4fd1e69c120a6dd42cefb7afeb":["849083f8095b1ffaff05a66e0b1e024617b9968d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b627755385655c7cd3fb296f17593658805cf4d5"]},"commit2Childs":{"849083f8095b1ffaff05a66e0b1e024617b9968d":["98b0091cfdf4ea4fd1e69c120a6dd42cefb7afeb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["849083f8095b1ffaff05a66e0b1e024617b9968d"],"b627755385655c7cd3fb296f17593658805cf4d5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5ff8a68c1177ac430ec03832a6e1c969b8a5b902":["11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6"],"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6":["b627755385655c7cd3fb296f17593658805cf4d5"],"98b0091cfdf4ea4fd1e69c120a6dd42cefb7afeb":["5ff8a68c1177ac430ec03832a6e1c969b8a5b902"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}