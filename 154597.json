{"path":"lucene/core/src/java/org/apache/lucene/index/MergeState#buildDocMaps(List[CodecReader],Sort).mjava","commits":[{"id":"ceaef6cfc68c8ab22a684192e469a8280f9e6e70","date":1462354657,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergeState#buildDocMaps(List[CodecReader],Sort).mjava","pathOld":"/dev/null","sourceNew":"  private DocMap[] buildDocMaps(List<CodecReader> readers, Sort indexSort) throws IOException {\n\n    int numReaders = readers.size();\n\n    if (indexSort == null) {\n      // no index sort ... we only must map around deletions, and rebase to the merged segment's docID space\n\n      int totalDocs = 0;\n      DocMap[] docMaps = new DocMap[numReaders];\n\n      // Remap docIDs around deletions:\n      for (int i = 0; i < numReaders; i++) {\n        LeafReader reader = readers.get(i);\n        Bits liveDocs = reader.getLiveDocs();\n\n        final PackedLongValues delDocMap;\n        if (liveDocs != null) {\n          delDocMap = removeDeletes(reader.maxDoc(), liveDocs);\n        } else {\n          delDocMap = null;\n        }\n\n        final int docBase = totalDocs;\n        docMaps[i] = new DocMap() {\n          @Override\n          public int get(int docID) {\n            if (liveDocs == null) {\n              return docBase + docID;\n            } else if (liveDocs.get(docID)) {\n              return docBase + (int) delDocMap.get(docID);\n            } else {\n              return -1;\n            }\n          }\n        };\n        totalDocs += reader.numDocs();\n      }\n\n      return docMaps;\n\n    } else {\n      // do a merge sort of the incoming leaves:\n      return MultiSorter.sort(indexSort, readers);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a6d0e4c7ab9c0e1fc073fddd21f4784555be9cd","date":1463081111,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergeState#buildDocMaps(List[CodecReader],Sort).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MergeState#buildDocMaps(List[CodecReader],Sort).mjava","sourceNew":"  private DocMap[] buildDocMaps(List<CodecReader> readers, Sort indexSort) throws IOException {\n\n    int numReaders = readers.size();\n\n    if (indexSort == null) {\n      // no index sort ... we only must map around deletions, and rebase to the merged segment's docID space\n\n      int totalDocs = 0;\n      DocMap[] docMaps = new DocMap[numReaders];\n\n      // Remap docIDs around deletions:\n      for (int i = 0; i < numReaders; i++) {\n        LeafReader reader = readers.get(i);\n        Bits liveDocs = reader.getLiveDocs();\n\n        final PackedLongValues delDocMap;\n        if (liveDocs != null) {\n          delDocMap = removeDeletes(reader.maxDoc(), liveDocs);\n        } else {\n          delDocMap = null;\n        }\n\n        final int docBase = totalDocs;\n        docMaps[i] = new DocMap() {\n          @Override\n          public int get(int docID) {\n            if (liveDocs == null) {\n              return docBase + docID;\n            } else if (liveDocs.get(docID)) {\n              return docBase + (int) delDocMap.get(docID);\n            } else {\n              return -1;\n            }\n          }\n        };\n        totalDocs += reader.numDocs();\n      }\n\n      return docMaps;\n\n    } else {\n      // do a merge sort of the incoming leaves:\n      long t0 = System.nanoTime();\n      DocMap[] result = MultiSorter.sort(indexSort, readers);\n      long t1 = System.nanoTime();\n      if (infoStream.isEnabled(\"SM\")) {\n        infoStream.message(\"SM\", String.format(Locale.ROOT, \"%.2f msec to build merge sorted DocMaps\", (t1-t0)/1000000.0));\n      }\n      return result;\n    }\n  }\n\n","sourceOld":"  private DocMap[] buildDocMaps(List<CodecReader> readers, Sort indexSort) throws IOException {\n\n    int numReaders = readers.size();\n\n    if (indexSort == null) {\n      // no index sort ... we only must map around deletions, and rebase to the merged segment's docID space\n\n      int totalDocs = 0;\n      DocMap[] docMaps = new DocMap[numReaders];\n\n      // Remap docIDs around deletions:\n      for (int i = 0; i < numReaders; i++) {\n        LeafReader reader = readers.get(i);\n        Bits liveDocs = reader.getLiveDocs();\n\n        final PackedLongValues delDocMap;\n        if (liveDocs != null) {\n          delDocMap = removeDeletes(reader.maxDoc(), liveDocs);\n        } else {\n          delDocMap = null;\n        }\n\n        final int docBase = totalDocs;\n        docMaps[i] = new DocMap() {\n          @Override\n          public int get(int docID) {\n            if (liveDocs == null) {\n              return docBase + docID;\n            } else if (liveDocs.get(docID)) {\n              return docBase + (int) delDocMap.get(docID);\n            } else {\n              return -1;\n            }\n          }\n        };\n        totalDocs += reader.numDocs();\n      }\n\n      return docMaps;\n\n    } else {\n      // do a merge sort of the incoming leaves:\n      return MultiSorter.sort(indexSort, readers);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergeState#buildDocMaps(List[CodecReader],Sort).mjava","pathOld":"/dev/null","sourceNew":"  private DocMap[] buildDocMaps(List<CodecReader> readers, Sort indexSort) throws IOException {\n\n    int numReaders = readers.size();\n\n    if (indexSort == null) {\n      // no index sort ... we only must map around deletions, and rebase to the merged segment's docID space\n\n      int totalDocs = 0;\n      DocMap[] docMaps = new DocMap[numReaders];\n\n      // Remap docIDs around deletions:\n      for (int i = 0; i < numReaders; i++) {\n        LeafReader reader = readers.get(i);\n        Bits liveDocs = reader.getLiveDocs();\n\n        final PackedLongValues delDocMap;\n        if (liveDocs != null) {\n          delDocMap = removeDeletes(reader.maxDoc(), liveDocs);\n        } else {\n          delDocMap = null;\n        }\n\n        final int docBase = totalDocs;\n        docMaps[i] = new DocMap() {\n          @Override\n          public int get(int docID) {\n            if (liveDocs == null) {\n              return docBase + docID;\n            } else if (liveDocs.get(docID)) {\n              return docBase + (int) delDocMap.get(docID);\n            } else {\n              return -1;\n            }\n          }\n        };\n        totalDocs += reader.numDocs();\n      }\n\n      return docMaps;\n\n    } else {\n      // do a merge sort of the incoming leaves:\n      long t0 = System.nanoTime();\n      DocMap[] result = MultiSorter.sort(indexSort, readers);\n      long t1 = System.nanoTime();\n      if (infoStream.isEnabled(\"SM\")) {\n        infoStream.message(\"SM\", String.format(Locale.ROOT, \"%.2f msec to build merge sorted DocMaps\", (t1-t0)/1000000.0));\n      }\n      return result;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergeState#buildDocMaps(List[CodecReader],Sort).mjava","pathOld":"/dev/null","sourceNew":"  private DocMap[] buildDocMaps(List<CodecReader> readers, Sort indexSort) throws IOException {\n\n    int numReaders = readers.size();\n\n    if (indexSort == null) {\n      // no index sort ... we only must map around deletions, and rebase to the merged segment's docID space\n\n      int totalDocs = 0;\n      DocMap[] docMaps = new DocMap[numReaders];\n\n      // Remap docIDs around deletions:\n      for (int i = 0; i < numReaders; i++) {\n        LeafReader reader = readers.get(i);\n        Bits liveDocs = reader.getLiveDocs();\n\n        final PackedLongValues delDocMap;\n        if (liveDocs != null) {\n          delDocMap = removeDeletes(reader.maxDoc(), liveDocs);\n        } else {\n          delDocMap = null;\n        }\n\n        final int docBase = totalDocs;\n        docMaps[i] = new DocMap() {\n          @Override\n          public int get(int docID) {\n            if (liveDocs == null) {\n              return docBase + docID;\n            } else if (liveDocs.get(docID)) {\n              return docBase + (int) delDocMap.get(docID);\n            } else {\n              return -1;\n            }\n          }\n        };\n        totalDocs += reader.numDocs();\n      }\n\n      return docMaps;\n\n    } else {\n      // do a merge sort of the incoming leaves:\n      long t0 = System.nanoTime();\n      DocMap[] result = MultiSorter.sort(indexSort, readers);\n      long t1 = System.nanoTime();\n      if (infoStream.isEnabled(\"SM\")) {\n        infoStream.message(\"SM\", String.format(Locale.ROOT, \"%.2f msec to build merge sorted DocMaps\", (t1-t0)/1000000.0));\n      }\n      return result;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergeState#buildDocMaps(List[CodecReader],Sort).mjava","pathOld":"/dev/null","sourceNew":"  private DocMap[] buildDocMaps(List<CodecReader> readers, Sort indexSort) throws IOException {\n\n    int numReaders = readers.size();\n\n    if (indexSort == null) {\n      // no index sort ... we only must map around deletions, and rebase to the merged segment's docID space\n\n      int totalDocs = 0;\n      DocMap[] docMaps = new DocMap[numReaders];\n\n      // Remap docIDs around deletions:\n      for (int i = 0; i < numReaders; i++) {\n        LeafReader reader = readers.get(i);\n        Bits liveDocs = reader.getLiveDocs();\n\n        final PackedLongValues delDocMap;\n        if (liveDocs != null) {\n          delDocMap = removeDeletes(reader.maxDoc(), liveDocs);\n        } else {\n          delDocMap = null;\n        }\n\n        final int docBase = totalDocs;\n        docMaps[i] = new DocMap() {\n          @Override\n          public int get(int docID) {\n            if (liveDocs == null) {\n              return docBase + docID;\n            } else if (liveDocs.get(docID)) {\n              return docBase + (int) delDocMap.get(docID);\n            } else {\n              return -1;\n            }\n          }\n        };\n        totalDocs += reader.numDocs();\n      }\n\n      return docMaps;\n\n    } else {\n      // do a merge sort of the incoming leaves:\n      long t0 = System.nanoTime();\n      DocMap[] result = MultiSorter.sort(indexSort, readers);\n      long t1 = System.nanoTime();\n      if (infoStream.isEnabled(\"SM\")) {\n        infoStream.message(\"SM\", String.format(Locale.ROOT, \"%.2f msec to build merge sorted DocMaps\", (t1-t0)/1000000.0));\n      }\n      return result;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergeState#buildDocMaps(List[CodecReader],Sort).mjava","pathOld":"/dev/null","sourceNew":"  private DocMap[] buildDocMaps(List<CodecReader> readers, Sort indexSort) throws IOException {\n\n    int numReaders = readers.size();\n\n    if (indexSort == null) {\n      // no index sort ... we only must map around deletions, and rebase to the merged segment's docID space\n\n      int totalDocs = 0;\n      DocMap[] docMaps = new DocMap[numReaders];\n\n      // Remap docIDs around deletions:\n      for (int i = 0; i < numReaders; i++) {\n        LeafReader reader = readers.get(i);\n        Bits liveDocs = reader.getLiveDocs();\n\n        final PackedLongValues delDocMap;\n        if (liveDocs != null) {\n          delDocMap = removeDeletes(reader.maxDoc(), liveDocs);\n        } else {\n          delDocMap = null;\n        }\n\n        final int docBase = totalDocs;\n        docMaps[i] = new DocMap() {\n          @Override\n          public int get(int docID) {\n            if (liveDocs == null) {\n              return docBase + docID;\n            } else if (liveDocs.get(docID)) {\n              return docBase + (int) delDocMap.get(docID);\n            } else {\n              return -1;\n            }\n          }\n        };\n        totalDocs += reader.numDocs();\n      }\n\n      return docMaps;\n\n    } else {\n      // do a merge sort of the incoming leaves:\n      long t0 = System.nanoTime();\n      DocMap[] result = MultiSorter.sort(indexSort, readers);\n      long t1 = System.nanoTime();\n      if (infoStream.isEnabled(\"SM\")) {\n        infoStream.message(\"SM\", String.format(Locale.ROOT, \"%.2f msec to build merge sorted DocMaps\", (t1-t0)/1000000.0));\n      }\n      return result;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"653128722fb3b4713ac331c621491a93f34a4a22","date":1479841816,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergeState#buildDocMaps(List[CodecReader],Sort).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MergeState#buildDocMaps(List[CodecReader],Sort).mjava","sourceNew":"  private DocMap[] buildDocMaps(List<CodecReader> readers, Sort indexSort) throws IOException {\n\n    if (indexSort == null) {\n      // no index sort ... we only must map around deletions, and rebase to the merged segment's docID space\n      return buildDeletionDocMaps(readers);\n    } else {\n      // do a merge sort of the incoming leaves:\n      long t0 = System.nanoTime();\n      DocMap[] result = MultiSorter.sort(indexSort, readers);\n      if (result == null) {\n        // already sorted so we can switch back to map around deletions\n        return buildDeletionDocMaps(readers);\n      } else {\n        needsIndexSort = true;\n      }\n      long t1 = System.nanoTime();\n      if (infoStream.isEnabled(\"SM\")) {\n        infoStream.message(\"SM\", String.format(Locale.ROOT, \"%.2f msec to build merge sorted DocMaps\", (t1-t0)/1000000.0));\n      }\n      return result;\n    }\n  }\n\n","sourceOld":"  private DocMap[] buildDocMaps(List<CodecReader> readers, Sort indexSort) throws IOException {\n\n    int numReaders = readers.size();\n\n    if (indexSort == null) {\n      // no index sort ... we only must map around deletions, and rebase to the merged segment's docID space\n\n      int totalDocs = 0;\n      DocMap[] docMaps = new DocMap[numReaders];\n\n      // Remap docIDs around deletions:\n      for (int i = 0; i < numReaders; i++) {\n        LeafReader reader = readers.get(i);\n        Bits liveDocs = reader.getLiveDocs();\n\n        final PackedLongValues delDocMap;\n        if (liveDocs != null) {\n          delDocMap = removeDeletes(reader.maxDoc(), liveDocs);\n        } else {\n          delDocMap = null;\n        }\n\n        final int docBase = totalDocs;\n        docMaps[i] = new DocMap() {\n          @Override\n          public int get(int docID) {\n            if (liveDocs == null) {\n              return docBase + docID;\n            } else if (liveDocs.get(docID)) {\n              return docBase + (int) delDocMap.get(docID);\n            } else {\n              return -1;\n            }\n          }\n        };\n        totalDocs += reader.numDocs();\n      }\n\n      return docMaps;\n\n    } else {\n      // do a merge sort of the incoming leaves:\n      long t0 = System.nanoTime();\n      DocMap[] result = MultiSorter.sort(indexSort, readers);\n      long t1 = System.nanoTime();\n      if (infoStream.isEnabled(\"SM\")) {\n        infoStream.message(\"SM\", String.format(Locale.ROOT, \"%.2f msec to build merge sorted DocMaps\", (t1-t0)/1000000.0));\n      }\n      return result;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergeState#buildDocMaps(List[CodecReader],Sort).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MergeState#buildDocMaps(List[CodecReader],Sort).mjava","sourceNew":"  private DocMap[] buildDocMaps(List<CodecReader> readers, Sort indexSort) throws IOException {\n\n    if (indexSort == null) {\n      // no index sort ... we only must map around deletions, and rebase to the merged segment's docID space\n      return buildDeletionDocMaps(readers);\n    } else {\n      // do a merge sort of the incoming leaves:\n      long t0 = System.nanoTime();\n      DocMap[] result = MultiSorter.sort(indexSort, readers);\n      if (result == null) {\n        // already sorted so we can switch back to map around deletions\n        return buildDeletionDocMaps(readers);\n      } else {\n        needsIndexSort = true;\n      }\n      long t1 = System.nanoTime();\n      if (infoStream.isEnabled(\"SM\")) {\n        infoStream.message(\"SM\", String.format(Locale.ROOT, \"%.2f msec to build merge sorted DocMaps\", (t1-t0)/1000000.0));\n      }\n      return result;\n    }\n  }\n\n","sourceOld":"  private DocMap[] buildDocMaps(List<CodecReader> readers, Sort indexSort) throws IOException {\n\n    int numReaders = readers.size();\n\n    if (indexSort == null) {\n      // no index sort ... we only must map around deletions, and rebase to the merged segment's docID space\n\n      int totalDocs = 0;\n      DocMap[] docMaps = new DocMap[numReaders];\n\n      // Remap docIDs around deletions:\n      for (int i = 0; i < numReaders; i++) {\n        LeafReader reader = readers.get(i);\n        Bits liveDocs = reader.getLiveDocs();\n\n        final PackedLongValues delDocMap;\n        if (liveDocs != null) {\n          delDocMap = removeDeletes(reader.maxDoc(), liveDocs);\n        } else {\n          delDocMap = null;\n        }\n\n        final int docBase = totalDocs;\n        docMaps[i] = new DocMap() {\n          @Override\n          public int get(int docID) {\n            if (liveDocs == null) {\n              return docBase + docID;\n            } else if (liveDocs.get(docID)) {\n              return docBase + (int) delDocMap.get(docID);\n            } else {\n              return -1;\n            }\n          }\n        };\n        totalDocs += reader.numDocs();\n      }\n\n      return docMaps;\n\n    } else {\n      // do a merge sort of the incoming leaves:\n      long t0 = System.nanoTime();\n      DocMap[] result = MultiSorter.sort(indexSort, readers);\n      long t1 = System.nanoTime();\n      if (infoStream.isEnabled(\"SM\")) {\n        infoStream.message(\"SM\", String.format(Locale.ROOT, \"%.2f msec to build merge sorted DocMaps\", (t1-t0)/1000000.0));\n      }\n      return result;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"727bb765ff2542275f6d31f67be18d7104bae148":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","653128722fb3b4713ac331c621491a93f34a4a22"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0a6d0e4c7ab9c0e1fc073fddd21f4784555be9cd":["ceaef6cfc68c8ab22a684192e469a8280f9e6e70"],"0ad30c6a479e764150a3316e57263319775f1df2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3d33e731a93d4b57e662ff094f64f94a745422d4"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0a6d0e4c7ab9c0e1fc073fddd21f4784555be9cd"],"653128722fb3b4713ac331c621491a93f34a4a22":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["653128722fb3b4713ac331c621491a93f34a4a22"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0ad30c6a479e764150a3316e57263319775f1df2"]},"commit2Childs":{"727bb765ff2542275f6d31f67be18d7104bae148":[],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["0a6d0e4c7ab9c0e1fc073fddd21f4784555be9cd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ceaef6cfc68c8ab22a684192e469a8280f9e6e70","0ad30c6a479e764150a3316e57263319775f1df2","3d33e731a93d4b57e662ff094f64f94a745422d4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89"],"0a6d0e4c7ab9c0e1fc073fddd21f4784555be9cd":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"653128722fb3b4713ac331c621491a93f34a4a22":["727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["727bb765ff2542275f6d31f67be18d7104bae148"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["653128722fb3b4713ac331c621491a93f34a4a22","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}