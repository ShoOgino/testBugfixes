{"path":"lucene/core/src/java/org/apache/lucene/index/MultiTermsEnum#next().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiTermsEnum#next().mjava","sourceNew":"  @Override\n  public BytesRef next() throws IOException {\n    if (lastSeekExact) {\n      // Must seekCeil at this point, so those subs that\n      // didn't have the term can find the following term.\n      // NOTE: we could save some CPU by only seekCeil the\n      // subs that didn't match the last exact seek... but\n      // most impls short-circuit if you seekCeil to term\n      // they are already on.\n      final SeekStatus status = seekCeil(current);\n      assert status == SeekStatus.FOUND;\n      lastSeekExact = false;\n    }\n    lastSeek = null;\n\n    // restore queue\n    pushTop();\n\n    // gather equal top fields\n    if (queue.size() > 0) {\n      pullTop();\n    } else {\n      current = null;\n    }\n\n    return current;\n  }\n\n","sourceOld":"  @Override\n  public BytesRef next() throws IOException {\n    if (lastSeekExact) {\n      // Must seekCeil at this point, so those subs that\n      // didn't have the term can find the following term.\n      // NOTE: we could save some CPU by only seekCeil the\n      // subs that didn't match the last exact seek... but\n      // most impls short-circuit if you seekCeil to term\n      // they are already on.\n      final SeekStatus status = seekCeil(current);\n      assert status == SeekStatus.FOUND;\n      lastSeekExact = false;\n    }\n    lastSeek = null;\n\n    // restore queue\n    pushTop();\n\n    // gather equal top fields\n    if (queue.size() > 0) {\n      pullTop();\n    } else {\n      current = null;\n    }\n\n    return current;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"957c610636f393a85a38f1af670540028db13e6b","date":1500044517,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiTermsEnum#next().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiTermsEnum#next().mjava","sourceNew":"  @Override\n  public BytesRef next() throws IOException {\n    if (lastSeekExact) {\n      // Must seekCeil at this point, so those subs that\n      // didn't have the term can find the following term.\n      // NOTE: we could save some CPU by only seekCeil the\n      // subs that didn't match the last exact seek... but\n      // most impls short-circuit if you seekCeil to term\n      // they are already on.\n      final SeekStatus status = seekCeil(current);\n      assert status == SeekStatus.FOUND;\n      lastSeekExact = false;\n    }\n    lastSeek = null;\n\n    // restore queue\n    pushTop();\n\n    // gather equal top fields\n    if (queue.size() > 0) {\n      // TODO: we could maybe defer this somewhat costly operation until one of the APIs that\n      // needs to see the top is invoked (docFreq, postings, etc.)\n      pullTop();\n    } else {\n      current = null;\n    }\n\n    return current;\n  }\n\n","sourceOld":"  @Override\n  public BytesRef next() throws IOException {\n    if (lastSeekExact) {\n      // Must seekCeil at this point, so those subs that\n      // didn't have the term can find the following term.\n      // NOTE: we could save some CPU by only seekCeil the\n      // subs that didn't match the last exact seek... but\n      // most impls short-circuit if you seekCeil to term\n      // they are already on.\n      final SeekStatus status = seekCeil(current);\n      assert status == SeekStatus.FOUND;\n      lastSeekExact = false;\n    }\n    lastSeek = null;\n\n    // restore queue\n    pushTop();\n\n    // gather equal top fields\n    if (queue.size() > 0) {\n      pullTop();\n    } else {\n      current = null;\n    }\n\n    return current;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiTermsEnum#next().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiTermsEnum#next().mjava","sourceNew":"  @Override\n  public BytesRef next() throws IOException {\n    if (lastSeekExact) {\n      // Must seekCeil at this point, so those subs that\n      // didn't have the term can find the following term.\n      // NOTE: we could save some CPU by only seekCeil the\n      // subs that didn't match the last exact seek... but\n      // most impls short-circuit if you seekCeil to term\n      // they are already on.\n      final SeekStatus status = seekCeil(current);\n      assert status == SeekStatus.FOUND;\n      lastSeekExact = false;\n    }\n    lastSeek = null;\n\n    // restore queue\n    pushTop();\n\n    // gather equal top fields\n    if (queue.size() > 0) {\n      // TODO: we could maybe defer this somewhat costly operation until one of the APIs that\n      // needs to see the top is invoked (docFreq, postings, etc.)\n      pullTop();\n    } else {\n      current = null;\n    }\n\n    return current;\n  }\n\n","sourceOld":"  @Override\n  public BytesRef next() throws IOException {\n    if (lastSeekExact) {\n      // Must seekCeil at this point, so those subs that\n      // didn't have the term can find the following term.\n      // NOTE: we could save some CPU by only seekCeil the\n      // subs that didn't match the last exact seek... but\n      // most impls short-circuit if you seekCeil to term\n      // they are already on.\n      final SeekStatus status = seekCeil(current);\n      assert status == SeekStatus.FOUND;\n      lastSeekExact = false;\n    }\n    lastSeek = null;\n\n    // restore queue\n    pushTop();\n\n    // gather equal top fields\n    if (queue.size() > 0) {\n      pullTop();\n    } else {\n      current = null;\n    }\n\n    return current;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"957c610636f393a85a38f1af670540028db13e6b":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","957c610636f393a85a38f1af670540028db13e6b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["957c610636f393a85a38f1af670540028db13e6b"]},"commit2Childs":{"957c610636f393a85a38f1af670540028db13e6b":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["957c610636f393a85a38f1af670540028db13e6b","aaf90fc29510e72665ac7934f34c3d1c25efad64"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}