{"path":"lucene/core/src/java/org/apache/lucene/analysis/AnalysisSPILoader#reload(ClassLoader).mjava","commits":[{"id":"313c36388b6cae6118f75a1860ad0ba0af7e1344","date":1601279368,"type":1,"author":"Tomoko Uchida","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/analysis/AnalysisSPILoader#reload(ClassLoader).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#reload(ClassLoader).mjava","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<>(this.services);\n    final LinkedHashSet<String> originalNames = new LinkedHashSet<>(this.originalNames);\n    ServiceLoader.load(clazz, classloader).stream().map(ServiceLoader.Provider::type).forEachOrdered(service -> {\n      String name = null;\n      String originalName = null;\n      Throwable cause = null;\n      try {\n        originalName = lookupSPIName(service);\n        name = originalName.toLowerCase(Locale.ROOT);\n        if (!isValidName(originalName)) {\n          throw new ServiceConfigurationError(\"The name \" + originalName + \" for \" + service.getName() +\n              \" is invalid: Allowed characters are (English) alphabet, digits, and underscore. It should be started with an alphabet.\");\n        }\n      } catch (NoSuchFieldException | IllegalAccessException | IllegalStateException e) {\n        cause = e;\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n            \" has no service name field: [public static final String NAME]\", cause);\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n        // preserve (case-sensitive) original name for reference\n        originalNames.add(originalName);\n      }\n    });\n\n    // make sure that the number of lookup keys is same to the number of original names.\n    // in fact this constraint should be met in existence checks of the lookup map key,\n    // so this is more like an assertion rather than a status check.\n    if (services.keySet().size() != originalNames.size()) {\n      throw new ServiceConfigurationError(\"Service lookup key set is inconsistent with original name set!\");\n    }\n\n    this.services = Map.copyOf(services);\n    this.originalNames = Set.copyOf(originalNames);\n  }\n\n","sourceOld":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators (e.g., from {@link #availableServices()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<>(this.services);\n    final LinkedHashSet<String> originalNames = new LinkedHashSet<>(this.originalNames);\n    ServiceLoader.load(clazz, classloader).stream().map(ServiceLoader.Provider::type).forEachOrdered(service -> {\n      String name = null;\n      String originalName = null;\n      Throwable cause = null;\n      try {\n        originalName = lookupSPIName(service);\n        name = originalName.toLowerCase(Locale.ROOT);\n        if (!isValidName(originalName)) {\n          throw new ServiceConfigurationError(\"The name \" + originalName + \" for \" + service.getName() +\n              \" is invalid: Allowed characters are (English) alphabet, digits, and underscore. It should be started with an alphabet.\");\n        }\n      } catch (NoSuchFieldException | IllegalAccessException | IllegalStateException e) {\n        cause = e;\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n            \" has no service name field: [public static final String NAME]\", cause);\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      //\n      // TODO: Should we disallow duplicate names here?\n      // Allowing it may get confusing on collisions, as different packages\n      // could contain same factory class, which is a naming bug!\n      // When changing this be careful to allow reload()!\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n        // preserve (case-sensitive) original name for reference\n        originalNames.add(originalName);\n      }\n    });\n\n    // make sure that the number of lookup keys is same to the number of original names.\n    // in fact this constraint should be met in existence checks of the lookup map key,\n    // so this is more like an assertion rather than a status check.\n    if (services.keySet().size() != originalNames.size()) {\n      throw new ServiceConfigurationError(\"Service lookup key set is inconsistent with original name set!\");\n    }\n\n    this.services = Map.copyOf(services);\n    this.originalNames = Set.copyOf(originalNames);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"313c36388b6cae6118f75a1860ad0ba0af7e1344":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["313c36388b6cae6118f75a1860ad0ba0af7e1344"]},"commit2Childs":{"313c36388b6cae6118f75a1860ad0ba0af7e1344":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["313c36388b6cae6118f75a1860ad0ba0af7e1344"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}