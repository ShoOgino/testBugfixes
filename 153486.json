{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#testRouting().mjava","commits":[{"id":"0544142c22eb88b6d8b3817f2e1190156aa4f9af","date":1551692505,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#testRouting().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    CollectionAdminRequest.createCollection(\"routing_collection\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(\"routing_collection\", 2, 2);\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    RouteResponse rr = (RouteResponse) response;\n    Map<String,LBSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(\"routing_collection\", new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .withParallelUpdates(true)\n        .build()) {\n      threadedClient.setDefaultCollection(\"routing_collection\");\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(\"routing_collection\");\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, \"routing_collection\"));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", getRandomClient().query(\"routing_collection\", solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, \"routing_collection\");\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc613ed6f75d1988140301ee8de8fdb056fa337","date":1588034757,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#testRouting().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    CollectionAdminRequest.createCollection(\"routing_collection\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(\"routing_collection\", 2, 2);\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    RouteResponse rr = (RouteResponse) response;\n    Map<String,LBSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(\"routing_collection\", new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .withParallelUpdates(true)\n        .build()) {\n      threadedClient.setDefaultCollection(\"routing_collection\");\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(\"routing_collection\");\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, \"routing_collection\"));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      if (log.isInfoEnabled()) {\n        log.info(\"output: {}\", getRandomClient().query(\"routing_collection\", solrParams));\n      }\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, \"routing_collection\");\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  @Test\n  public void testRouting() throws Exception {\n    CollectionAdminRequest.createCollection(\"routing_collection\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(\"routing_collection\", 2, 2);\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    RouteResponse rr = (RouteResponse) response;\n    Map<String,LBSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(\"routing_collection\", new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .withParallelUpdates(true)\n        .build()) {\n      threadedClient.setDefaultCollection(\"routing_collection\");\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(\"routing_collection\");\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, \"routing_collection\"));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", getRandomClient().query(\"routing_collection\", solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, \"routing_collection\");\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ba1b632c041956c93c41aa1143d16a567014891","date":1592328473,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#testRouting().mjava","sourceNew":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testRouting() throws Exception {\n    CollectionAdminRequest.createCollection(\"routing_collection\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(\"routing_collection\", 2, 2);\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    RouteResponse rr = (RouteResponse) response;\n    Map<String,LBSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(\"routing_collection\", new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .withParallelUpdates(true)\n        .build()) {\n      threadedClient.setDefaultCollection(\"routing_collection\");\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(\"routing_collection\");\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, \"routing_collection\"));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      if (log.isInfoEnabled()) {\n        log.info(\"output: {}\", getRandomClient().query(\"routing_collection\", solrParams));\n      }\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, \"routing_collection\");\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  @Test\n  public void testRouting() throws Exception {\n    CollectionAdminRequest.createCollection(\"routing_collection\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(\"routing_collection\", 2, 2);\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    RouteResponse rr = (RouteResponse) response;\n    Map<String,LBSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(\"routing_collection\", new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .withParallelUpdates(true)\n        .build()) {\n      threadedClient.setDefaultCollection(\"routing_collection\");\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(\"routing_collection\");\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, \"routing_collection\"));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      if (log.isInfoEnabled()) {\n        log.info(\"output: {}\", getRandomClient().query(\"routing_collection\", solrParams));\n      }\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, \"routing_collection\");\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9ba1b632c041956c93c41aa1143d16a567014891":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ba1b632c041956c93c41aa1143d16a567014891"]},"commit2Childs":{"9ba1b632c041956c93c41aa1143d16a567014891":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["9ba1b632c041956c93c41aa1143d16a567014891"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}