{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","commits":[{"id":"0544142c22eb88b6d8b3817f2e1190156aa4f9af","date":1551692505,"type":1,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    final Set<String> liveNodes = getClusterStateProvider().getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNodesList.get(0),\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNode,\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n\n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        if (col == null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection not found: \" + collectionName);\n        }\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      // TODO: allow filtering by group, role, etc\n      Set<String> seenNodes = new HashSet<>();\n      List<String> replicas = new ArrayList<>();\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (seenNodes.add(node)) { // if we haven't yet collected a URL to this node...\n            String url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), joinedInputCollections);\n            if (sendToLeaders && coreNodeProps.isLeader()) {\n              theUrlList.add(url); // put leaders here eagerly (if sendToLeader mode)\n            } else {\n              replicas.add(url); // replicas here\n            }\n          }\n        }\n      }\n\n      // Shuffle the leaders, if any    (none if !sendToLeaders)\n      Collections.shuffle(theUrlList, rand);\n\n      // Shuffle the replicas, if any, and append to our list\n      Collections.shuffle(replicas, rand);\n      theUrlList.addAll(replicas);\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBSolrClient.Req req = new LBSolrClient.Req(request, theUrlList);\n    LBSolrClient.Rsp rsp = getLbClient().request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    final Set<String> liveNodes = stateProvider.getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        if (col == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"Collection not found: \" + collectionName);\n        }\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      // TODO: allow filtering by group, role, etc\n      Set<String> seenNodes = new HashSet<>();\n      List<String> replicas = new ArrayList<>();\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (seenNodes.add(node)) { // if we haven't yet collected a URL to this node...\n            String url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), joinedInputCollections);\n            if (sendToLeaders && coreNodeProps.isLeader()) {\n              theUrlList.add(url); // put leaders here eagerly (if sendToLeader mode)\n            } else {\n              replicas.add(url); // replicas here\n            }\n          }\n        }\n      }\n\n      // Shuffle the leaders, if any    (none if !sendToLeaders)\n      Collections.shuffle(theUrlList, rand);\n\n      // Shuffle the replicas, if any, and append to our list\n      Collections.shuffle(replicas, rand);\n      theUrlList.addAll(replicas);\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"813335f324f8bd40ae4d83d8391674b42b536cc0","date":1555591986,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    boolean isUpdate = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        isUpdate = true;\n        if (inputCollections.size() > 1) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request must be sent to a single collection \" +\n              \"or an alias: \" + inputCollections);\n        }\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    final Set<String> liveNodes = getClusterStateProvider().getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNodesList.get(0),\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNode,\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections, isUpdate);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n\n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        if (col == null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection not found: \" + collectionName);\n        }\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      // TODO: allow filtering by group, role, etc\n      Set<String> seenNodes = new HashSet<>();\n      List<String> replicas = new ArrayList<>();\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (seenNodes.add(node)) { // if we haven't yet collected a URL to this node...\n            String url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), joinedInputCollections);\n            if (sendToLeaders && coreNodeProps.isLeader()) {\n              theUrlList.add(url); // put leaders here eagerly (if sendToLeader mode)\n            } else {\n              replicas.add(url); // replicas here\n            }\n          }\n        }\n      }\n\n      // Shuffle the leaders, if any    (none if !sendToLeaders)\n      Collections.shuffle(theUrlList, rand);\n\n      // Shuffle the replicas, if any, and append to our list\n      Collections.shuffle(replicas, rand);\n      theUrlList.addAll(replicas);\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBSolrClient.Req req = new LBSolrClient.Req(request, theUrlList);\n    LBSolrClient.Rsp rsp = getLbClient().request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    final Set<String> liveNodes = getClusterStateProvider().getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNodesList.get(0),\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNode,\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n\n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        if (col == null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection not found: \" + collectionName);\n        }\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      // TODO: allow filtering by group, role, etc\n      Set<String> seenNodes = new HashSet<>();\n      List<String> replicas = new ArrayList<>();\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (seenNodes.add(node)) { // if we haven't yet collected a URL to this node...\n            String url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), joinedInputCollections);\n            if (sendToLeaders && coreNodeProps.isLeader()) {\n              theUrlList.add(url); // put leaders here eagerly (if sendToLeader mode)\n            } else {\n              replicas.add(url); // replicas here\n            }\n          }\n        }\n      }\n\n      // Shuffle the leaders, if any    (none if !sendToLeaders)\n      Collections.shuffle(theUrlList, rand);\n\n      // Shuffle the replicas, if any, and append to our list\n      Collections.shuffle(replicas, rand);\n      theUrlList.addAll(replicas);\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBSolrClient.Req req = new LBSolrClient.Req(request, theUrlList);\n    LBSolrClient.Rsp rsp = getLbClient().request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad2b6c2ec630dc0bf592b217af5cd07c62ac2839","date":1575929518,"type":3,"author":"Houston Putman","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    boolean isUpdate = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        isUpdate = true;\n        if (inputCollections.size() > 1) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request must be sent to a single collection \" +\n              \"or an alias: \" + inputCollections);\n        }\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    ReplicaListTransformer replicaListTransformer = requestRLTGenerator.getReplicaListTransformer(reqParams);\n\n    final Set<String> liveNodes = getClusterStateProvider().getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNodesList.get(0),\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNode,\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections, isUpdate);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n\n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        if (col == null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection not found: \" + collectionName);\n        }\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      List<Replica> sortedReplicas = new ArrayList<>();\n      List<Replica> replicas = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        Replica leader = slice.getLeader();\n        for (Replica replica : slice.getReplicas()) {\n          String node = replica.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || replica.getState() != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (sendToLeaders && replica.equals(leader)) {\n            sortedReplicas.add(replica); // put leaders here eagerly (if sendToLeader mode)\n          } else {\n            replicas.add(replica); // replicas here\n          }\n        }\n      }\n\n      // Sort the leader replicas, if any, according to the request preferences    (none if !sendToLeaders)\n      replicaListTransformer.transform(sortedReplicas);\n\n      // Sort the replicas, if any, according to the request preferences and append to our list\n      replicaListTransformer.transform(replicas);\n\n      sortedReplicas.addAll(replicas);\n\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      Set<String> seenNodes = new HashSet<>();\n      sortedReplicas.forEach( replica -> {\n        if (seenNodes.add(replica.getNodeName())) {\n          theUrlList.add(ZkCoreNodeProps.getCoreUrl(replica.getBaseUrl(), joinedInputCollections));\n        }\n      });\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBSolrClient.Req req = new LBSolrClient.Req(request, theUrlList);\n    LBSolrClient.Rsp rsp = getLbClient().request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    boolean isUpdate = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        isUpdate = true;\n        if (inputCollections.size() > 1) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request must be sent to a single collection \" +\n              \"or an alias: \" + inputCollections);\n        }\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    final Set<String> liveNodes = getClusterStateProvider().getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNodesList.get(0),\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNode,\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections, isUpdate);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n\n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        if (col == null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection not found: \" + collectionName);\n        }\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      // TODO: allow filtering by group, role, etc\n      Set<String> seenNodes = new HashSet<>();\n      List<String> replicas = new ArrayList<>();\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (seenNodes.add(node)) { // if we haven't yet collected a URL to this node...\n            String url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), joinedInputCollections);\n            if (sendToLeaders && coreNodeProps.isLeader()) {\n              theUrlList.add(url); // put leaders here eagerly (if sendToLeader mode)\n            } else {\n              replicas.add(url); // replicas here\n            }\n          }\n        }\n      }\n\n      // Shuffle the leaders, if any    (none if !sendToLeaders)\n      Collections.shuffle(theUrlList, rand);\n\n      // Shuffle the replicas, if any, and append to our list\n      Collections.shuffle(replicas, rand);\n      theUrlList.addAll(replicas);\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBSolrClient.Req req = new LBSolrClient.Req(request, theUrlList);\n    LBSolrClient.Rsp rsp = getLbClient().request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"993b0c7dda6341b437fe5685d35c6cc35eaac420","date":1575985950,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    boolean isUpdate = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        isUpdate = true;\n        if (inputCollections.size() > 1) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request must be sent to a single collection \" +\n              \"or an alias: \" + inputCollections);\n        }\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    ReplicaListTransformer replicaListTransformer = requestRLTGenerator.getReplicaListTransformer(reqParams);\n\n    final Set<String> liveNodes = getClusterStateProvider().getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNodesList.get(0),\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNode,\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections, isUpdate);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n\n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        if (col == null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection not found: \" + collectionName);\n        }\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      List<Replica> sortedReplicas = new ArrayList<>();\n      List<Replica> replicas = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        Replica leader = slice.getLeader();\n        for (Replica replica : slice.getReplicas()) {\n          String node = replica.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || replica.getState() != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (sendToLeaders && replica.equals(leader)) {\n            sortedReplicas.add(replica); // put leaders here eagerly (if sendToLeader mode)\n          } else {\n            replicas.add(replica); // replicas here\n          }\n        }\n      }\n\n      // Sort the leader replicas, if any, according to the request preferences    (none if !sendToLeaders)\n      replicaListTransformer.transform(sortedReplicas);\n\n      // Sort the replicas, if any, according to the request preferences and append to our list\n      replicaListTransformer.transform(replicas);\n\n      sortedReplicas.addAll(replicas);\n\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      Set<String> seenNodes = new HashSet<>();\n      sortedReplicas.forEach( replica -> {\n        if (seenNodes.add(replica.getNodeName())) {\n          theUrlList.add(ZkCoreNodeProps.getCoreUrl(replica.getBaseUrl(), joinedInputCollections));\n        }\n      });\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBSolrClient.Req req = new LBSolrClient.Req(request, theUrlList);\n    LBSolrClient.Rsp rsp = getLbClient().request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    boolean isUpdate = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        isUpdate = true;\n        if (inputCollections.size() > 1) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request must be sent to a single collection \" +\n              \"or an alias: \" + inputCollections);\n        }\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    final Set<String> liveNodes = getClusterStateProvider().getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNodesList.get(0),\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNode,\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections, isUpdate);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n\n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        if (col == null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection not found: \" + collectionName);\n        }\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      // TODO: allow filtering by group, role, etc\n      Set<String> seenNodes = new HashSet<>();\n      List<String> replicas = new ArrayList<>();\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (seenNodes.add(node)) { // if we haven't yet collected a URL to this node...\n            String url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), joinedInputCollections);\n            if (sendToLeaders && coreNodeProps.isLeader()) {\n              theUrlList.add(url); // put leaders here eagerly (if sendToLeader mode)\n            } else {\n              replicas.add(url); // replicas here\n            }\n          }\n        }\n      }\n\n      // Shuffle the leaders, if any    (none if !sendToLeaders)\n      Collections.shuffle(theUrlList, rand);\n\n      // Shuffle the replicas, if any, and append to our list\n      Collections.shuffle(replicas, rand);\n      theUrlList.addAll(replicas);\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBSolrClient.Req req = new LBSolrClient.Req(request, theUrlList);\n    LBSolrClient.Rsp rsp = getLbClient().request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d","date":1592006776,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","sourceNew":"  protected NamedList<Object> sendRequest(@SuppressWarnings({\"rawtypes\"})SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    boolean isUpdate = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        isUpdate = true;\n        if (inputCollections.size() > 1) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request must be sent to a single collection \" +\n              \"or an alias: \" + inputCollections);\n        }\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    ReplicaListTransformer replicaListTransformer = requestRLTGenerator.getReplicaListTransformer(reqParams);\n\n    final Set<String> liveNodes = getClusterStateProvider().getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNodesList.get(0),\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNode,\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections, isUpdate);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n\n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        if (col == null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection not found: \" + collectionName);\n        }\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      List<Replica> sortedReplicas = new ArrayList<>();\n      List<Replica> replicas = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        Replica leader = slice.getLeader();\n        for (Replica replica : slice.getReplicas()) {\n          String node = replica.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || replica.getState() != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (sendToLeaders && replica.equals(leader)) {\n            sortedReplicas.add(replica); // put leaders here eagerly (if sendToLeader mode)\n          } else {\n            replicas.add(replica); // replicas here\n          }\n        }\n      }\n\n      // Sort the leader replicas, if any, according to the request preferences    (none if !sendToLeaders)\n      replicaListTransformer.transform(sortedReplicas);\n\n      // Sort the replicas, if any, according to the request preferences and append to our list\n      replicaListTransformer.transform(replicas);\n\n      sortedReplicas.addAll(replicas);\n\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      Set<String> seenNodes = new HashSet<>();\n      sortedReplicas.forEach( replica -> {\n        if (seenNodes.add(replica.getNodeName())) {\n          theUrlList.add(ZkCoreNodeProps.getCoreUrl(replica.getBaseUrl(), joinedInputCollections));\n        }\n      });\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBSolrClient.Req req = new LBSolrClient.Req(request, theUrlList);\n    LBSolrClient.Rsp rsp = getLbClient().request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    boolean isUpdate = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        isUpdate = true;\n        if (inputCollections.size() > 1) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request must be sent to a single collection \" +\n              \"or an alias: \" + inputCollections);\n        }\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    ReplicaListTransformer replicaListTransformer = requestRLTGenerator.getReplicaListTransformer(reqParams);\n\n    final Set<String> liveNodes = getClusterStateProvider().getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNodesList.get(0),\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNode,\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections, isUpdate);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n\n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        if (col == null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection not found: \" + collectionName);\n        }\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      List<Replica> sortedReplicas = new ArrayList<>();\n      List<Replica> replicas = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        Replica leader = slice.getLeader();\n        for (Replica replica : slice.getReplicas()) {\n          String node = replica.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || replica.getState() != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (sendToLeaders && replica.equals(leader)) {\n            sortedReplicas.add(replica); // put leaders here eagerly (if sendToLeader mode)\n          } else {\n            replicas.add(replica); // replicas here\n          }\n        }\n      }\n\n      // Sort the leader replicas, if any, according to the request preferences    (none if !sendToLeaders)\n      replicaListTransformer.transform(sortedReplicas);\n\n      // Sort the replicas, if any, according to the request preferences and append to our list\n      replicaListTransformer.transform(replicas);\n\n      sortedReplicas.addAll(replicas);\n\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      Set<String> seenNodes = new HashSet<>();\n      sortedReplicas.forEach( replica -> {\n        if (seenNodes.add(replica.getNodeName())) {\n          theUrlList.add(ZkCoreNodeProps.getCoreUrl(replica.getBaseUrl(), joinedInputCollections));\n        }\n      });\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBSolrClient.Req req = new LBSolrClient.Req(request, theUrlList);\n    LBSolrClient.Rsp rsp = getLbClient().request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"993b0c7dda6341b437fe5685d35c6cc35eaac420":["813335f324f8bd40ae4d83d8391674b42b536cc0","ad2b6c2ec630dc0bf592b217af5cd07c62ac2839"],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["ad2b6c2ec630dc0bf592b217af5cd07c62ac2839"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"813335f324f8bd40ae4d83d8391674b42b536cc0":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"ad2b6c2ec630dc0bf592b217af5cd07c62ac2839":["813335f324f8bd40ae4d83d8391674b42b536cc0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"]},"commit2Childs":{"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["813335f324f8bd40ae4d83d8391674b42b536cc0"],"993b0c7dda6341b437fe5685d35c6cc35eaac420":[],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"813335f324f8bd40ae4d83d8391674b42b536cc0":["993b0c7dda6341b437fe5685d35c6cc35eaac420","ad2b6c2ec630dc0bf592b217af5cd07c62ac2839"],"ad2b6c2ec630dc0bf592b217af5cd07c62ac2839":["993b0c7dda6341b437fe5685d35c6cc35eaac420","0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["993b0c7dda6341b437fe5685d35c6cc35eaac420","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}