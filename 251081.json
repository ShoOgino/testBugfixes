{"path":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doQueryFirstScoring(Bits,LeafCollector,DocIdSetIterator[],LeafCollector[],Bits[],LeafCollector[]).mjava","commits":[{"id":"5de121b64b42060b75c060b3d2fa3e4c12ac701c","date":1435251256,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doQueryFirstScoring(Bits,LeafCollector,DocIdSetIterator[],LeafCollector[],Bits[],LeafCollector[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doQueryFirstScoring(LeafCollector,DocIdSetIterator[],LeafCollector[],Bits[],LeafCollector[]).mjava","sourceNew":"  /** Used when base query is highly constraining vs the\n   *  drilldowns, or when the docs must be scored at once\n   *  (i.e., like BooleanScorer2, not BooleanScorer).  In\n   *  this case we just .next() on base and .advance() on\n   *  the dim filters. */ \n  private void doQueryFirstScoring(Bits acceptDocs, LeafCollector collector, DocIdSetIterator[] disis, LeafCollector[] sidewaysCollectors,\n                                   Bits[] bits, LeafCollector[] bitsSidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doQueryFirstScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    nextDoc: while (docID != PostingsEnum.NO_MORE_DOCS) {\n      if (acceptDocs != null && acceptDocs.get(docID) == false) {\n        docID = baseScorer.nextDoc();\n        continue;\n      }\n      LeafCollector failedCollector = null;\n      for (int i=0;i<disis.length;i++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        DocIdSetIterator disi = disis[i];\n        if (disi != null && disi.docID() < docID) {\n          disi.advance(docID);\n        }\n        if (disi == null || disi.docID() > docID) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = sidewaysCollectors[i];\n          }\n        }\n      }\n\n      // TODO: for the \"non-costly Bits\" we really should\n      // have passed them down as acceptDocs, but\n      // unfortunately we cannot distinguish today betwen\n      // \"bits() is so costly that you should apply it last\"\n      // from \"bits() is so cheap that you should apply it\n      // everywhere down low\"\n\n      // Fold in Filter Bits last, since they may be costly:\n      for(int i=0;i<bits.length;i++) {\n        if (bits[i].get(docID) == false) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = bitsSidewaysCollectors[i];\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedCollector == null) {\n        // Hit passed all filters, so it's \"real\":\n        collectHit(collector, sidewaysCollectors, bitsSidewaysCollectors);\n      } else {\n        // Hit missed exactly one filter:\n        collectNearMiss(failedCollector);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","sourceOld":"  /** Used when base query is highly constraining vs the\n   *  drilldowns, or when the docs must be scored at once\n   *  (i.e., like BooleanScorer2, not BooleanScorer).  In\n   *  this case we just .next() on base and .advance() on\n   *  the dim filters. */ \n  private void doQueryFirstScoring(LeafCollector collector, DocIdSetIterator[] disis, LeafCollector[] sidewaysCollectors,\n                                   Bits[] bits, LeafCollector[] bitsSidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doQueryFirstScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    nextDoc: while (docID != PostingsEnum.NO_MORE_DOCS) {\n      LeafCollector failedCollector = null;\n      for (int i=0;i<disis.length;i++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        DocIdSetIterator disi = disis[i];\n        if (disi != null && disi.docID() < docID) {\n          disi.advance(docID);\n        }\n        if (disi == null || disi.docID() > docID) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = sidewaysCollectors[i];\n          }\n        }\n      }\n\n      // TODO: for the \"non-costly Bits\" we really should\n      // have passed them down as acceptDocs, but\n      // unfortunately we cannot distinguish today betwen\n      // \"bits() is so costly that you should apply it last\"\n      // from \"bits() is so cheap that you should apply it\n      // everywhere down low\"\n\n      // Fold in Filter Bits last, since they may be costly:\n      for(int i=0;i<bits.length;i++) {\n        if (bits[i].get(docID) == false) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = bitsSidewaysCollectors[i];\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedCollector == null) {\n        // Hit passed all filters, so it's \"real\":\n        collectHit(collector, sidewaysCollectors, bitsSidewaysCollectors);\n      } else {\n        // Hit missed exactly one filter:\n        collectNearMiss(failedCollector);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd6be878365e339c75cc43ad7d5df95ab4ea21e5","date":1435762101,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doQueryFirstScoring(Bits,LeafCollector,DocsAndCost[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doQueryFirstScoring(Bits,LeafCollector,DocIdSetIterator[],LeafCollector[],Bits[],LeafCollector[]).mjava","sourceNew":"  /** Used when base query is highly constraining vs the\n   *  drilldowns, or when the docs must be scored at once\n   *  (i.e., like BooleanScorer2, not BooleanScorer).  In\n   *  this case we just .next() on base and .advance() on\n   *  the dim filters. */ \n  private void doQueryFirstScoring(Bits acceptDocs, LeafCollector collector, DocsAndCost[] dims) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doQueryFirstScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    nextDoc: while (docID != PostingsEnum.NO_MORE_DOCS) {\n      if (acceptDocs != null && acceptDocs.get(docID) == false) {\n        docID = baseScorer.nextDoc();\n        continue;\n      }\n      LeafCollector failedCollector = null;\n      for (DocsAndCost dim : dims) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        if (dim.approximation.docID() < docID) {\n          dim.approximation.advance(docID);\n        }\n\n        boolean matches = false;\n        if (dim.approximation.docID() == docID) {\n          if (dim.twoPhase == null) {\n            matches = true;\n          } else {\n            matches = dim.twoPhase.matches();\n          }\n        }\n\n        if (matches == false) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = dim.sidewaysLeafCollector;\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedCollector == null) {\n        // Hit passed all filters, so it's \"real\":\n        collectHit(collector, dims);\n      } else {\n        // Hit missed exactly one filter:\n        collectNearMiss(failedCollector);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","sourceOld":"  /** Used when base query is highly constraining vs the\n   *  drilldowns, or when the docs must be scored at once\n   *  (i.e., like BooleanScorer2, not BooleanScorer).  In\n   *  this case we just .next() on base and .advance() on\n   *  the dim filters. */ \n  private void doQueryFirstScoring(Bits acceptDocs, LeafCollector collector, DocIdSetIterator[] disis, LeafCollector[] sidewaysCollectors,\n                                   Bits[] bits, LeafCollector[] bitsSidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doQueryFirstScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    nextDoc: while (docID != PostingsEnum.NO_MORE_DOCS) {\n      if (acceptDocs != null && acceptDocs.get(docID) == false) {\n        docID = baseScorer.nextDoc();\n        continue;\n      }\n      LeafCollector failedCollector = null;\n      for (int i=0;i<disis.length;i++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        DocIdSetIterator disi = disis[i];\n        if (disi != null && disi.docID() < docID) {\n          disi.advance(docID);\n        }\n        if (disi == null || disi.docID() > docID) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = sidewaysCollectors[i];\n          }\n        }\n      }\n\n      // TODO: for the \"non-costly Bits\" we really should\n      // have passed them down as acceptDocs, but\n      // unfortunately we cannot distinguish today betwen\n      // \"bits() is so costly that you should apply it last\"\n      // from \"bits() is so cheap that you should apply it\n      // everywhere down low\"\n\n      // Fold in Filter Bits last, since they may be costly:\n      for(int i=0;i<bits.length;i++) {\n        if (bits[i].get(docID) == false) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = bitsSidewaysCollectors[i];\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedCollector == null) {\n        // Hit passed all filters, so it's \"real\":\n        collectHit(collector, sidewaysCollectors, bitsSidewaysCollectors);\n      } else {\n        // Hit missed exactly one filter:\n        collectNearMiss(failedCollector);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5de121b64b42060b75c060b3d2fa3e4c12ac701c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"dd6be878365e339c75cc43ad7d5df95ab4ea21e5":["5de121b64b42060b75c060b3d2fa3e4c12ac701c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dd6be878365e339c75cc43ad7d5df95ab4ea21e5"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5de121b64b42060b75c060b3d2fa3e4c12ac701c"],"5de121b64b42060b75c060b3d2fa3e4c12ac701c":["dd6be878365e339c75cc43ad7d5df95ab4ea21e5"],"dd6be878365e339c75cc43ad7d5df95ab4ea21e5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}