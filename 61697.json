{"path":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","sourceNew":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericField.DataType[] typeAnswers = new NumericField.DataType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final NumericField nf;\n      final Number answer;\n      final NumericField.DataType typeAnswer;\n      if (random.nextBoolean()) {\n        // float/double\n        if (random.nextBoolean()) {\n          final float f = random.nextFloat();\n          answer = Float.valueOf(f);\n          nf = new NumericField(\"nf\", answer, NumericField.getFieldType(NumericField.DataType.FLOAT, true));\n          typeAnswer = NumericField.DataType.FLOAT;\n        } else {\n          final double d = random.nextDouble();\n          answer = Double.valueOf(d);\n          nf = new NumericField(\"nf\", answer, NumericField.getFieldType(NumericField.DataType.DOUBLE, true));\n          typeAnswer = NumericField.DataType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random.nextBoolean()) {\n          final int i = random.nextInt();\n          answer = Integer.valueOf(i);\n          nf = new NumericField(\"nf\", answer, NumericField.getFieldType(NumericField.DataType.INT, true));\n          typeAnswer = NumericField.DataType.INT;\n        } else {\n          final long l = random.nextLong();\n          answer = Long.valueOf(l);\n          nf = new NumericField(\"nf\", answer, NumericField.getFieldType(NumericField.DataType.LONG, true));\n          typeAnswer = NumericField.DataType.LONG;\n        }\n      }\n      doc.add(nf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.INT, false));\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new NumericField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(IndexReader sub : r.getSequentialSubReaders()) {\n      final int[] ids = FieldCache.DEFAULT.getInts((AtomicReader) sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericField.DataType[] typeAnswers = new NumericField.DataType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final NumericField nf;\n      final Number answer;\n      final NumericField.DataType typeAnswer;\n      if (random.nextBoolean()) {\n        // float/double\n        if (random.nextBoolean()) {\n          final float f = random.nextFloat();\n          answer = Float.valueOf(f);\n          nf = new NumericField(\"nf\", answer, NumericField.getFieldType(NumericField.DataType.FLOAT, true));\n          typeAnswer = NumericField.DataType.FLOAT;\n        } else {\n          final double d = random.nextDouble();\n          answer = Double.valueOf(d);\n          nf = new NumericField(\"nf\", answer, NumericField.getFieldType(NumericField.DataType.DOUBLE, true));\n          typeAnswer = NumericField.DataType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random.nextBoolean()) {\n          final int i = random.nextInt();\n          answer = Integer.valueOf(i);\n          nf = new NumericField(\"nf\", answer, NumericField.getFieldType(NumericField.DataType.INT, true));\n          typeAnswer = NumericField.DataType.INT;\n        } else {\n          final long l = random.nextLong();\n          answer = Long.valueOf(l);\n          nf = new NumericField(\"nf\", answer, NumericField.getFieldType(NumericField.DataType.LONG, true));\n          typeAnswer = NumericField.DataType.LONG;\n        }\n      }\n      doc.add(nf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.INT, false));\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new NumericField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(IndexReader sub : r.getSequentialSubReaders()) {\n      final int[] ids = FieldCache.DEFAULT.getInts((AtomicReader) sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a78a90fc9701e511308346ea29f4f5e548bb39fe","date":1329489995,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","sourceNew":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random.nextBoolean()) {\n        // float/double\n        if (random.nextBoolean()) {\n          final float f = random.nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random.nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random.nextBoolean()) {\n          final int i = random.nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random.nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(IndexReader sub : r.getSequentialSubReaders()) {\n      final int[] ids = FieldCache.DEFAULT.getInts((AtomicReader) sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericField.DataType[] typeAnswers = new NumericField.DataType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final NumericField nf;\n      final Number answer;\n      final NumericField.DataType typeAnswer;\n      if (random.nextBoolean()) {\n        // float/double\n        if (random.nextBoolean()) {\n          final float f = random.nextFloat();\n          answer = Float.valueOf(f);\n          nf = new NumericField(\"nf\", answer, NumericField.getFieldType(NumericField.DataType.FLOAT, true));\n          typeAnswer = NumericField.DataType.FLOAT;\n        } else {\n          final double d = random.nextDouble();\n          answer = Double.valueOf(d);\n          nf = new NumericField(\"nf\", answer, NumericField.getFieldType(NumericField.DataType.DOUBLE, true));\n          typeAnswer = NumericField.DataType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random.nextBoolean()) {\n          final int i = random.nextInt();\n          answer = Integer.valueOf(i);\n          nf = new NumericField(\"nf\", answer, NumericField.getFieldType(NumericField.DataType.INT, true));\n          typeAnswer = NumericField.DataType.INT;\n        } else {\n          final long l = random.nextLong();\n          answer = Long.valueOf(l);\n          nf = new NumericField(\"nf\", answer, NumericField.getFieldType(NumericField.DataType.LONG, true));\n          typeAnswer = NumericField.DataType.LONG;\n        }\n      }\n      doc.add(nf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.INT, false));\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new NumericField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(IndexReader sub : r.getSequentialSubReaders()) {\n      final int[] ids = FieldCache.DEFAULT.getInts((AtomicReader) sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["fa0f44f887719e97183771e977cfc4bfb485b766","ab0e9f7ce724e6aea1fea746dded19e76d231cf8"],"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","sourceNew":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(IndexReader sub : r.getSequentialSubReaders()) {\n      final int[] ids = FieldCache.DEFAULT.getInts((AtomicReader) sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random.nextBoolean()) {\n        // float/double\n        if (random.nextBoolean()) {\n          final float f = random.nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random.nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random.nextBoolean()) {\n          final int i = random.nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random.nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(IndexReader sub : r.getSequentialSubReaders()) {\n      final int[] ids = FieldCache.DEFAULT.getInts((AtomicReader) sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","sourceNew":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(IndexReader sub : r.getSequentialSubReaders()) {\n      final int[] ids = FieldCache.DEFAULT.getInts((AtomicReader) sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(IndexReader sub : r.getSequentialSubReaders()) {\n      final int[] ids = FieldCache.DEFAULT.getInts((AtomicReader) sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4","date":1341839195,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","sourceNew":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(IndexReader sub : r.getSequentialSubReaders()) {\n      final int[] ids = FieldCache.DEFAULT.getInts((AtomicReader) sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final StoredDocument doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(IndexReader sub : r.getSequentialSubReaders()) {\n      final int[] ids = FieldCache.DEFAULT.getInts((AtomicReader) sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ced66195b26fdb1f77ee00e2a77ec6918dedd766","date":1344948886,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","sourceNew":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(AtomicReaderContext ctx : r.leaves()) {\n      final AtomicReader sub = ctx.reader();\n      final int[] ids = FieldCache.DEFAULT.getInts(sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(IndexReader sub : r.getSequentialSubReaders()) {\n      final int[] ids = FieldCache.DEFAULT.getInts((AtomicReader) sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["ab0e9f7ce724e6aea1fea746dded19e76d231cf8","da6d5ac19a80d65b1e864251f155d30960353b7e"],"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","sourceNew":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(AtomicReaderContext ctx : r.leaves()) {\n      final AtomicReader sub = ctx.reader();\n      final int[] ids = FieldCache.DEFAULT.getInts(sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final StoredDocument doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(IndexReader sub : r.getSequentialSubReaders()) {\n      final int[] ids = FieldCache.DEFAULT.getInts((AtomicReader) sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final StoredDocument doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3c188105a9aae04f56c24996f98f8333fc825d2e","date":1345031914,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","sourceNew":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(AtomicReaderContext ctx : r.leaves()) {\n      final AtomicReader sub = ctx.reader();\n      final int[] ids = FieldCache.DEFAULT.getInts(sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(IndexReader sub : r.getSequentialSubReaders()) {\n      final int[] ids = FieldCache.DEFAULT.getInts((AtomicReader) sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c93396a1df03720cb20e2c2f513a6fa59b21e4c","date":1345032673,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","sourceNew":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(IndexReader sub : r.getSequentialSubReaders()) {\n      final int[] ids = FieldCache.DEFAULT.getInts((AtomicReader) sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(AtomicReaderContext ctx : r.leaves()) {\n      final AtomicReader sub = ctx.reader();\n      final int[] ids = FieldCache.DEFAULT.getInts(sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","sourceNew":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(AtomicReaderContext ctx : r.leaves()) {\n      final AtomicReader sub = ctx.reader();\n      final int[] ids = FieldCache.DEFAULT.getInts(sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(IndexReader sub : r.getSequentialSubReaders()) {\n      final int[] ids = FieldCache.DEFAULT.getInts((AtomicReader) sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d028314cced5858683a1bb4741423d0f934257b","date":1346596535,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","sourceNew":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(AtomicReaderContext ctx : r.leaves()) {\n      final AtomicReader sub = ctx.reader();\n      final int[] ids = FieldCache.DEFAULT.getInts(sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final StoredDocument doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_NOT_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(AtomicReaderContext ctx : r.leaves()) {\n      final AtomicReader sub = ctx.reader();\n      final int[] ids = FieldCache.DEFAULT.getInts(sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final Document doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f45457a742a53533c348c4b990b1c579ff364467","date":1353197071,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","sourceNew":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(AtomicReaderContext ctx : r.leaves()) {\n      final AtomicReader sub = ctx.reader();\n      final FieldCache.Ints ids = FieldCache.DEFAULT.getInts(sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final StoredDocument doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids.get(docID)], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(AtomicReaderContext ctx : r.leaves()) {\n      final AtomicReader sub = ctx.reader();\n      final int[] ids = FieldCache.DEFAULT.getInts(sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final StoredDocument doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","sourceNew":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(AtomicReaderContext ctx : r.leaves()) {\n      final AtomicReader sub = ctx.reader();\n      final FieldCache.Ints ids = FieldCache.DEFAULT.getInts(sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final StoredDocument doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids.get(docID)], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(AtomicReaderContext ctx : r.leaves()) {\n      final AtomicReader sub = ctx.reader();\n      final int[] ids = FieldCache.DEFAULT.getInts(sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final StoredDocument doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids[docID]], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["ced66195b26fdb1f77ee00e2a77ec6918dedd766","fa0f44f887719e97183771e977cfc4bfb485b766"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70b55953b6a72596cb534ead735a8b849a473cac","date":1363634568,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testNumericField().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFieldsReader#testNumericField().mjava","sourceNew":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(AtomicReaderContext ctx : r.leaves()) {\n      final AtomicReader sub = ctx.reader();\n      final FieldCache.Ints ids = FieldCache.DEFAULT.getInts(sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final StoredDocument doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids.get(docID)], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNumericField() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final int numDocs = atLeast(500);\n    final Number[] answers = new Number[numDocs];\n    final NumericType[] typeAnswers = new NumericType[numDocs];\n    for(int id=0;id<numDocs;id++) {\n      Document doc = new Document();\n      final Field nf;\n      final Field sf;\n      final Number answer;\n      final NumericType typeAnswer;\n      if (random().nextBoolean()) {\n        // float/double\n        if (random().nextBoolean()) {\n          final float f = random().nextFloat();\n          answer = Float.valueOf(f);\n          nf = new FloatField(\"nf\", f, Field.Store.NO);\n          sf = new StoredField(\"nf\", f);\n          typeAnswer = NumericType.FLOAT;\n        } else {\n          final double d = random().nextDouble();\n          answer = Double.valueOf(d);\n          nf = new DoubleField(\"nf\", d, Field.Store.NO);\n          sf = new StoredField(\"nf\", d);\n          typeAnswer = NumericType.DOUBLE;\n        }\n      } else {\n        // int/long\n        if (random().nextBoolean()) {\n          final int i = random().nextInt();\n          answer = Integer.valueOf(i);\n          nf = new IntField(\"nf\", i, Field.Store.NO);\n          sf = new StoredField(\"nf\", i);\n          typeAnswer = NumericType.INT;\n        } else {\n          final long l = random().nextLong();\n          answer = Long.valueOf(l);\n          nf = new LongField(\"nf\", l, Field.Store.NO);\n          sf = new StoredField(\"nf\", l);\n          typeAnswer = NumericType.LONG;\n        }\n      }\n      doc.add(nf);\n      doc.add(sf);\n      answers[id] = answer;\n      typeAnswers[id] = typeAnswer;\n      FieldType ft = new FieldType(IntField.TYPE_STORED);\n      ft.setNumericPrecisionStep(Integer.MAX_VALUE);\n      doc.add(new IntField(\"id\", id, ft));\n      w.addDocument(doc);\n    }\n    final DirectoryReader r = w.getReader();\n    w.close();\n    \n    assertEquals(numDocs, r.numDocs());\n\n    for(AtomicReaderContext ctx : r.leaves()) {\n      final AtomicReader sub = ctx.reader();\n      final FieldCache.Ints ids = FieldCache.DEFAULT.getInts(sub, \"id\", false);\n      for(int docID=0;docID<sub.numDocs();docID++) {\n        final StoredDocument doc = sub.document(docID);\n        final Field f = (Field) doc.getField(\"nf\");\n        assertTrue(\"got f=\" + f, f instanceof StoredField);\n        assertEquals(answers[ids.get(docID)], f.numericValue());\n      }\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"3c188105a9aae04f56c24996f98f8333fc825d2e":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["3c188105a9aae04f56c24996f98f8333fc825d2e"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"f45457a742a53533c348c4b990b1c579ff364467":["1d028314cced5858683a1bb4741423d0f934257b"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"1d028314cced5858683a1bb4741423d0f934257b":["ced66195b26fdb1f77ee00e2a77ec6918dedd766","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["1d028314cced5858683a1bb4741423d0f934257b","f45457a742a53533c348c4b990b1c579ff364467"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"70b55953b6a72596cb534ead735a8b849a473cac":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"ced66195b26fdb1f77ee00e2a77ec6918dedd766":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["70b55953b6a72596cb534ead735a8b849a473cac"]},"commit2Childs":{"8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"3c188105a9aae04f56c24996f98f8333fc825d2e":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["1d028314cced5858683a1bb4741423d0f934257b"],"f45457a742a53533c348c4b990b1c579ff364467":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4","3c188105a9aae04f56c24996f98f8333fc825d2e","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"1d028314cced5858683a1bb4741423d0f934257b":["f45457a742a53533c348c4b990b1c579ff364467","d4d69c535930b5cce125cff868d40f6373dc27d4"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["70b55953b6a72596cb534ead735a8b849a473cac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"70b55953b6a72596cb534ead735a8b849a473cac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"ced66195b26fdb1f77ee00e2a77ec6918dedd766":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","1d028314cced5858683a1bb4741423d0f934257b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}