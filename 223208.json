{"path":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","commits":[{"id":"bd99abc71f9eda1ffb263a2ad3ab1564a1b2dc28","date":1471613297,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","pathOld":"/dev/null","sourceNew":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig()));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : atLeast(2);\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig()));\n              }\n            }\n            docs.close();\n            stop.set(true);\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().maxDoc());\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a7ba5082a5ef8031070cd426fa27dfe8469dfb2c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","pathOld":"/dev/null","sourceNew":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig()));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : atLeast(2);\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig()));\n              }\n            }\n            docs.close();\n            stop.set(true);\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().maxDoc());\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a7ba5082a5ef8031070cd426fa27dfe8469dfb2c","date":1473614565,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","sourceNew":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : atLeast(2);\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n              }\n            }\n            docs.close();\n            stop.set(true);\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().maxDoc());\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig()));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : atLeast(2);\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig()));\n              }\n            }\n            docs.close();\n            stop.set(true);\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().maxDoc());\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","bugFix":["bd99abc71f9eda1ffb263a2ad3ab1564a1b2dc28"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","sourceNew":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : atLeast(2);\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n              }\n            }\n            docs.close();\n            stop.set(true);\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().maxDoc());\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig()));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : atLeast(2);\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig()));\n              }\n            }\n            docs.close();\n            stop.set(true);\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().maxDoc());\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","sourceNew":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : atLeast(2);\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n              }\n            }\n            docs.close();\n            stop.set(true);\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().maxDoc());\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig()));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : atLeast(2);\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig()));\n              }\n            }\n            docs.close();\n            stop.set(true);\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().maxDoc());\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","pathOld":"/dev/null","sourceNew":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : atLeast(2);\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n              }\n            }\n            docs.close();\n            stop.set(true);\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().maxDoc());\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c66b89f95c24372e4e0bc443a1d8db9881cd509f","date":1524585453,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","sourceNew":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : atLeast(2);\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n              }\n            }\n            docs.close();\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().maxDoc());\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          } finally {\n            stop.set(true);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : atLeast(2);\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n              }\n            }\n            docs.close();\n            stop.set(true);\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().maxDoc());\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"feb4029567b43f074ed7b6eb8fb126d355075dfd","date":1544812585,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","sourceNew":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : atLeast(2);\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n              }\n            }\n            docs.close();\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().getDocStats().maxDoc);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          } finally {\n            stop.set(true);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : atLeast(2);\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n              }\n            }\n            docs.close();\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().maxDoc());\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          } finally {\n            stop.set(true);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f","date":1579652839,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","sourceNew":"  @Slow\n  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : 1;\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n              }\n            }\n            docs.close();\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().getDocStats().maxDoc);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          } finally {\n            stop.set(true);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : atLeast(2);\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n              }\n            }\n            docs.close();\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().getDocStats().maxDoc);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          } finally {\n            stop.set(true);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4208ed8e426ae5f75a41d8b4ae53f4587e413061","date":1580475454,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","sourceNew":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int numDocs = TEST_NIGHTLY ? atLeast(20000) : atLeast(200);\n            for (int i = 0; i < numDocs; i++) {\n              IndexWriter w = writerRef.get();\n              Document doc = new Document();\n              doc.add(newTextField(\"field\",\n                                   TestUtil.randomAnalysisString(random(), 256, false),\n                                   Field.Store.YES));\n              w.addDocument(doc);\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().getDocStats().maxDoc);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          } finally {\n            stop.set(true);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","sourceOld":"  @Slow\n  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            LineFileDocs docs = new LineFileDocs(random());\n            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : 1;\n            long endTime = System.nanoTime() + runTimeSec * 1000000000;\n            while (System.nanoTime() < endTime) {\n              IndexWriter w = writerRef.get();\n              w.addDocument(docs.nextDoc());\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n              }\n            }\n            docs.close();\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().getDocStats().maxDoc);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          } finally {\n            stop.set(true);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81b6049b4a65a8926e3a66746bfcff7a00a668c5","date":1587710166,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","sourceNew":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, ensureSaneIWCOnNigtly(newIndexWriterConfig(analyzer))));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int numDocs = TEST_NIGHTLY ? atLeast(20000) : atLeast(200);\n            for (int i = 0; i < numDocs; i++) {\n              IndexWriter w = writerRef.get();\n              Document doc = new Document();\n              doc.add(newTextField(\"field\",\n                                   TestUtil.randomAnalysisString(random(), 256, false),\n                                   Field.Store.YES));\n              w.addDocument(doc);\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, ensureSaneIWCOnNigtly(newIndexWriterConfig(analyzer))));\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().getDocStats().maxDoc);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          } finally {\n            stop.set(true);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int numDocs = TEST_NIGHTLY ? atLeast(20000) : atLeast(200);\n            for (int i = 0; i < numDocs; i++) {\n              IndexWriter w = writerRef.get();\n              Document doc = new Document();\n              doc.add(newTextField(\"field\",\n                                   TestUtil.randomAnalysisString(random(), 256, false),\n                                   Field.Store.YES));\n              w.addDocument(doc);\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().getDocStats().maxDoc);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          } finally {\n            stop.set(true);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e84628e1e00d06556b67af150a13dbfb1849a818","date":1588191102,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSearcherManager#testConcurrentIndexCloseSearchAndRefresh().mjava","sourceNew":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, ensureSaneIWCOnNightly(newIndexWriterConfig(analyzer))));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int numDocs = TEST_NIGHTLY ? atLeast(20000) : atLeast(200);\n            for (int i = 0; i < numDocs; i++) {\n              IndexWriter w = writerRef.get();\n              Document doc = new Document();\n              doc.add(newTextField(\"field\",\n                                   TestUtil.randomAnalysisString(random(), 256, false),\n                                   Field.Store.YES));\n              w.addDocument(doc);\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, ensureSaneIWCOnNightly(newIndexWriterConfig(analyzer))));\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().getDocStats().maxDoc);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          } finally {\n            stop.set(true);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {\n    final Directory dir = newFSDirectory(createTempDir());\n    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();\n    final MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);\n    writerRef.set(new IndexWriter(dir, ensureSaneIWCOnNigtly(newIndexWriterConfig(analyzer))));\n\n    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();\n    mgrRef.set(new SearcherManager(writerRef.get(), null));\n    final AtomicBoolean stop = new AtomicBoolean();\n\n    Thread indexThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int numDocs = TEST_NIGHTLY ? atLeast(20000) : atLeast(200);\n            for (int i = 0; i < numDocs; i++) {\n              IndexWriter w = writerRef.get();\n              Document doc = new Document();\n              doc.add(newTextField(\"field\",\n                                   TestUtil.randomAnalysisString(random(), 256, false),\n                                   Field.Store.YES));\n              w.addDocument(doc);\n              if (random().nextInt(1000) == 17) {\n                if (random().nextBoolean()) {\n                  w.close();\n                } else {\n                  w.rollback();\n                }\n                writerRef.set(new IndexWriter(dir, ensureSaneIWCOnNigtly(newIndexWriterConfig(analyzer))));\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: index count=\" + writerRef.get().getDocStats().maxDoc);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          } finally {\n            stop.set(true);\n          }\n        }\n      };\n\n    Thread searchThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            long totCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                IndexSearcher searcher;\n                try {\n                  searcher = mgr.acquire();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  continue;\n                }\n                totCount += searcher.getIndexReader().maxDoc();\n                mgr.release(searcher);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: search totCount=\" + totCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread refreshThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int refreshCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              if (mgr != null) {\n                refreshCount++;\n                try {\n                  mgr.maybeRefreshBlocking();\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                  continue;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: refresh count=\" + refreshCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    Thread closeThread = new Thread() {\n        @Override\n        public void run() {\n          try {\n            int closeCount = 0;\n            int aceCount = 0;\n            while (stop.get() == false) {\n              SearcherManager mgr = mgrRef.get();\n              assert mgr != null;\n              mgr.close();\n              closeCount++;\n              while (stop.get() == false) {\n                try {\n                  mgrRef.set(new SearcherManager(writerRef.get(), null));\n                  break;\n                } catch (AlreadyClosedException ace) {\n                  // ok\n                  aceCount++;\n                }\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(\"TEST: close count=\" + closeCount + \" aceCount=\" + aceCount);\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n      };\n\n    indexThread.start();\n    searchThread.start();\n    refreshThread.start();\n    closeThread.start();\n\n    indexThread.join();\n    searchThread.join();\n    refreshThread.join();\n    closeThread.join();\n\n    mgrRef.get().close();\n    writerRef.get().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["feb4029567b43f074ed7b6eb8fb126d355075dfd"],"e84628e1e00d06556b67af150a13dbfb1849a818":["81b6049b4a65a8926e3a66746bfcff7a00a668c5"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bd99abc71f9eda1ffb263a2ad3ab1564a1b2dc28"],"a7ba5082a5ef8031070cd426fa27dfe8469dfb2c":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"89424def13674ea17829b41c5883c54ecc31a132":["403d05f7f8d69b65659157eff1bc1d2717f04c66","a7ba5082a5ef8031070cd426fa27dfe8469dfb2c"],"c66b89f95c24372e4e0bc443a1d8db9881cd509f":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"feb4029567b43f074ed7b6eb8fb126d355075dfd":["c66b89f95c24372e4e0bc443a1d8db9881cd509f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["403d05f7f8d69b65659157eff1bc1d2717f04c66","89424def13674ea17829b41c5883c54ecc31a132"],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"bd99abc71f9eda1ffb263a2ad3ab1564a1b2dc28":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"81b6049b4a65a8926e3a66746bfcff7a00a668c5":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e84628e1e00d06556b67af150a13dbfb1849a818"]},"commit2Childs":{"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"e84628e1e00d06556b67af150a13dbfb1849a818":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["a7ba5082a5ef8031070cd426fa27dfe8469dfb2c","89424def13674ea17829b41c5883c54ecc31a132","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a7ba5082a5ef8031070cd426fa27dfe8469dfb2c":["89424def13674ea17829b41c5883c54ecc31a132"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"89424def13674ea17829b41c5883c54ecc31a132":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"c66b89f95c24372e4e0bc443a1d8db9881cd509f":["feb4029567b43f074ed7b6eb8fb126d355075dfd"],"feb4029567b43f074ed7b6eb8fb126d355075dfd":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["403d05f7f8d69b65659157eff1bc1d2717f04c66","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","bd99abc71f9eda1ffb263a2ad3ab1564a1b2dc28"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c66b89f95c24372e4e0bc443a1d8db9881cd509f"],"bd99abc71f9eda1ffb263a2ad3ab1564a1b2dc28":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["81b6049b4a65a8926e3a66746bfcff7a00a668c5"],"81b6049b4a65a8926e3a66746bfcff7a00a668c5":["e84628e1e00d06556b67af150a13dbfb1849a818"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}