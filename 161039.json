{"path":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dDistanceCalculator#pointOnBearing(Point,double,double,SpatialContext,Point).mjava","commits":[{"id":"57ac273b4e4637e6dd8cf5f2d90a474f897884d7","date":1505963386,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dDistanceCalculator#pointOnBearing(Point,double,double,SpatialContext,Point).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Point pointOnBearing(Point from, double distDEG, double bearingDEG, SpatialContext ctx, Point reuse) {\n    // Algorithm using Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae)\n    // which takes into account that planets may not be spherical.\n    //Code adaptation from http://www.movable-type.co.uk/scripts/latlong-vincenty.html\n    Geo3dPointShape geoFrom = (Geo3dPointShape) from;\n    GeoPoint point = (GeoPoint) geoFrom.shape;\n    double lat = point.getLatitude();\n    double lon = point.getLongitude();\n    double dist = DistanceUtils.DEGREES_TO_RADIANS * distDEG;\n    double bearing = DistanceUtils.DEGREES_TO_RADIANS * bearingDEG;\n\n    double sinα1 = Math.sin(bearing);\n    double cosα1 = Math.cos(bearing);\n\n    double tanU1 = (1 - planetModel.flattening) * Math.tan(lat);\n    double cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1));\n    double sinU1 = tanU1 * cosU1;\n\n    double σ1 = Math.atan2(tanU1, cosα1);\n    double sinα = cosU1 * sinα1;\n    double cosSqα = 1 - sinα * sinα;\n    double uSq = cosSqα * planetModel.squareRatio;// (planetModel.ab* planetModel.ab - planetModel.c*planetModel.c) / (planetModel.c*planetModel.c);\n    double A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\n    double B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n\n    double cos2σM;\n    double sinσ;\n    double cosσ;\n    double Δσ;\n\n    double σ = dist / (planetModel.c * A);\n    double σʹ;\n    double iterations = 0;\n    do {\n      cos2σM = Math.cos(2 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM * cos2σM) -\n          B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM * cos2σM)));\n      σʹ = σ;\n      σ = dist / (planetModel.c * A) + Δσ;\n    } while (Math.abs(σ - σʹ) > 1e-12 && ++iterations < 200);\n\n    if (iterations >= 200) {\n      throw new RuntimeException(\"Formula failed to converge\");\n    }\n\n    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1 - planetModel.flattening) * Math.sqrt(sinα * sinα + x * x));\n    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    double C = planetModel.flattening / 16 * cosSqα * (4 + planetModel.flattening * (4 - 3 * cosSqα));\n    double L = λ - (1 - C) * planetModel.flattening * sinα *\n        (σ + C * sinσ * (cos2σM + C * cosσ * (-1 + 2 * cos2σM * cos2σM)));\n    double λ2 = (lon + L + 3 * Math.PI) % (2 * Math.PI) - Math.PI;  // normalise to -180..+180\n\n    return ctx.getShapeFactory().pointXY(λ2 * DistanceUtils.RADIANS_TO_DEGREES,\n        φ2 * DistanceUtils.RADIANS_TO_DEGREES);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dDistanceCalculator#pointOnBearing(Point,double,double,SpatialContext,Point).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Point pointOnBearing(Point from, double distDEG, double bearingDEG, SpatialContext ctx, Point reuse) {\n    // Algorithm using Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae)\n    // which takes into account that planets may not be spherical.\n    //Code adaptation from http://www.movable-type.co.uk/scripts/latlong-vincenty.html\n    Geo3dPointShape geoFrom = (Geo3dPointShape) from;\n    GeoPoint point = (GeoPoint) geoFrom.shape;\n    double lat = point.getLatitude();\n    double lon = point.getLongitude();\n    double dist = DistanceUtils.DEGREES_TO_RADIANS * distDEG;\n    double bearing = DistanceUtils.DEGREES_TO_RADIANS * bearingDEG;\n\n    double sinα1 = Math.sin(bearing);\n    double cosα1 = Math.cos(bearing);\n\n    double tanU1 = (1 - planetModel.flattening) * Math.tan(lat);\n    double cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1));\n    double sinU1 = tanU1 * cosU1;\n\n    double σ1 = Math.atan2(tanU1, cosα1);\n    double sinα = cosU1 * sinα1;\n    double cosSqα = 1 - sinα * sinα;\n    double uSq = cosSqα * planetModel.squareRatio;// (planetModel.ab* planetModel.ab - planetModel.c*planetModel.c) / (planetModel.c*planetModel.c);\n    double A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\n    double B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n\n    double cos2σM;\n    double sinσ;\n    double cosσ;\n    double Δσ;\n\n    double σ = dist / (planetModel.c * A);\n    double σʹ;\n    double iterations = 0;\n    do {\n      cos2σM = Math.cos(2 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM * cos2σM) -\n          B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM * cos2σM)));\n      σʹ = σ;\n      σ = dist / (planetModel.c * A) + Δσ;\n    } while (Math.abs(σ - σʹ) > 1e-12 && ++iterations < 200);\n\n    if (iterations >= 200) {\n      throw new RuntimeException(\"Formula failed to converge\");\n    }\n\n    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1 - planetModel.flattening) * Math.sqrt(sinα * sinα + x * x));\n    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    double C = planetModel.flattening / 16 * cosSqα * (4 + planetModel.flattening * (4 - 3 * cosSqα));\n    double L = λ - (1 - C) * planetModel.flattening * sinα *\n        (σ + C * sinσ * (cos2σM + C * cosσ * (-1 + 2 * cos2σM * cos2σM)));\n    double λ2 = (lon + L + 3 * Math.PI) % (2 * Math.PI) - Math.PI;  // normalise to -180..+180\n\n    return ctx.getShapeFactory().pointXY(λ2 * DistanceUtils.RADIANS_TO_DEGREES,\n        φ2 * DistanceUtils.RADIANS_TO_DEGREES);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85da33268a9a33d1a1dc71ad826ff61037f42cbf","date":1513200768,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dDistanceCalculator#pointOnBearing(Point,double,double,SpatialContext,Point).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dDistanceCalculator#pointOnBearing(Point,double,double,SpatialContext,Point).mjava","sourceNew":"  @Override\n  public Point pointOnBearing(Point from, double distDEG, double bearingDEG, SpatialContext ctx, Point reuse) {\n    Geo3dPointShape geoFrom = (Geo3dPointShape) from;\n    GeoPoint point = (GeoPoint) geoFrom.shape;\n    double dist = DistanceUtils.DEGREES_TO_RADIANS * distDEG;\n    double bearing = DistanceUtils.DEGREES_TO_RADIANS * bearingDEG;\n    GeoPoint newPoint = planetModel.surfacePointOnBearing(point, dist, bearing);\n    double newLat = newPoint.getLatitude() * DistanceUtils.RADIANS_TO_DEGREES;\n    double newLon = newPoint.getLongitude() * DistanceUtils.RADIANS_TO_DEGREES;\n    if (reuse != null) {\n      reuse.reset(newLon, newLat);\n      return reuse;\n    }\n    else {\n      return ctx.getShapeFactory().pointXY(newLon, newLat);\n    }\n  }\n\n","sourceOld":"  @Override\n  public Point pointOnBearing(Point from, double distDEG, double bearingDEG, SpatialContext ctx, Point reuse) {\n    // Algorithm using Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae)\n    // which takes into account that planets may not be spherical.\n    //Code adaptation from http://www.movable-type.co.uk/scripts/latlong-vincenty.html\n    Geo3dPointShape geoFrom = (Geo3dPointShape) from;\n    GeoPoint point = (GeoPoint) geoFrom.shape;\n    double lat = point.getLatitude();\n    double lon = point.getLongitude();\n    double dist = DistanceUtils.DEGREES_TO_RADIANS * distDEG;\n    double bearing = DistanceUtils.DEGREES_TO_RADIANS * bearingDEG;\n\n    double sinα1 = Math.sin(bearing);\n    double cosα1 = Math.cos(bearing);\n\n    double tanU1 = (1 - planetModel.flattening) * Math.tan(lat);\n    double cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1));\n    double sinU1 = tanU1 * cosU1;\n\n    double σ1 = Math.atan2(tanU1, cosα1);\n    double sinα = cosU1 * sinα1;\n    double cosSqα = 1 - sinα * sinα;\n    double uSq = cosSqα * planetModel.squareRatio;// (planetModel.ab* planetModel.ab - planetModel.c*planetModel.c) / (planetModel.c*planetModel.c);\n    double A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\n    double B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n\n    double cos2σM;\n    double sinσ;\n    double cosσ;\n    double Δσ;\n\n    double σ = dist / (planetModel.c * A);\n    double σʹ;\n    double iterations = 0;\n    do {\n      cos2σM = Math.cos(2 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM * cos2σM) -\n          B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM * cos2σM)));\n      σʹ = σ;\n      σ = dist / (planetModel.c * A) + Δσ;\n    } while (Math.abs(σ - σʹ) > 1e-12 && ++iterations < 200);\n\n    if (iterations >= 200) {\n      throw new RuntimeException(\"Formula failed to converge\");\n    }\n\n    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1 - planetModel.flattening) * Math.sqrt(sinα * sinα + x * x));\n    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    double C = planetModel.flattening / 16 * cosSqα * (4 + planetModel.flattening * (4 - 3 * cosSqα));\n    double L = λ - (1 - C) * planetModel.flattening * sinα *\n        (σ + C * sinσ * (cos2σM + C * cosσ * (-1 + 2 * cos2σM * cos2σM)));\n    double λ2 = (lon + L + 3 * Math.PI) % (2 * Math.PI) - Math.PI;  // normalise to -180..+180\n\n    return ctx.getShapeFactory().pointXY(λ2 * DistanceUtils.RADIANS_TO_DEGREES,\n        φ2 * DistanceUtils.RADIANS_TO_DEGREES);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"85da33268a9a33d1a1dc71ad826ff61037f42cbf":["57ac273b4e4637e6dd8cf5f2d90a474f897884d7"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","57ac273b4e4637e6dd8cf5f2d90a474f897884d7"],"57ac273b4e4637e6dd8cf5f2d90a474f897884d7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["85da33268a9a33d1a1dc71ad826ff61037f42cbf"]},"commit2Childs":{"85da33268a9a33d1a1dc71ad826ff61037f42cbf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"57ac273b4e4637e6dd8cf5f2d90a474f897884d7":["85da33268a9a33d1a1dc71ad826ff61037f42cbf","6240b74b884c5587f2a4062dd27d6c32bf228889"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6240b74b884c5587f2a4062dd27d6c32bf228889","57ac273b4e4637e6dd8cf5f2d90a474f897884d7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6240b74b884c5587f2a4062dd27d6c32bf228889","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}