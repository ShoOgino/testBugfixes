{"path":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#updateContext(SortedSetDocValues).mjava","commits":[{"id":"84b24f47dd3dfa4e2396cd6f819a35445b0a53fd","date":1406137403,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#updateContext(SortedSetDocValues).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Update the ordinals based on the current reader. This method\n     * (or {@link #updateContext(SortedDocValues)} depending on the\n     * DocValues type) needs to be called for every reader before\n     * {@link #includes(long)} is called on any document of the reader.\n     *\n     * @param sdv DocValues for the current reader\n     */\n    public void updateContext(SortedSetDocValues sdv) {\n      if (start == null) {\n        /*\n         * Unset start. All ordinals will be greater than -1.\n         */\n        startLimit = -1;\n      } else {\n        startLimit = sdv.lookupTerm(start);\n        if (startLimit < 0) {\n          /*\n           * The term was not found in this segment. We'll use inserting-point as\n           * start ordinal (then, to be included in the interval, an ordinal needs to be\n           * greater or equal to startLimit)\n           */\n          startLimit = (startLimit * -1) - 1;\n        } else {\n          /*\n           * The term exists in this segment, If the interval has start open (the limit is\n           * excluded), then we move one ordinal higher. Then, to be included in the \n           * interval, an ordinal needs to be greater or equal to startLimit\n           */\n          if (startOpen) {\n            startLimit++;\n          }\n        }\n      }\n      if (end == null) {\n        /*\n         * Unset end. All ordinals will be lower than Long.MAX_VALUE.\n         */\n        endLimit = Long.MAX_VALUE;\n      } else {\n        endLimit = sdv.lookupTerm(end);\n        if (endLimit < 0) {\n          /*\n           * The term was not found in this segment. We'll use insertion-point -1 as\n           * endLimit. To be included in this interval, ordinals must be lower or \n           * equal to endLimit\n           */\n          endLimit = (endLimit * -1) - 2;\n        } else {\n          /*\n           * The term exists in this segment, If the interval has start open (the \n           * limit is excluded), then we move one ordinal lower. Then, to be\n           * included in the interval, an ordinal needs to be lower or equal to  \n           * endLimit\n           */\n          if (endOpen) {\n            endLimit--;\n          }\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["f7558b5077dd4abd457be151475f13b541f4f13e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7558b5077dd4abd457be151475f13b541f4f13e","date":1475830751,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#updateContext(SortedSetDocValues).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#updateContext(SortedSetDocValues).mjava","sourceNew":"    /**\n     * Update the ordinals based on the current reader. This method\n     * (or {@link #updateContext(SortedDocValues)} depending on the\n     * DocValues type) needs to be called for every reader before\n     * {@link #includes(long)} is called on any document of the reader.\n     *\n     * @param sdv DocValues for the current reader\n     */\n    public void updateContext(SortedSetDocValues sdv) throws IOException {\n      if (start == null) {\n        /*\n         * Unset start. All ordinals will be greater than -1.\n         */\n        startLimit = -1;\n      } else {\n        startLimit = sdv.lookupTerm(start);\n        if (startLimit < 0) {\n          /*\n           * The term was not found in this segment. We'll use inserting-point as\n           * start ordinal (then, to be included in the interval, an ordinal needs to be\n           * greater or equal to startLimit)\n           */\n          startLimit = (startLimit * -1) - 1;\n        } else {\n          /*\n           * The term exists in this segment, If the interval has start open (the limit is\n           * excluded), then we move one ordinal higher. Then, to be included in the \n           * interval, an ordinal needs to be greater or equal to startLimit\n           */\n          if (startOpen) {\n            startLimit++;\n          }\n        }\n      }\n      if (end == null) {\n        /*\n         * Unset end. All ordinals will be lower than Long.MAX_VALUE.\n         */\n        endLimit = Long.MAX_VALUE;\n      } else {\n        endLimit = sdv.lookupTerm(end);\n        if (endLimit < 0) {\n          /*\n           * The term was not found in this segment. We'll use insertion-point -1 as\n           * endLimit. To be included in this interval, ordinals must be lower or \n           * equal to endLimit\n           */\n          endLimit = (endLimit * -1) - 2;\n        } else {\n          /*\n           * The term exists in this segment, If the interval has start open (the \n           * limit is excluded), then we move one ordinal lower. Then, to be\n           * included in the interval, an ordinal needs to be lower or equal to  \n           * endLimit\n           */\n          if (endOpen) {\n            endLimit--;\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Update the ordinals based on the current reader. This method\n     * (or {@link #updateContext(SortedDocValues)} depending on the\n     * DocValues type) needs to be called for every reader before\n     * {@link #includes(long)} is called on any document of the reader.\n     *\n     * @param sdv DocValues for the current reader\n     */\n    public void updateContext(SortedSetDocValues sdv) {\n      if (start == null) {\n        /*\n         * Unset start. All ordinals will be greater than -1.\n         */\n        startLimit = -1;\n      } else {\n        startLimit = sdv.lookupTerm(start);\n        if (startLimit < 0) {\n          /*\n           * The term was not found in this segment. We'll use inserting-point as\n           * start ordinal (then, to be included in the interval, an ordinal needs to be\n           * greater or equal to startLimit)\n           */\n          startLimit = (startLimit * -1) - 1;\n        } else {\n          /*\n           * The term exists in this segment, If the interval has start open (the limit is\n           * excluded), then we move one ordinal higher. Then, to be included in the \n           * interval, an ordinal needs to be greater or equal to startLimit\n           */\n          if (startOpen) {\n            startLimit++;\n          }\n        }\n      }\n      if (end == null) {\n        /*\n         * Unset end. All ordinals will be lower than Long.MAX_VALUE.\n         */\n        endLimit = Long.MAX_VALUE;\n      } else {\n        endLimit = sdv.lookupTerm(end);\n        if (endLimit < 0) {\n          /*\n           * The term was not found in this segment. We'll use insertion-point -1 as\n           * endLimit. To be included in this interval, ordinals must be lower or \n           * equal to endLimit\n           */\n          endLimit = (endLimit * -1) - 2;\n        } else {\n          /*\n           * The term exists in this segment, If the interval has start open (the \n           * limit is excluded), then we move one ordinal lower. Then, to be\n           * included in the interval, an ordinal needs to be lower or equal to  \n           * endLimit\n           */\n          if (endOpen) {\n            endLimit--;\n          }\n        }\n      }\n    }\n\n","bugFix":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#updateContext(SortedSetDocValues).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#updateContext(SortedSetDocValues).mjava","sourceNew":"    /**\n     * Update the ordinals based on the current reader. This method\n     * (or {@link #updateContext(SortedDocValues)} depending on the\n     * DocValues type) needs to be called for every reader before\n     * {@link #includes(long)} is called on any document of the reader.\n     *\n     * @param sdv DocValues for the current reader\n     */\n    public void updateContext(SortedSetDocValues sdv) throws IOException {\n      if (start == null) {\n        /*\n         * Unset start. All ordinals will be greater than -1.\n         */\n        startLimit = -1;\n      } else {\n        startLimit = sdv.lookupTerm(start);\n        if (startLimit < 0) {\n          /*\n           * The term was not found in this segment. We'll use inserting-point as\n           * start ordinal (then, to be included in the interval, an ordinal needs to be\n           * greater or equal to startLimit)\n           */\n          startLimit = (startLimit * -1) - 1;\n        } else {\n          /*\n           * The term exists in this segment, If the interval has start open (the limit is\n           * excluded), then we move one ordinal higher. Then, to be included in the \n           * interval, an ordinal needs to be greater or equal to startLimit\n           */\n          if (startOpen) {\n            startLimit++;\n          }\n        }\n      }\n      if (end == null) {\n        /*\n         * Unset end. All ordinals will be lower than Long.MAX_VALUE.\n         */\n        endLimit = Long.MAX_VALUE;\n      } else {\n        endLimit = sdv.lookupTerm(end);\n        if (endLimit < 0) {\n          /*\n           * The term was not found in this segment. We'll use insertion-point -1 as\n           * endLimit. To be included in this interval, ordinals must be lower or \n           * equal to endLimit\n           */\n          endLimit = (endLimit * -1) - 2;\n        } else {\n          /*\n           * The term exists in this segment, If the interval has start open (the \n           * limit is excluded), then we move one ordinal lower. Then, to be\n           * included in the interval, an ordinal needs to be lower or equal to  \n           * endLimit\n           */\n          if (endOpen) {\n            endLimit--;\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Update the ordinals based on the current reader. This method\n     * (or {@link #updateContext(SortedDocValues)} depending on the\n     * DocValues type) needs to be called for every reader before\n     * {@link #includes(long)} is called on any document of the reader.\n     *\n     * @param sdv DocValues for the current reader\n     */\n    public void updateContext(SortedSetDocValues sdv) {\n      if (start == null) {\n        /*\n         * Unset start. All ordinals will be greater than -1.\n         */\n        startLimit = -1;\n      } else {\n        startLimit = sdv.lookupTerm(start);\n        if (startLimit < 0) {\n          /*\n           * The term was not found in this segment. We'll use inserting-point as\n           * start ordinal (then, to be included in the interval, an ordinal needs to be\n           * greater or equal to startLimit)\n           */\n          startLimit = (startLimit * -1) - 1;\n        } else {\n          /*\n           * The term exists in this segment, If the interval has start open (the limit is\n           * excluded), then we move one ordinal higher. Then, to be included in the \n           * interval, an ordinal needs to be greater or equal to startLimit\n           */\n          if (startOpen) {\n            startLimit++;\n          }\n        }\n      }\n      if (end == null) {\n        /*\n         * Unset end. All ordinals will be lower than Long.MAX_VALUE.\n         */\n        endLimit = Long.MAX_VALUE;\n      } else {\n        endLimit = sdv.lookupTerm(end);\n        if (endLimit < 0) {\n          /*\n           * The term was not found in this segment. We'll use insertion-point -1 as\n           * endLimit. To be included in this interval, ordinals must be lower or \n           * equal to endLimit\n           */\n          endLimit = (endLimit * -1) - 2;\n        } else {\n          /*\n           * The term exists in this segment, If the interval has start open (the \n           * limit is excluded), then we move one ordinal lower. Then, to be\n           * included in the interval, an ordinal needs to be lower or equal to  \n           * endLimit\n           */\n          if (endOpen) {\n            endLimit--;\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f7558b5077dd4abd457be151475f13b541f4f13e":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"84b24f47dd3dfa4e2396cd6f819a35445b0a53fd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd","f7558b5077dd4abd457be151475f13b541f4f13e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f7558b5077dd4abd457be151475f13b541f4f13e"]},"commit2Childs":{"f7558b5077dd4abd457be151475f13b541f4f13e":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd"],"84b24f47dd3dfa4e2396cd6f819a35445b0a53fd":["f7558b5077dd4abd457be151475f13b541f4f13e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}