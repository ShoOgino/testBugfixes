{"path":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","commits":[{"id":"a94e45463a0089149b0d148ae5369140e7f54b8c","date":1419231934,"type":0,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      q = q.rewrite(searcher.getIndexReader());\n      HashSet<Term> terms = new HashSet<Term>();\n      q.extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<String,TermStats>();\n      HashMap<String,CollectionStats> colMap = new HashMap<String,CollectionStats>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n        \n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n        \n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(\n              t.field(),\n              new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n      }\n      \n      String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n      rb.rsp.add(TERM_STATS_KEY, termStatsString);\n      String colStatsString = StatsUtil.colStatsMapToString(colMap);\n      rb.rsp.add(COL_STATS_KEY, colStatsString);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"termStats=\" + termStatsString + \", collectionStats=\"\n            + colStatsString + \", terms=\" + terms + \", numDocs=\"\n            + searcher.maxDoc());\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c3119ed4143b91eaf5ac74a4dc4625f5036d472c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05c52ac194342b760b830342ee8423fcf00e54d0","date":1429197275,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<Term>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<String,TermStats>();\n      HashMap<String,CollectionStats> colMap = new HashMap<String,CollectionStats>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n        \n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n        \n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(\n              t.field(),\n              new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n      }\n      \n      String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n      rb.rsp.add(TERM_STATS_KEY, termStatsString);\n      String colStatsString = StatsUtil.colStatsMapToString(colMap);\n      rb.rsp.add(COL_STATS_KEY, colStatsString);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"termStats=\" + termStatsString + \", collectionStats=\"\n            + colStatsString + \", terms=\" + terms + \", numDocs=\"\n            + searcher.maxDoc());\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      q = q.rewrite(searcher.getIndexReader());\n      HashSet<Term> terms = new HashSet<Term>();\n      q.extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<String,TermStats>();\n      HashMap<String,CollectionStats> colMap = new HashMap<String,CollectionStats>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n        \n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n        \n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(\n              t.field(),\n              new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n      }\n      \n      String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n      rb.rsp.add(TERM_STATS_KEY, termStatsString);\n      String colStatsString = StatsUtil.colStatsMapToString(colMap);\n      rb.rsp.add(COL_STATS_KEY, colStatsString);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"termStats=\" + termStatsString + \", collectionStats=\"\n            + colStatsString + \", terms=\" + terms + \", numDocs=\"\n            + searcher.maxDoc());\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc9c42f0c1f89f2b3964f2d39efe57860e578838","date":1438774812,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(t.field(), new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n      }\n      if (statsMap.size() != 0 && colMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats=\" + termStatsString + \", collectionStats=\"\n              + colStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<Term>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<String,TermStats>();\n      HashMap<String,CollectionStats> colMap = new HashMap<String,CollectionStats>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n        \n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n        \n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(\n              t.field(),\n              new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n      }\n      \n      String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n      rb.rsp.add(TERM_STATS_KEY, termStatsString);\n      String colStatsString = StatsUtil.colStatsMapToString(colMap);\n      rb.rsp.add(COL_STATS_KEY, colStatsString);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"termStats=\" + termStatsString + \", collectionStats=\"\n            + colStatsString + \", terms=\" + terms + \", numDocs=\"\n            + searcher.maxDoc());\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"295883c599f058f44454387d45144818e02296d5","date":1497292073,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(t.field(), new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats=\" + termStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats=\"\n              + colStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(t.field(), new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n      }\n      if (statsMap.size() != 0 && colMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats=\" + termStatsString + \", collectionStats=\"\n              + colStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":["c3119ed4143b91eaf5ac74a4dc4625f5036d472c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(t.field(), new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats=\" + termStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats=\"\n              + colStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(t.field(), new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n      }\n      if (statsMap.size() != 0 && colMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats=\" + termStatsString + \", collectionStats=\"\n              + colStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(t.field(), new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats=\" + termStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats=\"\n              + colStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(t.field(), new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n      }\n      if (statsMap.size() != 0 && colMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats=\" + termStatsString + \", collectionStats=\"\n              + colStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cec580eab009ed7a9afea0f3be7646b5a4f1ca60","date":1499445439,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(t.field(), new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(t.field(), new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats=\" + termStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats=\"\n              + colStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f9a989a32a073c55e3aef6f807a3474184bbcf49","date":1499930209,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(t.field(), new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(t.field(), new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats=\" + termStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats=\"\n              + colStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb569fd721c41eafc2a2d788499a7df490c7f1a5","date":1499930871,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(t.field(), new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(t.field(), new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats=\" + termStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats=\"\n              + colStatsString + \", terms=\" + terms + \", numDocs=\" + searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3119ed4143b91eaf5ac74a4dc4625f5036d472c","date":1509409932,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          colMap.put(t.field(), new CollectionStats(searcher.localCollectionStatistics(t.field())));\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst.docFreq() == 0) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":["295883c599f058f44454387d45144818e02296d5","a94e45463a0089149b0d148ae5369140e7f54b8c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, ScoreMode.COMPLETE).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, ScoreMode.COMPLETE).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, true).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6e9f769521480a623f897c0d59089b919fa4239","date":1515161835,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, ScoreMode.COMPLETE).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermStates termStates = TermStates.build(context, t, true);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termStates);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, ScoreMode.COMPLETE).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, ScoreMode.COMPLETE).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermStates termStates = TermStates.build(context, t, true);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termStates);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, ScoreMode.COMPLETE).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermContext termContext = TermContext.build(context, t);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termContext);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"475584d5e08a22ad3fc7babefe006d77bc744567","date":1523282824,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermStates termStates = TermStates.build(context, t, true);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termStates);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, ScoreMode.COMPLETE).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermStates termStates = TermStates.build(context, t, true);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termStates);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d58e44159788900f4a2113b84463dc3fbbf80f20","date":1523319203,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermStates termStates = TermStates.build(context, t, true);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termStates);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createNormalizedWeight(q, ScoreMode.COMPLETE).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermStates termStates = TermStates.build(context, t, true);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termStates);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermStates termStates = TermStates.build(context, t, true);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termStates);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      log.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermStates termStates = TermStates.build(context, t, true);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termStates);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7","date":1552575873,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      IndexSearcher statsCollectingSearcher = new IndexSearcher(searcher.getIndexReader()){\n        @Override\n        public CollectionStatistics collectionStatistics(String field) throws IOException {\n          CollectionStatistics cs = super.collectionStatistics(field);\n          if (cs != null) {\n            colMap.put(field, new CollectionStats(cs));\n          }\n          return cs;\n        }\n\n        @Override\n        public TermStatistics termStatistics(Term term, TermStates context) throws IOException {\n          TermStatistics ts = super.termStatistics(term, context);\n          if (ts == null) {\n            return null;\n          }\n          terms.add(term);\n          statsMap.put(term.toString(), new TermStats(term.field(), ts));\n          return ts;\n        }\n      };\n      statsCollectingSearcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1);\n\n      for (Term t : terms) {\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      log.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      searcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1).extractTerms(terms);\n      IndexReaderContext context = searcher.getTopReaderContext();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      for (Term t : terms) {\n        TermStates termStates = TermStates.build(context, t, true);\n\n        if (!colMap.containsKey(t.field())) { // collection stats for this field\n          CollectionStatistics collectionStatistics = searcher.localCollectionStatistics(t.field());\n          if (collectionStatistics != null) {\n            colMap.put(t.field(), new CollectionStats(collectionStatistics));\n          }\n        }\n\n        TermStatistics tst = searcher.localTermStatistics(t, termStates);\n        if (tst == null) { // skip terms that are not present here\n          continue;\n        }\n\n        statsMap.put(t.toString(), new TermStats(t.field(), tst));\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      log.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19238c4860c45945f1b1e39032e056ce9e266152","date":1568753304,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      IndexSearcher statsCollectingSearcher = new IndexSearcher(searcher.getIndexReader()){\n        @Override\n        public CollectionStatistics collectionStatistics(String field) throws IOException {\n          CollectionStatistics cs = super.collectionStatistics(field);\n          if (cs != null) {\n            colMap.put(field, new CollectionStats(cs));\n          }\n          return cs;\n        }\n\n        @Override\n        public TermStatistics termStatistics(Term term, int docFreq, long totalTermFreq) throws IOException {\n          TermStatistics ts = super.termStatistics(term, docFreq, totalTermFreq);\n          terms.add(term);\n          statsMap.put(term.toString(), new TermStats(term.field(), ts));\n          return ts;\n        }\n      };\n      statsCollectingSearcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1);\n\n      for (Term t : terms) {\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      log.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      IndexSearcher statsCollectingSearcher = new IndexSearcher(searcher.getIndexReader()){\n        @Override\n        public CollectionStatistics collectionStatistics(String field) throws IOException {\n          CollectionStatistics cs = super.collectionStatistics(field);\n          if (cs != null) {\n            colMap.put(field, new CollectionStats(cs));\n          }\n          return cs;\n        }\n\n        @Override\n        public TermStatistics termStatistics(Term term, TermStates context) throws IOException {\n          TermStatistics ts = super.termStatistics(term, context);\n          if (ts == null) {\n            return null;\n          }\n          terms.add(term);\n          statsMap.put(term.toString(), new TermStats(term.field(), ts));\n          return ts;\n        }\n      };\n      statsCollectingSearcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1);\n\n      for (Term t : terms) {\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      log.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df72a23fb74bebe914e3f3972063a884327c0436","date":1570470832,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#doReturnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  protected void doReturnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      Set<Term> additionalTerms = StatsUtil.termsFromEncodedString(rb.req.getParams().get(TERMS_KEY));\n      Set<String> additionalFields = StatsUtil.fieldsFromString(rb.req.getParams().get(FIELDS_KEY));\n      HashSet<Term> terms = new HashSet<>();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      IndexSearcher statsCollectingSearcher = new IndexSearcher(searcher.getIndexReader()){\n        @Override\n        public CollectionStatistics collectionStatistics(String field) throws IOException {\n          CollectionStatistics cs = super.collectionStatistics(field);\n          if (cs != null) {\n            colMap.put(field, new CollectionStats(cs));\n          }\n          return cs;\n        }\n\n        @Override\n        public TermStatistics termStatistics(Term term, int docFreq, long totalTermFreq) throws IOException {\n          TermStatistics ts = super.termStatistics(term, docFreq, totalTermFreq);\n          terms.add(term);\n          statsMap.put(term.toString(), new TermStats(term.field(), ts));\n          return ts;\n        }\n      };\n      statsCollectingSearcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1);\n      for (String field : additionalFields) {\n        if (colMap.containsKey(field)) {\n          continue;\n        }\n        statsCollectingSearcher.collectionStatistics(field);\n      }\n      for (Term term : additionalTerms) {\n        statsCollectingSearcher.createWeight(searcher.rewrite(new TermQuery(term)), ScoreMode.COMPLETE, 1);\n      }\n\n      CloudDescriptor cloudDescriptor = searcher.getCore().getCoreDescriptor().getCloudDescriptor();\n      if (cloudDescriptor != null) {\n        rb.rsp.add(ShardParams.SHARD_NAME, cloudDescriptor.getShardId());\n      }\n      if (!terms.isEmpty()) {\n        rb.rsp.add(TERMS_KEY, StatsUtil.termsToEncodedString(terms));\n      }\n      if (!statsMap.isEmpty()) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (!colMap.isEmpty()) {\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      log.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      IndexSearcher statsCollectingSearcher = new IndexSearcher(searcher.getIndexReader()){\n        @Override\n        public CollectionStatistics collectionStatistics(String field) throws IOException {\n          CollectionStatistics cs = super.collectionStatistics(field);\n          if (cs != null) {\n            colMap.put(field, new CollectionStats(cs));\n          }\n          return cs;\n        }\n\n        @Override\n        public TermStatistics termStatistics(Term term, int docFreq, long totalTermFreq) throws IOException {\n          TermStatistics ts = super.termStatistics(term, docFreq, totalTermFreq);\n          terms.add(term);\n          statsMap.put(term.toString(), new TermStats(term.field(), ts));\n          return ts;\n        }\n      };\n      statsCollectingSearcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1);\n\n      for (Term t : terms) {\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      log.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":4,"author":"jimczi","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      IndexSearcher statsCollectingSearcher = new IndexSearcher(searcher.getIndexReader()){\n        @Override\n        public CollectionStatistics collectionStatistics(String field) throws IOException {\n          CollectionStatistics cs = super.collectionStatistics(field);\n          if (cs != null) {\n            colMap.put(field, new CollectionStats(cs));\n          }\n          return cs;\n        }\n\n        @Override\n        public TermStatistics termStatistics(Term term, int docFreq, long totalTermFreq) throws IOException {\n          TermStatistics ts = super.termStatistics(term, docFreq, totalTermFreq);\n          terms.add(term);\n          statsMap.put(term.toString(), new TermStats(term.field(), ts));\n          return ts;\n        }\n      };\n      statsCollectingSearcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1);\n\n      for (Term t : terms) {\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      log.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["417142ff08fda9cf0b72d5133e63097a166c6458","a6e9f769521480a623f897c0d59089b919fa4239"],"475584d5e08a22ad3fc7babefe006d77bc744567":["b94236357aaa22b76c10629851fe4e376e0cea82"],"fb569fd721c41eafc2a2d788499a7df490c7f1a5":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","f9a989a32a073c55e3aef6f807a3474184bbcf49"],"19238c4860c45945f1b1e39032e056ce9e266152":["5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7"],"df72a23fb74bebe914e3f3972063a884327c0436":["19238c4860c45945f1b1e39032e056ce9e266152"],"05c52ac194342b760b830342ee8423fcf00e54d0":["a94e45463a0089149b0d148ae5369140e7f54b8c"],"295883c599f058f44454387d45144818e02296d5":["cc9c42f0c1f89f2b3964f2d39efe57860e578838"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["cc9c42f0c1f89f2b3964f2d39efe57860e578838","295883c599f058f44454387d45144818e02296d5"],"28288370235ed02234a64753cdbf0c6ec096304a":["cc9c42f0c1f89f2b3964f2d39efe57860e578838","295883c599f058f44454387d45144818e02296d5"],"f9a989a32a073c55e3aef6f807a3474184bbcf49":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cec580eab009ed7a9afea0f3be7646b5a4f1ca60"],"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"417142ff08fda9cf0b72d5133e63097a166c6458":["c3119ed4143b91eaf5ac74a4dc4625f5036d472c","9fc47cb7b4346802411bb432f501ed0673d7119e"],"a94e45463a0089149b0d148ae5369140e7f54b8c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["b94236357aaa22b76c10629851fe4e376e0cea82","475584d5e08a22ad3fc7babefe006d77bc744567"],"a6e9f769521480a623f897c0d59089b919fa4239":["417142ff08fda9cf0b72d5133e63097a166c6458"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cec580eab009ed7a9afea0f3be7646b5a4f1ca60":["28288370235ed02234a64753cdbf0c6ec096304a"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["c3119ed4143b91eaf5ac74a4dc4625f5036d472c"],"cc9c42f0c1f89f2b3964f2d39efe57860e578838":["05c52ac194342b760b830342ee8423fcf00e54d0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["df72a23fb74bebe914e3f3972063a884327c0436"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"c3119ed4143b91eaf5ac74a4dc4625f5036d472c":["cec580eab009ed7a9afea0f3be7646b5a4f1ca60"],"b0b597c65628ca9e73913a07e81691f8229bae35":["19238c4860c45945f1b1e39032e056ce9e266152","df72a23fb74bebe914e3f3972063a884327c0436"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["475584d5e08a22ad3fc7babefe006d77bc744567","d58e44159788900f4a2113b84463dc3fbbf80f20"],"475584d5e08a22ad3fc7babefe006d77bc744567":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"fb569fd721c41eafc2a2d788499a7df490c7f1a5":[],"19238c4860c45945f1b1e39032e056ce9e266152":["df72a23fb74bebe914e3f3972063a884327c0436","b0b597c65628ca9e73913a07e81691f8229bae35"],"df72a23fb74bebe914e3f3972063a884327c0436":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["fb569fd721c41eafc2a2d788499a7df490c7f1a5","f9a989a32a073c55e3aef6f807a3474184bbcf49"],"05c52ac194342b760b830342ee8423fcf00e54d0":["cc9c42f0c1f89f2b3964f2d39efe57860e578838"],"295883c599f058f44454387d45144818e02296d5":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"f9a989a32a073c55e3aef6f807a3474184bbcf49":["fb569fd721c41eafc2a2d788499a7df490c7f1a5"],"28288370235ed02234a64753cdbf0c6ec096304a":["cec580eab009ed7a9afea0f3be7646b5a4f1ca60"],"417142ff08fda9cf0b72d5133e63097a166c6458":["b94236357aaa22b76c10629851fe4e376e0cea82","a6e9f769521480a623f897c0d59089b919fa4239"],"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7":["19238c4860c45945f1b1e39032e056ce9e266152"],"a94e45463a0089149b0d148ae5369140e7f54b8c":["05c52ac194342b760b830342ee8423fcf00e54d0"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"a6e9f769521480a623f897c0d59089b919fa4239":["b94236357aaa22b76c10629851fe4e376e0cea82"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a94e45463a0089149b0d148ae5369140e7f54b8c"],"cec580eab009ed7a9afea0f3be7646b5a4f1ca60":["f9a989a32a073c55e3aef6f807a3474184bbcf49","c3119ed4143b91eaf5ac74a4dc4625f5036d472c"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"cc9c42f0c1f89f2b3964f2d39efe57860e578838":["295883c599f058f44454387d45144818e02296d5","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7"],"c3119ed4143b91eaf5ac74a4dc4625f5036d472c":["417142ff08fda9cf0b72d5133e63097a166c6458","9fc47cb7b4346802411bb432f501ed0673d7119e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["fb569fd721c41eafc2a2d788499a7df490c7f1a5","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}