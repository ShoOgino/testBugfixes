{"path":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekCeil(BytesRef).mjava","commits":[{"id":"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e","date":1400786907,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekCeil(BytesRef).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekCeil(BytesRef).mjava","sourceNew":"  @Override\n  public SeekStatus seekCeil(final BytesRef target) throws IOException {\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n   \n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n    //if (DEBUG) {\n    //System.out.println(\"\\nBTTR.seekCeil seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + target.utf8ToString() + \" \" + target + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=  \" + validIndexPrefix);\n    //printSeekState();\n    //}\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      //if (DEBUG) {\n      //System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //}\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n          \n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TOOD: we should write our vLong backwards (MSB\n      // first) to get better sharing from the FST\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        //if (DEBUG) {\n        //System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        //}\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        // TOOD: we could save the outputs in local\n        // byte[][] instead of making new objs ever\n        // seek; but, often the FST doesn't have any\n        // shared bytes (but this could change if we\n        // reverse vLong byte order)\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame:\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          //if (DEBUG) {\n          //System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          //}\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        //if (DEBUG) {\n        //System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); clear frame.scanned ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        //if (DEBUG) {\n        //System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current; return FOUND\");\n          //}\n          return SeekStatus.FOUND;\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current but term doesn't exist\");\n          //}\n        }\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      //if (DEBUG) {\n      //System.out.println(\"    no seek state; push root frame\");\n      //}\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    //if (DEBUG) {\n    //System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord+1=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    //}\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, false);\n        if (result == SeekStatus.END) {\n          term.copyBytes(target);\n          termExists = false;\n\n          if (next() != null) {\n            //if (DEBUG) {\n            //System.out.println(\"  return NOT_FOUND term=\" + brToString(term) + \" \" + term);\n            //}\n            return SeekStatus.NOT_FOUND;\n          } else {\n            //if (DEBUG) {\n            //System.out.println(\"  return END\");\n            //}\n            return SeekStatus.END;\n          }\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  return \" + result + \" term=\" + brToString(term) + \" \" + term);\n          //}\n          return result;\n        }\n      } else {\n        // Follow this arc\n        term.bytes[targetUpto] = (byte) targetLabel;\n        arc = nextArc;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        //if (DEBUG) {\n        //System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //}\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, false);\n\n    if (result == SeekStatus.END) {\n      term.copyBytes(target);\n      termExists = false;\n      if (next() != null) {\n        //if (DEBUG) {\n        //System.out.println(\"  return NOT_FOUND term=\" + term.utf8ToString() + \" \" + term);\n        //}\n        return SeekStatus.NOT_FOUND;\n      } else {\n        //if (DEBUG) {\n        //System.out.println(\"  return END\");\n        //}\n        return SeekStatus.END;\n      }\n    } else {\n      return result;\n    }\n  }\n\n","sourceOld":"  @Override\n  public SeekStatus seekCeil(final BytesRef target) throws IOException {\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n   \n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n    //if (DEBUG) {\n    //System.out.println(\"\\nBTTR.seekCeil seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + target.utf8ToString() + \" \" + target + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=  \" + validIndexPrefix);\n    //printSeekState();\n    //}\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      //if (DEBUG) {\n      //System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //}\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n          \n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TOOD: we should write our vLong backwards (MSB\n      // first) to get better sharing from the FST\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        //if (DEBUG) {\n        //System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        //}\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        // TOOD: we could save the outputs in local\n        // byte[][] instead of making new objs ever\n        // seek; but, often the FST doesn't have any\n        // shared bytes (but this could change if we\n        // reverse vLong byte order)\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame:\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          //if (DEBUG) {\n          //System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          //}\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        //if (DEBUG) {\n        //System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); clear frame.scanned ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        //if (DEBUG) {\n        //System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current; return FOUND\");\n          //}\n          return SeekStatus.FOUND;\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current but term doesn't exist\");\n          //}\n        }\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      //if (DEBUG) {\n      //System.out.println(\"    no seek state; push root frame\");\n      //}\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    //if (DEBUG) {\n    //System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord+1=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    //}\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, false);\n        if (result == SeekStatus.END) {\n          term.copyBytes(target);\n          termExists = false;\n\n          if (next() != null) {\n            //if (DEBUG) {\n            //System.out.println(\"  return NOT_FOUND term=\" + brToString(term) + \" \" + term);\n            //}\n            return SeekStatus.NOT_FOUND;\n          } else {\n            //if (DEBUG) {\n            //System.out.println(\"  return END\");\n            //}\n            return SeekStatus.END;\n          }\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  return \" + result + \" term=\" + brToString(term) + \" \" + term);\n          //}\n          return result;\n        }\n      } else {\n        // Follow this arc\n        term.bytes[targetUpto] = (byte) targetLabel;\n        arc = nextArc;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        //if (DEBUG) {\n        //System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //}\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, false);\n\n    if (result == SeekStatus.END) {\n      term.copyBytes(target);\n      termExists = false;\n      if (next() != null) {\n        //if (DEBUG) {\n        //System.out.println(\"  return NOT_FOUND term=\" + term.utf8ToString() + \" \" + term);\n        //}\n        return SeekStatus.NOT_FOUND;\n      } else {\n        //if (DEBUG) {\n        //System.out.println(\"  return END\");\n        //}\n        return SeekStatus.END;\n      }\n    } else {\n      return result;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d637064d608752565d4f9f41b2497dfdfdde50e","date":1400798123,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekCeil(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public SeekStatus seekCeil(final BytesRef target) throws IOException {\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n   \n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n    //if (DEBUG) {\n    //System.out.println(\"\\nBTTR.seekCeil seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + target.utf8ToString() + \" \" + target + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=  \" + validIndexPrefix);\n    //printSeekState();\n    //}\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      //if (DEBUG) {\n      //System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //}\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n          \n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TOOD: we should write our vLong backwards (MSB\n      // first) to get better sharing from the FST\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        //if (DEBUG) {\n        //System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        //}\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        // TOOD: we could save the outputs in local\n        // byte[][] instead of making new objs ever\n        // seek; but, often the FST doesn't have any\n        // shared bytes (but this could change if we\n        // reverse vLong byte order)\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame:\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          //if (DEBUG) {\n          //System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          //}\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        //if (DEBUG) {\n        //System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); clear frame.scanned ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        //if (DEBUG) {\n        //System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current; return FOUND\");\n          //}\n          return SeekStatus.FOUND;\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current but term doesn't exist\");\n          //}\n        }\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      //if (DEBUG) {\n      //System.out.println(\"    no seek state; push root frame\");\n      //}\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    //if (DEBUG) {\n    //System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord+1=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    //}\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, false);\n        if (result == SeekStatus.END) {\n          term.copyBytes(target);\n          termExists = false;\n\n          if (next() != null) {\n            //if (DEBUG) {\n            //System.out.println(\"  return NOT_FOUND term=\" + brToString(term) + \" \" + term);\n            //}\n            return SeekStatus.NOT_FOUND;\n          } else {\n            //if (DEBUG) {\n            //System.out.println(\"  return END\");\n            //}\n            return SeekStatus.END;\n          }\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  return \" + result + \" term=\" + brToString(term) + \" \" + term);\n          //}\n          return result;\n        }\n      } else {\n        // Follow this arc\n        term.bytes[targetUpto] = (byte) targetLabel;\n        arc = nextArc;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        //if (DEBUG) {\n        //System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //}\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, false);\n\n    if (result == SeekStatus.END) {\n      term.copyBytes(target);\n      termExists = false;\n      if (next() != null) {\n        //if (DEBUG) {\n        //System.out.println(\"  return NOT_FOUND term=\" + term.utf8ToString() + \" \" + term);\n        //}\n        return SeekStatus.NOT_FOUND;\n      } else {\n        //if (DEBUG) {\n        //System.out.println(\"  return END\");\n        //}\n        return SeekStatus.END;\n      }\n    } else {\n      return result;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekCeil(BytesRef).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekCeil(BytesRef).mjava","sourceNew":"  @Override\n  public SeekStatus seekCeil(final BytesRef target) throws IOException {\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    term.grow(1 + target.length);\n\n    assert clearEOF();\n\n    //if (DEBUG) {\n    //System.out.println(\"\\nBTTR.seekCeil seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + target.utf8ToString() + \" \" + target + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=  \" + validIndexPrefix);\n    //printSeekState();\n    //}\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      //if (DEBUG) {\n      //System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //}\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n          \n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length();\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TOOD: we should write our vLong backwards (MSB\n      // first) to get better sharing from the FST\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        //if (DEBUG) {\n        //System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        //}\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        // TOOD: we could save the outputs in local\n        // byte[][] instead of making new objs ever\n        // seek; but, often the FST doesn't have any\n        // shared bytes (but this could change if we\n        // reverse vLong byte order)\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame:\n        final int targetLimit2 = Math.min(target.length, term.length());\n        while (targetUpto < targetLimit2) {\n          cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          //if (DEBUG) {\n          //System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          //}\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length() - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        //if (DEBUG) {\n        //System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); clear frame.scanned ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        //if (DEBUG) {\n        //System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length() == target.length;\n        if (termExists) {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current; return FOUND\");\n          //}\n          return SeekStatus.FOUND;\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current but term doesn't exist\");\n          //}\n        }\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      //if (DEBUG) {\n      //System.out.println(\"    no seek state; push root frame\");\n      //}\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    //if (DEBUG) {\n    //System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord+1=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    //}\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, false);\n        if (result == SeekStatus.END) {\n          term.copyBytes(target);\n          termExists = false;\n\n          if (next() != null) {\n            //if (DEBUG) {\n            //System.out.println(\"  return NOT_FOUND term=\" + brToString(term) + \" \" + term);\n            //}\n            return SeekStatus.NOT_FOUND;\n          } else {\n            //if (DEBUG) {\n            //System.out.println(\"  return END\");\n            //}\n            return SeekStatus.END;\n          }\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  return \" + result + \" term=\" + brToString(term) + \" \" + term);\n          //}\n          return result;\n        }\n      } else {\n        // Follow this arc\n        term.setByteAt(targetUpto, (byte) targetLabel);\n        arc = nextArc;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        //if (DEBUG) {\n        //System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //}\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, false);\n\n    if (result == SeekStatus.END) {\n      term.copyBytes(target);\n      termExists = false;\n      if (next() != null) {\n        //if (DEBUG) {\n        //System.out.println(\"  return NOT_FOUND term=\" + term.utf8ToString() + \" \" + term);\n        //}\n        return SeekStatus.NOT_FOUND;\n      } else {\n        //if (DEBUG) {\n        //System.out.println(\"  return END\");\n        //}\n        return SeekStatus.END;\n      }\n    } else {\n      return result;\n    }\n  }\n\n","sourceOld":"  @Override\n  public SeekStatus seekCeil(final BytesRef target) throws IOException {\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n   \n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n    //if (DEBUG) {\n    //System.out.println(\"\\nBTTR.seekCeil seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + target.utf8ToString() + \" \" + target + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=  \" + validIndexPrefix);\n    //printSeekState();\n    //}\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      //if (DEBUG) {\n      //System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //}\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n          \n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TOOD: we should write our vLong backwards (MSB\n      // first) to get better sharing from the FST\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        //if (DEBUG) {\n        //System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        //}\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        // TOOD: we could save the outputs in local\n        // byte[][] instead of making new objs ever\n        // seek; but, often the FST doesn't have any\n        // shared bytes (but this could change if we\n        // reverse vLong byte order)\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame:\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          //if (DEBUG) {\n          //System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          //}\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        //if (DEBUG) {\n        //System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); clear frame.scanned ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        //if (DEBUG) {\n        //System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current; return FOUND\");\n          //}\n          return SeekStatus.FOUND;\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current but term doesn't exist\");\n          //}\n        }\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      //if (DEBUG) {\n      //System.out.println(\"    no seek state; push root frame\");\n      //}\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    //if (DEBUG) {\n    //System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord+1=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    //}\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, false);\n        if (result == SeekStatus.END) {\n          term.copyBytes(target);\n          termExists = false;\n\n          if (next() != null) {\n            //if (DEBUG) {\n            //System.out.println(\"  return NOT_FOUND term=\" + brToString(term) + \" \" + term);\n            //}\n            return SeekStatus.NOT_FOUND;\n          } else {\n            //if (DEBUG) {\n            //System.out.println(\"  return END\");\n            //}\n            return SeekStatus.END;\n          }\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  return \" + result + \" term=\" + brToString(term) + \" \" + term);\n          //}\n          return result;\n        }\n      } else {\n        // Follow this arc\n        term.bytes[targetUpto] = (byte) targetLabel;\n        arc = nextArc;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        //if (DEBUG) {\n        //System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //}\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, false);\n\n    if (result == SeekStatus.END) {\n      term.copyBytes(target);\n      termExists = false;\n      if (next() != null) {\n        //if (DEBUG) {\n        //System.out.println(\"  return NOT_FOUND term=\" + term.utf8ToString() + \" \" + term);\n        //}\n        return SeekStatus.NOT_FOUND;\n      } else {\n        //if (DEBUG) {\n        //System.out.println(\"  return END\");\n        //}\n        return SeekStatus.END;\n      }\n    } else {\n      return result;\n    }\n  }\n\n","bugFix":["6256acedd658c13275a01e4ba106a621956a22f6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b9a93029569c1c47d7293e62bb47da401240b01","date":1413923937,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekCeil(BytesRef).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekCeil(BytesRef).mjava","sourceNew":"  @Override\n  public SeekStatus seekCeil(final BytesRef target) throws IOException {\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    term.grow(1 + target.length);\n\n    assert clearEOF();\n\n    //if (DEBUG) {\n    //System.out.println(\"\\nBTTR.seekCeil seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + target.utf8ToString() + \" \" + target + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=  \" + validIndexPrefix);\n    //printSeekState();\n    //}\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      //if (DEBUG) {\n      //System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //}\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n          \n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length();\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: we should write our vLong backwards (MSB\n      // first) to get better sharing from the FST\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        //if (DEBUG) {\n        //System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        //}\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        // TODO: we could save the outputs in local\n        // byte[][] instead of making new objs ever\n        // seek; but, often the FST doesn't have any\n        // shared bytes (but this could change if we\n        // reverse vLong byte order)\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame:\n        final int targetLimit2 = Math.min(target.length, term.length());\n        while (targetUpto < targetLimit2) {\n          cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          //if (DEBUG) {\n          //System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          //}\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length() - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        //if (DEBUG) {\n        //System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); clear frame.scanned ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        //if (DEBUG) {\n        //System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length() == target.length;\n        if (termExists) {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current; return FOUND\");\n          //}\n          return SeekStatus.FOUND;\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current but term doesn't exist\");\n          //}\n        }\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      //if (DEBUG) {\n      //System.out.println(\"    no seek state; push root frame\");\n      //}\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    //if (DEBUG) {\n    //System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord+1=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    //}\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, false);\n        if (result == SeekStatus.END) {\n          term.copyBytes(target);\n          termExists = false;\n\n          if (next() != null) {\n            //if (DEBUG) {\n            //System.out.println(\"  return NOT_FOUND term=\" + brToString(term) + \" \" + term);\n            //}\n            return SeekStatus.NOT_FOUND;\n          } else {\n            //if (DEBUG) {\n            //System.out.println(\"  return END\");\n            //}\n            return SeekStatus.END;\n          }\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  return \" + result + \" term=\" + brToString(term) + \" \" + term);\n          //}\n          return result;\n        }\n      } else {\n        // Follow this arc\n        term.setByteAt(targetUpto, (byte) targetLabel);\n        arc = nextArc;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        //if (DEBUG) {\n        //System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //}\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, false);\n\n    if (result == SeekStatus.END) {\n      term.copyBytes(target);\n      termExists = false;\n      if (next() != null) {\n        //if (DEBUG) {\n        //System.out.println(\"  return NOT_FOUND term=\" + term.utf8ToString() + \" \" + term);\n        //}\n        return SeekStatus.NOT_FOUND;\n      } else {\n        //if (DEBUG) {\n        //System.out.println(\"  return END\");\n        //}\n        return SeekStatus.END;\n      }\n    } else {\n      return result;\n    }\n  }\n\n","sourceOld":"  @Override\n  public SeekStatus seekCeil(final BytesRef target) throws IOException {\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    term.grow(1 + target.length);\n\n    assert clearEOF();\n\n    //if (DEBUG) {\n    //System.out.println(\"\\nBTTR.seekCeil seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + target.utf8ToString() + \" \" + target + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=  \" + validIndexPrefix);\n    //printSeekState();\n    //}\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      //if (DEBUG) {\n      //System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //}\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n          \n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length();\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TOOD: we should write our vLong backwards (MSB\n      // first) to get better sharing from the FST\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        //if (DEBUG) {\n        //System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        //}\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        // TOOD: we could save the outputs in local\n        // byte[][] instead of making new objs ever\n        // seek; but, often the FST doesn't have any\n        // shared bytes (but this could change if we\n        // reverse vLong byte order)\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame:\n        final int targetLimit2 = Math.min(target.length, term.length());\n        while (targetUpto < targetLimit2) {\n          cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          //if (DEBUG) {\n          //System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          //}\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length() - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        //if (DEBUG) {\n        //System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); clear frame.scanned ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        //if (DEBUG) {\n        //System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length() == target.length;\n        if (termExists) {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current; return FOUND\");\n          //}\n          return SeekStatus.FOUND;\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current but term doesn't exist\");\n          //}\n        }\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      //if (DEBUG) {\n      //System.out.println(\"    no seek state; push root frame\");\n      //}\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    //if (DEBUG) {\n    //System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord+1=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    //}\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, false);\n        if (result == SeekStatus.END) {\n          term.copyBytes(target);\n          termExists = false;\n\n          if (next() != null) {\n            //if (DEBUG) {\n            //System.out.println(\"  return NOT_FOUND term=\" + brToString(term) + \" \" + term);\n            //}\n            return SeekStatus.NOT_FOUND;\n          } else {\n            //if (DEBUG) {\n            //System.out.println(\"  return END\");\n            //}\n            return SeekStatus.END;\n          }\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  return \" + result + \" term=\" + brToString(term) + \" \" + term);\n          //}\n          return result;\n        }\n      } else {\n        // Follow this arc\n        term.setByteAt(targetUpto, (byte) targetLabel);\n        arc = nextArc;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        //if (DEBUG) {\n        //System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //}\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, false);\n\n    if (result == SeekStatus.END) {\n      term.copyBytes(target);\n      termExists = false;\n      if (next() != null) {\n        //if (DEBUG) {\n        //System.out.println(\"  return NOT_FOUND term=\" + term.utf8ToString() + \" \" + term);\n        //}\n        return SeekStatus.NOT_FOUND;\n      } else {\n        //if (DEBUG) {\n        //System.out.println(\"  return END\");\n        //}\n        return SeekStatus.END;\n      }\n    } else {\n      return result;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekCeil(BytesRef).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekCeil(BytesRef).mjava","sourceNew":"  @Override\n  public SeekStatus seekCeil(final BytesRef target) throws IOException {\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    term.grow(1 + target.length);\n\n    assert clearEOF();\n\n    //if (DEBUG) {\n    //System.out.println(\"\\nBTTR.seekCeil seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + target.utf8ToString() + \" \" + target + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=  \" + validIndexPrefix);\n    //printSeekState();\n    //}\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      //if (DEBUG) {\n      //System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //}\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n          \n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length();\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: we should write our vLong backwards (MSB\n      // first) to get better sharing from the FST\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        //if (DEBUG) {\n        //System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        //}\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        // TODO: we could save the outputs in local\n        // byte[][] instead of making new objs ever\n        // seek; but, often the FST doesn't have any\n        // shared bytes (but this could change if we\n        // reverse vLong byte order)\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame:\n        final int targetLimit2 = Math.min(target.length, term.length());\n        while (targetUpto < targetLimit2) {\n          cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          //if (DEBUG) {\n          //System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          //}\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length() - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        //if (DEBUG) {\n        //System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); clear frame.scanned ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        //if (DEBUG) {\n        //System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length() == target.length;\n        if (termExists) {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current; return FOUND\");\n          //}\n          return SeekStatus.FOUND;\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current but term doesn't exist\");\n          //}\n        }\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      //if (DEBUG) {\n      //System.out.println(\"    no seek state; push root frame\");\n      //}\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    //if (DEBUG) {\n    //System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord+1=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    //}\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, false);\n        if (result == SeekStatus.END) {\n          term.copyBytes(target);\n          termExists = false;\n\n          if (next() != null) {\n            //if (DEBUG) {\n            //System.out.println(\"  return NOT_FOUND term=\" + brToString(term) + \" \" + term);\n            //}\n            return SeekStatus.NOT_FOUND;\n          } else {\n            //if (DEBUG) {\n            //System.out.println(\"  return END\");\n            //}\n            return SeekStatus.END;\n          }\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  return \" + result + \" term=\" + brToString(term) + \" \" + term);\n          //}\n          return result;\n        }\n      } else {\n        // Follow this arc\n        term.setByteAt(targetUpto, (byte) targetLabel);\n        arc = nextArc;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        //if (DEBUG) {\n        //System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //}\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, false);\n\n    if (result == SeekStatus.END) {\n      term.copyBytes(target);\n      termExists = false;\n      if (next() != null) {\n        //if (DEBUG) {\n        //System.out.println(\"  return NOT_FOUND term=\" + term.utf8ToString() + \" \" + term);\n        //}\n        return SeekStatus.NOT_FOUND;\n      } else {\n        //if (DEBUG) {\n        //System.out.println(\"  return END\");\n        //}\n        return SeekStatus.END;\n      }\n    } else {\n      return result;\n    }\n  }\n\n","sourceOld":"  @Override\n  public SeekStatus seekCeil(final BytesRef target) throws IOException {\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    term.grow(1 + target.length);\n\n    assert clearEOF();\n\n    //if (DEBUG) {\n    //System.out.println(\"\\nBTTR.seekCeil seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + target.utf8ToString() + \" \" + target + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=  \" + validIndexPrefix);\n    //printSeekState();\n    //}\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      //if (DEBUG) {\n      //System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //}\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n          \n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length();\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TOOD: we should write our vLong backwards (MSB\n      // first) to get better sharing from the FST\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        //if (DEBUG) {\n        //System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        //}\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        // TOOD: we could save the outputs in local\n        // byte[][] instead of making new objs ever\n        // seek; but, often the FST doesn't have any\n        // shared bytes (but this could change if we\n        // reverse vLong byte order)\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame:\n        final int targetLimit2 = Math.min(target.length, term.length());\n        while (targetUpto < targetLimit2) {\n          cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          //if (DEBUG) {\n          //System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          //}\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length() - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        //if (DEBUG) {\n        //System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); clear frame.scanned ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        //if (DEBUG) {\n        //System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length() == target.length;\n        if (termExists) {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current; return FOUND\");\n          //}\n          return SeekStatus.FOUND;\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current but term doesn't exist\");\n          //}\n        }\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      //if (DEBUG) {\n      //System.out.println(\"    no seek state; push root frame\");\n      //}\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    //if (DEBUG) {\n    //System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord+1=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    //}\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, false);\n        if (result == SeekStatus.END) {\n          term.copyBytes(target);\n          termExists = false;\n\n          if (next() != null) {\n            //if (DEBUG) {\n            //System.out.println(\"  return NOT_FOUND term=\" + brToString(term) + \" \" + term);\n            //}\n            return SeekStatus.NOT_FOUND;\n          } else {\n            //if (DEBUG) {\n            //System.out.println(\"  return END\");\n            //}\n            return SeekStatus.END;\n          }\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  return \" + result + \" term=\" + brToString(term) + \" \" + term);\n          //}\n          return result;\n        }\n      } else {\n        // Follow this arc\n        term.setByteAt(targetUpto, (byte) targetLabel);\n        arc = nextArc;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        //if (DEBUG) {\n        //System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //}\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, false);\n\n    if (result == SeekStatus.END) {\n      term.copyBytes(target);\n      termExists = false;\n      if (next() != null) {\n        //if (DEBUG) {\n        //System.out.println(\"  return NOT_FOUND term=\" + term.utf8ToString() + \" \" + term);\n        //}\n        return SeekStatus.NOT_FOUND;\n      } else {\n        //if (DEBUG) {\n        //System.out.println(\"  return END\");\n        //}\n        return SeekStatus.END;\n      }\n    } else {\n      return result;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekCeil(BytesRef).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekCeil(BytesRef).mjava","sourceNew":"  @Override\n  public SeekStatus seekCeil(final BytesRef target) throws IOException {\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    term.grow(1 + target.length);\n\n    assert clearEOF();\n\n    //if (DEBUG) {\n    //System.out.println(\"\\nBTTR.seekCeil seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + target.utf8ToString() + \" \" + target + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=  \" + validIndexPrefix);\n    //printSeekState();\n    //}\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      //if (DEBUG) {\n      //System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //}\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output();\n      targetUpto = 0;\n          \n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length();\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: we should write our vLong backwards (MSB\n      // first) to get better sharing from the FST\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        //if (DEBUG) {\n        //System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        //}\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        assert arc.label() == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label() + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        // TODO: we could save the outputs in local\n        // byte[][] instead of making new objs ever\n        // seek; but, often the FST doesn't have any\n        // shared bytes (but this could change if we\n        // reverse vLong byte order)\n        if (arc.output() != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame:\n        final int targetLimit2 = Math.min(target.length, term.length());\n        while (targetUpto < targetLimit2) {\n          cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          //if (DEBUG) {\n          //System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          //}\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length() - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        //if (DEBUG) {\n        //System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); clear frame.scanned ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        //if (DEBUG) {\n        //System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length() == target.length;\n        if (termExists) {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current; return FOUND\");\n          //}\n          return SeekStatus.FOUND;\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current but term doesn't exist\");\n          //}\n        }\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output() != null;\n\n      //if (DEBUG) {\n      //System.out.println(\"    no seek state; push root frame\");\n      //}\n\n      output = arc.output();\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput()), 0);\n    }\n\n    //if (DEBUG) {\n    //System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord+1=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    //}\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, false);\n        if (result == SeekStatus.END) {\n          term.copyBytes(target);\n          termExists = false;\n\n          if (next() != null) {\n            //if (DEBUG) {\n            //System.out.println(\"  return NOT_FOUND term=\" + brToString(term) + \" \" + term);\n            //}\n            return SeekStatus.NOT_FOUND;\n          } else {\n            //if (DEBUG) {\n            //System.out.println(\"  return END\");\n            //}\n            return SeekStatus.END;\n          }\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  return \" + result + \" term=\" + brToString(term) + \" \" + term);\n          //}\n          return result;\n        }\n      } else {\n        // Follow this arc\n        term.setByteAt(targetUpto, (byte) targetLabel);\n        arc = nextArc;\n        // Aggregate output as we go:\n        assert arc.output() != null;\n        if (arc.output() != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n        }\n\n        //if (DEBUG) {\n        //System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //}\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput()), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, false);\n\n    if (result == SeekStatus.END) {\n      term.copyBytes(target);\n      termExists = false;\n      if (next() != null) {\n        //if (DEBUG) {\n        //System.out.println(\"  return NOT_FOUND term=\" + term.utf8ToString() + \" \" + term);\n        //}\n        return SeekStatus.NOT_FOUND;\n      } else {\n        //if (DEBUG) {\n        //System.out.println(\"  return END\");\n        //}\n        return SeekStatus.END;\n      }\n    } else {\n      return result;\n    }\n  }\n\n","sourceOld":"  @Override\n  public SeekStatus seekCeil(final BytesRef target) throws IOException {\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    term.grow(1 + target.length);\n\n    assert clearEOF();\n\n    //if (DEBUG) {\n    //System.out.println(\"\\nBTTR.seekCeil seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + target.utf8ToString() + \" \" + target + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=  \" + validIndexPrefix);\n    //printSeekState();\n    //}\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      //if (DEBUG) {\n      //System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //}\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n          \n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length();\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: we should write our vLong backwards (MSB\n      // first) to get better sharing from the FST\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        //if (DEBUG) {\n        //System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        //}\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        // TODO: we could save the outputs in local\n        // byte[][] instead of making new objs ever\n        // seek; but, often the FST doesn't have any\n        // shared bytes (but this could change if we\n        // reverse vLong byte order)\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame:\n        final int targetLimit2 = Math.min(target.length, term.length());\n        while (targetUpto < targetLimit2) {\n          cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          //if (DEBUG) {\n          //System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          //}\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length() - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        //if (DEBUG) {\n        //System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); clear frame.scanned ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        //if (DEBUG) {\n        //System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length() == target.length;\n        if (termExists) {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current; return FOUND\");\n          //}\n          return SeekStatus.FOUND;\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current but term doesn't exist\");\n          //}\n        }\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      //if (DEBUG) {\n      //System.out.println(\"    no seek state; push root frame\");\n      //}\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    //if (DEBUG) {\n    //System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord+1=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    //}\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, false);\n        if (result == SeekStatus.END) {\n          term.copyBytes(target);\n          termExists = false;\n\n          if (next() != null) {\n            //if (DEBUG) {\n            //System.out.println(\"  return NOT_FOUND term=\" + brToString(term) + \" \" + term);\n            //}\n            return SeekStatus.NOT_FOUND;\n          } else {\n            //if (DEBUG) {\n            //System.out.println(\"  return END\");\n            //}\n            return SeekStatus.END;\n          }\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  return \" + result + \" term=\" + brToString(term) + \" \" + term);\n          //}\n          return result;\n        }\n      } else {\n        // Follow this arc\n        term.setByteAt(targetUpto, (byte) targetLabel);\n        arc = nextArc;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        //if (DEBUG) {\n        //System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //}\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, false);\n\n    if (result == SeekStatus.END) {\n      term.copyBytes(target);\n      termExists = false;\n      if (next() != null) {\n        //if (DEBUG) {\n        //System.out.println(\"  return NOT_FOUND term=\" + term.utf8ToString() + \" \" + term);\n        //}\n        return SeekStatus.NOT_FOUND;\n      } else {\n        //if (DEBUG) {\n        //System.out.println(\"  return END\");\n        //}\n        return SeekStatus.END;\n      }\n    } else {\n      return result;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekCeil(BytesRef).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekCeil(BytesRef).mjava","sourceNew":"  @Override\n  public SeekStatus seekCeil(final BytesRef target) throws IOException {\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    term.grow(1 + target.length);\n\n    assert clearEOF();\n\n    //if (DEBUG) {\n    //System.out.println(\"\\nBTTR.seekCeil seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + target.utf8ToString() + \" \" + target + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=  \" + validIndexPrefix);\n    //printSeekState();\n    //}\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      //if (DEBUG) {\n      //System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //}\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output();\n      targetUpto = 0;\n          \n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length();\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: we should write our vLong backwards (MSB\n      // first) to get better sharing from the FST\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        //if (DEBUG) {\n        //System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        //}\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        assert arc.label() == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label() + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        // TODO: we could save the outputs in local\n        // byte[][] instead of making new objs ever\n        // seek; but, often the FST doesn't have any\n        // shared bytes (but this could change if we\n        // reverse vLong byte order)\n        if (arc.output() != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame:\n        final int targetLimit2 = Math.min(target.length, term.length());\n        while (targetUpto < targetLimit2) {\n          cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          //if (DEBUG) {\n          //System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          //}\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length() - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        //if (DEBUG) {\n        //System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); clear frame.scanned ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        //if (DEBUG) {\n        //System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length() == target.length;\n        if (termExists) {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current; return FOUND\");\n          //}\n          return SeekStatus.FOUND;\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current but term doesn't exist\");\n          //}\n        }\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output() != null;\n\n      //if (DEBUG) {\n      //System.out.println(\"    no seek state; push root frame\");\n      //}\n\n      output = arc.output();\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput()), 0);\n    }\n\n    //if (DEBUG) {\n    //System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord+1=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    //}\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, false);\n        if (result == SeekStatus.END) {\n          term.copyBytes(target);\n          termExists = false;\n\n          if (next() != null) {\n            //if (DEBUG) {\n            //System.out.println(\"  return NOT_FOUND term=\" + brToString(term) + \" \" + term);\n            //}\n            return SeekStatus.NOT_FOUND;\n          } else {\n            //if (DEBUG) {\n            //System.out.println(\"  return END\");\n            //}\n            return SeekStatus.END;\n          }\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  return \" + result + \" term=\" + brToString(term) + \" \" + term);\n          //}\n          return result;\n        }\n      } else {\n        // Follow this arc\n        term.setByteAt(targetUpto, (byte) targetLabel);\n        arc = nextArc;\n        // Aggregate output as we go:\n        assert arc.output() != null;\n        if (arc.output() != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output());\n        }\n\n        //if (DEBUG) {\n        //System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //}\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput()), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, false);\n\n    if (result == SeekStatus.END) {\n      term.copyBytes(target);\n      termExists = false;\n      if (next() != null) {\n        //if (DEBUG) {\n        //System.out.println(\"  return NOT_FOUND term=\" + term.utf8ToString() + \" \" + term);\n        //}\n        return SeekStatus.NOT_FOUND;\n      } else {\n        //if (DEBUG) {\n        //System.out.println(\"  return END\");\n        //}\n        return SeekStatus.END;\n      }\n    } else {\n      return result;\n    }\n  }\n\n","sourceOld":"  @Override\n  public SeekStatus seekCeil(final BytesRef target) throws IOException {\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    term.grow(1 + target.length);\n\n    assert clearEOF();\n\n    //if (DEBUG) {\n    //System.out.println(\"\\nBTTR.seekCeil seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + target.utf8ToString() + \" \" + target + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=  \" + validIndexPrefix);\n    //printSeekState();\n    //}\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      //if (DEBUG) {\n      //System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //}\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n          \n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length();\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: we should write our vLong backwards (MSB\n      // first) to get better sharing from the FST\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        //if (DEBUG) {\n        //System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        //}\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        // TODO: we could save the outputs in local\n        // byte[][] instead of making new objs ever\n        // seek; but, often the FST doesn't have any\n        // shared bytes (but this could change if we\n        // reverse vLong byte order)\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame:\n        final int targetLimit2 = Math.min(target.length, term.length());\n        while (targetUpto < targetLimit2) {\n          cmp = (term.byteAt(targetUpto)&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          //if (DEBUG) {\n          //System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          //}\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length() - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        //if (DEBUG) {\n        //System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); clear frame.scanned ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        //if (DEBUG) {\n        //System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //}\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length() == target.length;\n        if (termExists) {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current; return FOUND\");\n          //}\n          return SeekStatus.FOUND;\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  target is same as current but term doesn't exist\");\n          //}\n        }\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      //if (DEBUG) {\n      //System.out.println(\"    no seek state; push root frame\");\n      //}\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    //if (DEBUG) {\n    //System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord+1=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    //}\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, false);\n        if (result == SeekStatus.END) {\n          term.copyBytes(target);\n          termExists = false;\n\n          if (next() != null) {\n            //if (DEBUG) {\n            //System.out.println(\"  return NOT_FOUND term=\" + brToString(term) + \" \" + term);\n            //}\n            return SeekStatus.NOT_FOUND;\n          } else {\n            //if (DEBUG) {\n            //System.out.println(\"  return END\");\n            //}\n            return SeekStatus.END;\n          }\n        } else {\n          //if (DEBUG) {\n          //System.out.println(\"  return \" + result + \" term=\" + brToString(term) + \" \" + term);\n          //}\n          return result;\n        }\n      } else {\n        // Follow this arc\n        term.setByteAt(targetUpto, (byte) targetLabel);\n        arc = nextArc;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        //if (DEBUG) {\n        //System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //}\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, false);\n\n    if (result == SeekStatus.END) {\n      term.copyBytes(target);\n      termExists = false;\n      if (next() != null) {\n        //if (DEBUG) {\n        //System.out.println(\"  return NOT_FOUND term=\" + term.utf8ToString() + \" \" + term);\n        //}\n        return SeekStatus.NOT_FOUND;\n      } else {\n        //if (DEBUG) {\n        //System.out.println(\"  return END\");\n        //}\n        return SeekStatus.END;\n      }\n    } else {\n      return result;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4b9a93029569c1c47d7293e62bb47da401240b01":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","4b9a93029569c1c47d7293e62bb47da401240b01"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"f8061ddd97f3352007d927dae445884a6f3d857b":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["54204c8a3ca26aeafd273139fc29baf70d0f6786"]},"commit2Childs":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e","4d637064d608752565d4f9f41b2497dfdfdde50e"],"4b9a93029569c1c47d7293e62bb47da401240b01":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["54204c8a3ca26aeafd273139fc29baf70d0f6786","f8061ddd97f3352007d927dae445884a6f3d857b"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["4b9a93029569c1c47d7293e62bb47da401240b01","db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}