{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/RoutedAliasCreateCollectionCmd#createCollectionAndWait(ClusterState,String,Map[String,String],String,OverseerCollectionMessageHandler).mjava","commits":[{"id":"3cbd743a4843f513f793670e3ab0e272bf824faf","date":1518149529,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/RoutedAliasCreateCollectionCmd#createCollectionAndWait(ClusterState,String,Map[String,String],String,OverseerCollectionMessageHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/RoutedAliasCreateCollectionCmd#createCollectionAndWait(ClusterState,NamedList,String,Map[String,String],String,OverseerCollectionMessageHandler).mjava","sourceNew":"  /**\n   * Creates a collection (for use in a routed alias), waiting for it to be ready before returning.\n   * If the collection already exists then this is not an error.\n   * IMPORTANT: Only call this from an {@link OverseerCollectionMessageHandler.Cmd}.\n   */\n  static NamedList createCollectionAndWait(ClusterState clusterState, String aliasName, Map<String, String> aliasMetadata,\n                                           String createCollName, OverseerCollectionMessageHandler ocmh) throws Exception {\n    // Map alias metadata starting with a prefix to a create-collection API request\n    final ModifiableSolrParams createReqParams = new ModifiableSolrParams();\n    for (Map.Entry<String, String> e : aliasMetadata.entrySet()) {\n      if (e.getKey().startsWith(CREATE_COLLECTION_PREFIX)) {\n        createReqParams.set(e.getKey().substring(CREATE_COLLECTION_PREFIX.length()), e.getValue());\n      }\n    }\n    if (createReqParams.get(COLL_CONF) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"We require an explicit \" + COLL_CONF );\n    }\n    createReqParams.set(NAME, createCollName);\n    createReqParams.set(\"property.\" + ROUTED_ALIAS_NAME_CORE_PROP, aliasName);\n    // a CollectionOperation reads params and produces a message (Map) that is supposed to be sent to the Overseer.\n    //   Although we could create the Map without it, there are a fair amount of rules we don't want to reproduce.\n    final Map<String, Object> createMsgMap = CollectionsHandler.CollectionOperation.CREATE_OP.execute(\n        new LocalSolrQueryRequest(null, createReqParams),\n        null,\n        ocmh.overseer.getCoreContainer().getCollectionsHandler());\n    createMsgMap.put(Overseer.QUEUE_OPERATION, \"create\");\n\n    NamedList results = new NamedList();\n    try {\n      // Since we are running in the Overseer here, send the message directly to the Overseer CreateCollectionCmd.\n      // note: there's doesn't seem to be any point in locking on the collection name, so we don't. We currently should\n      //   already have a lock on the alias name which should be sufficient.\n      ocmh.commandMap.get(CollectionParams.CollectionAction.CREATE).call(clusterState, new ZkNodeProps(createMsgMap), results);\n    } catch (SolrException e) {\n      // The collection might already exist, and that's okay -- we can adopt it.\n      if (!e.getMessage().contains(\"collection already exists\")) {\n        throw e;\n      }\n    }\n\n    CollectionsHandler.waitForActiveCollection(createCollName, ocmh.overseer.getCoreContainer(),\n        new OverseerSolrResponse(results));\n    return results;\n  }\n\n","sourceOld":"  /**\n   * Creates a collection (for use in a routed alias), waiting for it to be ready before returning.\n   * If the collection already exists then this is not an error.\n   * IMPORTANT: Only call this from an {@link OverseerCollectionMessageHandler.Cmd}.\n   */\n  static void createCollectionAndWait(ClusterState clusterState, NamedList results, String aliasName, Map<String, String> aliasMetadata, String createCollName, OverseerCollectionMessageHandler ocmh) throws Exception {\n    // Map alias metadata starting with a prefix to a create-collection API request\n    final ModifiableSolrParams createReqParams = new ModifiableSolrParams();\n    for (Map.Entry<String, String> e : aliasMetadata.entrySet()) {\n      if (e.getKey().startsWith(CREATE_COLLECTION_PREFIX)) {\n        createReqParams.set(e.getKey().substring(CREATE_COLLECTION_PREFIX.length()), e.getValue());\n      }\n    }\n    if (createReqParams.get(COLL_CONF) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"We require an explicit \" + COLL_CONF );\n    }\n    createReqParams.set(NAME, createCollName);\n    createReqParams.set(\"property.\" + ROUTED_ALIAS_NAME_CORE_PROP, aliasName);\n    // a CollectionOperation reads params and produces a message (Map) that is supposed to be sent to the Overseer.\n    //   Although we could create the Map without it, there are a fair amount of rules we don't want to reproduce.\n    final Map<String, Object> createMsgMap = CollectionsHandler.CollectionOperation.CREATE_OP.execute(\n        new LocalSolrQueryRequest(null, createReqParams),\n        null,\n        ocmh.overseer.getCoreContainer().getCollectionsHandler());\n    createMsgMap.put(Overseer.QUEUE_OPERATION, \"create\");\n\n    try {\n      // Since we are running in the Overseer here, send the message directly to the Overseer CreateCollectionCmd.\n      // note: there's doesn't seem to be any point in locking on the collection name, so we don't. We currently should\n      //   already have a lock on the alias name which should be sufficient.\n      ocmh.commandMap.get(CollectionParams.CollectionAction.CREATE).call(clusterState, new ZkNodeProps(createMsgMap), results);\n    } catch (SolrException e) {\n      // The collection might already exist, and that's okay -- we can adopt it.\n      if (!e.getMessage().contains(\"collection already exists\")) {\n        throw e;\n      }\n    }\n\n    CollectionsHandler.waitForActiveCollection(createCollName, null, ocmh.overseer.getCoreContainer(), new OverseerSolrResponse(results));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1b6eb78cb29a08063ed0ed2816d8817ede89fa90","date":1518149772,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MaintainRoutedAliasCmd#createCollectionAndWait(ClusterState,String,Map[String,String],String,OverseerCollectionMessageHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/RoutedAliasCreateCollectionCmd#createCollectionAndWait(ClusterState,String,Map[String,String],String,OverseerCollectionMessageHandler).mjava","sourceNew":"  /**\n   * Creates a collection (for use in a routed alias), waiting for it to be ready before returning.\n   * If the collection already exists then this is not an error.\n   * IMPORTANT: Only call this from an {@link OverseerCollectionMessageHandler.Cmd}.\n   */\n  static NamedList createCollectionAndWait(ClusterState clusterState, String aliasName, Map<String, String> aliasMetadata,\n                                           String createCollName, OverseerCollectionMessageHandler ocmh) throws Exception {\n    // Map alias metadata starting with a prefix to a create-collection API request\n    final ModifiableSolrParams createReqParams = new ModifiableSolrParams();\n    for (Map.Entry<String, String> e : aliasMetadata.entrySet()) {\n      if (e.getKey().startsWith(CREATE_COLLECTION_PREFIX)) {\n        createReqParams.set(e.getKey().substring(CREATE_COLLECTION_PREFIX.length()), e.getValue());\n      }\n    }\n    if (createReqParams.get(COLL_CONF) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"We require an explicit \" + COLL_CONF );\n    }\n    createReqParams.set(NAME, createCollName);\n    createReqParams.set(\"property.\" + ROUTED_ALIAS_NAME_CORE_PROP, aliasName);\n    // a CollectionOperation reads params and produces a message (Map) that is supposed to be sent to the Overseer.\n    //   Although we could create the Map without it, there are a fair amount of rules we don't want to reproduce.\n    final Map<String, Object> createMsgMap = CollectionsHandler.CollectionOperation.CREATE_OP.execute(\n        new LocalSolrQueryRequest(null, createReqParams),\n        null,\n        ocmh.overseer.getCoreContainer().getCollectionsHandler());\n    createMsgMap.put(Overseer.QUEUE_OPERATION, \"create\");\n\n    NamedList results = new NamedList();\n    try {\n      // Since we are running in the Overseer here, send the message directly to the Overseer CreateCollectionCmd.\n      // note: there's doesn't seem to be any point in locking on the collection name, so we don't. We currently should\n      //   already have a lock on the alias name which should be sufficient.\n      ocmh.commandMap.get(CollectionParams.CollectionAction.CREATE).call(clusterState, new ZkNodeProps(createMsgMap), results);\n    } catch (SolrException e) {\n      // The collection might already exist, and that's okay -- we can adopt it.\n      if (!e.getMessage().contains(\"collection already exists\")) {\n        throw e;\n      }\n    }\n\n    CollectionsHandler.waitForActiveCollection(createCollName, ocmh.overseer.getCoreContainer(),\n        new OverseerSolrResponse(results));\n    return results;\n  }\n\n","sourceOld":"  /**\n   * Creates a collection (for use in a routed alias), waiting for it to be ready before returning.\n   * If the collection already exists then this is not an error.\n   * IMPORTANT: Only call this from an {@link OverseerCollectionMessageHandler.Cmd}.\n   */\n  static NamedList createCollectionAndWait(ClusterState clusterState, String aliasName, Map<String, String> aliasMetadata,\n                                           String createCollName, OverseerCollectionMessageHandler ocmh) throws Exception {\n    // Map alias metadata starting with a prefix to a create-collection API request\n    final ModifiableSolrParams createReqParams = new ModifiableSolrParams();\n    for (Map.Entry<String, String> e : aliasMetadata.entrySet()) {\n      if (e.getKey().startsWith(CREATE_COLLECTION_PREFIX)) {\n        createReqParams.set(e.getKey().substring(CREATE_COLLECTION_PREFIX.length()), e.getValue());\n      }\n    }\n    if (createReqParams.get(COLL_CONF) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"We require an explicit \" + COLL_CONF );\n    }\n    createReqParams.set(NAME, createCollName);\n    createReqParams.set(\"property.\" + ROUTED_ALIAS_NAME_CORE_PROP, aliasName);\n    // a CollectionOperation reads params and produces a message (Map) that is supposed to be sent to the Overseer.\n    //   Although we could create the Map without it, there are a fair amount of rules we don't want to reproduce.\n    final Map<String, Object> createMsgMap = CollectionsHandler.CollectionOperation.CREATE_OP.execute(\n        new LocalSolrQueryRequest(null, createReqParams),\n        null,\n        ocmh.overseer.getCoreContainer().getCollectionsHandler());\n    createMsgMap.put(Overseer.QUEUE_OPERATION, \"create\");\n\n    NamedList results = new NamedList();\n    try {\n      // Since we are running in the Overseer here, send the message directly to the Overseer CreateCollectionCmd.\n      // note: there's doesn't seem to be any point in locking on the collection name, so we don't. We currently should\n      //   already have a lock on the alias name which should be sufficient.\n      ocmh.commandMap.get(CollectionParams.CollectionAction.CREATE).call(clusterState, new ZkNodeProps(createMsgMap), results);\n    } catch (SolrException e) {\n      // The collection might already exist, and that's okay -- we can adopt it.\n      if (!e.getMessage().contains(\"collection already exists\")) {\n        throw e;\n      }\n    }\n\n    CollectionsHandler.waitForActiveCollection(createCollName, ocmh.overseer.getCoreContainer(),\n        new OverseerSolrResponse(results));\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3cbd743a4843f513f793670e3ab0e272bf824faf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1b6eb78cb29a08063ed0ed2816d8817ede89fa90":["3cbd743a4843f513f793670e3ab0e272bf824faf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1b6eb78cb29a08063ed0ed2816d8817ede89fa90"]},"commit2Childs":{"3cbd743a4843f513f793670e3ab0e272bf824faf":["1b6eb78cb29a08063ed0ed2816d8817ede89fa90"],"1b6eb78cb29a08063ed0ed2816d8817ede89fa90":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3cbd743a4843f513f793670e3ab0e272bf824faf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}