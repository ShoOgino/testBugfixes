{"path":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","commits":[{"id":"46df9d682d3407bf67ce2946c9f9267376809bc2","date":1521244495,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    final String collectionName = \"raceDeleteReplica\";\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        LOG.info(\"Running delete core {}\",cd);\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              LOG.error(\"Datcm get slice on 211 {}\", shard);\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n\n    waitForState(\"Timeout for replica:\"+replica1.getName()+\" register itself as DOWN after failed to register\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica replica = shard.getReplica(replica1.getName());\n      return replica != null && replica.getState() == DOWN;\n    });\n\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(leader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4f86850b6346a909afce52ba92071c1064a82ab0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"203e3fcf513c02ee2c07015f2ce277e26dc60907","date":1521404157,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    final String collectionName = \"raceDeleteReplica\";\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        LOG.info(\"Running delete core {}\",cd);\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              LOG.error(\"Datcm get slice on 211 {}\", shard);\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n\n    waitForState(\"Timeout for replica:\"+replica1.getName()+\" register itself as DOWN after failed to register\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica replica = shard.getReplica(replica1.getName());\n      return replica != null && replica.getState() == DOWN;\n    });\n\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(leader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4f86850b6346a909afce52ba92071c1064a82ab0","date":1521606353,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","sourceNew":"  @Test\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    final String collectionName = \"raceDeleteReplica\";\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        LOG.info(\"Running delete core {}\",cd);\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n\n    waitForState(\"Timeout for replica:\"+replica1.getName()+\" register itself as DOWN after failed to register\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica replica = shard.getReplica(replica1.getName());\n      return replica != null && replica.getState() == DOWN;\n    });\n\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(leader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  @Test\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    final String collectionName = \"raceDeleteReplica\";\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        LOG.info(\"Running delete core {}\",cd);\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              LOG.error(\"Datcm get slice on 211 {}\", shard);\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n\n    waitForState(\"Timeout for replica:\"+replica1.getName()+\" register itself as DOWN after failed to register\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica replica = shard.getReplica(replica1.getName());\n      return replica != null && replica.getState() == DOWN;\n    });\n\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(leader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","bugFix":["46df9d682d3407bf67ce2946c9f9267376809bc2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","date":1521731438,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","sourceNew":"  @Test\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    final String collectionName = \"raceDeleteReplica\";\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        LOG.info(\"Running delete core {}\",cd);\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n\n    waitForState(\"Timeout for replica:\"+replica1.getName()+\" register itself as DOWN after failed to register\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica replica = shard.getReplica(replica1.getName());\n      return replica != null && replica.getState() == DOWN;\n    });\n\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(leader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  @Test\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    final String collectionName = \"raceDeleteReplica\";\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        LOG.info(\"Running delete core {}\",cd);\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              LOG.error(\"Datcm get slice on 211 {}\", shard);\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n\n    waitForState(\"Timeout for replica:\"+replica1.getName()+\" register itself as DOWN after failed to register\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica replica = shard.getReplica(replica1.getName());\n      return replica != null && replica.getState() == DOWN;\n    });\n\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(leader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28ba172425e443e0f08a49de6d73586c418d7251","date":1523970991,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","sourceNew":"  @Test\n  @Slow\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"true\");\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  @Test\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    final String collectionName = \"raceDeleteReplica\";\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        LOG.info(\"Running delete core {}\",cd);\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n\n    waitForState(\"Timeout for replica:\"+replica1.getName()+\" register itself as DOWN after failed to register\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica replica = shard.getReplica(replica1.getName());\n      return replica != null && replica.getState() == DOWN;\n    });\n\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(leader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43ad790248d7f7daee5d9cced548c546f37c7218","date":1527269998,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","sourceNew":"  @Test\n  @Slow\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"true\");\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"true\");\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11d6f92dfa9251d9da6d80ec5963a9cbecc90180","date":1530559969,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","sourceNew":"  @Test\n  @Slow\n  //28-June-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"true\");\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"true\");\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","sourceNew":"  @Test\n  @Slow\n  //28-June-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"true\");\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"true\");\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","sourceNew":"  @Test\n  @Slow\n  //28-June-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"true\");\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"true\");\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cdc53359111a5e3782f56300070ab2878ec82cb9","date":1534542016,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","sourceNew":"  @Test\n  @Slow\n  //28-June-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 17-Aug-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"true\");\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  //28-June-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"true\");\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14076e7b40405aa1f08702d8df762d08b5d44f70","date":1537071979,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","sourceNew":"  @Test\n  @Slow\n  //28-June-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  // commented 15-Sep-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 17-Aug-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"true\");\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  //28-June-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 17-Aug-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"true\");\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","sourceNew":"  @Test\n  @Slow\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  //28-June-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  // commented 15-Sep-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 17-Aug-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"true\");\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","bugFix":["14076e7b40405aa1f08702d8df762d08b5d44f70","28ba172425e443e0f08a49de6d73586c418d7251","11d6f92dfa9251d9da6d80ec5963a9cbecc90180"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8d35c84fdef07284c122012ca4000d3b7285a66e","date":1545962630,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","sourceNew":"  @Test\n  @Slow\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b5c929d2716fa79d443b93a82adb1da5b578ebd8","date":1550428858,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","sourceNew":"  @Test\n  @Slow\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica().mjava","sourceNew":"  @Test\n  @Slow\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    final String collectionName = \"raceDeleteReplicaCollection\";\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 1, 2);\n    \n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        log.info(\"Running delete core {}\",cd);\n\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          cluster.getOpenOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Timeout adding replica to shard\", () -> {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        return true;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        return false;\n      }\n    });\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica latestLeader = shard1.getLeader();\n    leaderJetty = getJettyForReplica(latestLeader);\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(latestLeader.getName());\n    });\n\n    leaderJetty.start();\n    cluster.waitForActiveCollection(collectionName, 1, 2);\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  @Test\n  @Slow\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void raceConditionOnDeleteAndRegisterReplica() throws Exception {\n    raceConditionOnDeleteAndRegisterReplica(\"false\");\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, null).process(cluster.getSolrClient());\n  }\n\n","bugFix":["28ba172425e443e0f08a49de6d73586c418d7251"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["203e3fcf513c02ee2c07015f2ce277e26dc60907","4f86850b6346a909afce52ba92071c1064a82ab0"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["b5c929d2716fa79d443b93a82adb1da5b578ebd8"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["14076e7b40405aa1f08702d8df762d08b5d44f70"],"cdc53359111a5e3782f56300070ab2878ec82cb9":["11d6f92dfa9251d9da6d80ec5963a9cbecc90180"],"b5c929d2716fa79d443b93a82adb1da5b578ebd8":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","46df9d682d3407bf67ce2946c9f9267376809bc2"],"14076e7b40405aa1f08702d8df762d08b5d44f70":["cdc53359111a5e3782f56300070ab2878ec82cb9"],"43ad790248d7f7daee5d9cced548c546f37c7218":["28ba172425e443e0f08a49de6d73586c418d7251"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"11d6f92dfa9251d9da6d80ec5963a9cbecc90180":["43ad790248d7f7daee5d9cced548c546f37c7218"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["43ad790248d7f7daee5d9cced548c546f37c7218","11d6f92dfa9251d9da6d80ec5963a9cbecc90180"],"4f86850b6346a909afce52ba92071c1064a82ab0":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"28ba172425e443e0f08a49de6d73586c418d7251":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"46df9d682d3407bf67ce2946c9f9267376809bc2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["43ad790248d7f7daee5d9cced548c546f37c7218","11d6f92dfa9251d9da6d80ec5963a9cbecc90180"]},"commit2Childs":{"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["28ba172425e443e0f08a49de6d73586c418d7251"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"cdc53359111a5e3782f56300070ab2878ec82cb9":["14076e7b40405aa1f08702d8df762d08b5d44f70"],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","4f86850b6346a909afce52ba92071c1064a82ab0"],"b5c929d2716fa79d443b93a82adb1da5b578ebd8":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"14076e7b40405aa1f08702d8df762d08b5d44f70":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"43ad790248d7f7daee5d9cced548c546f37c7218":["11d6f92dfa9251d9da6d80ec5963a9cbecc90180","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["b5c929d2716fa79d443b93a82adb1da5b578ebd8"],"11d6f92dfa9251d9da6d80ec5963a9cbecc90180":["cdc53359111a5e3782f56300070ab2878ec82cb9","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"4f86850b6346a909afce52ba92071c1064a82ab0":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["203e3fcf513c02ee2c07015f2ce277e26dc60907","46df9d682d3407bf67ce2946c9f9267376809bc2"],"28ba172425e443e0f08a49de6d73586c418d7251":["43ad790248d7f7daee5d9cced548c546f37c7218"],"46df9d682d3407bf67ce2946c9f9267376809bc2":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}