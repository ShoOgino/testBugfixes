{"path":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","commits":[{"id":"a0a97513a3a796fa8e709a0dcfec8a2e628e721b","date":1458922983,"type":0,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          sortedNumericDocValues.setDocument(doc);\n          for (int i = 0; i < sortedNumericDocValues.count(); i++) {\n            long value = sortedNumericDocValues.valueAt(i);\n            joinValues.add(value);\n            if (needsScore) {\n              scoreAggregator.accept(value, scorer.score());\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          long value = numericDocValues.get(doc);\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (doc > sortedNumericDocValues.docID()) {\n            sortedNumericDocValues.advance(doc);\n          }\n          if (doc == sortedNumericDocValues.docID()) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          int dvDocID = numericDocValues.docID();\n          if (dvDocID < doc) {\n            dvDocID = numericDocValues.advance(doc);\n          }\n          long value;\n          if (dvDocID == doc) {\n            value = numericDocValues.longValue();\n          } else {\n            value = 0;\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          sortedNumericDocValues.setDocument(doc);\n          for (int i = 0; i < sortedNumericDocValues.count(); i++) {\n            long value = sortedNumericDocValues.valueAt(i);\n            joinValues.add(value);\n            if (needsScore) {\n              scoreAggregator.accept(value, scorer.score());\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          long value = numericDocValues.get(doc);\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (doc > sortedNumericDocValues.docID()) {\n            sortedNumericDocValues.advance(doc);\n          }\n          if (doc == sortedNumericDocValues.docID()) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          int dvDocID = numericDocValues.docID();\n          if (dvDocID < doc) {\n            dvDocID = numericDocValues.advance(doc);\n          }\n          long value;\n          if (dvDocID == doc) {\n            value = numericDocValues.longValue();\n          } else {\n            value = 0;\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          sortedNumericDocValues.setDocument(doc);\n          for (int i = 0; i < sortedNumericDocValues.count(); i++) {\n            long value = sortedNumericDocValues.valueAt(i);\n            joinValues.add(value);\n            if (needsScore) {\n              scoreAggregator.accept(value, scorer.score());\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          long value = numericDocValues.get(doc);\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (doc > sortedNumericDocValues.docID()) {\n            sortedNumericDocValues.advance(doc);\n          }\n          if (doc == sortedNumericDocValues.docID()) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          int dvDocID = numericDocValues.docID();\n          if (dvDocID < doc) {\n            dvDocID = numericDocValues.advance(doc);\n          }\n          long value;\n          if (dvDocID == doc) {\n            value = numericDocValues.longValue();\n          } else {\n            value = 0;\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          sortedNumericDocValues.setDocument(doc);\n          for (int i = 0; i < sortedNumericDocValues.count(); i++) {\n            long value = sortedNumericDocValues.valueAt(i);\n            joinValues.add(value);\n            if (needsScore) {\n              scoreAggregator.accept(value, scorer.score());\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          long value = numericDocValues.get(doc);\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7","date":1495529154,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (doc > sortedNumericDocValues.docID()) {\n            sortedNumericDocValues.advance(doc);\n          }\n          if (doc == sortedNumericDocValues.docID()) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          int dvDocID = numericDocValues.docID();\n          if (dvDocID < doc) {\n            dvDocID = numericDocValues.advance(doc);\n          }\n          long value;\n          if (dvDocID == doc) {\n            value = numericDocValues.longValue();\n          } else {\n            value = 0;\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(scoreMode, fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (doc > sortedNumericDocValues.docID()) {\n            sortedNumericDocValues.advance(doc);\n          }\n          if (doc == sortedNumericDocValues.docID()) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          int dvDocID = numericDocValues.docID();\n          if (dvDocID < doc) {\n            dvDocID = numericDocValues.advance(doc);\n          }\n          long value;\n          if (dvDocID == doc) {\n            value = numericDocValues.longValue();\n          } else {\n            value = 0;\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (doc > sortedNumericDocValues.docID()) {\n            sortedNumericDocValues.advance(doc);\n          }\n          if (doc == sortedNumericDocValues.docID()) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          int dvDocID = numericDocValues.docID();\n          if (dvDocID < doc) {\n            dvDocID = numericDocValues.advance(doc);\n          }\n          long value;\n          if (dvDocID == doc) {\n            value = numericDocValues.longValue();\n          } else {\n            value = 0;\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(scoreMode, fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (doc > sortedNumericDocValues.docID()) {\n            sortedNumericDocValues.advance(doc);\n          }\n          if (doc == sortedNumericDocValues.docID()) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          int dvDocID = numericDocValues.docID();\n          if (dvDocID < doc) {\n            dvDocID = numericDocValues.advance(doc);\n          }\n          long value;\n          if (dvDocID == doc) {\n            value = numericDocValues.longValue();\n          } else {\n            value = 0;\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (doc > sortedNumericDocValues.docID()) {\n            sortedNumericDocValues.advance(doc);\n          }\n          if (doc == sortedNumericDocValues.docID()) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          int dvDocID = numericDocValues.docID();\n          if (dvDocID < doc) {\n            dvDocID = numericDocValues.advance(doc);\n          }\n          long value;\n          if (dvDocID == doc) {\n            value = numericDocValues.longValue();\n          } else {\n            value = 0;\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(scoreMode, fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (doc > sortedNumericDocValues.docID()) {\n            sortedNumericDocValues.advance(doc);\n          }\n          if (doc == sortedNumericDocValues.docID()) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          int dvDocID = numericDocValues.docID();\n          if (dvDocID < doc) {\n            dvDocID = numericDocValues.advance(doc);\n          }\n          long value;\n          if (dvDocID == doc) {\n            value = numericDocValues.longValue();\n          } else {\n            value = 0;\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(scoreMode, fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (doc > sortedNumericDocValues.docID()) {\n            sortedNumericDocValues.advance(doc);\n          }\n          if (doc == sortedNumericDocValues.docID()) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          int dvDocID = numericDocValues.docID();\n          if (dvDocID < doc) {\n            dvDocID = numericDocValues.advance(doc);\n          }\n          long value;\n          if (dvDocID == doc) {\n            value = numericDocValues.longValue();\n          } else {\n            value = 0;\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(scoreMode, fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (doc > sortedNumericDocValues.docID()) {\n            sortedNumericDocValues.advance(doc);\n          }\n          if (doc == sortedNumericDocValues.docID()) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          int dvDocID = numericDocValues.docID();\n          if (dvDocID < doc) {\n            dvDocID = numericDocValues.advance(doc);\n          }\n          long value;\n          if (dvDocID == doc) {\n            value = numericDocValues.longValue();\n          } else {\n            value = 0;\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return needsScore;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(scoreMode, fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81f64a6570bc5d216c5d575c3b29ecb106fa0e6b","date":1518443389,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (sortedNumericDocValues.advanceExact(doc)) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          long value = 0;\n          if (numericDocValues.advanceExact(doc)) {\n            value = numericDocValues.longValue();\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(scoreMode, fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (doc > sortedNumericDocValues.docID()) {\n            sortedNumericDocValues.advance(doc);\n          }\n          if (doc == sortedNumericDocValues.docID()) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          int dvDocID = numericDocValues.docID();\n          if (dvDocID < doc) {\n            dvDocID = numericDocValues.advance(doc);\n          }\n          long value;\n          if (dvDocID == doc) {\n            value = numericDocValues.longValue();\n          } else {\n            value = 0;\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(scoreMode, fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bfcdec9fcf0409223f35c5ec3bc14094314941b4","date":1518533599,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (sortedNumericDocValues.advanceExact(doc)) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          long value = 0;\n          if (numericDocValues.advanceExact(doc)) {\n            value = numericDocValues.longValue();\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(scoreMode, fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (doc > sortedNumericDocValues.docID()) {\n            sortedNumericDocValues.advance(doc);\n          }\n          if (doc == sortedNumericDocValues.docID()) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          int dvDocID = numericDocValues.docID();\n          if (dvDocID < doc) {\n            dvDocID = numericDocValues.advance(doc);\n          }\n          long value;\n          if (dvDocID == doc) {\n            value = numericDocValues.longValue();\n          } else {\n            value = 0;\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(scoreMode, fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285244982ce6aa163d1e60a707f0e6e121736ce5","date":1536055304,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorable scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (sortedNumericDocValues.advanceExact(doc)) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorable scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          long value = 0;\n          if (numericDocValues.advanceExact(doc)) {\n            value = numericDocValues.longValue();\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(scoreMode, fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (sortedNumericDocValues.advanceExact(doc)) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorer scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          long value = 0;\n          if (numericDocValues.advanceExact(doc)) {\n            value = numericDocValues.longValue();\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(scoreMode, fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"95904004e26fe5b84dcda2fa112ebf7cc9721a60","date":1560149781,"type":3,"author":"Tim Underwood","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Class[#-extends-Number],Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorable scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (sortedNumericDocValues.advanceExact(doc)) {\n            for (int i = 0, count = sortedNumericDocValues.docValueCount(); i < count; i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorable scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          long value = 0;\n          if (numericDocValues.advanceExact(doc)) {\n            value = numericDocValues.longValue();\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(scoreMode, fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs, ints, floats and longs.\n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntPoint}, {@link LongPoint}, {@link FloatPoint}\n   *                                  or {@link DoublePoint}.\n   * @param numericType               either {@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Float}\n   *                                  or {@link java.lang.Double} it should correspond to toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Class<? extends Number> numericType,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    TreeSet<Long> joinValues = new TreeSet<>();\n    Map<Long, Float> aggregatedScores = new HashMap<>();\n    Map<Long, Integer> occurrences = new HashMap<>();\n    boolean needsScore = scoreMode != ScoreMode.None;\n    BiConsumer<Long, Float> scoreAggregator;\n    if (scoreMode == ScoreMode.Max) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.max(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Min) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, Math.min(currentValue, score));\n        }\n      };\n    } else if (scoreMode == ScoreMode.Total) {\n      scoreAggregator = (key, score) -> {\n        Float currentValue = aggregatedScores.putIfAbsent(key, score);\n        if (currentValue != null) {\n          aggregatedScores.put(key, currentValue + score);\n        }\n      };\n    } else if (scoreMode == ScoreMode.Avg) {\n      scoreAggregator = (key, score) -> {\n        Float currentSore = aggregatedScores.putIfAbsent(key, score);\n        if (currentSore != null) {\n          aggregatedScores.put(key, currentSore + score);\n        }\n        Integer currentOccurrence = occurrences.putIfAbsent(key, 1);\n        if (currentOccurrence != null) {\n          occurrences.put(key, ++currentOccurrence);\n        }\n\n      };\n    } else {\n      scoreAggregator = (key, score) -> {\n        throw new UnsupportedOperationException();\n      };\n    }\n\n    LongFunction<Float> joinScorer;\n    if (scoreMode == ScoreMode.Avg) {\n      joinScorer = (joinValue) -> {\n        Float aggregatedScore = aggregatedScores.get(joinValue);\n        Integer occurrence = occurrences.get(joinValue);\n        return aggregatedScore / occurrence;\n      };\n    } else {\n      joinScorer = aggregatedScores::get;\n    }\n\n    Collector collector;\n    if (multipleValuesPerDocument) {\n      collector = new SimpleCollector() {\n\n        SortedNumericDocValues sortedNumericDocValues;\n        Scorable scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          if (sortedNumericDocValues.advanceExact(doc)) {\n            for (int i = 0; i < sortedNumericDocValues.docValueCount(); i++) {\n              long value = sortedNumericDocValues.nextValue();\n              joinValues.add(value);\n              if (needsScore) {\n                scoreAggregator.accept(value, scorer.score());\n              }\n            }\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          sortedNumericDocValues = DocValues.getSortedNumeric(context.reader(), fromField);\n        }\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    } else {\n      collector = new SimpleCollector() {\n\n        NumericDocValues numericDocValues;\n        Scorable scorer;\n        private int lastDocID = -1;\n\n        private boolean docsInOrder(int docID) {\n          if (docID < lastDocID) {\n            throw new AssertionError(\"docs out of order: lastDocID=\" + lastDocID + \" vs docID=\" + docID);\n          }\n          lastDocID = docID;\n          return true;\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          assert docsInOrder(doc);\n          long value = 0;\n          if (numericDocValues.advanceExact(doc)) {\n            value = numericDocValues.longValue();\n          }\n          joinValues.add(value);\n          if (needsScore) {\n            scoreAggregator.accept(value, scorer.score());\n          }\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          numericDocValues = DocValues.getNumeric(context.reader(), fromField);\n          lastDocID = -1;\n        }\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public org.apache.lucene.search.ScoreMode scoreMode() {\n          return needsScore ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n    }\n    fromSearcher.search(fromQuery, collector);\n\n    Iterator<Long> iterator = joinValues.iterator();\n\n    final int bytesPerDim;\n    final BytesRef encoded = new BytesRef();\n    final PointInSetIncludingScoreQuery.Stream stream;\n    if (Integer.class.equals(numericType)) {\n      bytesPerDim = Integer.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            IntPoint.encodeDimension((int) value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Long.class.equals(numericType)) {\n      bytesPerDim = Long.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            LongPoint.encodeDimension(value, encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Float.class.equals(numericType)) {\n      bytesPerDim = Float.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            FloatPoint.encodeDimension(Float.intBitsToFloat((int) value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else if (Double.class.equals(numericType)) {\n      bytesPerDim = Double.BYTES;\n      stream = new PointInSetIncludingScoreQuery.Stream() {\n        @Override\n        public BytesRef next() {\n          if (iterator.hasNext()) {\n            long value = iterator.next();\n            DoublePoint.encodeDimension(Double.longBitsToDouble(value), encoded.bytes, 0);\n            if (needsScore) {\n              score = joinScorer.apply(value);\n            }\n            return encoded;\n          } else {\n            return null;\n          }\n        }\n      };\n    } else {\n      throw new IllegalArgumentException(\"unsupported numeric type, only Integer, Long, Float and Double are supported\");\n    }\n\n    encoded.bytes = new byte[bytesPerDim];\n    encoded.length = bytesPerDim;\n\n    if (needsScore) {\n      return new PointInSetIncludingScoreQuery(scoreMode, fromQuery, multipleValuesPerDocument, toField, bytesPerDim, stream) {\n\n        @Override\n        protected String toString(byte[] value) {\n          return toString.apply(value, numericType);\n        }\n      };\n    } else {\n      return new PointInSetQuery(toField, 1, bytesPerDim, stream) {\n        @Override\n        protected String toString(byte[] value) {\n          return PointInSetIncludingScoreQuery.toString.apply(value, numericType);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"81f64a6570bc5d216c5d575c3b29ecb106fa0e6b":["417142ff08fda9cf0b72d5133e63097a166c6458"],"95904004e26fe5b84dcda2fa112ebf7cc9721a60":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"bfcdec9fcf0409223f35c5ec3bc14094314941b4":["417142ff08fda9cf0b72d5133e63097a166c6458","81f64a6570bc5d216c5d575c3b29ecb106fa0e6b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"417142ff08fda9cf0b72d5133e63097a166c6458":["00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7","9fc47cb7b4346802411bb432f501ed0673d7119e"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7"],"00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0a97513a3a796fa8e709a0dcfec8a2e628e721b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["95904004e26fe5b84dcda2fa112ebf7cc9721a60"]},"commit2Childs":{"81f64a6570bc5d216c5d575c3b29ecb106fa0e6b":["bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"95904004e26fe5b84dcda2fa112ebf7cc9721a60":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bfcdec9fcf0409223f35c5ec3bc14094314941b4":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"417142ff08fda9cf0b72d5133e63097a166c6458":["81f64a6570bc5d216c5d575c3b29ecb106fa0e6b","bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7":["417142ff08fda9cf0b72d5133e63097a166c6458","e9017cf144952056066919f1ebc7897ff9bd71b1","9fc47cb7b4346802411bb432f501ed0673d7119e"],"a0a97513a3a796fa8e709a0dcfec8a2e628e721b":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["95904004e26fe5b84dcda2fa112ebf7cc9721a60"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e9017cf144952056066919f1ebc7897ff9bd71b1","00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}