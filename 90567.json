{"path":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermStates[],Term[]).mjava","commits":[{"id":"a6e9f769521480a623f897c0d59089b919fa4239","date":1515161835,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermStates[],Term[]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":"  protected Query buildQuery(final int maxDoc,\n                             final TermStates[] contextArray, final Term[] queryTerms) {\n    List<Query> lowFreqQueries = new ArrayList<>();\n    List<Query> highFreqQueries = new ArrayList<>();\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermStates termStates = contextArray[i];\n      if (termStates == null) {\n        lowFreqQueries.add(newTermQuery(queryTerms[i], null));\n      } else {\n        if ((maxTermFrequency >= 1f && termStates.docFreq() > maxTermFrequency)\n            || (termStates.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreqQueries\n              .add(newTermQuery(queryTerms[i], termStates));\n        } else {\n          lowFreqQueries.add(newTermQuery(queryTerms[i], termStates));\n        }\n      }\n    }\n    final int numLowFreqClauses = lowFreqQueries.size();\n    final int numHighFreqClauses = highFreqQueries.size();\n    Occur lowFreqOccur = this.lowFreqOccur;\n    Occur highFreqOccur = this.highFreqOccur;\n    int lowFreqMinShouldMatch = 0;\n    int highFreqMinShouldMatch = 0;\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      lowFreqMinShouldMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      highFreqMinShouldMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n    }\n    if (lowFreqQueries.isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqMinShouldMatch == 0 && highFreqOccur != Occur.MUST) {\n        highFreqOccur = Occur.MUST;\n      }\n    }\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n\n    if (lowFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder lowFreq = new BooleanQuery.Builder();\n      for (Query query : lowFreqQueries) {\n        lowFreq.add(query, lowFreqOccur);\n      }\n      lowFreq.setMinimumNumberShouldMatch(lowFreqMinShouldMatch);\n      Query lowFreqQuery = lowFreq.build();\n      builder.add(new BoostQuery(lowFreqQuery, lowFreqBoost), Occur.MUST);\n    }\n    if (highFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder highFreq = new BooleanQuery.Builder();\n      for (Query query : highFreqQueries) {\n        highFreq.add(query, highFreqOccur);\n      }\n      highFreq.setMinimumNumberShouldMatch(highFreqMinShouldMatch);\n      Query highFreqQuery = highFreq.build();\n      builder.add(new BoostQuery(highFreqQuery, highFreqBoost), Occur.SHOULD);\n    }\n    return builder.build();\n  }\n\n","sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    List<Query> lowFreqQueries = new ArrayList<>();\n    List<Query> highFreqQueries = new ArrayList<>();\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreqQueries.add(newTermQuery(queryTerms[i], null));\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreqQueries\n              .add(newTermQuery(queryTerms[i], termContext));\n        } else {\n          lowFreqQueries.add(newTermQuery(queryTerms[i], termContext));\n        }\n      }\n    }\n    final int numLowFreqClauses = lowFreqQueries.size();\n    final int numHighFreqClauses = highFreqQueries.size();\n    Occur lowFreqOccur = this.lowFreqOccur;\n    Occur highFreqOccur = this.highFreqOccur;\n    int lowFreqMinShouldMatch = 0;\n    int highFreqMinShouldMatch = 0;\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      lowFreqMinShouldMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      highFreqMinShouldMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n    }\n    if (lowFreqQueries.isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqMinShouldMatch == 0 && highFreqOccur != Occur.MUST) {\n        highFreqOccur = Occur.MUST;\n      }\n    }\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n\n    if (lowFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder lowFreq = new BooleanQuery.Builder();\n      for (Query query : lowFreqQueries) {\n        lowFreq.add(query, lowFreqOccur);\n      }\n      lowFreq.setMinimumNumberShouldMatch(lowFreqMinShouldMatch);\n      Query lowFreqQuery = lowFreq.build();\n      builder.add(new BoostQuery(lowFreqQuery, lowFreqBoost), Occur.MUST);\n    }\n    if (highFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder highFreq = new BooleanQuery.Builder();\n      for (Query query : highFreqQueries) {\n        highFreq.add(query, highFreqOccur);\n      }\n      highFreq.setMinimumNumberShouldMatch(highFreqMinShouldMatch);\n      Query highFreqQuery = highFreq.build();\n      builder.add(new BoostQuery(highFreqQuery, highFreqBoost), Occur.SHOULD);\n    }\n    return builder.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermStates[],Term[]).mjava","pathOld":"/dev/null","sourceNew":"  protected Query buildQuery(final int maxDoc,\n                             final TermStates[] contextArray, final Term[] queryTerms) {\n    List<Query> lowFreqQueries = new ArrayList<>();\n    List<Query> highFreqQueries = new ArrayList<>();\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermStates termStates = contextArray[i];\n      if (termStates == null) {\n        lowFreqQueries.add(newTermQuery(queryTerms[i], null));\n      } else {\n        if ((maxTermFrequency >= 1f && termStates.docFreq() > maxTermFrequency)\n            || (termStates.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreqQueries\n              .add(newTermQuery(queryTerms[i], termStates));\n        } else {\n          lowFreqQueries.add(newTermQuery(queryTerms[i], termStates));\n        }\n      }\n    }\n    final int numLowFreqClauses = lowFreqQueries.size();\n    final int numHighFreqClauses = highFreqQueries.size();\n    Occur lowFreqOccur = this.lowFreqOccur;\n    Occur highFreqOccur = this.highFreqOccur;\n    int lowFreqMinShouldMatch = 0;\n    int highFreqMinShouldMatch = 0;\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      lowFreqMinShouldMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      highFreqMinShouldMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n    }\n    if (lowFreqQueries.isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqMinShouldMatch == 0 && highFreqOccur != Occur.MUST) {\n        highFreqOccur = Occur.MUST;\n      }\n    }\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n\n    if (lowFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder lowFreq = new BooleanQuery.Builder();\n      for (Query query : lowFreqQueries) {\n        lowFreq.add(query, lowFreqOccur);\n      }\n      lowFreq.setMinimumNumberShouldMatch(lowFreqMinShouldMatch);\n      Query lowFreqQuery = lowFreq.build();\n      builder.add(new BoostQuery(lowFreqQuery, lowFreqBoost), Occur.MUST);\n    }\n    if (highFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder highFreq = new BooleanQuery.Builder();\n      for (Query query : highFreqQueries) {\n        highFreq.add(query, highFreqOccur);\n      }\n      highFreq.setMinimumNumberShouldMatch(highFreqMinShouldMatch);\n      Query highFreqQuery = highFreq.build();\n      builder.add(new BoostQuery(highFreqQuery, highFreqBoost), Occur.SHOULD);\n    }\n    return builder.build();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a6e9f769521480a623f897c0d59089b919fa4239"],"a6e9f769521480a623f897c0d59089b919fa4239":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a6e9f769521480a623f897c0d59089b919fa4239":["b94236357aaa22b76c10629851fe4e376e0cea82"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","a6e9f769521480a623f897c0d59089b919fa4239"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}