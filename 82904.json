{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","commits":[{"id":"40aa98241c87d86a0077beb8023713d93a0becfe","date":1459784560,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"/dev/null","sourceNew":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  protected static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      throw new IllegalStateException(\"Ending edge buffer had only \"+edgeBuffer.size()+\" edges\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0384fe767a50d9d16907ca6924a3227c24a5c98c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09af2c9610ce53a4b25fd99344299b40318a4a1a","date":1459876565,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"/dev/null","sourceNew":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  protected static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      throw new IllegalStateException(\"Ending edge buffer had only \"+edgeBuffer.size()+\" edges\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a75c862521bb895a29958e7bc5cb188597205a08","date":1459977470,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  protected static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      throw new IllegalStateException(\"Ending edge buffer had only \"+edgeBuffer.size()+\" edges\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    //System.out.println(\"Concave polygon points:\");\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      //System.out.println(\" \"+edge.plane+\": \"+edge.startPoint+\"->\"+edge.endPoint+\"; previous? \"+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?\"in\":\"out\")+\" next? \"+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?\"in\":\"out\"));\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  protected static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      throw new IllegalStateException(\"Ending edge buffer had only \"+edgeBuffer.size()+\" edges\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5864f13b0b1ae08430bed46d2fcbc5f5c7005195","date":1460068279,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  private static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      throw new IllegalStateException(\"Ending edge buffer had only \"+edgeBuffer.size()+\" edges\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    //System.out.println(\"Concave polygon points:\");\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      //System.out.println(\" \"+edge.plane+\": \"+edge.startPoint+\"->\"+edge.endPoint+\"; previous? \"+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?\"in\":\"out\")+\" next? \"+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?\"in\":\"out\"));\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  protected static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      throw new IllegalStateException(\"Ending edge buffer had only \"+edgeBuffer.size()+\" edges\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    //System.out.println(\"Concave polygon points:\");\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      //System.out.println(\" \"+edge.plane+\": \"+edge.startPoint+\"->\"+edge.endPoint+\"; previous? \"+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?\"in\":\"out\")+\" next? \"+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?\"in\":\"out\"));\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa76b98015a97f0eca94f0f11fd1b6975838c3ee","date":1461000501,"type":5,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,MutableBoolean,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param seenConcave is true if we've already seen a concave polygon.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  private static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n      \n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    if (seenConcave.value) {\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n\n    seenConcave.value = true;\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      throw new IllegalStateException(\"Ending edge buffer had only \"+edgeBuffer.size()+\" edges\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    //System.out.println(\"Concave polygon points:\");\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      //System.out.println(\" \"+edge.plane+\": \"+edge.startPoint+\"->\"+edge.endPoint+\"; previous? \"+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?\"in\":\"out\")+\" next? \"+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?\"in\":\"out\"));\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  private static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      throw new IllegalStateException(\"Ending edge buffer had only \"+edgeBuffer.size()+\" edges\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    //System.out.println(\"Concave polygon points:\");\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      //System.out.println(\" \"+edge.plane+\": \"+edge.startPoint+\"->\"+edge.endPoint+\"; previous? \"+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?\"in\":\"out\")+\" next? \"+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?\"in\":\"out\"));\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"5864f13b0b1ae08430bed46d2fcbc5f5c7005195":["a75c862521bb895a29958e7bc5cb188597205a08"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","40aa98241c87d86a0077beb8023713d93a0becfe"],"fa76b98015a97f0eca94f0f11fd1b6975838c3ee":["5864f13b0b1ae08430bed46d2fcbc5f5c7005195"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"40aa98241c87d86a0077beb8023713d93a0becfe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"a75c862521bb895a29958e7bc5cb188597205a08":["40aa98241c87d86a0077beb8023713d93a0becfe"]},"commit2Childs":{"5864f13b0b1ae08430bed46d2fcbc5f5c7005195":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":[],"fa76b98015a97f0eca94f0f11fd1b6975838c3ee":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09af2c9610ce53a4b25fd99344299b40318a4a1a","40aa98241c87d86a0077beb8023713d93a0becfe"],"40aa98241c87d86a0077beb8023713d93a0becfe":["09af2c9610ce53a4b25fd99344299b40318a4a1a","a75c862521bb895a29958e7bc5cb188597205a08"],"a75c862521bb895a29958e7bc5cb188597205a08":["5864f13b0b1ae08430bed46d2fcbc5f5c7005195"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09af2c9610ce53a4b25fd99344299b40318a4a1a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}