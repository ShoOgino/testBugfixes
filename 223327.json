{"path":"lucene/sandbox/src/java/org/apache/lucene/search/PointInRectQuery#createWeight(IndexSearcher,boolean).mjava","commits":[{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/PointInRectQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/DimensionalPointInRectQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, 1));\n                             if (lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, 1));\n\n                             if (minLat <= cellMinLat && maxLat >= cellMaxLat && minLon <= cellMinLon && maxLon >= cellMaxLon) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n\n                             if (cellMaxLat < minLat || cellMinLat > maxLat || cellMaxLon < minLon || cellMinLon > maxLon) {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             return Relation.CELL_CROSSES_QUERY;\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        DimensionalValues values = reader.getDimensionalValues();\n        if (values == null) {\n          // No docs in this segment had any dimensional fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = DimensionalLatLonField.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = DimensionalLatLonField.decodeLon(NumericUtils.bytesToInt(packedValue, 1));\n                             if (lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = DimensionalLatLonField.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = DimensionalLatLonField.decodeLon(NumericUtils.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = DimensionalLatLonField.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = DimensionalLatLonField.decodeLon(NumericUtils.bytesToInt(maxPackedValue, 1));\n\n                             if (minLat <= cellMinLat && maxLat >= cellMaxLat && minLon <= cellMinLon && maxLon >= cellMaxLon) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n\n                             if (cellMaxLat < minLat || cellMinLat > maxLat || cellMaxLon < minLon || cellMinLon > maxLon) {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             return Relation.CELL_CROSSES_QUERY;\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f226a8b088dd9c8f6ab287a77237c4aa00a238e5","date":1456187572,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/PointInRectQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInRectQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n\n                             if (minLat <= cellMinLat && maxLat >= cellMaxLat && minLon <= cellMinLon && maxLon >= cellMaxLon) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n\n                             if (cellMaxLat < minLat || cellMinLat > maxLat || cellMaxLon < minLon || cellMinLon > maxLon) {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             return Relation.CELL_CROSSES_QUERY;\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, 1));\n                             if (lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, 1));\n\n                             if (minLat <= cellMinLat && maxLat >= cellMaxLat && minLon <= cellMinLon && maxLon >= cellMaxLon) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n\n                             if (cellMaxLat < minLat || cellMinLat > maxLat || cellMaxLon < minLon || cellMinLon > maxLon) {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             return Relation.CELL_CROSSES_QUERY;\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"419a8f52c6635419beb951255cacbbb281044c57","date":1456189353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/PointInRectQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInRectQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n\n                             if (minLat <= cellMinLat && maxLat >= cellMaxLat && minLon <= cellMinLon && maxLon >= cellMaxLon) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n\n                             if (cellMaxLat < minLat || cellMinLat > maxLat || cellMaxLon < minLon || cellMinLon > maxLon) {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             return Relation.CELL_CROSSES_QUERY;\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, 1));\n                             if (lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, 1));\n\n                             if (minLat <= cellMinLat && maxLat >= cellMaxLat && minLon <= cellMinLon && maxLon >= cellMaxLon) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n\n                             if (cellMaxLat < minLat || cellMinLat > maxLat || cellMaxLon < minLon || cellMinLon > maxLon) {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             return Relation.CELL_CROSSES_QUERY;\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"609ba4ce51a7095e9815d4fb2666ec85714f8f54","date":1456320705,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInRectQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n\n                             if (minLat <= cellMinLat && maxLat >= cellMaxLat && minLon <= cellMinLon && maxLon >= cellMaxLon) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n\n                             if (cellMaxLat < minLat || cellMinLat > maxLat || cellMaxLon < minLon || cellMinLon > maxLon) {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             return Relation.CELL_CROSSES_QUERY;\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6","date":1456321728,"type":4,"author":"Mike McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInRectQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n\n                             if (minLat <= cellMinLat && maxLat >= cellMaxLat && minLon <= cellMinLon && maxLon >= cellMaxLon) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n\n                             if (cellMaxLat < minLat || cellMinLat > maxLat || cellMaxLon < minLon || cellMinLon > maxLon) {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             return Relation.CELL_CROSSES_QUERY;\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"609ba4ce51a7095e9815d4fb2666ec85714f8f54":["419a8f52c6635419beb951255cacbbb281044c57"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"419a8f52c6635419beb951255cacbbb281044c57":["cab7a79353f33d1a94cd307bf33aa5148601ebe6","f226a8b088dd9c8f6ab287a77237c4aa00a238e5"],"f226a8b088dd9c8f6ab287a77237c4aa00a238e5":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6":["419a8f52c6635419beb951255cacbbb281044c57","609ba4ce51a7095e9815d4fb2666ec85714f8f54"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["609ba4ce51a7095e9815d4fb2666ec85714f8f54"]},"commit2Childs":{"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["419a8f52c6635419beb951255cacbbb281044c57","f226a8b088dd9c8f6ab287a77237c4aa00a238e5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"609ba4ce51a7095e9815d4fb2666ec85714f8f54":["1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"419a8f52c6635419beb951255cacbbb281044c57":["609ba4ce51a7095e9815d4fb2666ec85714f8f54","1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6"],"f226a8b088dd9c8f6ab287a77237c4aa00a238e5":["419a8f52c6635419beb951255cacbbb281044c57"],"1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}