{"path":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","commits":[{"id":"55110eb60c5105294fc2ae7912d82b750865aa58","date":1341389822,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=1, v=4\n   *  - 24 bits per value -> b=3, v=8\n   *  - 50 bits per value -> b=25, v=32\n   *  - 63 bits per value -> b=63, v = 64\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + v) longs in memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (8 * (b + v))</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = (ramBudget >>> 3) / (blocks() + values());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * blocks() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / values());\n    } else {\n      return iterations;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=1, v=4\n   *  - 24 bits per value -> b=3, v=8\n   *  - 50 bits per value -> b=25, v=32\n   *  - 63 bits per value -> b=63, v = 64\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + v) longs in memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (8 * (b + v))</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = (ramBudget >>> 3) / (blocks() + values());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * blocks() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / values());\n    } else {\n      return iterations;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e3359210474c12c0b79e6400450313e3d7ef2bb","date":1344347790,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","sourceNew":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=1, v=4\n   *  - 24 bits per value -> b=3, v=8\n   *  - 50 bits per value -> b=25, v=32\n   *  - 63 bits per value -> b=63, v=64\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + v) longs in memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (8 * (b + v))</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = (ramBudget >>> 3) / (blockCount() + valueCount());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * blockCount() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / valueCount());\n    } else {\n      return iterations;\n    }\n  }\n\n","sourceOld":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=1, v=4\n   *  - 24 bits per value -> b=3, v=8\n   *  - 50 bits per value -> b=25, v=32\n   *  - 63 bits per value -> b=63, v = 64\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + v) longs in memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (8 * (b + v))</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = (ramBudget >>> 3) / (blocks() + values());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * blocks() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / values());\n    } else {\n      return iterations;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8615860cb50aefb8eebca1d1b3893dbe21cf126","date":1345550448,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","sourceNew":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=1, v=4\n   *  - 24 bits per value -> b=3, v=8\n   *  - 50 bits per value -> b=25, v=32\n   *  - 63 bits per value -> b=63, v=64\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + v) longs in memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (8 * (b + v))</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = (ramBudget >>> 3) / (blockCount() + valueCount());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * blockCount() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / valueCount());\n    } else {\n      return iterations;\n    }\n  }\n\n","sourceOld":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=1, v=4\n   *  - 24 bits per value -> b=3, v=8\n   *  - 50 bits per value -> b=25, v=32\n   *  - 63 bits per value -> b=63, v = 64\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + v) longs in memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (8 * (b + v))</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = (ramBudget >>> 3) / (blocks() + values());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * blocks() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / values());\n    } else {\n      return iterations;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"001b25b42373b22a52f399dbf072f1224632e8e6","date":1345889167,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","sourceNew":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=1, v=4\n   *  - 24 bits per value -> b=3, v=8\n   *  - 50 bits per value -> b=25, v=32\n   *  - 63 bits per value -> b=63, v=64\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + v) longs in memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (8 * (b + v))</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = (ramBudget >>> 3) / (blockCount() + valueCount());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * blockCount() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / valueCount());\n    } else {\n      return iterations;\n    }\n  }\n\n","sourceOld":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=1, v=4\n   *  - 24 bits per value -> b=3, v=8\n   *  - 50 bits per value -> b=25, v=32\n   *  - 63 bits per value -> b=63, v = 64\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + v) longs in memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (8 * (b + v))</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = (ramBudget >>> 3) / (blocks() + values());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * blocks() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / values());\n    } else {\n      return iterations;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c661dcad9680b8a6ce5bf2cc583a69ec965328bc","date":1352297862,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","sourceNew":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=1, v=4\n   *  - 24 bits per value -> b=3, v=8\n   *  - 50 bits per value -> b=25, v=32\n   *  - 63 bits per value -> b=63, v=64\n   *  - ...\n   * <p>\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + v) longs in memory.\n   * <p>\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (8 * (b + v))</code> (since a long is 8 bytes).\n   * <p>\n   * The resulting number of iterations of this method is guaranteed not to\n   * overflow when multiplied by\n   * <tt>8 * {@link PackedInts.Encoder#blockCount()}</tt> or\n   * <tt>8 * {@link PackedInts.Decoder#blockCount()}</tt>.\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = (ramBudget >>> 3) / (blockCount() + valueCount());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * blockCount() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / valueCount());\n    } else {\n      return iterations;\n    }\n  }\n\n","sourceOld":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=1, v=4\n   *  - 24 bits per value -> b=3, v=8\n   *  - 50 bits per value -> b=25, v=32\n   *  - 63 bits per value -> b=63, v=64\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + v) longs in memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (8 * (b + v))</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = (ramBudget >>> 3) / (blockCount() + valueCount());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * blockCount() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / valueCount());\n    } else {\n      return iterations;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e29d4d91327929d477b701d3ef2f5b3457d26ec5","date":1359465689,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","sourceNew":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=2, v=1\n   *  - 24 bits per value -> b=3, v=1\n   *  - 50 bits per value -> b=25, v=4\n   *  - 63 bits per value -> b=63, v=8\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + 8v) bytes of memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (b + 8v)</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = ramBudget / (byteBlockCount() + 8 * byteValueCount());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * byteValueCount() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / byteValueCount());\n    } else {\n      return iterations;\n    }\n  }\n\n","sourceOld":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=1, v=4\n   *  - 24 bits per value -> b=3, v=8\n   *  - 50 bits per value -> b=25, v=32\n   *  - 63 bits per value -> b=63, v=64\n   *  - ...\n   * <p>\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + v) longs in memory.\n   * <p>\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (8 * (b + v))</code> (since a long is 8 bytes).\n   * <p>\n   * The resulting number of iterations of this method is guaranteed not to\n   * overflow when multiplied by\n   * <tt>8 * {@link PackedInts.Encoder#blockCount()}</tt> or\n   * <tt>8 * {@link PackedInts.Decoder#blockCount()}</tt>.\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = (ramBudget >>> 3) / (blockCount() + valueCount());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * blockCount() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / valueCount());\n    } else {\n      return iterations;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de522d9303bd67c8473a269a1319125d1f3700e0","date":1359477856,"type":3,"author":"Adrien Grand","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","sourceNew":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=2, v=1\n   *  - 24 bits per value -> b=3, v=1\n   *  - 50 bits per value -> b=25, v=4\n   *  - 63 bits per value -> b=63, v=8\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + 8v) bytes of memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (b + 8v)</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = ramBudget / (byteBlockCount() + 8 * byteValueCount());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * byteValueCount() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / byteValueCount());\n    } else {\n      return iterations;\n    }\n  }\n\n","sourceOld":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=1, v=4\n   *  - 24 bits per value -> b=3, v=8\n   *  - 50 bits per value -> b=25, v=32\n   *  - 63 bits per value -> b=63, v=64\n   *  - ...\n   * <p>\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + v) longs in memory.\n   * <p>\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (8 * (b + v))</code> (since a long is 8 bytes).\n   * <p>\n   * The resulting number of iterations of this method is guaranteed not to\n   * overflow when multiplied by\n   * <tt>8 * {@link PackedInts.Encoder#blockCount()}</tt> or\n   * <tt>8 * {@link PackedInts.Decoder#blockCount()}</tt>.\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = (ramBudget >>> 3) / (blockCount() + valueCount());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * blockCount() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / valueCount());\n    } else {\n      return iterations;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/BulkOperation#computeIterations(int,int).mjava","sourceNew":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -&gt; b=2, v=1\n   *  - 24 bits per value -&gt; b=3, v=1\n   *  - 50 bits per value -&gt; b=25, v=4\n   *  - 63 bits per value -&gt; b=63, v=8\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput): this requires n * (b + 8v) bytes of memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (b + 8v)</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = ramBudget / (byteBlockCount() + 8 * byteValueCount());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * byteValueCount() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / byteValueCount());\n    } else {\n      return iterations;\n    }\n  }\n\n","sourceOld":"  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=2, v=1\n   *  - 24 bits per value -> b=3, v=1\n   *  - 50 bits per value -> b=25, v=4\n   *  - 63 bits per value -> b=63, v=8\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + 8v) bytes of memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (b + 8v)</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = ramBudget / (byteBlockCount() + 8 * byteValueCount());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * byteValueCount() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / byteValueCount());\n    } else {\n      return iterations;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e29d4d91327929d477b701d3ef2f5b3457d26ec5":["c661dcad9680b8a6ce5bf2cc583a69ec965328bc"],"001b25b42373b22a52f399dbf072f1224632e8e6":["55110eb60c5105294fc2ae7912d82b750865aa58","f8615860cb50aefb8eebca1d1b3893dbe21cf126"],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["e29d4d91327929d477b701d3ef2f5b3457d26ec5"],"55110eb60c5105294fc2ae7912d82b750865aa58":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","55110eb60c5105294fc2ae7912d82b750865aa58"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c661dcad9680b8a6ce5bf2cc583a69ec965328bc":["f8615860cb50aefb8eebca1d1b3893dbe21cf126"],"0e3359210474c12c0b79e6400450313e3d7ef2bb":["fe33227f6805edab2036cbb80645cc4e2d1fa424"],"f8615860cb50aefb8eebca1d1b3893dbe21cf126":["55110eb60c5105294fc2ae7912d82b750865aa58","0e3359210474c12c0b79e6400450313e3d7ef2bb"],"de522d9303bd67c8473a269a1319125d1f3700e0":["c661dcad9680b8a6ce5bf2cc583a69ec965328bc","e29d4d91327929d477b701d3ef2f5b3457d26ec5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b1eb427f2c6beed80d1724555fc1db003ccf3030"]},"commit2Childs":{"e29d4d91327929d477b701d3ef2f5b3457d26ec5":["b1eb427f2c6beed80d1724555fc1db003ccf3030","de522d9303bd67c8473a269a1319125d1f3700e0"],"001b25b42373b22a52f399dbf072f1224632e8e6":[],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"55110eb60c5105294fc2ae7912d82b750865aa58":["001b25b42373b22a52f399dbf072f1224632e8e6","fe33227f6805edab2036cbb80645cc4e2d1fa424","f8615860cb50aefb8eebca1d1b3893dbe21cf126"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["0e3359210474c12c0b79e6400450313e3d7ef2bb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55110eb60c5105294fc2ae7912d82b750865aa58","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"c661dcad9680b8a6ce5bf2cc583a69ec965328bc":["e29d4d91327929d477b701d3ef2f5b3457d26ec5","de522d9303bd67c8473a269a1319125d1f3700e0"],"0e3359210474c12c0b79e6400450313e3d7ef2bb":["f8615860cb50aefb8eebca1d1b3893dbe21cf126"],"f8615860cb50aefb8eebca1d1b3893dbe21cf126":["001b25b42373b22a52f399dbf072f1224632e8e6","c661dcad9680b8a6ce5bf2cc583a69ec965328bc"],"de522d9303bd67c8473a269a1319125d1f3700e0":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["001b25b42373b22a52f399dbf072f1224632e8e6","de522d9303bd67c8473a269a1319125d1f3700e0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}