{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findSafePath(SafePath,List[GeoPoint],int,int).mjava","commits":[{"id":"536a864ce38bf14fb3f072a3129a389e95200e20","date":1461068886,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findSafePath(SafePath,List[GeoPoint],int,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Recursive depth-first path search.  In order to find a valid path, we must consider all possible legal extensions of\n   * the current path.  We discard any path that produces illegalities (meaning anything that would allow any coplanarity\n   * to continue to exist no matter from which direction one looks at it), and take the first legal path we find.\n   * @param currentPath is the current path (not null).\n   * @param points is the raw list of points under consideration.\n   * @param pointIndex is the index of the point that represents the next possible point for consideration for path\n   *  extension.\n   * @param startPointIndex is index of the point that starts the current path, so that we can know when we are done.\n   * @return null if there was no safe path found, or the safe path if one was discovered.\n   */\n  private static SafePath findSafePath(final SafePath currentPath, final List<GeoPoint> points, final int pointIndex,\n    final int startPointIndex) {\n    //System.err.println(\"extending path...\");\n      \n    // Loop across all possible path extensions, and consider each in turn\n    int considerPointIndex = pointIndex;\n    while (true) {\n      // Check if the extension of currentPath to considerPointIndex is workable\n      final GeoPoint considerStartPoint = currentPath.lastPoint;\n      final GeoPoint considerEndPoint = points.get(considerPointIndex);\n      // Create a plane including these two\n      final Plane considerPlane = new Plane(considerStartPoint, considerEndPoint);\n      boolean isChoiceLegal = true;\n      //System.err.println(\" considering \"+considerStartPoint+\" to \"+considerEndPoint);\n      if (isChoiceLegal) {\n        // Consider the previous plane/point\n        if (currentPath.lastPlane != null) {\n          if (currentPath.lastPlane.evaluateIsZero(considerEndPoint)) {\n            //System.err.println(\"  coplanar with last plane\");\n            // no good\n            isChoiceLegal = false;\n          } else if (considerPlane.evaluateIsZero(currentPath.previous.lastPoint)) {\n            //System.err.println(\"  last point coplanar with this plane\");\n            isChoiceLegal = false;\n          }\n        }\n      }\n      \n      if (isChoiceLegal && considerPointIndex == startPointIndex) {\n        // Verify that the first plane (already recorded) works together with the last plane\n        final SafePath firstPlaneEndpoint = currentPath.findFirstEndpoint();\n        if (firstPlaneEndpoint == null) {\n          //System.err.println(\"  path not long enough\");\n          isChoiceLegal = false;\n        } else {\n          if (firstPlaneEndpoint.lastPlane.evaluateIsZero(considerStartPoint)) {\n            //System.err.println(\"  last point is coplanar with start plane\");\n            isChoiceLegal = false;\n          } else if (considerPlane.evaluateIsZero(firstPlaneEndpoint.lastPoint)) {\n            //System.err.println(\"  first point is coplanar with last plane\");\n            isChoiceLegal = false;\n          }\n        }\n      }\n      \n      if (isChoiceLegal) {\n        // All points between the start and end, if any, must be on the plane.\n        int checkIndex = getLegalIndex(currentPath.lastPointIndex + 1, points.size());\n        while (checkIndex != considerPointIndex) {\n          if (!considerPlane.evaluateIsZero(points.get(checkIndex))) {\n            // This possibility is no good.  But does it say anything about other possibilities?  I think\n            // it may mean we don't have to consider any further extensions; gotta work that through\n            // mathematically though before coding it.\n            //System.err.println(\"  interior point not coplanar with trial plane\");\n            isChoiceLegal = false;\n            break;\n            //return null;\n          }\n          checkIndex = getLegalIndex(checkIndex + 1, points.size());\n        }\n      }\n      \n      \n      final int nextPointIndex = getLegalIndex(considerPointIndex + 1, points.size());\n      if (isChoiceLegal) {\n        // Extend the path and call ourselves recursively.\n        if (considerPointIndex == startPointIndex) {\n          // Current path has been validated; return it\n          return currentPath;\n        }\n        //System.err.println(\" adding to path: \"+considerEndPoint+\"; \"+considerPlane);\n        final SafePath newPath = new SafePath(currentPath, considerEndPoint, considerPointIndex, considerPlane);\n        final SafePath result = findSafePath(newPath, points, nextPointIndex, startPointIndex);\n        if (result != null) {\n          return result;\n        }\n      }\n      if (considerPointIndex == startPointIndex) {\n        break;\n      }\n      considerPointIndex = nextPointIndex;\n    }\n    return null;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2b323adf946209e3dff4da8140b772252e816f2","date":1461071380,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findSafePath(SafePath,List[GeoPoint],int,int).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findSafePath(SafePath,List[GeoPoint],int,int).mjava","sourceNew":"  /** Recursive depth-first path search.  In order to find a valid path, we must consider all possible legal extensions of\n   * the current path.  We discard any path that produces illegalities (meaning anything that would allow any coplanarity\n   * to continue to exist no matter from which direction one looks at it), and take the first legal path we find.\n   * @param currentPath is the current path (not null).\n   * @param points is the raw list of points under consideration.\n   * @param pointIndex is the index of the point that represents the next possible point for consideration for path\n   *  extension.\n   * @param startPointIndex is index of the point that starts the current path, so that we can know when we are done.\n   * @return null if there was no safe path found, or the safe path if one was discovered.\n   */\n  private static SafePath findSafePath(final SafePath currentPath, final List<GeoPoint> points, final int pointIndex,\n    final int startPointIndex) {\n    //System.err.println(\"extending path...\");\n      \n    // Loop across all possible path extensions, and consider each in turn\n    int considerPointIndex = pointIndex;\n    while (true) {\n      // Check if the extension of currentPath to considerPointIndex is workable\n      final GeoPoint considerStartPoint = currentPath.lastPoint;\n      final GeoPoint considerEndPoint = points.get(considerPointIndex);\n      final int nextPointIndex = getLegalIndex(considerPointIndex + 1, points.size());\n      if (!considerStartPoint.isNumericallyIdentical(considerEndPoint)) {\n        // Create a plane including these two\n        final Plane considerPlane = new Plane(considerStartPoint, considerEndPoint);\n        \n        boolean isChoiceLegal = true;\n\n        //System.err.println(\" considering \"+considerStartPoint+\" to \"+considerEndPoint);\n        if (isChoiceLegal) {\n          // Consider the previous plane/point\n          if (currentPath.lastPlane != null) {\n            if (currentPath.lastPlane.evaluateIsZero(considerEndPoint)) {\n              //System.err.println(\"  coplanar with last plane\");\n              // no good\n              isChoiceLegal = false;\n            } else if (considerPlane.evaluateIsZero(currentPath.previous.lastPoint)) {\n              //System.err.println(\"  last point coplanar with this plane\");\n              isChoiceLegal = false;\n            }\n          }\n        }\n        \n        if (isChoiceLegal && considerPointIndex == startPointIndex) {\n          // Verify that the first plane (already recorded) works together with the last plane\n          final SafePath firstPlaneEndpoint = currentPath.findFirstEndpoint();\n          if (firstPlaneEndpoint == null) {\n            //System.err.println(\"  path not long enough\");\n            isChoiceLegal = false;\n          } else {\n            if (firstPlaneEndpoint.lastPlane.evaluateIsZero(considerStartPoint)) {\n              //System.err.println(\"  last point is coplanar with start plane\");\n              isChoiceLegal = false;\n            } else if (considerPlane.evaluateIsZero(firstPlaneEndpoint.lastPoint)) {\n              //System.err.println(\"  first point is coplanar with last plane\");\n              isChoiceLegal = false;\n            }\n          }\n        }\n        \n        if (isChoiceLegal) {\n          // All points between the start and end, if any, must be on the plane.\n          int checkIndex = getLegalIndex(currentPath.lastPointIndex + 1, points.size());\n          while (checkIndex != considerPointIndex) {\n            if (!considerPlane.evaluateIsZero(points.get(checkIndex))) {\n              // This possibility is no good.  But does it say anything about other possibilities?  I think\n              // it may mean we don't have to consider any further extensions; gotta work that through\n              // mathematically though before coding it.\n              //System.err.println(\"  interior point not coplanar with trial plane\");\n              isChoiceLegal = false;\n              break;\n              //return null;\n            }\n            checkIndex = getLegalIndex(checkIndex + 1, points.size());\n          }\n        }\n        \n        if (isChoiceLegal) {\n          // Extend the path and call ourselves recursively.\n          if (considerPointIndex == startPointIndex) {\n            // Current path has been validated; return it\n            return currentPath;\n          }\n          //System.err.println(\" adding to path: \"+considerEndPoint+\"; \"+considerPlane);\n          final SafePath newPath = new SafePath(currentPath, considerEndPoint, considerPointIndex, considerPlane);\n          final SafePath result = findSafePath(newPath, points, nextPointIndex, startPointIndex);\n          if (result != null) {\n            return result;\n          }\n        }\n\n      }\n      \n      if (considerPointIndex == startPointIndex) {\n        break;\n      }\n      considerPointIndex = nextPointIndex;\n    }\n    return null;\n  }\n\n","sourceOld":"  /** Recursive depth-first path search.  In order to find a valid path, we must consider all possible legal extensions of\n   * the current path.  We discard any path that produces illegalities (meaning anything that would allow any coplanarity\n   * to continue to exist no matter from which direction one looks at it), and take the first legal path we find.\n   * @param currentPath is the current path (not null).\n   * @param points is the raw list of points under consideration.\n   * @param pointIndex is the index of the point that represents the next possible point for consideration for path\n   *  extension.\n   * @param startPointIndex is index of the point that starts the current path, so that we can know when we are done.\n   * @return null if there was no safe path found, or the safe path if one was discovered.\n   */\n  private static SafePath findSafePath(final SafePath currentPath, final List<GeoPoint> points, final int pointIndex,\n    final int startPointIndex) {\n    //System.err.println(\"extending path...\");\n      \n    // Loop across all possible path extensions, and consider each in turn\n    int considerPointIndex = pointIndex;\n    while (true) {\n      // Check if the extension of currentPath to considerPointIndex is workable\n      final GeoPoint considerStartPoint = currentPath.lastPoint;\n      final GeoPoint considerEndPoint = points.get(considerPointIndex);\n      // Create a plane including these two\n      final Plane considerPlane = new Plane(considerStartPoint, considerEndPoint);\n      boolean isChoiceLegal = true;\n      //System.err.println(\" considering \"+considerStartPoint+\" to \"+considerEndPoint);\n      if (isChoiceLegal) {\n        // Consider the previous plane/point\n        if (currentPath.lastPlane != null) {\n          if (currentPath.lastPlane.evaluateIsZero(considerEndPoint)) {\n            //System.err.println(\"  coplanar with last plane\");\n            // no good\n            isChoiceLegal = false;\n          } else if (considerPlane.evaluateIsZero(currentPath.previous.lastPoint)) {\n            //System.err.println(\"  last point coplanar with this plane\");\n            isChoiceLegal = false;\n          }\n        }\n      }\n      \n      if (isChoiceLegal && considerPointIndex == startPointIndex) {\n        // Verify that the first plane (already recorded) works together with the last plane\n        final SafePath firstPlaneEndpoint = currentPath.findFirstEndpoint();\n        if (firstPlaneEndpoint == null) {\n          //System.err.println(\"  path not long enough\");\n          isChoiceLegal = false;\n        } else {\n          if (firstPlaneEndpoint.lastPlane.evaluateIsZero(considerStartPoint)) {\n            //System.err.println(\"  last point is coplanar with start plane\");\n            isChoiceLegal = false;\n          } else if (considerPlane.evaluateIsZero(firstPlaneEndpoint.lastPoint)) {\n            //System.err.println(\"  first point is coplanar with last plane\");\n            isChoiceLegal = false;\n          }\n        }\n      }\n      \n      if (isChoiceLegal) {\n        // All points between the start and end, if any, must be on the plane.\n        int checkIndex = getLegalIndex(currentPath.lastPointIndex + 1, points.size());\n        while (checkIndex != considerPointIndex) {\n          if (!considerPlane.evaluateIsZero(points.get(checkIndex))) {\n            // This possibility is no good.  But does it say anything about other possibilities?  I think\n            // it may mean we don't have to consider any further extensions; gotta work that through\n            // mathematically though before coding it.\n            //System.err.println(\"  interior point not coplanar with trial plane\");\n            isChoiceLegal = false;\n            break;\n            //return null;\n          }\n          checkIndex = getLegalIndex(checkIndex + 1, points.size());\n        }\n      }\n      \n      \n      final int nextPointIndex = getLegalIndex(considerPointIndex + 1, points.size());\n      if (isChoiceLegal) {\n        // Extend the path and call ourselves recursively.\n        if (considerPointIndex == startPointIndex) {\n          // Current path has been validated; return it\n          return currentPath;\n        }\n        //System.err.println(\" adding to path: \"+considerEndPoint+\"; \"+considerPlane);\n        final SafePath newPath = new SafePath(currentPath, considerEndPoint, considerPointIndex, considerPlane);\n        final SafePath result = findSafePath(newPath, points, nextPointIndex, startPointIndex);\n        if (result != null) {\n          return result;\n        }\n      }\n      if (considerPointIndex == startPointIndex) {\n        break;\n      }\n      considerPointIndex = nextPointIndex;\n    }\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c4ea54ac6c0e876359818ff9634e6c179769c1e","date":1461111125,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findSafePath(SafePath,List[GeoPoint],int,int).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findSafePath(SafePath,List[GeoPoint],int,int).mjava","sourceNew":"  /** Recursive depth-first path search.  In order to find a valid path, we must consider all possible legal extensions of\n   * the current path.  We discard any path that produces illegalities (meaning anything that would allow any coplanarity\n   * to continue to exist no matter from which direction one looks at it), and take the first legal path we find.\n   * @param currentPath is the current path (not null).\n   * @param points is the raw list of points under consideration.\n   * @param pointIndex is the index of the point that represents the next possible point for consideration for path\n   *  extension.\n   * @param startPointIndex is index of the point that starts the current path, so that we can know when we are done.\n   * @return null if there was no safe path found, or the safe path if one was discovered.\n   */\n  private static SafePath findSafePath(final SafePath currentPath, final List<GeoPoint> points, final int pointIndex,\n    final int startPointIndex) {\n    //System.err.println(\"extending path...\");\n      \n    // Loop across all possible path extensions, and consider each in turn\n    int considerPointIndex = pointIndex;\n    while (true) {\n      // Check if the extension of currentPath to considerPointIndex is workable\n      final GeoPoint considerStartPoint = currentPath.lastPoint;\n      final GeoPoint considerEndPoint = points.get(considerPointIndex);\n      final int nextPointIndex = getLegalIndex(considerPointIndex + 1, points.size());\n      if (!considerStartPoint.isNumericallyIdentical(considerEndPoint)) {\n        // Create a plane including these two\n        final Plane considerPlane = new Plane(considerStartPoint, considerEndPoint);\n        \n        boolean isChoiceLegal = true;\n\n        //System.err.println(\" considering \"+considerStartPoint+\" to \"+considerEndPoint);\n        if (isChoiceLegal) {\n          // Consider the previous plane/point\n          if (currentPath.lastPlane != null) {\n            if (currentPath.lastPlane.evaluateIsZero(considerEndPoint)) {\n              //System.err.println(\"  coplanar with last plane\");\n              // no good\n              isChoiceLegal = false;\n            } else if (considerPlane.evaluateIsZero(currentPath.previous.lastPoint)) {\n              //System.err.println(\"  last point coplanar with this plane\");\n              isChoiceLegal = false;\n            }\n          }\n        }\n        \n        if (isChoiceLegal && considerPointIndex == startPointIndex) {\n          // Verify that the first plane (already recorded) works together with the last plane\n          final SafePath firstPlaneEndpoint = currentPath.findFirstEndpoint();\n          if (firstPlaneEndpoint == null) {\n            //System.err.println(\"  path not long enough\");\n            isChoiceLegal = false;\n          } else {\n            if (firstPlaneEndpoint.lastPlane.evaluateIsZero(considerStartPoint)) {\n              //System.err.println(\"  last point is coplanar with start plane\");\n              isChoiceLegal = false;\n            } else if (considerPlane.evaluateIsZero(firstPlaneEndpoint.lastPoint)) {\n              //System.err.println(\"  first point is coplanar with last plane\");\n              isChoiceLegal = false;\n            }\n          }\n        }\n        \n        if (isChoiceLegal) {\n          // All points between the start and end, if any, must be on the plane.\n          int checkIndex = getLegalIndex(currentPath.lastPointIndex + 1, points.size());\n          while (checkIndex != considerPointIndex) {\n            if (!considerPlane.evaluateIsZero(points.get(checkIndex))) {\n              // This possibility is no good.  But does it say anything about other possibilities?  I think\n              // it may mean we don't have to consider any further extensions.  I can't prove this, but\n              // it makes this algorithm complete in not an insane period of time at least...\n              //System.err.println(\"  interior point not coplanar with trial plane\");\n              //isChoiceLegal = false;\n              //break;\n              return null;\n            }\n            checkIndex = getLegalIndex(checkIndex + 1, points.size());\n          }\n        }\n        \n        if (isChoiceLegal) {\n          // Extend the path and call ourselves recursively.\n          if (considerPointIndex == startPointIndex) {\n            // Current path has been validated; return it\n            return currentPath;\n          }\n          //System.err.println(\" adding to path: \"+considerEndPoint+\"; \"+considerPlane);\n          final SafePath newPath = new SafePath(currentPath, considerEndPoint, considerPointIndex, considerPlane);\n          final SafePath result = findSafePath(newPath, points, nextPointIndex, startPointIndex);\n          if (result != null) {\n            return result;\n          }\n        }\n\n      }\n      \n      if (considerPointIndex == startPointIndex) {\n        break;\n      }\n      considerPointIndex = nextPointIndex;\n    }\n    return null;\n  }\n\n","sourceOld":"  /** Recursive depth-first path search.  In order to find a valid path, we must consider all possible legal extensions of\n   * the current path.  We discard any path that produces illegalities (meaning anything that would allow any coplanarity\n   * to continue to exist no matter from which direction one looks at it), and take the first legal path we find.\n   * @param currentPath is the current path (not null).\n   * @param points is the raw list of points under consideration.\n   * @param pointIndex is the index of the point that represents the next possible point for consideration for path\n   *  extension.\n   * @param startPointIndex is index of the point that starts the current path, so that we can know when we are done.\n   * @return null if there was no safe path found, or the safe path if one was discovered.\n   */\n  private static SafePath findSafePath(final SafePath currentPath, final List<GeoPoint> points, final int pointIndex,\n    final int startPointIndex) {\n    //System.err.println(\"extending path...\");\n      \n    // Loop across all possible path extensions, and consider each in turn\n    int considerPointIndex = pointIndex;\n    while (true) {\n      // Check if the extension of currentPath to considerPointIndex is workable\n      final GeoPoint considerStartPoint = currentPath.lastPoint;\n      final GeoPoint considerEndPoint = points.get(considerPointIndex);\n      final int nextPointIndex = getLegalIndex(considerPointIndex + 1, points.size());\n      if (!considerStartPoint.isNumericallyIdentical(considerEndPoint)) {\n        // Create a plane including these two\n        final Plane considerPlane = new Plane(considerStartPoint, considerEndPoint);\n        \n        boolean isChoiceLegal = true;\n\n        //System.err.println(\" considering \"+considerStartPoint+\" to \"+considerEndPoint);\n        if (isChoiceLegal) {\n          // Consider the previous plane/point\n          if (currentPath.lastPlane != null) {\n            if (currentPath.lastPlane.evaluateIsZero(considerEndPoint)) {\n              //System.err.println(\"  coplanar with last plane\");\n              // no good\n              isChoiceLegal = false;\n            } else if (considerPlane.evaluateIsZero(currentPath.previous.lastPoint)) {\n              //System.err.println(\"  last point coplanar with this plane\");\n              isChoiceLegal = false;\n            }\n          }\n        }\n        \n        if (isChoiceLegal && considerPointIndex == startPointIndex) {\n          // Verify that the first plane (already recorded) works together with the last plane\n          final SafePath firstPlaneEndpoint = currentPath.findFirstEndpoint();\n          if (firstPlaneEndpoint == null) {\n            //System.err.println(\"  path not long enough\");\n            isChoiceLegal = false;\n          } else {\n            if (firstPlaneEndpoint.lastPlane.evaluateIsZero(considerStartPoint)) {\n              //System.err.println(\"  last point is coplanar with start plane\");\n              isChoiceLegal = false;\n            } else if (considerPlane.evaluateIsZero(firstPlaneEndpoint.lastPoint)) {\n              //System.err.println(\"  first point is coplanar with last plane\");\n              isChoiceLegal = false;\n            }\n          }\n        }\n        \n        if (isChoiceLegal) {\n          // All points between the start and end, if any, must be on the plane.\n          int checkIndex = getLegalIndex(currentPath.lastPointIndex + 1, points.size());\n          while (checkIndex != considerPointIndex) {\n            if (!considerPlane.evaluateIsZero(points.get(checkIndex))) {\n              // This possibility is no good.  But does it say anything about other possibilities?  I think\n              // it may mean we don't have to consider any further extensions; gotta work that through\n              // mathematically though before coding it.\n              //System.err.println(\"  interior point not coplanar with trial plane\");\n              isChoiceLegal = false;\n              break;\n              //return null;\n            }\n            checkIndex = getLegalIndex(checkIndex + 1, points.size());\n          }\n        }\n        \n        if (isChoiceLegal) {\n          // Extend the path and call ourselves recursively.\n          if (considerPointIndex == startPointIndex) {\n            // Current path has been validated; return it\n            return currentPath;\n          }\n          //System.err.println(\" adding to path: \"+considerEndPoint+\"; \"+considerPlane);\n          final SafePath newPath = new SafePath(currentPath, considerEndPoint, considerPointIndex, considerPlane);\n          final SafePath result = findSafePath(newPath, points, nextPointIndex, startPointIndex);\n          if (result != null) {\n            return result;\n          }\n        }\n\n      }\n      \n      if (considerPointIndex == startPointIndex) {\n        break;\n      }\n      considerPointIndex = nextPointIndex;\n    }\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99b0a9e4d18bb364d2546e5230cc61abcd2d366b","date":1461241852,"type":5,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findSafePath(SafePath,List[GeoPoint],int,int,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findSafePath(SafePath,List[GeoPoint],int,int).mjava","sourceNew":"  /** Recursive depth-first path search.  In order to find a valid path, we must consider all possible legal extensions of\n   * the current path.  We discard any path that produces illegalities (meaning anything that would allow any coplanarity\n   * to continue to exist no matter from which direction one looks at it), and take the first legal path we find.\n   * @param currentPath is the current path (not null).\n   * @param points is the raw list of points under consideration.\n   * @param pointIndex is the index of the point that represents the next possible point for consideration for path\n   *  extension.\n   * @param startPointIndex is index of the point that starts the current path, so that we can know when we are done.\n   * @param leniencyValue is the maximum allowed distance of a point being skipped from the revised polygon.  Pass zero if\n   *  no leniency desired.\n   * @return null if there was no safe path found, or the safe path if one was discovered.\n   */\n  private static SafePath findSafePath(final SafePath currentPath, final List<GeoPoint> points, final int pointIndex,\n    final int startPointIndex, final double leniencyValue) {\n    //System.err.println(\"extending path...\");\n      \n    // Loop across all possible path extensions, and consider each in turn\n    int considerPointIndex = pointIndex;\n    while (true) {\n      // Check if the extension of currentPath to considerPointIndex is workable\n      final GeoPoint considerStartPoint = currentPath.lastPoint;\n      final GeoPoint considerEndPoint = points.get(considerPointIndex);\n      final int nextPointIndex = getLegalIndex(considerPointIndex + 1, points.size());\n      if (!considerStartPoint.isNumericallyIdentical(considerEndPoint)) {\n        // Create a plane including these two\n        final Plane considerPlane = new Plane(considerStartPoint, considerEndPoint);\n        \n        boolean isChoiceLegal = true;\n\n        //System.err.println(\" considering \"+considerStartPoint+\" to \"+considerEndPoint);\n        if (isChoiceLegal) {\n          // Consider the previous plane/point\n          if (currentPath.lastPlane != null) {\n            if (currentPath.lastPlane.evaluateIsZero(considerEndPoint)) {\n              //System.err.println(\"  coplanar with last plane\");\n              // no good\n              isChoiceLegal = false;\n            } else if (considerPlane.evaluateIsZero(currentPath.previous.lastPoint)) {\n              //System.err.println(\"  last point coplanar with this plane\");\n              isChoiceLegal = false;\n            } else {\n              // To guarantee that no planes we build are coplanar with edge points, we need to verify everything back from\n              // considerEndPoint back to the start of the path.  We build the edge from considerEndPoint back to each\n              // of the SafePath points already determined.  Then, we need to look at all triangles that include that edge and\n              // the SafePath points in between.  If all of those triangles are legal, we can be assured that adding the current\n              // proposed point is safe to do.\n              // This is, of course, a lot of work -- specifically, it's O(n^2) for each point in the path, which leads to an O(n^3)\n              // evaluation time overall!!\n              // The only alternative is to understand the cases under which these triangles would be introduced, and tailor the\n              // cleaning to catch those cases only.  Still need to figure that out.  The case that blows up is when *all* the points\n              // for a triangle are coplanar, so theoretically we don't even need to generate the triangle at all(!)\n              // \n              // Build a plane that represents the third edge in this triangle, to guarantee that we can compose\n              // the polygon from triangles\n              final Plane thirdPlane = new Plane(currentPath.previous.lastPoint, considerEndPoint);\n              if (thirdPlane.evaluateIsZero(considerStartPoint)) {\n                isChoiceLegal = false;\n              }\n            }\n          }\n        }\n        \n        if (isChoiceLegal && considerPointIndex == startPointIndex) {\n          // Verify that the first plane (already recorded) works together with the last plane\n          final SafePath firstPlaneEndpoint = currentPath.findFirstEndpoint();\n          if (firstPlaneEndpoint == null) {\n            //System.err.println(\"  path not long enough\");\n            isChoiceLegal = false;\n          } else {\n            if (firstPlaneEndpoint.lastPlane.evaluateIsZero(considerStartPoint)) {\n              //System.err.println(\"  last point is coplanar with start plane\");\n              isChoiceLegal = false;\n            } else if (considerPlane.evaluateIsZero(firstPlaneEndpoint.lastPoint)) {\n              //System.err.println(\"  first point is coplanar with last plane\");\n              isChoiceLegal = false;\n            } else {\n              // Build a plane that represents the third edge in this triangle, to guarantee that we can compose\n              // the polygon from triangles\n              final Plane thirdPlane = new Plane(considerStartPoint, firstPlaneEndpoint.lastPoint);\n              if (thirdPlane.evaluateIsZero(considerEndPoint)) {\n                isChoiceLegal = false;\n              }\n            }\n          }\n        }\n        \n        if (isChoiceLegal) {\n          // All points between the start and end, if any, must be on the plane.\n          int checkIndex = getLegalIndex(currentPath.lastPointIndex + 1, points.size());\n          while (checkIndex != considerPointIndex) {\n            if (Math.abs(considerPlane.evaluate(points.get(checkIndex))) >= Vector.MINIMUM_RESOLUTION + leniencyValue) {\n              // This possibility is no good.  But does it say anything about other possibilities?  I think\n              // it may mean we don't have to consider any further extensions.  I can't prove this, but\n              // it makes this algorithm complete in not an insane period of time at least...\n              //System.err.println(\"  interior point not coplanar with trial plane\");\n              //isChoiceLegal = false;\n              //break;\n              return null;\n            }\n            checkIndex = getLegalIndex(checkIndex + 1, points.size());\n          }\n        }\n        \n        if (isChoiceLegal) {\n          // Extend the path and call ourselves recursively.\n          if (considerPointIndex == startPointIndex) {\n            // Current path has been validated; return it\n            return currentPath;\n          }\n          //System.err.println(\" adding to path: \"+considerEndPoint+\"; \"+considerPlane);\n          final SafePath newPath = new SafePath(currentPath, considerEndPoint, considerPointIndex, considerPlane);\n          final SafePath result = findSafePath(newPath, points, nextPointIndex, startPointIndex, leniencyValue);\n          if (result != null) {\n            return result;\n          }\n        }\n\n      }\n      \n      if (considerPointIndex == startPointIndex) {\n        break;\n      }\n      considerPointIndex = nextPointIndex;\n    }\n    return null;\n  }\n\n","sourceOld":"  /** Recursive depth-first path search.  In order to find a valid path, we must consider all possible legal extensions of\n   * the current path.  We discard any path that produces illegalities (meaning anything that would allow any coplanarity\n   * to continue to exist no matter from which direction one looks at it), and take the first legal path we find.\n   * @param currentPath is the current path (not null).\n   * @param points is the raw list of points under consideration.\n   * @param pointIndex is the index of the point that represents the next possible point for consideration for path\n   *  extension.\n   * @param startPointIndex is index of the point that starts the current path, so that we can know when we are done.\n   * @return null if there was no safe path found, or the safe path if one was discovered.\n   */\n  private static SafePath findSafePath(final SafePath currentPath, final List<GeoPoint> points, final int pointIndex,\n    final int startPointIndex) {\n    //System.err.println(\"extending path...\");\n      \n    // Loop across all possible path extensions, and consider each in turn\n    int considerPointIndex = pointIndex;\n    while (true) {\n      // Check if the extension of currentPath to considerPointIndex is workable\n      final GeoPoint considerStartPoint = currentPath.lastPoint;\n      final GeoPoint considerEndPoint = points.get(considerPointIndex);\n      final int nextPointIndex = getLegalIndex(considerPointIndex + 1, points.size());\n      if (!considerStartPoint.isNumericallyIdentical(considerEndPoint)) {\n        // Create a plane including these two\n        final Plane considerPlane = new Plane(considerStartPoint, considerEndPoint);\n        \n        boolean isChoiceLegal = true;\n\n        //System.err.println(\" considering \"+considerStartPoint+\" to \"+considerEndPoint);\n        if (isChoiceLegal) {\n          // Consider the previous plane/point\n          if (currentPath.lastPlane != null) {\n            if (currentPath.lastPlane.evaluateIsZero(considerEndPoint)) {\n              //System.err.println(\"  coplanar with last plane\");\n              // no good\n              isChoiceLegal = false;\n            } else if (considerPlane.evaluateIsZero(currentPath.previous.lastPoint)) {\n              //System.err.println(\"  last point coplanar with this plane\");\n              isChoiceLegal = false;\n            }\n          }\n        }\n        \n        if (isChoiceLegal && considerPointIndex == startPointIndex) {\n          // Verify that the first plane (already recorded) works together with the last plane\n          final SafePath firstPlaneEndpoint = currentPath.findFirstEndpoint();\n          if (firstPlaneEndpoint == null) {\n            //System.err.println(\"  path not long enough\");\n            isChoiceLegal = false;\n          } else {\n            if (firstPlaneEndpoint.lastPlane.evaluateIsZero(considerStartPoint)) {\n              //System.err.println(\"  last point is coplanar with start plane\");\n              isChoiceLegal = false;\n            } else if (considerPlane.evaluateIsZero(firstPlaneEndpoint.lastPoint)) {\n              //System.err.println(\"  first point is coplanar with last plane\");\n              isChoiceLegal = false;\n            }\n          }\n        }\n        \n        if (isChoiceLegal) {\n          // All points between the start and end, if any, must be on the plane.\n          int checkIndex = getLegalIndex(currentPath.lastPointIndex + 1, points.size());\n          while (checkIndex != considerPointIndex) {\n            if (!considerPlane.evaluateIsZero(points.get(checkIndex))) {\n              // This possibility is no good.  But does it say anything about other possibilities?  I think\n              // it may mean we don't have to consider any further extensions.  I can't prove this, but\n              // it makes this algorithm complete in not an insane period of time at least...\n              //System.err.println(\"  interior point not coplanar with trial plane\");\n              //isChoiceLegal = false;\n              //break;\n              return null;\n            }\n            checkIndex = getLegalIndex(checkIndex + 1, points.size());\n          }\n        }\n        \n        if (isChoiceLegal) {\n          // Extend the path and call ourselves recursively.\n          if (considerPointIndex == startPointIndex) {\n            // Current path has been validated; return it\n            return currentPath;\n          }\n          //System.err.println(\" adding to path: \"+considerEndPoint+\"; \"+considerPlane);\n          final SafePath newPath = new SafePath(currentPath, considerEndPoint, considerPointIndex, considerPlane);\n          final SafePath result = findSafePath(newPath, points, nextPointIndex, startPointIndex);\n          if (result != null) {\n            return result;\n          }\n        }\n\n      }\n      \n      if (considerPointIndex == startPointIndex) {\n        break;\n      }\n      considerPointIndex = nextPointIndex;\n    }\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2c4ea54ac6c0e876359818ff9634e6c179769c1e":["f2b323adf946209e3dff4da8140b772252e816f2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f2b323adf946209e3dff4da8140b772252e816f2":["536a864ce38bf14fb3f072a3129a389e95200e20"],"99b0a9e4d18bb364d2546e5230cc61abcd2d366b":["2c4ea54ac6c0e876359818ff9634e6c179769c1e"],"536a864ce38bf14fb3f072a3129a389e95200e20":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["99b0a9e4d18bb364d2546e5230cc61abcd2d366b"]},"commit2Childs":{"2c4ea54ac6c0e876359818ff9634e6c179769c1e":["99b0a9e4d18bb364d2546e5230cc61abcd2d366b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["536a864ce38bf14fb3f072a3129a389e95200e20"],"f2b323adf946209e3dff4da8140b772252e816f2":["2c4ea54ac6c0e876359818ff9634e6c179769c1e"],"536a864ce38bf14fb3f072a3129a389e95200e20":["f2b323adf946209e3dff4da8140b772252e816f2"],"99b0a9e4d18bb364d2546e5230cc61abcd2d366b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}