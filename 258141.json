{"path":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","commits":[{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n      } \n      if (IndexReader.indexExists(this)) {\n        _TestUtil.checkIndex(this);\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n      } \n      if (codecProvider != null) {\n        if (IndexReader.indexExists(this, codecProvider)) {\n          _TestUtil.checkIndex(this, codecProvider);\n        }\n      } else {\n        if (IndexReader.indexExists(this)) {\n          _TestUtil.checkIndex(this);\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6a3fe8668125a7bb217ab4b515c348a6d21ddf9","date":1322493662,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (IndexReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        unSyncedFiles.remove(\"segments.gen\"); // otherwise we add minutes to the tests: LUCENE-3605\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this);\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n      } \n      if (IndexReader.indexExists(this)) {\n        _TestUtil.checkIndex(this);\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"47d5b6b2c183bf4deaffb52b7cb8dec16c8dcf0f","date":1322512504,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (IndexReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        unSyncedFiles.remove(\"segments.gen\"); // otherwise we add minutes to the tests: LUCENE-3605\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (IndexReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        unSyncedFiles.remove(\"segments.gen\"); // otherwise we add minutes to the tests: LUCENE-3605\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this);\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ceef57f21382e9c2115ed48b8e59c77d88957ad","date":1322525856,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (IndexReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        unSyncedFiles.remove(\"segments.gen\"); // otherwise we add minutes to the tests: LUCENE-3605\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          IndexReader ir1 = IndexReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          IndexReader ir2 = IndexReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (IndexReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        unSyncedFiles.remove(\"segments.gen\"); // otherwise we add minutes to the tests: LUCENE-3605\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af9b2f910f7011e60325d367a3aefa7a319d3ba7","date":1324575573,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (IndexReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          IndexReader ir1 = IndexReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          IndexReader ir2 = IndexReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (IndexReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        unSyncedFiles.remove(\"segments.gen\"); // otherwise we add minutes to the tests: LUCENE-3605\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          IndexReader ir1 = IndexReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          IndexReader ir2 = IndexReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d85277fe0f487ec4ed00df56cce41f715e1a5a1c","date":1326716247,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (IndexReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, crossCheckTermVectorsOnClose);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          IndexReader ir1 = IndexReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          IndexReader ir2 = IndexReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (IndexReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          IndexReader ir1 = IndexReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          IndexReader ir2 = IndexReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":["d19974432be9aed28ee7dca73bdf01d139e763a9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94","date":1327846543,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, crossCheckTermVectorsOnClose);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (IndexReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, crossCheckTermVectorsOnClose);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          IndexReader ir1 = IndexReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          IndexReader ir2 = IndexReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, crossCheckTermVectorsOnClose);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (IndexReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, crossCheckTermVectorsOnClose);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          IndexReader ir1 = IndexReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          IndexReader ir2 = IndexReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#close().mjava","sourceNew":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, crossCheckTermVectorsOnClose);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void close() throws IOException {\n    maybeYield();\n    if (openFiles == null) {\n      openFiles = new HashMap<String,Integer>();\n      openFilesDeleted = new HashSet<String>();\n    }\n    if (noDeleteOpenFile && openFiles.size() > 0) {\n      // print the first one as its very verbose otherwise\n      Exception cause = null;\n      Iterator<Exception> stacktraces = openFileHandles.values().iterator();\n      if (stacktraces.hasNext())\n        cause = stacktraces.next();\n      // RuntimeException instead of IOException because\n      // super() does not throw IOException currently:\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open files: \" + openFiles, cause);\n    }\n    if (noDeleteOpenFile && openLocks.size() > 0) {\n      throw new RuntimeException(\"MockDirectoryWrapper: cannot close: there are still open locks: \" + openLocks);\n    }\n    open = false;\n    if (checkIndexOnClose) {\n      if (DirectoryReader.indexExists(this)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now crash\");\n        }\n        crash(); // corrumpt any unsynced-files\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"\\nNOTE: MockDirectoryWrapper: now run CheckIndex\");\n        } \n        _TestUtil.checkIndex(this, crossCheckTermVectorsOnClose);\n\n        if (assertNoUnreferencedFilesOnClose) {\n          // now look for unreferenced files:\n          String[] startFiles = listAll();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).rollback();\n          String[] endFiles = listAll();\n\n          Arrays.sort(startFiles);\n          Arrays.sort(endFiles);\n\n          if (!Arrays.equals(startFiles, endFiles)) {\n            assert false : \"unreferenced files: before delete:\\n    \" + Arrays.toString(startFiles) + \"\\n  after delete:\\n    \" + Arrays.toString(endFiles);\n          }\n\n          DirectoryReader ir1 = DirectoryReader.open(this);\n          int numDocs1 = ir1.numDocs();\n          ir1.close();\n          new IndexWriter(this, new IndexWriterConfig(LuceneTestCase.TEST_VERSION_CURRENT, null)).close();\n          DirectoryReader ir2 = DirectoryReader.open(this);\n          int numDocs2 = ir2.numDocs();\n          ir2.close();\n          assert numDocs1 == numDocs2 : \"numDocs changed after opening/closing IW: before=\" + numDocs1 + \" after=\" + numDocs2;\n        }\n      }\n    }\n    delegate.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a6a3fe8668125a7bb217ab4b515c348a6d21ddf9":["7b91922b55d15444d554721b352861d028eb8278"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"d85277fe0f487ec4ed00df56cce41f715e1a5a1c":["af9b2f910f7011e60325d367a3aefa7a319d3ba7"],"af9b2f910f7011e60325d367a3aefa7a319d3ba7":["0ceef57f21382e9c2115ed48b8e59c77d88957ad"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94":["d85277fe0f487ec4ed00df56cce41f715e1a5a1c"],"47d5b6b2c183bf4deaffb52b7cb8dec16c8dcf0f":["a6a3fe8668125a7bb217ab4b515c348a6d21ddf9"],"0ceef57f21382e9c2115ed48b8e59c77d88957ad":["47d5b6b2c183bf4deaffb52b7cb8dec16c8dcf0f"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["d85277fe0f487ec4ed00df56cce41f715e1a5a1c","a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["a6a3fe8668125a7bb217ab4b515c348a6d21ddf9"],"a6a3fe8668125a7bb217ab4b515c348a6d21ddf9":["47d5b6b2c183bf4deaffb52b7cb8dec16c8dcf0f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d85277fe0f487ec4ed00df56cce41f715e1a5a1c":["a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94","5cab9a86bd67202d20b6adc463008c8e982b070a"],"af9b2f910f7011e60325d367a3aefa7a319d3ba7":["d85277fe0f487ec4ed00df56cce41f715e1a5a1c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7b91922b55d15444d554721b352861d028eb8278"],"a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"47d5b6b2c183bf4deaffb52b7cb8dec16c8dcf0f":["0ceef57f21382e9c2115ed48b8e59c77d88957ad"],"0ceef57f21382e9c2115ed48b8e59c77d88957ad":["af9b2f910f7011e60325d367a3aefa7a319d3ba7"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}