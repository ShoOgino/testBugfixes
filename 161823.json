{"path":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#getParamsFromJSON(Map[String,String[]],String).mjava","commits":[{"id":"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d","date":1426480823,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#getParamsFromJSON(Map[String,String[]],String).mjava","pathOld":"/dev/null","sourceNew":"  private static void getParamsFromJSON(Map<String, String[]> params, String json) {\n    if (json.indexOf(\"params\") < 0) {\n      return;\n    }\n\n    JSONParser parser = new JSONParser(json);\n    try {\n      JSONUtil.expect(parser, JSONParser.OBJECT_START);\n      boolean found = JSONUtil.advanceToMapKey(parser, \"params\", false);\n      if (!found) {\n        return;\n      }\n\n      parser.nextEvent();  // advance to the value\n\n      Object o = ObjectBuilder.getVal(parser);\n      if (!(o instanceof Map)) return;\n      Map<String,Object> map = (Map<String,Object>)o;\n      // To make consistent with json.param handling, we should make query params come after json params (i.e. query params should\n      // appear to overwrite json params.\n\n      // Solr params are based on String though, so we need to convert\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        Object val = entry.getValue();\n        if (params.get(key) != null) {\n          continue;\n        }\n\n        if (val == null) {\n          params.remove(key);\n        } else if (val instanceof List) {\n          List lst = (List) val;\n          String[] vals = new String[lst.size()];\n          for (int i = 0; i < vals.length; i++) {\n            vals[i] = lst.get(i).toString();\n          }\n          params.put(key, vals);\n        } else {\n          params.put(key, new String[]{val.toString()});\n        }\n      }\n\n    } catch (Exception e) {\n      // ignore parse exceptions at this stage, they may be caused by incomplete macro expansions\n      return;\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#getParamsFromJSON(Map[String,String[]],String).mjava","pathOld":"/dev/null","sourceNew":"  private static void getParamsFromJSON(Map<String, String[]> params, String json) {\n    if (json.indexOf(\"params\") < 0) {\n      return;\n    }\n\n    JSONParser parser = new JSONParser(json);\n    try {\n      JSONUtil.expect(parser, JSONParser.OBJECT_START);\n      boolean found = JSONUtil.advanceToMapKey(parser, \"params\", false);\n      if (!found) {\n        return;\n      }\n\n      parser.nextEvent();  // advance to the value\n\n      Object o = ObjectBuilder.getVal(parser);\n      if (!(o instanceof Map)) return;\n      Map<String,Object> map = (Map<String,Object>)o;\n      // To make consistent with json.param handling, we should make query params come after json params (i.e. query params should\n      // appear to overwrite json params.\n\n      // Solr params are based on String though, so we need to convert\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        Object val = entry.getValue();\n        if (params.get(key) != null) {\n          continue;\n        }\n\n        if (val == null) {\n          params.remove(key);\n        } else if (val instanceof List) {\n          List lst = (List) val;\n          String[] vals = new String[lst.size()];\n          for (int i = 0; i < vals.length; i++) {\n            vals[i] = lst.get(i).toString();\n          }\n          params.put(key, vals);\n        } else {\n          params.put(key, new String[]{val.toString()});\n        }\n      }\n\n    } catch (Exception e) {\n      // ignore parse exceptions at this stage, they may be caused by incomplete macro expansions\n      return;\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0dec8faa342587767c2f95ad26a8315b8068392b","date":1578083291,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#getParamsFromJSON(Map[String,String[]],String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#getParamsFromJSON(Map[String,String[]],String).mjava","sourceNew":"  private static void getParamsFromJSON(Map<String, String[]> params, String json) {\n    if (json.indexOf(\"params\") < 0) {\n      return;\n    }\n\n    JSONParser parser = new JSONParser(json);\n    try {\n      JSONUtil.expect(parser, JSONParser.OBJECT_START);\n      boolean found = JSONUtil.advanceToMapKey(parser, \"params\", false);\n      if (!found) {\n        return;\n      }\n\n      parser.nextEvent();  // advance to the value\n\n      Object o = ObjectBuilder.getVal(parser);\n      if (!(o instanceof Map)) return;\n      @SuppressWarnings(\"unchecked\")\n      Map<String,Object> map = (Map<String,Object>)o;\n      // To make consistent with json.param handling, we should make query params come after json params (i.e. query params should\n      // appear to overwrite json params.\n\n      // Solr params are based on String though, so we need to convert\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        Object val = entry.getValue();\n        if (params.get(key) != null) {\n          continue;\n        }\n\n        if (val == null) {\n          params.remove(key);\n        } else if (val instanceof List) {\n          List<?> lst = (List<?>) val;\n          String[] vals = new String[lst.size()];\n          for (int i = 0; i < vals.length; i++) {\n            vals[i] = lst.get(i).toString();\n          }\n          params.put(key, vals);\n        } else {\n          params.put(key, new String[]{val.toString()});\n        }\n      }\n\n    } catch (Exception e) {\n      // ignore parse exceptions at this stage, they may be caused by incomplete macro expansions\n      return;\n    }\n\n  }\n\n","sourceOld":"  private static void getParamsFromJSON(Map<String, String[]> params, String json) {\n    if (json.indexOf(\"params\") < 0) {\n      return;\n    }\n\n    JSONParser parser = new JSONParser(json);\n    try {\n      JSONUtil.expect(parser, JSONParser.OBJECT_START);\n      boolean found = JSONUtil.advanceToMapKey(parser, \"params\", false);\n      if (!found) {\n        return;\n      }\n\n      parser.nextEvent();  // advance to the value\n\n      Object o = ObjectBuilder.getVal(parser);\n      if (!(o instanceof Map)) return;\n      Map<String,Object> map = (Map<String,Object>)o;\n      // To make consistent with json.param handling, we should make query params come after json params (i.e. query params should\n      // appear to overwrite json params.\n\n      // Solr params are based on String though, so we need to convert\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        Object val = entry.getValue();\n        if (params.get(key) != null) {\n          continue;\n        }\n\n        if (val == null) {\n          params.remove(key);\n        } else if (val instanceof List) {\n          List lst = (List) val;\n          String[] vals = new String[lst.size()];\n          for (int i = 0; i < vals.length; i++) {\n            vals[i] = lst.get(i).toString();\n          }\n          params.put(key, vals);\n        } else {\n          params.put(key, new String[]{val.toString()});\n        }\n      }\n\n    } catch (Exception e) {\n      // ignore parse exceptions at this stage, they may be caused by incomplete macro expansions\n      return;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca62564055241632cd20d65b5ecb8c8e93bd60c4","date":1578383112,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#getParamsFromJSON(Map[String,String[]],String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#getParamsFromJSON(Map[String,String[]],String).mjava","sourceNew":"  private static void getParamsFromJSON(Map<String, String[]> params, String json) {\n    if (json.indexOf(\"params\") < 0) {\n      return;\n    }\n\n    JSONParser parser = new JSONParser(json);\n    try {\n      JSONUtil.expect(parser, JSONParser.OBJECT_START);\n      boolean found = JSONUtil.advanceToMapKey(parser, \"params\", false);\n      if (!found) {\n        return;\n      }\n\n      parser.nextEvent();  // advance to the value\n\n      Object o = ObjectBuilder.getVal(parser);\n      if (!(o instanceof Map)) return;\n      @SuppressWarnings(\"unchecked\")\n      Map<String,Object> map = (Map<String,Object>)o;\n      // To make consistent with json.param handling, we should make query params come after json params (i.e. query params should\n      // appear to overwrite json params.\n\n      // Solr params are based on String though, so we need to convert\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        Object val = entry.getValue();\n        if (params.get(key) != null) {\n          continue;\n        }\n\n        if (val == null) {\n          params.remove(key);\n        } else if (val instanceof List) {\n          List<?> lst = (List<?>) val;\n          String[] vals = new String[lst.size()];\n          for (int i = 0; i < vals.length; i++) {\n            vals[i] = lst.get(i).toString();\n          }\n          params.put(key, vals);\n        } else {\n          params.put(key, new String[]{val.toString()});\n        }\n      }\n\n    } catch (Exception e) {\n      // ignore parse exceptions at this stage, they may be caused by incomplete macro expansions\n      return;\n    }\n\n  }\n\n","sourceOld":"  private static void getParamsFromJSON(Map<String, String[]> params, String json) {\n    if (json.indexOf(\"params\") < 0) {\n      return;\n    }\n\n    JSONParser parser = new JSONParser(json);\n    try {\n      JSONUtil.expect(parser, JSONParser.OBJECT_START);\n      boolean found = JSONUtil.advanceToMapKey(parser, \"params\", false);\n      if (!found) {\n        return;\n      }\n\n      parser.nextEvent();  // advance to the value\n\n      Object o = ObjectBuilder.getVal(parser);\n      if (!(o instanceof Map)) return;\n      Map<String,Object> map = (Map<String,Object>)o;\n      // To make consistent with json.param handling, we should make query params come after json params (i.e. query params should\n      // appear to overwrite json params.\n\n      // Solr params are based on String though, so we need to convert\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        Object val = entry.getValue();\n        if (params.get(key) != null) {\n          continue;\n        }\n\n        if (val == null) {\n          params.remove(key);\n        } else if (val instanceof List) {\n          List lst = (List) val;\n          String[] vals = new String[lst.size()];\n          for (int i = 0; i < vals.length; i++) {\n            vals[i] = lst.get(i).toString();\n          }\n          params.put(key, vals);\n        } else {\n          params.put(key, new String[]{val.toString()});\n        }\n      }\n\n    } catch (Exception e) {\n      // ignore parse exceptions at this stage, they may be caused by incomplete macro expansions\n      return;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"0dec8faa342587767c2f95ad26a8315b8068392b":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ca62564055241632cd20d65b5ecb8c8e93bd60c4":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d","0dec8faa342587767c2f95ad26a8315b8068392b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0dec8faa342587767c2f95ad26a8315b8068392b"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0dec8faa342587767c2f95ad26a8315b8068392b":["ca62564055241632cd20d65b5ecb8c8e93bd60c4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0dec8faa342587767c2f95ad26a8315b8068392b","ca62564055241632cd20d65b5ecb8c8e93bd60c4"],"ca62564055241632cd20d65b5ecb8c8e93bd60c4":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ca62564055241632cd20d65b5ecb8c8e93bd60c4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}