{"path":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(String[],Directory,Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean,boolean).mjava","commits":[{"id":"950882a2bd2a5f9dc16a154871584eaa643d882a","date":1436366563,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(String[],Directory,Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean,boolean).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      // Incoming SegmentInfos may have NRT changes not yet visible in the latest commit, so we have to protect its files from deletion too:\n      checkpoint(segmentInfos, false);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.timSort(commits);\n\n    // refCounts only includes \"normal\" filenames (does not include write.lock)\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        // A segments_N file should never have ref count 0 on init:\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = null;\n            try {\n              sis = SegmentInfos.readCommit(directoryOrig, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      // Incoming SegmentInfos may have NRT changes not yet visible in the latest commit, so we have to protect its files from deletion too:\n      checkpoint(segmentInfos, false);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.timSort(commits);\n\n    // refCounts only includes \"normal\" filenames (does not include write.lock)\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(String[],Directory,Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(String[],Directory,Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean,boolean).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      // Incoming SegmentInfos may have NRT changes not yet visible in the latest commit, so we have to protect its files from deletion too:\n      checkpoint(segmentInfos, false);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.timSort(commits);\n\n    // refCounts only includes \"normal\" filenames (does not include write.lock)\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Set<String> toDelete = new HashSet<>();\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        // A segments_N file should never have ref count 0 on init:\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      // Incoming SegmentInfos may have NRT changes not yet visible in the latest commit, so we have to protect its files from deletion too:\n      checkpoint(segmentInfos, false);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.timSort(commits);\n\n    // refCounts only includes \"normal\" filenames (does not include write.lock)\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        // A segments_N file should never have ref count 0 on init:\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(String[],Directory,Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(String[],Directory,Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean,boolean).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      // Incoming SegmentInfos may have NRT changes not yet visible in the latest commit, so we have to protect its files from deletion too:\n      checkpoint(segmentInfos, false);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.timSort(commits);\n\n    // refCounts only includes \"normal\" filenames (does not include write.lock)\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Set<String> toDelete = new HashSet<>();\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        // A segments_N file should never have ref count 0 on init:\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      // Incoming SegmentInfos may have NRT changes not yet visible in the latest commit, so we have to protect its files from deletion too:\n      checkpoint(segmentInfos, false);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.timSort(commits);\n\n    // refCounts only includes \"normal\" filenames (does not include write.lock)\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        // A segments_N file should never have ref count 0 on init:\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(String[],Directory,Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(String[],Directory,Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean,boolean).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      // Incoming SegmentInfos may have NRT changes not yet visible in the latest commit, so we have to protect its files from deletion too:\n      checkpoint(segmentInfos, false);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.timSort(commits);\n\n    // refCounts only includes \"normal\" filenames (does not include write.lock)\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Set<String> toDelete = new HashSet<>();\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        // A segments_N file should never have ref count 0 on init:\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      // Incoming SegmentInfos may have NRT changes not yet visible in the latest commit, so we have to protect its files from deletion too:\n      checkpoint(segmentInfos, false);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.timSort(commits);\n\n    // refCounts only includes \"normal\" filenames (does not include write.lock)\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        // A segments_N file should never have ref count 0 on init:\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(String[],Directory,Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(String[],Directory,Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean,boolean).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      // Incoming SegmentInfos may have NRT changes not yet visible in the latest commit, so we have to protect its files from deletion too:\n      checkpoint(segmentInfos, false);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.timSort(commits);\n\n    // refCounts only includes \"normal\" filenames (does not include write.lock)\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Set<String> toDelete = new HashSet<>();\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        // A segments_N file should never have ref count 0 on init:\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      // Incoming SegmentInfos may have NRT changes not yet visible in the latest commit, so we have to protect its files from deletion too:\n      checkpoint(segmentInfos, false);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.timSort(commits);\n\n    // refCounts only includes \"normal\" filenames (does not include write.lock)\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        // A segments_N file should never have ref count 0 on init:\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5e84aa7f651de6493590da495bcbe46d32cf038","date":1526462263,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(String[],Directory,Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(String[],Directory,Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean,boolean).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      // Incoming SegmentInfos may have NRT changes not yet visible in the latest commit, so we have to protect its files from deletion too:\n      checkpoint(segmentInfos, false);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.timSort(commits);\n    Collection<String> relevantFiles = new HashSet<>(refCounts.keySet());\n    Set<String> pendingDeletions = directoryOrig.getPendingDeletions();\n    if (pendingDeletions.isEmpty() == false) {\n      relevantFiles.addAll(pendingDeletions);\n    }\n    // refCounts only includes \"normal\" filenames (does not include write.lock)\n    inflateGens(segmentInfos, relevantFiles, infoStream);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Set<String> toDelete = new HashSet<>();\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        // A segments_N file should never have ref count 0 on init:\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      // Incoming SegmentInfos may have NRT changes not yet visible in the latest commit, so we have to protect its files from deletion too:\n      checkpoint(segmentInfos, false);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.timSort(commits);\n\n    // refCounts only includes \"normal\" filenames (does not include write.lock)\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Set<String> toDelete = new HashSet<>();\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        // A segments_N file should never have ref count 0 on init:\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7166881391ea0f64d02756406371ce34719e4e8","date":1567583487,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(String[],Directory,Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(String[],Directory,Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean,boolean).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      // Incoming SegmentInfos may have NRT changes not yet visible in the latest commit, so we have to protect its files from deletion too:\n      checkpoint(segmentInfos, false);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.timSort(commits);\n    Collection<String> relevantFiles = new HashSet<>(refCounts.keySet());\n    Set<String> pendingDeletions = directoryOrig.getPendingDeletions();\n    if (pendingDeletions.isEmpty() == false) {\n      relevantFiles.addAll(pendingDeletions);\n    }\n    // refCounts only includes \"normal\" filenames (does not include write.lock)\n    inflateGens(segmentInfos, relevantFiles, infoStream);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Set<String> toDelete = new HashSet<>();\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        // A segments_N file should never have ref count 0 on init:\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      // Incoming SegmentInfos may have NRT changes not yet visible in the latest commit, so we have to protect its files from deletion too:\n      checkpoint(segmentInfos, false);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.timSort(commits);\n    Collection<String> relevantFiles = new HashSet<>(refCounts.keySet());\n    Set<String> pendingDeletions = directoryOrig.getPendingDeletions();\n    if (pendingDeletions.isEmpty() == false) {\n      relevantFiles.addAll(pendingDeletions);\n    }\n    // refCounts only includes \"normal\" filenames (does not include write.lock)\n    inflateGens(segmentInfos, relevantFiles, infoStream);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Set<String> toDelete = new HashSet<>();\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        // A segments_N file should never have ref count 0 on init:\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5a207d19eac354d649c3f0e2cce070017c78125e":["950882a2bd2a5f9dc16a154871584eaa643d882a","b470f36a9372c97283360b1304eacbde22df6c0d"],"b470f36a9372c97283360b1304eacbde22df6c0d":["950882a2bd2a5f9dc16a154871584eaa643d882a","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["950882a2bd2a5f9dc16a154871584eaa643d882a","b470f36a9372c97283360b1304eacbde22df6c0d"],"f7166881391ea0f64d02756406371ce34719e4e8":["c5e84aa7f651de6493590da495bcbe46d32cf038"],"950882a2bd2a5f9dc16a154871584eaa643d882a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["950882a2bd2a5f9dc16a154871584eaa643d882a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f7166881391ea0f64d02756406371ce34719e4e8"],"c5e84aa7f651de6493590da495bcbe46d32cf038":["5a207d19eac354d649c3f0e2cce070017c78125e"]},"commit2Childs":{"5a207d19eac354d649c3f0e2cce070017c78125e":["c5e84aa7f651de6493590da495bcbe46d32cf038"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["950882a2bd2a5f9dc16a154871584eaa643d882a"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"950882a2bd2a5f9dc16a154871584eaa643d882a":["5a207d19eac354d649c3f0e2cce070017c78125e","b470f36a9372c97283360b1304eacbde22df6c0d","1e6acbaae7af722f17204ceccf0f7db5753eccf3","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"f7166881391ea0f64d02756406371ce34719e4e8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["b470f36a9372c97283360b1304eacbde22df6c0d"],"c5e84aa7f651de6493590da495bcbe46d32cf038":["f7166881391ea0f64d02756406371ce34719e4e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}