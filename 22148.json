{"path":"lucene/facet/src/java/org/apache/lucene/facet/RangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","commits":[{"id":"21d36d0db865f7b84026b447bec653469a6e66df","date":1385495602,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/RangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/simple/RangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    // TODO: test if this is faster (in the past it was\n    // faster to do MatchingDocs on the inside) ... see\n    // patches on LUCENE-4965):\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          \n          long v = fv.longVal(doc);\n\n          // TODO: if all ranges are non-overlapping, we\n          // should instead do a bin-search up front\n          // (really, a specialized case of the interval\n          // tree)\n          // TODO: use interval tree instead of linear search:\n          for (int j = 0; j < ranges.length; j++) {\n            if (ranges[j].accept(v)) {\n              counts[j]++;\n            }\n          }\n        }\n\n        doc++;\n      }\n    }\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    // TODO: test if this is faster (in the past it was\n    // faster to do MatchingDocs on the inside) ... see\n    // patches on LUCENE-4965):\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          \n          long v = fv.longVal(doc);\n\n          // TODO: if all ranges are non-overlapping, we\n          // should instead do a bin-search up front\n          // (really, a specialized case of the interval\n          // tree)\n          // TODO: use interval tree instead of linear search:\n          for (int j = 0; j < ranges.length; j++) {\n            if (ranges[j].accept(v)) {\n              counts[j]++;\n            }\n          }\n        }\n\n        doc++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd3ed8c8fa2a4b995f5dfca3f00e5ce80161de0e","date":1385900513,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/LongRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/RangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    // TODO: test if this is faster (in the past it was\n    // faster to do MatchingDocs on the inside) ... see\n    // patches on LUCENE-4965):\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          \n          long v = fv.longVal(doc);\n\n          // TODO: if all ranges are non-overlapping, we\n          // should instead do a bin-search up front\n          // (really, a specialized case of the interval\n          // tree)\n          // TODO: use interval tree instead of linear search:\n          for (int j = 0; j < ranges.length; j++) {\n            if (ranges[j].accept(v)) {\n              counts[j]++;\n            }\n          }\n        }\n\n        doc++;\n      }\n    }\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    // TODO: test if this is faster (in the past it was\n    // faster to do MatchingDocs on the inside) ... see\n    // patches on LUCENE-4965):\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          \n          long v = fv.longVal(doc);\n\n          // TODO: if all ranges are non-overlapping, we\n          // should instead do a bin-search up front\n          // (really, a specialized case of the interval\n          // tree)\n          // TODO: use interval tree instead of linear search:\n          for (int j = 0; j < ranges.length; j++) {\n            if (ranges[j].accept(v)) {\n              counts[j]++;\n            }\n          }\n        }\n\n        doc++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bd3ed8c8fa2a4b995f5dfca3f00e5ce80161de0e":["21d36d0db865f7b84026b447bec653469a6e66df"],"21d36d0db865f7b84026b447bec653469a6e66df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["21d36d0db865f7b84026b447bec653469a6e66df","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bd3ed8c8fa2a4b995f5dfca3f00e5ce80161de0e":[],"21d36d0db865f7b84026b447bec653469a6e66df":["bd3ed8c8fa2a4b995f5dfca3f00e5ce80161de0e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["bd3ed8c8fa2a4b995f5dfca3f00e5ce80161de0e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}