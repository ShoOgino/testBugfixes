{"path":"solr/core/src/test/org/apache/solr/cloud/api/collections/TestCollectionsAPIViaSolrCloudCluster#testStopAllStartAll().mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/TestCollectionsAPIViaSolrCloudCluster#testStopAllStartAll().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCollectionsAPIViaSolrCloudCluster#testStopAllStartAll().mjava","sourceNew":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    assertNotNull(cluster.getZkServer());\n    List<JettySolrRunner> jettys = cluster.getJettySolrRunners();\n    assertEquals(nodeCount, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    final SolrQuery query = new SolrQuery(\"*:*\");\n    final SolrInputDocument doc = new SolrInputDocument();\n\n    // create collection\n    createCollection(collectionName, null);\n\n    ZkStateReader zkStateReader = client.getZkStateReader();\n\n    // modify collection\n    final int numDocs = 1 + random().nextInt(10);\n    for (int ii = 1; ii <= numDocs; ++ii) {\n      doc.setField(\"id\", \"\"+ii);\n      client.add(collectionName, doc);\n      if (ii*2 == numDocs) client.commit(collectionName);\n    }\n    client.commit(collectionName);\n\n    // query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n\n    // the test itself\n    zkStateReader.forceUpdateCollection(collectionName);\n    final ClusterState clusterState = zkStateReader.getClusterState();\n\n    final Set<Integer> leaderIndices = new HashSet<>();\n    final Set<Integer> followerIndices = new HashSet<>();\n    {\n      final Map<String,Boolean> shardLeaderMap = new HashMap<>();\n      for (final Slice slice : clusterState.getCollection(collectionName).getSlices()) {\n        for (final Replica replica : slice.getReplicas()) {\n          shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n        }\n        shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n      }\n      for (int ii = 0; ii < jettys.size(); ++ii) {\n        final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n        final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n        final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n        if (Boolean.TRUE.equals(isLeader)) {\n          leaderIndices.add(ii);\n        } else if (Boolean.FALSE.equals(isLeader)) {\n          followerIndices.add(ii);\n        } // else neither leader nor follower i.e. node without a replica (for our collection)\n      }\n    }\n    final List<Integer> leaderIndicesList = new ArrayList<>(leaderIndices);\n    final List<Integer> followerIndicesList = new ArrayList<>(followerIndices);\n\n    // first stop the followers (in no particular order)\n    Collections.shuffle(followerIndicesList, random());\n    for (Integer ii : followerIndicesList) {\n      if (!leaderIndices.contains(ii)) {\n        cluster.stopJettySolrRunner(jettys.get(ii));\n      }\n    }\n\n    // then stop the leaders (again in no particular order)\n    Collections.shuffle(leaderIndicesList, random());\n    for (Integer ii : leaderIndicesList) {\n      cluster.stopJettySolrRunner(jettys.get(ii));\n    }\n\n    // calculate restart order\n    final List<Integer> restartIndicesList = new ArrayList<>();\n    Collections.shuffle(leaderIndicesList, random());\n    restartIndicesList.addAll(leaderIndicesList);\n    Collections.shuffle(followerIndicesList, random());\n    restartIndicesList.addAll(followerIndicesList);\n    if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n    // and then restart jettys in that order\n    for (Integer ii : restartIndicesList) {\n      final JettySolrRunner jetty = jettys.get(ii);\n      if (!jetty.isRunning()) {\n        cluster.startJettySolrRunner(jetty);\n        assertTrue(jetty.isRunning());\n      }\n    }\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    zkStateReader.forceUpdateCollection(collectionName);\n\n    // re-query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n  }\n\n","sourceOld":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    assertNotNull(cluster.getZkServer());\n    List<JettySolrRunner> jettys = cluster.getJettySolrRunners();\n    assertEquals(nodeCount, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    final SolrQuery query = new SolrQuery(\"*:*\");\n    final SolrInputDocument doc = new SolrInputDocument();\n\n    // create collection\n    createCollection(collectionName, null);\n\n    ZkStateReader zkStateReader = client.getZkStateReader();\n\n    // modify collection\n    final int numDocs = 1 + random().nextInt(10);\n    for (int ii = 1; ii <= numDocs; ++ii) {\n      doc.setField(\"id\", \"\"+ii);\n      client.add(collectionName, doc);\n      if (ii*2 == numDocs) client.commit(collectionName);\n    }\n    client.commit(collectionName);\n\n    // query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n\n    // the test itself\n    zkStateReader.forceUpdateCollection(collectionName);\n    final ClusterState clusterState = zkStateReader.getClusterState();\n\n    final Set<Integer> leaderIndices = new HashSet<>();\n    final Set<Integer> followerIndices = new HashSet<>();\n    {\n      final Map<String,Boolean> shardLeaderMap = new HashMap<>();\n      for (final Slice slice : clusterState.getCollection(collectionName).getSlices()) {\n        for (final Replica replica : slice.getReplicas()) {\n          shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n        }\n        shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n      }\n      for (int ii = 0; ii < jettys.size(); ++ii) {\n        final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n        final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n        final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n        if (Boolean.TRUE.equals(isLeader)) {\n          leaderIndices.add(ii);\n        } else if (Boolean.FALSE.equals(isLeader)) {\n          followerIndices.add(ii);\n        } // else neither leader nor follower i.e. node without a replica (for our collection)\n      }\n    }\n    final List<Integer> leaderIndicesList = new ArrayList<>(leaderIndices);\n    final List<Integer> followerIndicesList = new ArrayList<>(followerIndices);\n\n    // first stop the followers (in no particular order)\n    Collections.shuffle(followerIndicesList, random());\n    for (Integer ii : followerIndicesList) {\n      if (!leaderIndices.contains(ii)) {\n        cluster.stopJettySolrRunner(jettys.get(ii));\n      }\n    }\n\n    // then stop the leaders (again in no particular order)\n    Collections.shuffle(leaderIndicesList, random());\n    for (Integer ii : leaderIndicesList) {\n      cluster.stopJettySolrRunner(jettys.get(ii));\n    }\n\n    // calculate restart order\n    final List<Integer> restartIndicesList = new ArrayList<>();\n    Collections.shuffle(leaderIndicesList, random());\n    restartIndicesList.addAll(leaderIndicesList);\n    Collections.shuffle(followerIndicesList, random());\n    restartIndicesList.addAll(followerIndicesList);\n    if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n    // and then restart jettys in that order\n    for (Integer ii : restartIndicesList) {\n      final JettySolrRunner jetty = jettys.get(ii);\n      if (!jetty.isRunning()) {\n        cluster.startJettySolrRunner(jetty);\n        assertTrue(jetty.isRunning());\n      }\n    }\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    zkStateReader.forceUpdateCollection(collectionName);\n\n    // re-query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/TestCollectionsAPIViaSolrCloudCluster#testStopAllStartAll().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCollectionsAPIViaSolrCloudCluster#testStopAllStartAll().mjava","sourceNew":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    assertNotNull(cluster.getZkServer());\n    List<JettySolrRunner> jettys = cluster.getJettySolrRunners();\n    assertEquals(nodeCount, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    final SolrQuery query = new SolrQuery(\"*:*\");\n    final SolrInputDocument doc = new SolrInputDocument();\n\n    // create collection\n    createCollection(collectionName, null);\n\n    ZkStateReader zkStateReader = client.getZkStateReader();\n\n    // modify collection\n    final int numDocs = 1 + random().nextInt(10);\n    for (int ii = 1; ii <= numDocs; ++ii) {\n      doc.setField(\"id\", \"\"+ii);\n      client.add(collectionName, doc);\n      if (ii*2 == numDocs) client.commit(collectionName);\n    }\n    client.commit(collectionName);\n\n    // query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n\n    // the test itself\n    zkStateReader.forceUpdateCollection(collectionName);\n    final ClusterState clusterState = zkStateReader.getClusterState();\n\n    final Set<Integer> leaderIndices = new HashSet<>();\n    final Set<Integer> followerIndices = new HashSet<>();\n    {\n      final Map<String,Boolean> shardLeaderMap = new HashMap<>();\n      for (final Slice slice : clusterState.getCollection(collectionName).getSlices()) {\n        for (final Replica replica : slice.getReplicas()) {\n          shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n        }\n        shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n      }\n      for (int ii = 0; ii < jettys.size(); ++ii) {\n        final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n        final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n        final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n        if (Boolean.TRUE.equals(isLeader)) {\n          leaderIndices.add(ii);\n        } else if (Boolean.FALSE.equals(isLeader)) {\n          followerIndices.add(ii);\n        } // else neither leader nor follower i.e. node without a replica (for our collection)\n      }\n    }\n    final List<Integer> leaderIndicesList = new ArrayList<>(leaderIndices);\n    final List<Integer> followerIndicesList = new ArrayList<>(followerIndices);\n\n    // first stop the followers (in no particular order)\n    Collections.shuffle(followerIndicesList, random());\n    for (Integer ii : followerIndicesList) {\n      if (!leaderIndices.contains(ii)) {\n        cluster.stopJettySolrRunner(jettys.get(ii));\n      }\n    }\n\n    // then stop the leaders (again in no particular order)\n    Collections.shuffle(leaderIndicesList, random());\n    for (Integer ii : leaderIndicesList) {\n      cluster.stopJettySolrRunner(jettys.get(ii));\n    }\n\n    // calculate restart order\n    final List<Integer> restartIndicesList = new ArrayList<>();\n    Collections.shuffle(leaderIndicesList, random());\n    restartIndicesList.addAll(leaderIndicesList);\n    Collections.shuffle(followerIndicesList, random());\n    restartIndicesList.addAll(followerIndicesList);\n    if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n    // and then restart jettys in that order\n    for (Integer ii : restartIndicesList) {\n      final JettySolrRunner jetty = jettys.get(ii);\n      if (!jetty.isRunning()) {\n        cluster.startJettySolrRunner(jetty);\n        assertTrue(jetty.isRunning());\n      }\n    }\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    zkStateReader.forceUpdateCollection(collectionName);\n\n    // re-query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n  }\n\n","sourceOld":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    assertNotNull(cluster.getZkServer());\n    List<JettySolrRunner> jettys = cluster.getJettySolrRunners();\n    assertEquals(nodeCount, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    final SolrQuery query = new SolrQuery(\"*:*\");\n    final SolrInputDocument doc = new SolrInputDocument();\n\n    // create collection\n    createCollection(collectionName, null);\n\n    ZkStateReader zkStateReader = client.getZkStateReader();\n\n    // modify collection\n    final int numDocs = 1 + random().nextInt(10);\n    for (int ii = 1; ii <= numDocs; ++ii) {\n      doc.setField(\"id\", \"\"+ii);\n      client.add(collectionName, doc);\n      if (ii*2 == numDocs) client.commit(collectionName);\n    }\n    client.commit(collectionName);\n\n    // query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n\n    // the test itself\n    zkStateReader.forceUpdateCollection(collectionName);\n    final ClusterState clusterState = zkStateReader.getClusterState();\n\n    final Set<Integer> leaderIndices = new HashSet<>();\n    final Set<Integer> followerIndices = new HashSet<>();\n    {\n      final Map<String,Boolean> shardLeaderMap = new HashMap<>();\n      for (final Slice slice : clusterState.getCollection(collectionName).getSlices()) {\n        for (final Replica replica : slice.getReplicas()) {\n          shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n        }\n        shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n      }\n      for (int ii = 0; ii < jettys.size(); ++ii) {\n        final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n        final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n        final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n        if (Boolean.TRUE.equals(isLeader)) {\n          leaderIndices.add(ii);\n        } else if (Boolean.FALSE.equals(isLeader)) {\n          followerIndices.add(ii);\n        } // else neither leader nor follower i.e. node without a replica (for our collection)\n      }\n    }\n    final List<Integer> leaderIndicesList = new ArrayList<>(leaderIndices);\n    final List<Integer> followerIndicesList = new ArrayList<>(followerIndices);\n\n    // first stop the followers (in no particular order)\n    Collections.shuffle(followerIndicesList, random());\n    for (Integer ii : followerIndicesList) {\n      if (!leaderIndices.contains(ii)) {\n        cluster.stopJettySolrRunner(jettys.get(ii));\n      }\n    }\n\n    // then stop the leaders (again in no particular order)\n    Collections.shuffle(leaderIndicesList, random());\n    for (Integer ii : leaderIndicesList) {\n      cluster.stopJettySolrRunner(jettys.get(ii));\n    }\n\n    // calculate restart order\n    final List<Integer> restartIndicesList = new ArrayList<>();\n    Collections.shuffle(leaderIndicesList, random());\n    restartIndicesList.addAll(leaderIndicesList);\n    Collections.shuffle(followerIndicesList, random());\n    restartIndicesList.addAll(followerIndicesList);\n    if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n    // and then restart jettys in that order\n    for (Integer ii : restartIndicesList) {\n      final JettySolrRunner jetty = jettys.get(ii);\n      if (!jetty.isRunning()) {\n        cluster.startJettySolrRunner(jetty);\n        assertTrue(jetty.isRunning());\n      }\n    }\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    zkStateReader.forceUpdateCollection(collectionName);\n\n    // re-query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b584197d68a4da38ad62f872c693f734cae5ea3e","date":1534751225,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/TestCollectionsAPIViaSolrCloudCluster#testStopAllStartAll().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/TestCollectionsAPIViaSolrCloudCluster#testStopAllStartAll().mjava","sourceNew":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    assertNotNull(cluster.getZkServer());\n    List<JettySolrRunner> jettys = new ArrayList<>(cluster.getJettySolrRunners()); // make a copy\n    assertEquals(nodeCount, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    final SolrQuery query = new SolrQuery(\"*:*\");\n    final SolrInputDocument doc = new SolrInputDocument();\n\n    // create collection\n    createCollection(collectionName, null);\n\n    ZkStateReader zkStateReader = client.getZkStateReader();\n\n    // modify collection\n    final int numDocs = 1 + random().nextInt(10);\n    for (int ii = 1; ii <= numDocs; ++ii) {\n      doc.setField(\"id\", \"\"+ii);\n      client.add(collectionName, doc);\n      if (ii*2 == numDocs) client.commit(collectionName);\n    }\n    client.commit(collectionName);\n\n    // query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n\n    // the test itself\n    zkStateReader.forceUpdateCollection(collectionName);\n    final ClusterState clusterState = zkStateReader.getClusterState();\n\n    final Set<Integer> leaderIndices = new HashSet<>();\n    final Set<Integer> followerIndices = new HashSet<>();\n    {\n      final Map<String,Boolean> shardLeaderMap = new HashMap<>();\n      for (final Slice slice : clusterState.getCollection(collectionName).getSlices()) {\n        for (final Replica replica : slice.getReplicas()) {\n          shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n        }\n        shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n      }\n      for (int ii = 0; ii < jettys.size(); ++ii) {\n        final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n        final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n        final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n        if (Boolean.TRUE.equals(isLeader)) {\n          leaderIndices.add(ii);\n        } else if (Boolean.FALSE.equals(isLeader)) {\n          followerIndices.add(ii);\n        } // else neither leader nor follower i.e. node without a replica (for our collection)\n      }\n    }\n    final List<Integer> leaderIndicesList = new ArrayList<>(leaderIndices);\n    final List<Integer> followerIndicesList = new ArrayList<>(followerIndices);\n\n    // first stop the followers (in no particular order)\n    Collections.shuffle(followerIndicesList, random());\n    for (Integer ii : followerIndicesList) {\n      if (!leaderIndices.contains(ii)) {\n        cluster.stopJettySolrRunner(jettys.get(ii));\n      }\n    }\n\n    // then stop the leaders (again in no particular order)\n    Collections.shuffle(leaderIndicesList, random());\n    for (Integer ii : leaderIndicesList) {\n      cluster.stopJettySolrRunner(jettys.get(ii));\n    }\n\n    // calculate restart order\n    final List<Integer> restartIndicesList = new ArrayList<>();\n    Collections.shuffle(leaderIndicesList, random());\n    restartIndicesList.addAll(leaderIndicesList);\n    Collections.shuffle(followerIndicesList, random());\n    restartIndicesList.addAll(followerIndicesList);\n    if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n    // and then restart jettys in that order\n    for (Integer ii : restartIndicesList) {\n      final JettySolrRunner jetty = jettys.get(ii);\n      if (!jetty.isRunning()) {\n        cluster.startJettySolrRunner(jetty);\n        assertTrue(jetty.isRunning());\n      }\n    }\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    zkStateReader.forceUpdateCollection(collectionName);\n\n    // re-query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n  }\n\n","sourceOld":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    assertNotNull(cluster.getZkServer());\n    List<JettySolrRunner> jettys = cluster.getJettySolrRunners();\n    assertEquals(nodeCount, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    final SolrQuery query = new SolrQuery(\"*:*\");\n    final SolrInputDocument doc = new SolrInputDocument();\n\n    // create collection\n    createCollection(collectionName, null);\n\n    ZkStateReader zkStateReader = client.getZkStateReader();\n\n    // modify collection\n    final int numDocs = 1 + random().nextInt(10);\n    for (int ii = 1; ii <= numDocs; ++ii) {\n      doc.setField(\"id\", \"\"+ii);\n      client.add(collectionName, doc);\n      if (ii*2 == numDocs) client.commit(collectionName);\n    }\n    client.commit(collectionName);\n\n    // query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n\n    // the test itself\n    zkStateReader.forceUpdateCollection(collectionName);\n    final ClusterState clusterState = zkStateReader.getClusterState();\n\n    final Set<Integer> leaderIndices = new HashSet<>();\n    final Set<Integer> followerIndices = new HashSet<>();\n    {\n      final Map<String,Boolean> shardLeaderMap = new HashMap<>();\n      for (final Slice slice : clusterState.getCollection(collectionName).getSlices()) {\n        for (final Replica replica : slice.getReplicas()) {\n          shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n        }\n        shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n      }\n      for (int ii = 0; ii < jettys.size(); ++ii) {\n        final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n        final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n        final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n        if (Boolean.TRUE.equals(isLeader)) {\n          leaderIndices.add(ii);\n        } else if (Boolean.FALSE.equals(isLeader)) {\n          followerIndices.add(ii);\n        } // else neither leader nor follower i.e. node without a replica (for our collection)\n      }\n    }\n    final List<Integer> leaderIndicesList = new ArrayList<>(leaderIndices);\n    final List<Integer> followerIndicesList = new ArrayList<>(followerIndices);\n\n    // first stop the followers (in no particular order)\n    Collections.shuffle(followerIndicesList, random());\n    for (Integer ii : followerIndicesList) {\n      if (!leaderIndices.contains(ii)) {\n        cluster.stopJettySolrRunner(jettys.get(ii));\n      }\n    }\n\n    // then stop the leaders (again in no particular order)\n    Collections.shuffle(leaderIndicesList, random());\n    for (Integer ii : leaderIndicesList) {\n      cluster.stopJettySolrRunner(jettys.get(ii));\n    }\n\n    // calculate restart order\n    final List<Integer> restartIndicesList = new ArrayList<>();\n    Collections.shuffle(leaderIndicesList, random());\n    restartIndicesList.addAll(leaderIndicesList);\n    Collections.shuffle(followerIndicesList, random());\n    restartIndicesList.addAll(followerIndicesList);\n    if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n    // and then restart jettys in that order\n    for (Integer ii : restartIndicesList) {\n      final JettySolrRunner jetty = jettys.get(ii);\n      if (!jetty.isRunning()) {\n        cluster.startJettySolrRunner(jetty);\n        assertTrue(jetty.isRunning());\n      }\n    }\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    zkStateReader.forceUpdateCollection(collectionName);\n\n    // re-query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/TestCollectionsAPIViaSolrCloudCluster#testStopAllStartAll().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/TestCollectionsAPIViaSolrCloudCluster#testStopAllStartAll().mjava","sourceNew":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    assertNotNull(cluster.getZkServer());\n    List<JettySolrRunner> jettys = new ArrayList<>(cluster.getJettySolrRunners()); // make a copy\n    assertEquals(nodeCount, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    final SolrQuery query = new SolrQuery(\"*:*\");\n    final SolrInputDocument doc = new SolrInputDocument();\n\n    // create collection\n    createCollection(collectionName, null);\n\n    ZkStateReader zkStateReader = client.getZkStateReader();\n\n    // modify collection\n    final int numDocs = 1 + random().nextInt(10);\n    for (int ii = 1; ii <= numDocs; ++ii) {\n      doc.setField(\"id\", \"\"+ii);\n      client.add(collectionName, doc);\n      if (ii*2 == numDocs) client.commit(collectionName);\n    }\n    client.commit(collectionName);\n\n    // query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n\n    // the test itself\n    zkStateReader.forceUpdateCollection(collectionName);\n    final ClusterState clusterState = zkStateReader.getClusterState();\n\n    final Set<Integer> leaderIndices = new HashSet<>();\n    final Set<Integer> followerIndices = new HashSet<>();\n    {\n      final Map<String,Boolean> shardLeaderMap = new HashMap<>();\n      for (final Slice slice : clusterState.getCollection(collectionName).getSlices()) {\n        for (final Replica replica : slice.getReplicas()) {\n          shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n        }\n        shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n      }\n      for (int ii = 0; ii < jettys.size(); ++ii) {\n        final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n        final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n        final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n        if (Boolean.TRUE.equals(isLeader)) {\n          leaderIndices.add(ii);\n        } else if (Boolean.FALSE.equals(isLeader)) {\n          followerIndices.add(ii);\n        } // else neither leader nor follower i.e. node without a replica (for our collection)\n      }\n    }\n    final List<Integer> leaderIndicesList = new ArrayList<>(leaderIndices);\n    final List<Integer> followerIndicesList = new ArrayList<>(followerIndices);\n\n    // first stop the followers (in no particular order)\n    Collections.shuffle(followerIndicesList, random());\n    for (Integer ii : followerIndicesList) {\n      if (!leaderIndices.contains(ii)) {\n        cluster.stopJettySolrRunner(jettys.get(ii));\n      }\n    }\n\n    // then stop the leaders (again in no particular order)\n    Collections.shuffle(leaderIndicesList, random());\n    for (Integer ii : leaderIndicesList) {\n      cluster.stopJettySolrRunner(jettys.get(ii));\n    }\n\n    // calculate restart order\n    final List<Integer> restartIndicesList = new ArrayList<>();\n    Collections.shuffle(leaderIndicesList, random());\n    restartIndicesList.addAll(leaderIndicesList);\n    Collections.shuffle(followerIndicesList, random());\n    restartIndicesList.addAll(followerIndicesList);\n    if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n    // and then restart jettys in that order\n    for (Integer ii : restartIndicesList) {\n      final JettySolrRunner jetty = jettys.get(ii);\n      if (!jetty.isRunning()) {\n        cluster.startJettySolrRunner(jetty);\n        assertTrue(jetty.isRunning());\n      }\n    }\n    cluster.waitForAllNodes(30);\n    cluster.waitForActiveCollection(collectionName, numShards, numShards * numReplicas);\n\n    zkStateReader.forceUpdateCollection(collectionName);\n\n    // re-query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n  }\n\n","sourceOld":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    assertNotNull(cluster.getZkServer());\n    List<JettySolrRunner> jettys = new ArrayList<>(cluster.getJettySolrRunners()); // make a copy\n    assertEquals(nodeCount, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    final SolrQuery query = new SolrQuery(\"*:*\");\n    final SolrInputDocument doc = new SolrInputDocument();\n\n    // create collection\n    createCollection(collectionName, null);\n\n    ZkStateReader zkStateReader = client.getZkStateReader();\n\n    // modify collection\n    final int numDocs = 1 + random().nextInt(10);\n    for (int ii = 1; ii <= numDocs; ++ii) {\n      doc.setField(\"id\", \"\"+ii);\n      client.add(collectionName, doc);\n      if (ii*2 == numDocs) client.commit(collectionName);\n    }\n    client.commit(collectionName);\n\n    // query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n\n    // the test itself\n    zkStateReader.forceUpdateCollection(collectionName);\n    final ClusterState clusterState = zkStateReader.getClusterState();\n\n    final Set<Integer> leaderIndices = new HashSet<>();\n    final Set<Integer> followerIndices = new HashSet<>();\n    {\n      final Map<String,Boolean> shardLeaderMap = new HashMap<>();\n      for (final Slice slice : clusterState.getCollection(collectionName).getSlices()) {\n        for (final Replica replica : slice.getReplicas()) {\n          shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n        }\n        shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n      }\n      for (int ii = 0; ii < jettys.size(); ++ii) {\n        final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n        final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n        final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n        if (Boolean.TRUE.equals(isLeader)) {\n          leaderIndices.add(ii);\n        } else if (Boolean.FALSE.equals(isLeader)) {\n          followerIndices.add(ii);\n        } // else neither leader nor follower i.e. node without a replica (for our collection)\n      }\n    }\n    final List<Integer> leaderIndicesList = new ArrayList<>(leaderIndices);\n    final List<Integer> followerIndicesList = new ArrayList<>(followerIndices);\n\n    // first stop the followers (in no particular order)\n    Collections.shuffle(followerIndicesList, random());\n    for (Integer ii : followerIndicesList) {\n      if (!leaderIndices.contains(ii)) {\n        cluster.stopJettySolrRunner(jettys.get(ii));\n      }\n    }\n\n    // then stop the leaders (again in no particular order)\n    Collections.shuffle(leaderIndicesList, random());\n    for (Integer ii : leaderIndicesList) {\n      cluster.stopJettySolrRunner(jettys.get(ii));\n    }\n\n    // calculate restart order\n    final List<Integer> restartIndicesList = new ArrayList<>();\n    Collections.shuffle(leaderIndicesList, random());\n    restartIndicesList.addAll(leaderIndicesList);\n    Collections.shuffle(followerIndicesList, random());\n    restartIndicesList.addAll(followerIndicesList);\n    if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n    // and then restart jettys in that order\n    for (Integer ii : restartIndicesList) {\n      final JettySolrRunner jetty = jettys.get(ii);\n      if (!jetty.isRunning()) {\n        cluster.startJettySolrRunner(jetty);\n        assertTrue(jetty.isRunning());\n      }\n    }\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    zkStateReader.forceUpdateCollection(collectionName);\n\n    // re-query collection\n    assertEquals(numDocs, client.query(collectionName, query).getResults().getNumFound());\n  }\n\n","bugFix":["5719bfb2650ba43855e20564d39873bbbdc7f02c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["b584197d68a4da38ad62f872c693f734cae5ea3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b584197d68a4da38ad62f872c693f734cae5ea3e":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["b584197d68a4da38ad62f872c693f734cae5ea3e"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"b584197d68a4da38ad62f872c693f734cae5ea3e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}