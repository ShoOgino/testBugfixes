{"path":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewShard(ClusterState,String,int,int,int,String).mjava","commits":[{"id":"1eeda7e62e149f90eee8895af874c74efa7d4852","date":1375293182,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewShard(ClusterState,String,int,int,int,String).mjava","pathOld":"/dev/null","sourceNew":"  public static ArrayList<Node> getNodesForNewShard(ClusterState clusterState, String collectionName, int numSlices, int maxShardsPerNode, int repFactor, String createNodeSetStr) {\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n\n    HashMap<String,Node> nodeNameVsShardCount =  new HashMap<String, Node>();\n    for (String s : nodeList) nodeNameVsShardCount.put(s,new Node(s));\n    for (String s : clusterState.getCollections()) {\n      DocCollection c = clusterState.getCollection(s);\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          Node count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++;\n            if (s.equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    if (nodeNameVsShardCount.size() <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create collection \" + collectionName\n          + \". No live Solr-instances\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET + \":\" + createNodeSetStr:\"\"));\n    }\n\n    if (repFactor > nodeNameVsShardCount.size()) {\n      log.warn(\"Specified \"\n          + REPLICATION_FACTOR\n          + \" of \"\n          + repFactor\n          + \" on collection \"\n          + collectionName\n          + \" is higher than or equal to the number of Solr instances currently live or part of your \" + CREATE_NODE_SET + \"(\"\n          + nodeList.size()\n          + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n    }\n\n    int maxCoresAllowedToCreate = maxShardsPerNode * nodeList.size();\n    int requestedCoresToCreate = numSlices * repFactor;\n    int minCoresToCreate = requestedCoresToCreate;\n    if (maxCoresAllowedToCreate < minCoresToCreate) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create shards \" + collectionName + \". Value of \"\n          + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n          + \", and the number of live nodes is \" + nodeList.size()\n          + \". This allows a maximum of \" + maxCoresAllowedToCreate\n          + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n          + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n          + \". This requires \" + requestedCoresToCreate\n          + \" shards to be created (higher than the allowed number)\");\n    }\n\n    ArrayList<Node> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, new Comparator<Node>() {\n      @Override\n      public int compare(Node x, Node y) {\n        return (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1);\n      }\n    });\n    return sortedNodeList;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewShard(ClusterState,String,int,int,int,String).mjava","pathOld":"/dev/null","sourceNew":"  public static ArrayList<Node> getNodesForNewShard(ClusterState clusterState, String collectionName, int numSlices, int maxShardsPerNode, int repFactor, String createNodeSetStr) {\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n\n    HashMap<String,Node> nodeNameVsShardCount =  new HashMap<String, Node>();\n    for (String s : nodeList) nodeNameVsShardCount.put(s,new Node(s));\n    for (String s : clusterState.getCollections()) {\n      DocCollection c = clusterState.getCollection(s);\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          Node count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++;\n            if (s.equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    if (nodeNameVsShardCount.size() <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create collection \" + collectionName\n          + \". No live Solr-instances\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET + \":\" + createNodeSetStr:\"\"));\n    }\n\n    if (repFactor > nodeNameVsShardCount.size()) {\n      log.warn(\"Specified \"\n          + REPLICATION_FACTOR\n          + \" of \"\n          + repFactor\n          + \" on collection \"\n          + collectionName\n          + \" is higher than or equal to the number of Solr instances currently live or part of your \" + CREATE_NODE_SET + \"(\"\n          + nodeList.size()\n          + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n    }\n\n    int maxCoresAllowedToCreate = maxShardsPerNode * nodeList.size();\n    int requestedCoresToCreate = numSlices * repFactor;\n    int minCoresToCreate = requestedCoresToCreate;\n    if (maxCoresAllowedToCreate < minCoresToCreate) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create shards \" + collectionName + \". Value of \"\n          + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n          + \", and the number of live nodes is \" + nodeList.size()\n          + \". This allows a maximum of \" + maxCoresAllowedToCreate\n          + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n          + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n          + \". This requires \" + requestedCoresToCreate\n          + \" shards to be created (higher than the allowed number)\");\n    }\n\n    ArrayList<Node> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, new Comparator<Node>() {\n      @Override\n      public int compare(Node x, Node y) {\n        return (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1);\n      }\n    });\n    return sortedNodeList;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewShard(ClusterState,String,int,int,int,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewShard(ClusterState,String,int,int,int,String).mjava","sourceNew":"  public static ArrayList<Node> getNodesForNewShard(ClusterState clusterState, String collectionName, int numSlices, int maxShardsPerNode, int repFactor, String createNodeSetStr) {\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n\n    HashMap<String,Node> nodeNameVsShardCount =  new HashMap<>();\n    for (String s : nodeList) nodeNameVsShardCount.put(s,new Node(s));\n    for (String s : clusterState.getCollections()) {\n      DocCollection c = clusterState.getCollection(s);\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          Node count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++;\n            if (s.equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    if (nodeNameVsShardCount.size() <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create collection \" + collectionName\n          + \". No live Solr-instances\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET + \":\" + createNodeSetStr:\"\"));\n    }\n\n    if (repFactor > nodeNameVsShardCount.size()) {\n      log.warn(\"Specified \"\n          + REPLICATION_FACTOR\n          + \" of \"\n          + repFactor\n          + \" on collection \"\n          + collectionName\n          + \" is higher than or equal to the number of Solr instances currently live or part of your \" + CREATE_NODE_SET + \"(\"\n          + nodeList.size()\n          + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n    }\n\n    int maxCoresAllowedToCreate = maxShardsPerNode * nodeList.size();\n    int requestedCoresToCreate = numSlices * repFactor;\n    int minCoresToCreate = requestedCoresToCreate;\n    if (maxCoresAllowedToCreate < minCoresToCreate) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create shards \" + collectionName + \". Value of \"\n          + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n          + \", and the number of live nodes is \" + nodeList.size()\n          + \". This allows a maximum of \" + maxCoresAllowedToCreate\n          + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n          + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n          + \". This requires \" + requestedCoresToCreate\n          + \" shards to be created (higher than the allowed number)\");\n    }\n\n    ArrayList<Node> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, new Comparator<Node>() {\n      @Override\n      public int compare(Node x, Node y) {\n        return (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1);\n      }\n    });\n    return sortedNodeList;\n  }\n\n","sourceOld":"  public static ArrayList<Node> getNodesForNewShard(ClusterState clusterState, String collectionName, int numSlices, int maxShardsPerNode, int repFactor, String createNodeSetStr) {\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n\n    HashMap<String,Node> nodeNameVsShardCount =  new HashMap<String, Node>();\n    for (String s : nodeList) nodeNameVsShardCount.put(s,new Node(s));\n    for (String s : clusterState.getCollections()) {\n      DocCollection c = clusterState.getCollection(s);\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          Node count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++;\n            if (s.equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    if (nodeNameVsShardCount.size() <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create collection \" + collectionName\n          + \". No live Solr-instances\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET + \":\" + createNodeSetStr:\"\"));\n    }\n\n    if (repFactor > nodeNameVsShardCount.size()) {\n      log.warn(\"Specified \"\n          + REPLICATION_FACTOR\n          + \" of \"\n          + repFactor\n          + \" on collection \"\n          + collectionName\n          + \" is higher than or equal to the number of Solr instances currently live or part of your \" + CREATE_NODE_SET + \"(\"\n          + nodeList.size()\n          + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n    }\n\n    int maxCoresAllowedToCreate = maxShardsPerNode * nodeList.size();\n    int requestedCoresToCreate = numSlices * repFactor;\n    int minCoresToCreate = requestedCoresToCreate;\n    if (maxCoresAllowedToCreate < minCoresToCreate) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create shards \" + collectionName + \". Value of \"\n          + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n          + \", and the number of live nodes is \" + nodeList.size()\n          + \". This allows a maximum of \" + maxCoresAllowedToCreate\n          + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n          + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n          + \". This requires \" + requestedCoresToCreate\n          + \" shards to be created (higher than the allowed number)\");\n    }\n\n    ArrayList<Node> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, new Comparator<Node>() {\n      @Override\n      public int compare(Node x, Node y) {\n        return (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1);\n      }\n    });\n    return sortedNodeList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad7bdba3e91cf3373cda2e52239cb761fc0b452","date":1408019547,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewShard(ClusterState,String,int,int,int,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewShard(ClusterState,String,int,int,int,String).mjava","sourceNew":"  public static ArrayList<Node> getNodesForNewShard(ClusterState clusterState, String collectionName, int numSlices, int maxShardsPerNode, int repFactor, String createNodeSetStr) {\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n\n    HashMap<String,Node> nodeNameVsShardCount =  new HashMap<>();\n    for (String s : nodeList) nodeNameVsShardCount.put(s,new Node(s));\n    for (String s : clusterState.getCollections()) {\n      DocCollection c = clusterState.getCollection(s);\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          Node count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++;\n            if (s.equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    if (nodeNameVsShardCount.size() <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create collection \" + collectionName\n          + \". No live Solr-instances\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET + \":\" + createNodeSetStr:\"\"));\n    }\n\n    if (repFactor > nodeNameVsShardCount.size()) {\n      log.warn(\"Specified \"\n          + ZkStateReader.REPLICATION_FACTOR\n          + \" of \"\n          + repFactor\n          + \" on collection \"\n          + collectionName\n          + \" is higher than or equal to the number of Solr instances currently live or part of your \" + CREATE_NODE_SET + \"(\"\n          + nodeList.size()\n          + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n    }\n\n    int maxCoresAllowedToCreate = maxShardsPerNode * nodeList.size();\n    int requestedCoresToCreate = numSlices * repFactor;\n    int minCoresToCreate = requestedCoresToCreate;\n    if (maxCoresAllowedToCreate < minCoresToCreate) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create shards \" + collectionName + \". Value of \"\n          + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n          + \", and the number of live nodes is \" + nodeList.size()\n          + \". This allows a maximum of \" + maxCoresAllowedToCreate\n          + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n          + \" and value of \" + ZkStateReader.REPLICATION_FACTOR + \" is \" + repFactor\n          + \". This requires \" + requestedCoresToCreate\n          + \" shards to be created (higher than the allowed number)\");\n    }\n\n    ArrayList<Node> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, new Comparator<Node>() {\n      @Override\n      public int compare(Node x, Node y) {\n        return (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1);\n      }\n    });\n    return sortedNodeList;\n  }\n\n","sourceOld":"  public static ArrayList<Node> getNodesForNewShard(ClusterState clusterState, String collectionName, int numSlices, int maxShardsPerNode, int repFactor, String createNodeSetStr) {\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n\n    HashMap<String,Node> nodeNameVsShardCount =  new HashMap<>();\n    for (String s : nodeList) nodeNameVsShardCount.put(s,new Node(s));\n    for (String s : clusterState.getCollections()) {\n      DocCollection c = clusterState.getCollection(s);\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          Node count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++;\n            if (s.equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    if (nodeNameVsShardCount.size() <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create collection \" + collectionName\n          + \". No live Solr-instances\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET + \":\" + createNodeSetStr:\"\"));\n    }\n\n    if (repFactor > nodeNameVsShardCount.size()) {\n      log.warn(\"Specified \"\n          + REPLICATION_FACTOR\n          + \" of \"\n          + repFactor\n          + \" on collection \"\n          + collectionName\n          + \" is higher than or equal to the number of Solr instances currently live or part of your \" + CREATE_NODE_SET + \"(\"\n          + nodeList.size()\n          + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n    }\n\n    int maxCoresAllowedToCreate = maxShardsPerNode * nodeList.size();\n    int requestedCoresToCreate = numSlices * repFactor;\n    int minCoresToCreate = requestedCoresToCreate;\n    if (maxCoresAllowedToCreate < minCoresToCreate) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create shards \" + collectionName + \". Value of \"\n          + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n          + \", and the number of live nodes is \" + nodeList.size()\n          + \". This allows a maximum of \" + maxCoresAllowedToCreate\n          + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n          + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n          + \". This requires \" + requestedCoresToCreate\n          + \" shards to be created (higher than the allowed number)\");\n    }\n\n    ArrayList<Node> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, new Comparator<Node>() {\n      @Override\n      public int compare(Node x, Node y) {\n        return (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1);\n      }\n    });\n    return sortedNodeList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewShard(ClusterState,String,int,int,int,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewShard(ClusterState,String,int,int,int,String).mjava","sourceNew":"  public static ArrayList<Node> getNodesForNewShard(ClusterState clusterState, String collectionName, int numSlices, int maxShardsPerNode, int repFactor, String createNodeSetStr) {\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n\n    HashMap<String,Node> nodeNameVsShardCount =  new HashMap<>();\n    for (String s : nodeList) nodeNameVsShardCount.put(s,new Node(s));\n    for (String s : clusterState.getCollections()) {\n      DocCollection c = clusterState.getCollection(s);\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          Node count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++;\n            if (s.equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    if (nodeNameVsShardCount.size() <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create collection \" + collectionName\n          + \". No live Solr-instances\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET + \":\" + createNodeSetStr:\"\"));\n    }\n\n    if (repFactor > nodeNameVsShardCount.size()) {\n      log.warn(\"Specified \"\n          + ZkStateReader.REPLICATION_FACTOR\n          + \" of \"\n          + repFactor\n          + \" on collection \"\n          + collectionName\n          + \" is higher than or equal to the number of Solr instances currently live or part of your \" + CREATE_NODE_SET + \"(\"\n          + nodeList.size()\n          + \"). It's unusual to run two replica of the same slice on the same Solr-instance.\");\n    }\n\n    int maxCoresAllowedToCreate = maxShardsPerNode * nodeList.size();\n    int requestedCoresToCreate = numSlices * repFactor;\n    int minCoresToCreate = requestedCoresToCreate;\n    if (maxCoresAllowedToCreate < minCoresToCreate) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create shards \" + collectionName + \". Value of \"\n          + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n          + \", and the number of live nodes is \" + nodeList.size()\n          + \". This allows a maximum of \" + maxCoresAllowedToCreate\n          + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n          + \" and value of \" + ZkStateReader.REPLICATION_FACTOR + \" is \" + repFactor\n          + \". This requires \" + requestedCoresToCreate\n          + \" shards to be created (higher than the allowed number)\");\n    }\n\n    ArrayList<Node> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, new Comparator<Node>() {\n      @Override\n      public int compare(Node x, Node y) {\n        return (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1);\n      }\n    });\n    return sortedNodeList;\n  }\n\n","sourceOld":"  public static ArrayList<Node> getNodesForNewShard(ClusterState clusterState, String collectionName, int numSlices, int maxShardsPerNode, int repFactor, String createNodeSetStr) {\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n\n    HashMap<String,Node> nodeNameVsShardCount =  new HashMap<>();\n    for (String s : nodeList) nodeNameVsShardCount.put(s,new Node(s));\n    for (String s : clusterState.getCollections()) {\n      DocCollection c = clusterState.getCollection(s);\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          Node count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++;\n            if (s.equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    if (nodeNameVsShardCount.size() <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create collection \" + collectionName\n          + \". No live Solr-instances\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET + \":\" + createNodeSetStr:\"\"));\n    }\n\n    if (repFactor > nodeNameVsShardCount.size()) {\n      log.warn(\"Specified \"\n          + ZkStateReader.REPLICATION_FACTOR\n          + \" of \"\n          + repFactor\n          + \" on collection \"\n          + collectionName\n          + \" is higher than or equal to the number of Solr instances currently live or part of your \" + CREATE_NODE_SET + \"(\"\n          + nodeList.size()\n          + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n    }\n\n    int maxCoresAllowedToCreate = maxShardsPerNode * nodeList.size();\n    int requestedCoresToCreate = numSlices * repFactor;\n    int minCoresToCreate = requestedCoresToCreate;\n    if (maxCoresAllowedToCreate < minCoresToCreate) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create shards \" + collectionName + \". Value of \"\n          + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n          + \", and the number of live nodes is \" + nodeList.size()\n          + \". This allows a maximum of \" + maxCoresAllowedToCreate\n          + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n          + \" and value of \" + ZkStateReader.REPLICATION_FACTOR + \" is \" + repFactor\n          + \". This requires \" + requestedCoresToCreate\n          + \" shards to be created (higher than the allowed number)\");\n    }\n\n    ArrayList<Node> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, new Comparator<Node>() {\n      @Override\n      public int compare(Node x, Node y) {\n        return (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1);\n      }\n    });\n    return sortedNodeList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec4fc24ecd353171e03bd016c1681cd97476015f","date":1432214672,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewShard(ClusterState,String,String,int,String,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewShard(ClusterState,String,int,int,int,String).mjava","sourceNew":"  public static List<Node> getNodesForNewShard(ClusterState clusterState, String collectionName,String shard,int numberOfNodes,\n                                                    String createNodeSetStr, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    Integer repFactor = coll.getInt(REPLICATION_FACTOR, 1);\n    int numSlices = coll.getSlices().size();\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n\n    HashMap<String,Node> nodeNameVsShardCount =  new HashMap<>();\n    for (String s : nodeList) nodeNameVsShardCount.put(s,new Node(s));\n    for (String s : clusterState.getCollections()) {\n      DocCollection c = clusterState.getCollection(s);\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          Node count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++;\n            if (s.equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    if (nodeNameVsShardCount.size() <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create collection \" + collectionName\n          + \". No live Solr-instances\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET + \":\" + createNodeSetStr:\"\"));\n    }\n\n    if (repFactor > nodeNameVsShardCount.size()) {\n      log.warn(\"Specified \"\n          + ZkStateReader.REPLICATION_FACTOR\n          + \" of \"\n          + repFactor\n          + \" on collection \"\n          + collectionName\n          + \" is higher than or equal to the number of Solr instances currently live or part of your \" + CREATE_NODE_SET + \"(\"\n          + nodeList.size()\n          + \"). It's unusual to run two replica of the same slice on the same Solr-instance.\");\n    }\n\n    int maxCoresAllowedToCreate = maxShardsPerNode * nodeList.size();\n    int requestedCoresToCreate = numSlices * repFactor;\n    int minCoresToCreate = requestedCoresToCreate;\n    if (maxCoresAllowedToCreate < minCoresToCreate) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create shards \" + collectionName + \". Value of \"\n          + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n          + \", and the number of live nodes is \" + nodeList.size()\n          + \". This allows a maximum of \" + maxCoresAllowedToCreate\n          + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n          + \" and value of \" + ZkStateReader.REPLICATION_FACTOR + \" is \" + repFactor\n          + \". This requires \" + requestedCoresToCreate\n          + \" shards to be created (higher than the allowed number)\");\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if(l != null) {\n      ArrayList<Rule> rules = new ArrayList<>();\n      for (Object o : l) rules.add(new Rule((Map) o));\n      Map<String, Map<String,Integer>> shardVsNodes = new LinkedHashMap<>();\n      for (Slice slice : coll.getSlices()) {\n        LinkedHashMap<String, Integer> n = new LinkedHashMap<>();\n        shardVsNodes.put(slice.getName(), n);\n        for (Replica replica : slice.getReplicas()) {\n          Integer count = n.get(replica.getNodeName());\n          if(count == null) count = 0;\n          n.put(replica.getNodeName(),++count);\n        }\n      }\n      List snitches = (List) coll.get(DocCollection.SNITCH);\n      List<String> nodesList = createNodeList == null ?\n          new ArrayList<>(clusterState.getLiveNodes()) :\n          createNodeList ;\n      Map<ReplicaAssigner.Position, String> positions = new ReplicaAssigner(\n          rules,\n          Collections.singletonMap(shard, numberOfNodes),\n          snitches,\n          shardVsNodes,\n          nodesList, cc, clusterState).getNodeMappings();\n\n      List<Node> n = new ArrayList<>();\n      for (String s : positions.values()) n.add(new Node(s));\n      return n;\n\n    }else {\n\n      ArrayList<Node> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n      Collections.sort(sortedNodeList, new Comparator<Node>() {\n        @Override\n        public int compare(Node x, Node y) {\n          return (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1);\n        }\n      });\n      return sortedNodeList;\n    }\n  }\n\n","sourceOld":"  public static ArrayList<Node> getNodesForNewShard(ClusterState clusterState, String collectionName, int numSlices, int maxShardsPerNode, int repFactor, String createNodeSetStr) {\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n\n    Set<String> nodes = clusterState.getLiveNodes();\n\n    List<String> nodeList = new ArrayList<>(nodes.size());\n    nodeList.addAll(nodes);\n    if (createNodeList != null) nodeList.retainAll(createNodeList);\n\n\n    HashMap<String,Node> nodeNameVsShardCount =  new HashMap<>();\n    for (String s : nodeList) nodeNameVsShardCount.put(s,new Node(s));\n    for (String s : clusterState.getCollections()) {\n      DocCollection c = clusterState.getCollection(s);\n      //identify suitable nodes  by checking the no:of cores in each of them\n      for (Slice slice : c.getSlices()) {\n        Collection<Replica> replicas = slice.getReplicas();\n        for (Replica replica : replicas) {\n          Node count = nodeNameVsShardCount.get(replica.getNodeName());\n          if (count != null) {\n            count.totalNodes++;\n            if (s.equals(collectionName)) {\n              count.thisCollectionNodes++;\n              if (count.thisCollectionNodes >= maxShardsPerNode) nodeNameVsShardCount.remove(replica.getNodeName());\n            }\n          }\n        }\n      }\n    }\n\n    if (nodeNameVsShardCount.size() <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create collection \" + collectionName\n          + \". No live Solr-instances\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET + \":\" + createNodeSetStr:\"\"));\n    }\n\n    if (repFactor > nodeNameVsShardCount.size()) {\n      log.warn(\"Specified \"\n          + ZkStateReader.REPLICATION_FACTOR\n          + \" of \"\n          + repFactor\n          + \" on collection \"\n          + collectionName\n          + \" is higher than or equal to the number of Solr instances currently live or part of your \" + CREATE_NODE_SET + \"(\"\n          + nodeList.size()\n          + \"). It's unusual to run two replica of the same slice on the same Solr-instance.\");\n    }\n\n    int maxCoresAllowedToCreate = maxShardsPerNode * nodeList.size();\n    int requestedCoresToCreate = numSlices * repFactor;\n    int minCoresToCreate = requestedCoresToCreate;\n    if (maxCoresAllowedToCreate < minCoresToCreate) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create shards \" + collectionName + \". Value of \"\n          + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n          + \", and the number of live nodes is \" + nodeList.size()\n          + \". This allows a maximum of \" + maxCoresAllowedToCreate\n          + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n          + \" and value of \" + ZkStateReader.REPLICATION_FACTOR + \" is \" + repFactor\n          + \". This requires \" + requestedCoresToCreate\n          + \" shards to be created (higher than the allowed number)\");\n    }\n\n    ArrayList<Node> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, new Comparator<Node>() {\n      @Override\n      public int compare(Node x, Node y) {\n        return (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1);\n      }\n    });\n    return sortedNodeList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["1eeda7e62e149f90eee8895af874c74efa7d4852"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1eeda7e62e149f90eee8895af874c74efa7d4852"],"ec4fc24ecd353171e03bd016c1681cd97476015f":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1eeda7e62e149f90eee8895af874c74efa7d4852":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ec4fc24ecd353171e03bd016c1681cd97476015f"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["ec4fc24ecd353171e03bd016c1681cd97476015f"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"ec4fc24ecd353171e03bd016c1681cd97476015f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","1eeda7e62e149f90eee8895af874c74efa7d4852"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}