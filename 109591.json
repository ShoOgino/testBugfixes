{"path":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentInfo(SegmentCommitInfo,boolean,boolean,List[LeafReaderContext],IndexSchema).mjava","commits":[{"id":"3470ed04f0378c1ceb02e540e3296dd27c0ae3d5","date":1552136881,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentInfo(SegmentCommitInfo,boolean,boolean,List[LeafReaderContext],IndexSchema).mjava","pathOld":"/dev/null","sourceNew":"  private SimpleOrderedMap<Object> getSegmentInfo(\n      SegmentCommitInfo segmentCommitInfo, boolean withSizeInfo, boolean withFieldInfos,\n      List<LeafReaderContext> leafContexts, IndexSchema schema) throws IOException {\n    SimpleOrderedMap<Object> segmentInfoMap = new SimpleOrderedMap<>();\n\n    segmentInfoMap.add(NAME, segmentCommitInfo.info.name);\n    segmentInfoMap.add(\"delCount\", segmentCommitInfo.getDelCount());\n    segmentInfoMap.add(\"softDelCount\", segmentCommitInfo.getSoftDelCount());\n    segmentInfoMap.add(\"hasFieldUpdates\", segmentCommitInfo.hasFieldUpdates());\n    segmentInfoMap.add(\"sizeInBytes\", segmentCommitInfo.sizeInBytes());\n    segmentInfoMap.add(\"size\", segmentCommitInfo.info.maxDoc());\n    Long timestamp = Long.parseLong(segmentCommitInfo.info.getDiagnostics()\n        .get(\"timestamp\"));\n    segmentInfoMap.add(\"age\", new Date(timestamp));\n    segmentInfoMap.add(\"source\",\n        segmentCommitInfo.info.getDiagnostics().get(\"source\"));\n    segmentInfoMap.add(\"version\", segmentCommitInfo.info.getVersion().toString());\n    // don't open a new SegmentReader - try to find the right one from the leaf contexts\n    SegmentReader seg = null;\n    for (LeafReaderContext lrc : leafContexts) {\n      LeafReader leafReader = lrc.reader();\n      // unwrap\n      while (leafReader instanceof FilterLeafReader) {\n        leafReader = ((FilterLeafReader)leafReader).getDelegate();\n      }\n      if (leafReader instanceof SegmentReader) {\n        SegmentReader sr = (SegmentReader)leafReader;\n        if (sr.getSegmentInfo().info.equals(segmentCommitInfo.info)) {\n          seg = sr;\n          break;\n        }\n      }\n    }\n    if (seg != null) {\n      LeafMetaData metaData = seg.getMetaData();\n      if (metaData != null) {\n        segmentInfoMap.add(\"createdVersionMajor\", metaData.getCreatedVersionMajor());\n        segmentInfoMap.add(\"minVersion\", metaData.getMinVersion().toString());\n        if (metaData.getSort() != null) {\n          segmentInfoMap.add(\"sort\", metaData.getSort().toString());\n        }\n      }\n    }\n    if (!segmentCommitInfo.info.getDiagnostics().isEmpty()) {\n      segmentInfoMap.add(\"diagnostics\", segmentCommitInfo.info.getDiagnostics());\n    }\n    if (!segmentCommitInfo.info.getAttributes().isEmpty()) {\n      segmentInfoMap.add(\"attributes\", segmentCommitInfo.info.getAttributes());\n    }\n    if (withSizeInfo) {\n      Directory dir = segmentCommitInfo.info.dir;\n      List<Pair<String, Long>> files = segmentCommitInfo.files().stream()\n          .map(f -> {\n            long size = -1;\n            try {\n              size = dir.fileLength(f);\n            } catch (IOException e) {\n            }\n            return new Pair<String, Long>(f, size);\n          }).sorted((p1, p2) -> {\n            if (p1.second() > p2.second()) {\n              return -1;\n            } else if (p1.second() < p2.second()) {\n              return 1;\n            } else {\n              return 0;\n            }\n          }).collect(Collectors.toList());\n      if (!files.isEmpty()) {\n        SimpleOrderedMap<Object> topFiles = new SimpleOrderedMap<>();\n        for (int i = 0; i < Math.min(files.size(), 5); i++) {\n          Pair<String, Long> p = files.get(i);\n          topFiles.add(p.first(), RamUsageEstimator.humanReadableUnits(p.second()));\n        }\n        segmentInfoMap.add(\"largestFiles\", topFiles);\n      }\n    }\n    if (seg != null && withSizeInfo) {\n      SimpleOrderedMap<Object> ram = new SimpleOrderedMap<>();\n      ram.add(\"total\", seg.ramBytesUsed());\n      for (Accountable ac : seg.getChildResources()) {\n        accountableToMap(ac, ram::add);\n      }\n      segmentInfoMap.add(\"ramBytesUsed\", ram);\n    }\n    if (withFieldInfos) {\n      if (seg == null) {\n        log.debug(\"Skipping segment info - not available as a SegmentReader: \" + segmentCommitInfo);\n      } else {\n        FieldInfos fis = seg.getFieldInfos();\n        SimpleOrderedMap<Object> fields = new SimpleOrderedMap<>();\n        for (FieldInfo fi : fis) {\n          fields.add(fi.name, getFieldInfo(seg, fi, schema));\n        }\n        segmentInfoMap.add(\"fields\", fields);\n      }\n    }\n\n    return segmentInfoMap;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentInfo(SegmentCommitInfo,boolean,boolean,List[LeafReaderContext],IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentInfo(SegmentCommitInfo,boolean,boolean,List[LeafReaderContext],IndexSchema).mjava","sourceNew":"  private SimpleOrderedMap<Object> getSegmentInfo(\n      SegmentCommitInfo segmentCommitInfo, boolean withSizeInfo, boolean withFieldInfos,\n      List<LeafReaderContext> leafContexts, IndexSchema schema) throws IOException {\n    SimpleOrderedMap<Object> segmentInfoMap = new SimpleOrderedMap<>();\n\n    segmentInfoMap.add(NAME, segmentCommitInfo.info.name);\n    segmentInfoMap.add(\"delCount\", segmentCommitInfo.getDelCount());\n    segmentInfoMap.add(\"softDelCount\", segmentCommitInfo.getSoftDelCount());\n    segmentInfoMap.add(\"hasFieldUpdates\", segmentCommitInfo.hasFieldUpdates());\n    segmentInfoMap.add(\"sizeInBytes\", segmentCommitInfo.sizeInBytes());\n    segmentInfoMap.add(\"size\", segmentCommitInfo.info.maxDoc());\n    Long timestamp = Long.parseLong(segmentCommitInfo.info.getDiagnostics()\n        .get(\"timestamp\"));\n    segmentInfoMap.add(\"age\", new Date(timestamp));\n    segmentInfoMap.add(\"source\",\n        segmentCommitInfo.info.getDiagnostics().get(\"source\"));\n    segmentInfoMap.add(\"version\", segmentCommitInfo.info.getVersion().toString());\n    // don't open a new SegmentReader - try to find the right one from the leaf contexts\n    SegmentReader seg = null;\n    for (LeafReaderContext lrc : leafContexts) {\n      LeafReader leafReader = lrc.reader();\n      // unwrap\n      while (leafReader instanceof FilterLeafReader) {\n        leafReader = ((FilterLeafReader)leafReader).getDelegate();\n      }\n      if (leafReader instanceof SegmentReader) {\n        SegmentReader sr = (SegmentReader)leafReader;\n        if (sr.getSegmentInfo().info.equals(segmentCommitInfo.info)) {\n          seg = sr;\n          break;\n        }\n      }\n    }\n    if (seg != null) {\n      LeafMetaData metaData = seg.getMetaData();\n      if (metaData != null) {\n        segmentInfoMap.add(\"createdVersionMajor\", metaData.getCreatedVersionMajor());\n        segmentInfoMap.add(\"minVersion\", metaData.getMinVersion().toString());\n        if (metaData.getSort() != null) {\n          segmentInfoMap.add(\"sort\", metaData.getSort().toString());\n        }\n      }\n    }\n    if (!segmentCommitInfo.info.getDiagnostics().isEmpty()) {\n      segmentInfoMap.add(\"diagnostics\", segmentCommitInfo.info.getDiagnostics());\n    }\n    if (!segmentCommitInfo.info.getAttributes().isEmpty()) {\n      segmentInfoMap.add(\"attributes\", segmentCommitInfo.info.getAttributes());\n    }\n    if (withSizeInfo) {\n      Directory dir = segmentCommitInfo.info.dir;\n      List<Pair<String, Long>> files = segmentCommitInfo.files().stream()\n          .map(f -> {\n            long size = -1;\n            try {\n              size = dir.fileLength(f);\n            } catch (IOException e) {\n            }\n            return new Pair<String, Long>(f, size);\n          }).sorted((p1, p2) -> {\n            if (p1.second() > p2.second()) {\n              return -1;\n            } else if (p1.second() < p2.second()) {\n              return 1;\n            } else {\n              return 0;\n            }\n          }).collect(Collectors.toList());\n      if (!files.isEmpty()) {\n        SimpleOrderedMap<Object> topFiles = new SimpleOrderedMap<>();\n        for (int i = 0; i < Math.min(files.size(), 5); i++) {\n          Pair<String, Long> p = files.get(i);\n          topFiles.add(p.first(), RamUsageEstimator.humanReadableUnits(p.second()));\n        }\n        segmentInfoMap.add(\"largestFiles\", topFiles);\n      }\n    }\n    if (seg != null && withSizeInfo) {\n      SimpleOrderedMap<Object> ram = new SimpleOrderedMap<>();\n      ram.add(\"total\", seg.ramBytesUsed());\n      for (Accountable ac : seg.getChildResources()) {\n        accountableToMap(ac, ram::add);\n      }\n      segmentInfoMap.add(\"ramBytesUsed\", ram);\n    }\n    if (withFieldInfos) {\n      if (seg == null) {\n        log.debug(\"Skipping segment info - not available as a SegmentReader: {}\", segmentCommitInfo);\n      } else {\n        FieldInfos fis = seg.getFieldInfos();\n        SimpleOrderedMap<Object> fields = new SimpleOrderedMap<>();\n        for (FieldInfo fi : fis) {\n          fields.add(fi.name, getFieldInfo(seg, fi, schema));\n        }\n        segmentInfoMap.add(\"fields\", fields);\n      }\n    }\n\n    return segmentInfoMap;\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> getSegmentInfo(\n      SegmentCommitInfo segmentCommitInfo, boolean withSizeInfo, boolean withFieldInfos,\n      List<LeafReaderContext> leafContexts, IndexSchema schema) throws IOException {\n    SimpleOrderedMap<Object> segmentInfoMap = new SimpleOrderedMap<>();\n\n    segmentInfoMap.add(NAME, segmentCommitInfo.info.name);\n    segmentInfoMap.add(\"delCount\", segmentCommitInfo.getDelCount());\n    segmentInfoMap.add(\"softDelCount\", segmentCommitInfo.getSoftDelCount());\n    segmentInfoMap.add(\"hasFieldUpdates\", segmentCommitInfo.hasFieldUpdates());\n    segmentInfoMap.add(\"sizeInBytes\", segmentCommitInfo.sizeInBytes());\n    segmentInfoMap.add(\"size\", segmentCommitInfo.info.maxDoc());\n    Long timestamp = Long.parseLong(segmentCommitInfo.info.getDiagnostics()\n        .get(\"timestamp\"));\n    segmentInfoMap.add(\"age\", new Date(timestamp));\n    segmentInfoMap.add(\"source\",\n        segmentCommitInfo.info.getDiagnostics().get(\"source\"));\n    segmentInfoMap.add(\"version\", segmentCommitInfo.info.getVersion().toString());\n    // don't open a new SegmentReader - try to find the right one from the leaf contexts\n    SegmentReader seg = null;\n    for (LeafReaderContext lrc : leafContexts) {\n      LeafReader leafReader = lrc.reader();\n      // unwrap\n      while (leafReader instanceof FilterLeafReader) {\n        leafReader = ((FilterLeafReader)leafReader).getDelegate();\n      }\n      if (leafReader instanceof SegmentReader) {\n        SegmentReader sr = (SegmentReader)leafReader;\n        if (sr.getSegmentInfo().info.equals(segmentCommitInfo.info)) {\n          seg = sr;\n          break;\n        }\n      }\n    }\n    if (seg != null) {\n      LeafMetaData metaData = seg.getMetaData();\n      if (metaData != null) {\n        segmentInfoMap.add(\"createdVersionMajor\", metaData.getCreatedVersionMajor());\n        segmentInfoMap.add(\"minVersion\", metaData.getMinVersion().toString());\n        if (metaData.getSort() != null) {\n          segmentInfoMap.add(\"sort\", metaData.getSort().toString());\n        }\n      }\n    }\n    if (!segmentCommitInfo.info.getDiagnostics().isEmpty()) {\n      segmentInfoMap.add(\"diagnostics\", segmentCommitInfo.info.getDiagnostics());\n    }\n    if (!segmentCommitInfo.info.getAttributes().isEmpty()) {\n      segmentInfoMap.add(\"attributes\", segmentCommitInfo.info.getAttributes());\n    }\n    if (withSizeInfo) {\n      Directory dir = segmentCommitInfo.info.dir;\n      List<Pair<String, Long>> files = segmentCommitInfo.files().stream()\n          .map(f -> {\n            long size = -1;\n            try {\n              size = dir.fileLength(f);\n            } catch (IOException e) {\n            }\n            return new Pair<String, Long>(f, size);\n          }).sorted((p1, p2) -> {\n            if (p1.second() > p2.second()) {\n              return -1;\n            } else if (p1.second() < p2.second()) {\n              return 1;\n            } else {\n              return 0;\n            }\n          }).collect(Collectors.toList());\n      if (!files.isEmpty()) {\n        SimpleOrderedMap<Object> topFiles = new SimpleOrderedMap<>();\n        for (int i = 0; i < Math.min(files.size(), 5); i++) {\n          Pair<String, Long> p = files.get(i);\n          topFiles.add(p.first(), RamUsageEstimator.humanReadableUnits(p.second()));\n        }\n        segmentInfoMap.add(\"largestFiles\", topFiles);\n      }\n    }\n    if (seg != null && withSizeInfo) {\n      SimpleOrderedMap<Object> ram = new SimpleOrderedMap<>();\n      ram.add(\"total\", seg.ramBytesUsed());\n      for (Accountable ac : seg.getChildResources()) {\n        accountableToMap(ac, ram::add);\n      }\n      segmentInfoMap.add(\"ramBytesUsed\", ram);\n    }\n    if (withFieldInfos) {\n      if (seg == null) {\n        log.debug(\"Skipping segment info - not available as a SegmentReader: \" + segmentCommitInfo);\n      } else {\n        FieldInfos fis = seg.getFieldInfos();\n        SimpleOrderedMap<Object> fields = new SimpleOrderedMap<>();\n        for (FieldInfo fi : fis) {\n          fields.add(fi.name, getFieldInfo(seg, fi, schema));\n        }\n        segmentInfoMap.add(\"fields\", fields);\n      }\n    }\n\n    return segmentInfoMap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee4883d944766f23a7d88ddbeca1c09acdc7a9a8","date":1589565769,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentInfo(SegmentCommitInfo,boolean,boolean,List[LeafReaderContext],IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentInfo(SegmentCommitInfo,boolean,boolean,List[LeafReaderContext],IndexSchema).mjava","sourceNew":"  private SimpleOrderedMap<Object> getSegmentInfo(\n      SegmentCommitInfo segmentCommitInfo, boolean withSizeInfo, boolean withFieldInfos,\n      List<LeafReaderContext> leafContexts, IndexSchema schema) throws IOException {\n    SimpleOrderedMap<Object> segmentInfoMap = new SimpleOrderedMap<>();\n\n    segmentInfoMap.add(NAME, segmentCommitInfo.info.name);\n    segmentInfoMap.add(\"delCount\", segmentCommitInfo.getDelCount());\n    segmentInfoMap.add(\"softDelCount\", segmentCommitInfo.getSoftDelCount());\n    segmentInfoMap.add(\"hasFieldUpdates\", segmentCommitInfo.hasFieldUpdates());\n    segmentInfoMap.add(\"sizeInBytes\", segmentCommitInfo.sizeInBytes());\n    segmentInfoMap.add(\"size\", segmentCommitInfo.info.maxDoc());\n    Long timestamp = Long.parseLong(segmentCommitInfo.info.getDiagnostics()\n        .get(\"timestamp\"));\n    segmentInfoMap.add(\"age\", new Date(timestamp));\n    segmentInfoMap.add(\"source\",\n        segmentCommitInfo.info.getDiagnostics().get(\"source\"));\n    segmentInfoMap.add(\"version\", segmentCommitInfo.info.getVersion().toString());\n    // don't open a new SegmentReader - try to find the right one from the leaf contexts\n    SegmentReader seg = null;\n    for (LeafReaderContext lrc : leafContexts) {\n      LeafReader leafReader = lrc.reader();\n      leafReader = FilterLeafReader.unwrap(leafReader);\n      if (leafReader instanceof SegmentReader) {\n        SegmentReader sr = (SegmentReader)leafReader;\n        if (sr.getSegmentInfo().info.equals(segmentCommitInfo.info)) {\n          seg = sr;\n          break;\n        }\n      }\n    }\n    if (seg != null) {\n      LeafMetaData metaData = seg.getMetaData();\n      if (metaData != null) {\n        segmentInfoMap.add(\"createdVersionMajor\", metaData.getCreatedVersionMajor());\n        segmentInfoMap.add(\"minVersion\", metaData.getMinVersion().toString());\n        if (metaData.getSort() != null) {\n          segmentInfoMap.add(\"sort\", metaData.getSort().toString());\n        }\n      }\n    }\n    if (!segmentCommitInfo.info.getDiagnostics().isEmpty()) {\n      segmentInfoMap.add(\"diagnostics\", segmentCommitInfo.info.getDiagnostics());\n    }\n    if (!segmentCommitInfo.info.getAttributes().isEmpty()) {\n      segmentInfoMap.add(\"attributes\", segmentCommitInfo.info.getAttributes());\n    }\n    if (withSizeInfo) {\n      Directory dir = segmentCommitInfo.info.dir;\n      List<Pair<String, Long>> files = segmentCommitInfo.files().stream()\n          .map(f -> {\n            long size = -1;\n            try {\n              size = dir.fileLength(f);\n            } catch (IOException e) {\n            }\n            return new Pair<String, Long>(f, size);\n          }).sorted((p1, p2) -> {\n            if (p1.second() > p2.second()) {\n              return -1;\n            } else if (p1.second() < p2.second()) {\n              return 1;\n            } else {\n              return 0;\n            }\n          }).collect(Collectors.toList());\n      if (!files.isEmpty()) {\n        SimpleOrderedMap<Object> topFiles = new SimpleOrderedMap<>();\n        for (int i = 0; i < Math.min(files.size(), 5); i++) {\n          Pair<String, Long> p = files.get(i);\n          topFiles.add(p.first(), RamUsageEstimator.humanReadableUnits(p.second()));\n        }\n        segmentInfoMap.add(\"largestFiles\", topFiles);\n      }\n    }\n    if (seg != null && withSizeInfo) {\n      SimpleOrderedMap<Object> ram = new SimpleOrderedMap<>();\n      ram.add(\"total\", seg.ramBytesUsed());\n      for (Accountable ac : seg.getChildResources()) {\n        accountableToMap(ac, ram::add);\n      }\n      segmentInfoMap.add(\"ramBytesUsed\", ram);\n    }\n    if (withFieldInfos) {\n      if (seg == null) {\n        log.debug(\"Skipping segment info - not available as a SegmentReader: {}\", segmentCommitInfo);\n      } else {\n        FieldInfos fis = seg.getFieldInfos();\n        SimpleOrderedMap<Object> fields = new SimpleOrderedMap<>();\n        for (FieldInfo fi : fis) {\n          fields.add(fi.name, getFieldInfo(seg, fi, schema));\n        }\n        segmentInfoMap.add(\"fields\", fields);\n      }\n    }\n\n    return segmentInfoMap;\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> getSegmentInfo(\n      SegmentCommitInfo segmentCommitInfo, boolean withSizeInfo, boolean withFieldInfos,\n      List<LeafReaderContext> leafContexts, IndexSchema schema) throws IOException {\n    SimpleOrderedMap<Object> segmentInfoMap = new SimpleOrderedMap<>();\n\n    segmentInfoMap.add(NAME, segmentCommitInfo.info.name);\n    segmentInfoMap.add(\"delCount\", segmentCommitInfo.getDelCount());\n    segmentInfoMap.add(\"softDelCount\", segmentCommitInfo.getSoftDelCount());\n    segmentInfoMap.add(\"hasFieldUpdates\", segmentCommitInfo.hasFieldUpdates());\n    segmentInfoMap.add(\"sizeInBytes\", segmentCommitInfo.sizeInBytes());\n    segmentInfoMap.add(\"size\", segmentCommitInfo.info.maxDoc());\n    Long timestamp = Long.parseLong(segmentCommitInfo.info.getDiagnostics()\n        .get(\"timestamp\"));\n    segmentInfoMap.add(\"age\", new Date(timestamp));\n    segmentInfoMap.add(\"source\",\n        segmentCommitInfo.info.getDiagnostics().get(\"source\"));\n    segmentInfoMap.add(\"version\", segmentCommitInfo.info.getVersion().toString());\n    // don't open a new SegmentReader - try to find the right one from the leaf contexts\n    SegmentReader seg = null;\n    for (LeafReaderContext lrc : leafContexts) {\n      LeafReader leafReader = lrc.reader();\n      // unwrap\n      while (leafReader instanceof FilterLeafReader) {\n        leafReader = ((FilterLeafReader)leafReader).getDelegate();\n      }\n      if (leafReader instanceof SegmentReader) {\n        SegmentReader sr = (SegmentReader)leafReader;\n        if (sr.getSegmentInfo().info.equals(segmentCommitInfo.info)) {\n          seg = sr;\n          break;\n        }\n      }\n    }\n    if (seg != null) {\n      LeafMetaData metaData = seg.getMetaData();\n      if (metaData != null) {\n        segmentInfoMap.add(\"createdVersionMajor\", metaData.getCreatedVersionMajor());\n        segmentInfoMap.add(\"minVersion\", metaData.getMinVersion().toString());\n        if (metaData.getSort() != null) {\n          segmentInfoMap.add(\"sort\", metaData.getSort().toString());\n        }\n      }\n    }\n    if (!segmentCommitInfo.info.getDiagnostics().isEmpty()) {\n      segmentInfoMap.add(\"diagnostics\", segmentCommitInfo.info.getDiagnostics());\n    }\n    if (!segmentCommitInfo.info.getAttributes().isEmpty()) {\n      segmentInfoMap.add(\"attributes\", segmentCommitInfo.info.getAttributes());\n    }\n    if (withSizeInfo) {\n      Directory dir = segmentCommitInfo.info.dir;\n      List<Pair<String, Long>> files = segmentCommitInfo.files().stream()\n          .map(f -> {\n            long size = -1;\n            try {\n              size = dir.fileLength(f);\n            } catch (IOException e) {\n            }\n            return new Pair<String, Long>(f, size);\n          }).sorted((p1, p2) -> {\n            if (p1.second() > p2.second()) {\n              return -1;\n            } else if (p1.second() < p2.second()) {\n              return 1;\n            } else {\n              return 0;\n            }\n          }).collect(Collectors.toList());\n      if (!files.isEmpty()) {\n        SimpleOrderedMap<Object> topFiles = new SimpleOrderedMap<>();\n        for (int i = 0; i < Math.min(files.size(), 5); i++) {\n          Pair<String, Long> p = files.get(i);\n          topFiles.add(p.first(), RamUsageEstimator.humanReadableUnits(p.second()));\n        }\n        segmentInfoMap.add(\"largestFiles\", topFiles);\n      }\n    }\n    if (seg != null && withSizeInfo) {\n      SimpleOrderedMap<Object> ram = new SimpleOrderedMap<>();\n      ram.add(\"total\", seg.ramBytesUsed());\n      for (Accountable ac : seg.getChildResources()) {\n        accountableToMap(ac, ram::add);\n      }\n      segmentInfoMap.add(\"ramBytesUsed\", ram);\n    }\n    if (withFieldInfos) {\n      if (seg == null) {\n        log.debug(\"Skipping segment info - not available as a SegmentReader: {}\", segmentCommitInfo);\n      } else {\n        FieldInfos fis = seg.getFieldInfos();\n        SimpleOrderedMap<Object> fields = new SimpleOrderedMap<>();\n        for (FieldInfo fi : fis) {\n          fields.add(fi.name, getFieldInfo(seg, fi, schema));\n        }\n        segmentInfoMap.add(\"fields\", fields);\n      }\n    }\n\n    return segmentInfoMap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3470ed04f0378c1ceb02e540e3296dd27c0ae3d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"575e66bd4b2349209027f6801184da7fc3cba13f":["3470ed04f0378c1ceb02e540e3296dd27c0ae3d5"],"ee4883d944766f23a7d88ddbeca1c09acdc7a9a8":["575e66bd4b2349209027f6801184da7fc3cba13f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ee4883d944766f23a7d88ddbeca1c09acdc7a9a8"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3470ed04f0378c1ceb02e540e3296dd27c0ae3d5"],"3470ed04f0378c1ceb02e540e3296dd27c0ae3d5":["575e66bd4b2349209027f6801184da7fc3cba13f"],"575e66bd4b2349209027f6801184da7fc3cba13f":["ee4883d944766f23a7d88ddbeca1c09acdc7a9a8"],"ee4883d944766f23a7d88ddbeca1c09acdc7a9a8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}