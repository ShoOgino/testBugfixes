{"path":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeHeader(DataOutput,String,int).mjava","commits":[{"id":"bcce0e518c0546269a896ca6124ba4313059185f","date":1340381078,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeHeader(DataOutput,String,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#writeHeader(DataOutput,String,int).mjava","sourceNew":"  /**\n   * Writes a codec header, which records both a string to\n   * identify the file and a version number. This header can\n   * be parsed and validated with \n   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.\n   * <p>\n   * CodecHeader --&gt; Magic,CodecName,Version\n   * <ul>\n   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This\n   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.\n   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This\n   *        is a string to identify this file.\n   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records\n   *        the version of the file.\n   * </ul>\n   * <p>\n   * Note that the length of a codec header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   */\n  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","sourceOld":"  /**\n   * Writes a codec header, which records both a string to\n   * identify the file and a version number. This header can\n   * be parsed and validated with \n   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.\n   * <p>\n   * CodecHeader --&gt; Magic,CodecName,Version\n   * <ul>\n   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This\n   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.\n   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This\n   *        is a string to identify this file.\n   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records\n   *        the version of the file.\n   * </ul>\n   * <p>\n   * Note that the length of a codec header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   */\n  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeHeader(DataOutput,String,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#writeHeader(DataOutput,String,int).mjava","sourceNew":"  /**\n   * Writes a codec header, which records both a string to\n   * identify the file and a version number. This header can\n   * be parsed and validated with \n   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.\n   * <p>\n   * CodecHeader --&gt; Magic,CodecName,Version\n   * <ul>\n   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This\n   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.\n   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This\n   *        is a string to identify this file.\n   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records\n   *        the version of the file.\n   * </ul>\n   * <p>\n   * Note that the length of a codec header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   */\n  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","sourceOld":"  /**\n   * Writes a codec header, which records both a string to\n   * identify the file and a version number. This header can\n   * be parsed and validated with \n   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.\n   * <p>\n   * CodecHeader --&gt; Magic,CodecName,Version\n   * <ul>\n   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This\n   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.\n   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This\n   *        is a string to identify this file.\n   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records\n   *        the version of the file.\n   * </ul>\n   * <p>\n   * Note that the length of a codec header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   */\n  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"500867f0f15393f6b2c38c3366e414fccba04ed6","date":1411520390,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeHeader(DataOutput,String,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeHeader(DataOutput,String,int).mjava","sourceNew":"  /**\n   * Writes a codec header, which records both a string to\n   * identify the file and a version number. This header can\n   * be parsed and validated with \n   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.\n   * <p>\n   * CodecHeader --&gt; Magic,CodecName,Version\n   * <ul>\n   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This\n   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.\n   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This\n   *        is a string to identify this file.\n   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records\n   *        the version of the file.\n   * </ul>\n   * <p>\n   * Note that the length of a codec header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or is more than 127 characters in length\n   */\n  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","sourceOld":"  /**\n   * Writes a codec header, which records both a string to\n   * identify the file and a version number. This header can\n   * be parsed and validated with \n   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.\n   * <p>\n   * CodecHeader --&gt; Magic,CodecName,Version\n   * <ul>\n   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This\n   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.\n   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This\n   *        is a string to identify this file.\n   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records\n   *        the version of the file.\n   * </ul>\n   * <p>\n   * Note that the length of a codec header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   */\n  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b11b097f011a298f1a54676482032c2b261e26f3","date":1411698138,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeHeader(DataOutput,String,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeHeader(DataOutput,String,int).mjava","sourceNew":"  /**\n   * Writes a codec header, which records both a string to\n   * identify the file and a version number. This header can\n   * be parsed and validated with \n   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.\n   * <p>\n   * CodecHeader --&gt; Magic,CodecName,Version\n   * <ul>\n   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This\n   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.\n   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This\n   *        is a string to identify this file.\n   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records\n   *        the version of the file.\n   * </ul>\n   * <p>\n   * Note that the length of a codec header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or is more than 127 characters in length\n   */\n  public static void writeHeader(DataOutput out, String codec, int version) throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","sourceOld":"  /**\n   * Writes a codec header, which records both a string to\n   * identify the file and a version number. This header can\n   * be parsed and validated with \n   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.\n   * <p>\n   * CodecHeader --&gt; Magic,CodecName,Version\n   * <ul>\n   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This\n   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.\n   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This\n   *        is a string to identify this file.\n   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records\n   *        the version of the file.\n   * </ul>\n   * <p>\n   * Note that the length of a codec header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or is more than 127 characters in length\n   */\n  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f6bd27530a2846413fe2d00030493c0e2d3a072","date":1411811855,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeHeader(DataOutput,String,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeHeader(DataOutput,String,int).mjava","sourceNew":"  /**\n   * Writes a codec header, which records both a string to\n   * identify the file and a version number. This header can\n   * be parsed and validated with \n   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.\n   * <p>\n   * CodecHeader --&gt; Magic,CodecName,Version\n   * <ul>\n   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This\n   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.\n   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This\n   *        is a string to identify this file.\n   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records\n   *        the version of the file.\n   * </ul>\n   * <p>\n   * Note that the length of a codec header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or is more than 127 characters in length\n   */\n  public static void writeHeader(DataOutput out, String codec, int version) throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","sourceOld":"  /**\n   * Writes a codec header, which records both a string to\n   * identify the file and a version number. This header can\n   * be parsed and validated with \n   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.\n   * <p>\n   * CodecHeader --&gt; Magic,CodecName,Version\n   * <ul>\n   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This\n   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.\n   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This\n   *        is a string to identify this file.\n   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records\n   *        the version of the file.\n   * </ul>\n   * <p>\n   * Note that the length of a codec header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or is more than 127 characters in length\n   */\n  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","bugFix":["7b91922b55d15444d554721b352861d028eb8278","5a26f154aa4ead03cc4cb89ee0e9e4f9b79443f0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bcce0e518c0546269a896ca6124ba4313059185f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bcce0e518c0546269a896ca6124ba4313059185f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["500867f0f15393f6b2c38c3366e414fccba04ed6","b11b097f011a298f1a54676482032c2b261e26f3"],"500867f0f15393f6b2c38c3366e414fccba04ed6":["bcce0e518c0546269a896ca6124ba4313059185f"],"b11b097f011a298f1a54676482032c2b261e26f3":["500867f0f15393f6b2c38c3366e414fccba04ed6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5f6bd27530a2846413fe2d00030493c0e2d3a072"]},"commit2Childs":{"bcce0e518c0546269a896ca6124ba4313059185f":["fe33227f6805edab2036cbb80645cc4e2d1fa424","500867f0f15393f6b2c38c3366e414fccba04ed6"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bcce0e518c0546269a896ca6124ba4313059185f","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"500867f0f15393f6b2c38c3366e414fccba04ed6":["5f6bd27530a2846413fe2d00030493c0e2d3a072","b11b097f011a298f1a54676482032c2b261e26f3"],"b11b097f011a298f1a54676482032c2b261e26f3":["5f6bd27530a2846413fe2d00030493c0e2d3a072"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}