{"path":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#resolveFullDocument(SolrCore,BytesRef,ReturnFields,SolrInputDocument,List,Set[String]).mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#resolveFullDocument(SolrCore,BytesRef,ReturnFields,SolrInputDocument,List,Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  /***\n   * Given a partial document obtained from the transaction log (e.g. as a result of RTG), resolve to a full document\n   * by populating all the partial updates that were applied on top of that last full document update.\n   * \n   * @param onlyTheseFields When a non-null set of field names is passed in, the resolve process only attempts to populate\n   *        the given fields in this set. When this set is null, it resolves all fields.\n   * @return Returns the merged document, i.e. the resolved full document, or null if the document was not found (deleted\n   *          after the resolving began)\n   */\n  private static SolrDocument resolveFullDocument(SolrCore core, BytesRef idBytes,\n                                           ReturnFields returnFields, SolrInputDocument partialDoc, List logEntry, Set<String> onlyTheseFields) throws IOException {\n    if (idBytes == null || logEntry.size() != 5) {\n      throw new SolrException(ErrorCode.INVALID_STATE, \"Either Id field not present in partial document or log entry doesn't have previous version.\");\n    }\n    long prevPointer = (long) logEntry.get(UpdateLog.PREV_POINTER_IDX);\n    long prevVersion = (long) logEntry.get(UpdateLog.PREV_VERSION_IDX);\n\n    // get the last full document from ulog\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    long lastPrevPointer = ulog.applyPartialUpdates(idBytes, prevPointer, prevVersion, onlyTheseFields, partialDoc);\n\n    if (lastPrevPointer == -1) { // full document was not found in tlog, but exists in index\n      SolrDocument mergedDoc = mergePartialDocWithFullDocFromIndex(core, idBytes, returnFields, onlyTheseFields, partialDoc);\n      return mergedDoc;\n    } else if (lastPrevPointer > 0) {\n      // We were supposed to have found the last full doc also in the tlogs, but the prevPointer links led to nowhere\n      // We should reopen a new RT searcher and get the doc. This should be a rare occurrence\n      Term idTerm = new Term(core.getLatestSchema().getUniqueKeyField().getName(), idBytes);\n      SolrDocument mergedDoc = reopenRealtimeSearcherAndGet(core, idTerm, returnFields);\n      if (mergedDoc == null) {\n        return null; // the document may have been deleted as the resolving was going on.\n      }\n      return mergedDoc;\n    } else { // i.e. lastPrevPointer==0\n      assert lastPrevPointer == 0;\n      // We have successfully resolved the document based off the tlogs\n      return toSolrDoc(partialDoc, core.getLatestSchema());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["57273019d2938b9b30faae55f6983a2e71a56ec5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#resolveFullDocument(SolrCore,BytesRef,ReturnFields,SolrInputDocument,List,Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  /***\n   * Given a partial document obtained from the transaction log (e.g. as a result of RTG), resolve to a full document\n   * by populating all the partial updates that were applied on top of that last full document update.\n   * \n   * @param onlyTheseFields When a non-null set of field names is passed in, the resolve process only attempts to populate\n   *        the given fields in this set. When this set is null, it resolves all fields.\n   * @return Returns the merged document, i.e. the resolved full document, or null if the document was not found (deleted\n   *          after the resolving began)\n   */\n  private static SolrDocument resolveFullDocument(SolrCore core, BytesRef idBytes,\n                                           ReturnFields returnFields, SolrInputDocument partialDoc, List logEntry, Set<String> onlyTheseFields) throws IOException {\n    if (idBytes == null || logEntry.size() != 5) {\n      throw new SolrException(ErrorCode.INVALID_STATE, \"Either Id field not present in partial document or log entry doesn't have previous version.\");\n    }\n    long prevPointer = (long) logEntry.get(UpdateLog.PREV_POINTER_IDX);\n    long prevVersion = (long) logEntry.get(UpdateLog.PREV_VERSION_IDX);\n\n    // get the last full document from ulog\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    long lastPrevPointer = ulog.applyPartialUpdates(idBytes, prevPointer, prevVersion, onlyTheseFields, partialDoc);\n\n    if (lastPrevPointer == -1) { // full document was not found in tlog, but exists in index\n      SolrDocument mergedDoc = mergePartialDocWithFullDocFromIndex(core, idBytes, returnFields, onlyTheseFields, partialDoc);\n      return mergedDoc;\n    } else if (lastPrevPointer > 0) {\n      // We were supposed to have found the last full doc also in the tlogs, but the prevPointer links led to nowhere\n      // We should reopen a new RT searcher and get the doc. This should be a rare occurrence\n      Term idTerm = new Term(core.getLatestSchema().getUniqueKeyField().getName(), idBytes);\n      SolrDocument mergedDoc = reopenRealtimeSearcherAndGet(core, idTerm, returnFields);\n      if (mergedDoc == null) {\n        return null; // the document may have been deleted as the resolving was going on.\n      }\n      return mergedDoc;\n    } else { // i.e. lastPrevPointer==0\n      assert lastPrevPointer == 0;\n      // We have successfully resolved the document based off the tlogs\n      return toSolrDoc(partialDoc, core.getLatestSchema());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e1bfbfa5a260860e3f12522fca45ec1240752f","date":1521057510,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#resolveFullDocument(SolrCore,BytesRef,ReturnFields,SolrInputDocument,List,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#resolveFullDocument(SolrCore,BytesRef,ReturnFields,SolrInputDocument,List,Set[String]).mjava","sourceNew":"  /***\n   * Given a partial document obtained from the transaction log (e.g. as a result of RTG), resolve to a full document\n   * by populating all the partial updates that were applied on top of that last full document update.\n   * \n   * @param onlyTheseFields When a non-null set of field names is passed in, the resolve process only attempts to populate\n   *        the given fields in this set. When this set is null, it resolves all fields.\n   * @return Returns the merged document, i.e. the resolved full document, or null if the document was not found (deleted\n   *          after the resolving began)\n   */\n  private static SolrDocument resolveFullDocument(SolrCore core, BytesRef idBytes,\n                                           ReturnFields returnFields, SolrInputDocument partialDoc, List logEntry, Set<String> onlyTheseFields) throws IOException {\n    if (idBytes == null || (logEntry.size() != 5 && logEntry.size() != 6)) {\n      throw new SolrException(ErrorCode.INVALID_STATE, \"Either Id field not present in partial document or log entry doesn't have previous version.\");\n    }\n    long prevPointer = (long) logEntry.get(UpdateLog.PREV_POINTER_IDX);\n    long prevVersion = (long) logEntry.get(UpdateLog.PREV_VERSION_IDX);\n\n    // get the last full document from ulog\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    long lastPrevPointer = ulog.applyPartialUpdates(idBytes, prevPointer, prevVersion, onlyTheseFields, partialDoc);\n\n    if (lastPrevPointer == -1) { // full document was not found in tlog, but exists in index\n      SolrDocument mergedDoc = mergePartialDocWithFullDocFromIndex(core, idBytes, returnFields, onlyTheseFields, partialDoc);\n      return mergedDoc;\n    } else if (lastPrevPointer > 0) {\n      // We were supposed to have found the last full doc also in the tlogs, but the prevPointer links led to nowhere\n      // We should reopen a new RT searcher and get the doc. This should be a rare occurrence\n      Term idTerm = new Term(core.getLatestSchema().getUniqueKeyField().getName(), idBytes);\n      SolrDocument mergedDoc = reopenRealtimeSearcherAndGet(core, idTerm, returnFields);\n      if (mergedDoc == null) {\n        return null; // the document may have been deleted as the resolving was going on.\n      }\n      return mergedDoc;\n    } else { // i.e. lastPrevPointer==0\n      assert lastPrevPointer == 0;\n      // We have successfully resolved the document based off the tlogs\n      return toSolrDoc(partialDoc, core.getLatestSchema());\n    }\n  }\n\n","sourceOld":"  /***\n   * Given a partial document obtained from the transaction log (e.g. as a result of RTG), resolve to a full document\n   * by populating all the partial updates that were applied on top of that last full document update.\n   * \n   * @param onlyTheseFields When a non-null set of field names is passed in, the resolve process only attempts to populate\n   *        the given fields in this set. When this set is null, it resolves all fields.\n   * @return Returns the merged document, i.e. the resolved full document, or null if the document was not found (deleted\n   *          after the resolving began)\n   */\n  private static SolrDocument resolveFullDocument(SolrCore core, BytesRef idBytes,\n                                           ReturnFields returnFields, SolrInputDocument partialDoc, List logEntry, Set<String> onlyTheseFields) throws IOException {\n    if (idBytes == null || logEntry.size() != 5) {\n      throw new SolrException(ErrorCode.INVALID_STATE, \"Either Id field not present in partial document or log entry doesn't have previous version.\");\n    }\n    long prevPointer = (long) logEntry.get(UpdateLog.PREV_POINTER_IDX);\n    long prevVersion = (long) logEntry.get(UpdateLog.PREV_VERSION_IDX);\n\n    // get the last full document from ulog\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    long lastPrevPointer = ulog.applyPartialUpdates(idBytes, prevPointer, prevVersion, onlyTheseFields, partialDoc);\n\n    if (lastPrevPointer == -1) { // full document was not found in tlog, but exists in index\n      SolrDocument mergedDoc = mergePartialDocWithFullDocFromIndex(core, idBytes, returnFields, onlyTheseFields, partialDoc);\n      return mergedDoc;\n    } else if (lastPrevPointer > 0) {\n      // We were supposed to have found the last full doc also in the tlogs, but the prevPointer links led to nowhere\n      // We should reopen a new RT searcher and get the doc. This should be a rare occurrence\n      Term idTerm = new Term(core.getLatestSchema().getUniqueKeyField().getName(), idBytes);\n      SolrDocument mergedDoc = reopenRealtimeSearcherAndGet(core, idTerm, returnFields);\n      if (mergedDoc == null) {\n        return null; // the document may have been deleted as the resolving was going on.\n      }\n      return mergedDoc;\n    } else { // i.e. lastPrevPointer==0\n      assert lastPrevPointer == 0;\n      // We have successfully resolved the document based off the tlogs\n      return toSolrDoc(partialDoc, core.getLatestSchema());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"57273019d2938b9b30faae55f6983a2e71a56ec5","date":1550480608,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#resolveFullDocument(SolrCore,BytesRef,ReturnFields,SolrInputDocument,List,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#resolveFullDocument(SolrCore,BytesRef,ReturnFields,SolrInputDocument,List,Set[String]).mjava","sourceNew":"  /***\n   * Given a partial document obtained from the transaction log (e.g. as a result of RTG), resolve to a full document\n   * by populating all the partial updates that were applied on top of that last full document update.\n   * \n   * @param onlyTheseFields When a non-null set of field names is passed in, the resolve process only attempts to populate\n   *        the given fields in this set. When this set is null, it resolves all fields.\n   * @return Returns the merged document, i.e. the resolved full document, or null if the document was not found (deleted\n   *          after the resolving began)\n   */\n  private static SolrDocument resolveFullDocument(SolrCore core, BytesRef idBytes,\n                                           ReturnFields returnFields, SolrInputDocument partialDoc, List logEntry, Set<String> onlyTheseFields) throws IOException {\n    if (idBytes == null || (logEntry.size() != 5 && logEntry.size() != 6)) {\n      throw new SolrException(ErrorCode.INVALID_STATE, \"Either Id field not present in partial document or log entry doesn't have previous version.\");\n    }\n    long prevPointer = (long) logEntry.get(UpdateLog.PREV_POINTER_IDX);\n    long prevVersion = (long) logEntry.get(UpdateLog.PREV_VERSION_IDX);\n\n    // get the last full document from ulog\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    long lastPrevPointer = ulog.applyPartialUpdates(idBytes, prevPointer, prevVersion, onlyTheseFields, partialDoc);\n\n    if (lastPrevPointer == -1) { // full document was not found in tlog, but exists in index\n      SolrDocument mergedDoc = mergePartialDocWithFullDocFromIndex(core, idBytes, returnFields, onlyTheseFields, partialDoc);\n      return mergedDoc;\n    } else if (lastPrevPointer > 0) {\n      // We were supposed to have found the last full doc also in the tlogs, but the prevPointer links led to nowhere\n      // We should reopen a new RT searcher and get the doc. This should be a rare occurrence\n      Term idTerm = new Term(core.getLatestSchema().getUniqueKeyField().getName(), idBytes);\n      SolrDocument mergedDoc = reopenRealtimeSearcherAndGet(core, idTerm, returnFields);\n      if (mergedDoc == null) {\n        return null; // the document may have been deleted as the resolving was going on.\n      }\n      return mergedDoc;\n    } else { // i.e. lastPrevPointer==0\n      assert lastPrevPointer == 0;\n      // We have successfully resolved the document based off the tlogs\n\n      // determine whether we can use the in place document, if the caller specified onlyTheseFields\n      // and those fields are all supported for in-place updates\n      IndexSchema schema = core.getLatestSchema();\n      boolean forInPlaceUpdate = onlyTheseFields != null\n          && onlyTheseFields.stream().map(schema::getField)\n          .allMatch(f -> null!=f && AtomicUpdateDocumentMerger.isSupportedFieldForInPlaceUpdate(f));\n\n      return toSolrDoc(partialDoc, schema, forInPlaceUpdate);\n    }\n  }\n\n","sourceOld":"  /***\n   * Given a partial document obtained from the transaction log (e.g. as a result of RTG), resolve to a full document\n   * by populating all the partial updates that were applied on top of that last full document update.\n   * \n   * @param onlyTheseFields When a non-null set of field names is passed in, the resolve process only attempts to populate\n   *        the given fields in this set. When this set is null, it resolves all fields.\n   * @return Returns the merged document, i.e. the resolved full document, or null if the document was not found (deleted\n   *          after the resolving began)\n   */\n  private static SolrDocument resolveFullDocument(SolrCore core, BytesRef idBytes,\n                                           ReturnFields returnFields, SolrInputDocument partialDoc, List logEntry, Set<String> onlyTheseFields) throws IOException {\n    if (idBytes == null || (logEntry.size() != 5 && logEntry.size() != 6)) {\n      throw new SolrException(ErrorCode.INVALID_STATE, \"Either Id field not present in partial document or log entry doesn't have previous version.\");\n    }\n    long prevPointer = (long) logEntry.get(UpdateLog.PREV_POINTER_IDX);\n    long prevVersion = (long) logEntry.get(UpdateLog.PREV_VERSION_IDX);\n\n    // get the last full document from ulog\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    long lastPrevPointer = ulog.applyPartialUpdates(idBytes, prevPointer, prevVersion, onlyTheseFields, partialDoc);\n\n    if (lastPrevPointer == -1) { // full document was not found in tlog, but exists in index\n      SolrDocument mergedDoc = mergePartialDocWithFullDocFromIndex(core, idBytes, returnFields, onlyTheseFields, partialDoc);\n      return mergedDoc;\n    } else if (lastPrevPointer > 0) {\n      // We were supposed to have found the last full doc also in the tlogs, but the prevPointer links led to nowhere\n      // We should reopen a new RT searcher and get the doc. This should be a rare occurrence\n      Term idTerm = new Term(core.getLatestSchema().getUniqueKeyField().getName(), idBytes);\n      SolrDocument mergedDoc = reopenRealtimeSearcherAndGet(core, idTerm, returnFields);\n      if (mergedDoc == null) {\n        return null; // the document may have been deleted as the resolving was going on.\n      }\n      return mergedDoc;\n    } else { // i.e. lastPrevPointer==0\n      assert lastPrevPointer == 0;\n      // We have successfully resolved the document based off the tlogs\n      return toSolrDoc(partialDoc, core.getLatestSchema());\n    }\n  }\n\n","bugFix":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8582f07e9350eaeb33bf6c4617b8c9895d99c839","date":1591307386,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#resolveFullDocument(SolrCore,BytesRef,ReturnFields,SolrInputDocument,List,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#resolveFullDocument(SolrCore,BytesRef,ReturnFields,SolrInputDocument,List,Set[String]).mjava","sourceNew":"  /***\n   * Given a partial document obtained from the transaction log (e.g. as a result of RTG), resolve to a full document\n   * by populating all the partial updates that were applied on top of that last full document update.\n   * \n   * @param onlyTheseFields When a non-null set of field names is passed in, the resolve process only attempts to populate\n   *        the given fields in this set. When this set is null, it resolves all fields.\n   * @return Returns the merged document, i.e. the resolved full document, or null if the document was not found (deleted\n   *          after the resolving began)\n   */\n  private static SolrDocument resolveFullDocument(SolrCore core, BytesRef idBytes,\n                                                  ReturnFields returnFields, SolrInputDocument partialDoc,\n                                                  @SuppressWarnings({\"rawtypes\"}) List logEntry,\n                                                  Set<String> onlyTheseFields) throws IOException {\n    if (idBytes == null || (logEntry.size() != 5 && logEntry.size() != 6)) {\n      throw new SolrException(ErrorCode.INVALID_STATE, \"Either Id field not present in partial document or log entry doesn't have previous version.\");\n    }\n    long prevPointer = (long) logEntry.get(UpdateLog.PREV_POINTER_IDX);\n    long prevVersion = (long) logEntry.get(UpdateLog.PREV_VERSION_IDX);\n\n    // get the last full document from ulog\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    long lastPrevPointer = ulog.applyPartialUpdates(idBytes, prevPointer, prevVersion, onlyTheseFields, partialDoc);\n\n    if (lastPrevPointer == -1) { // full document was not found in tlog, but exists in index\n      SolrDocument mergedDoc = mergePartialDocWithFullDocFromIndex(core, idBytes, returnFields, onlyTheseFields, partialDoc);\n      return mergedDoc;\n    } else if (lastPrevPointer > 0) {\n      // We were supposed to have found the last full doc also in the tlogs, but the prevPointer links led to nowhere\n      // We should reopen a new RT searcher and get the doc. This should be a rare occurrence\n      Term idTerm = new Term(core.getLatestSchema().getUniqueKeyField().getName(), idBytes);\n      SolrDocument mergedDoc = reopenRealtimeSearcherAndGet(core, idTerm, returnFields);\n      if (mergedDoc == null) {\n        return null; // the document may have been deleted as the resolving was going on.\n      }\n      return mergedDoc;\n    } else { // i.e. lastPrevPointer==0\n      assert lastPrevPointer == 0;\n      // We have successfully resolved the document based off the tlogs\n\n      // determine whether we can use the in place document, if the caller specified onlyTheseFields\n      // and those fields are all supported for in-place updates\n      IndexSchema schema = core.getLatestSchema();\n      boolean forInPlaceUpdate = onlyTheseFields != null\n          && onlyTheseFields.stream().map(schema::getField)\n          .allMatch(f -> null!=f && AtomicUpdateDocumentMerger.isSupportedFieldForInPlaceUpdate(f));\n\n      return toSolrDoc(partialDoc, schema, forInPlaceUpdate);\n    }\n  }\n\n","sourceOld":"  /***\n   * Given a partial document obtained from the transaction log (e.g. as a result of RTG), resolve to a full document\n   * by populating all the partial updates that were applied on top of that last full document update.\n   * \n   * @param onlyTheseFields When a non-null set of field names is passed in, the resolve process only attempts to populate\n   *        the given fields in this set. When this set is null, it resolves all fields.\n   * @return Returns the merged document, i.e. the resolved full document, or null if the document was not found (deleted\n   *          after the resolving began)\n   */\n  private static SolrDocument resolveFullDocument(SolrCore core, BytesRef idBytes,\n                                           ReturnFields returnFields, SolrInputDocument partialDoc, List logEntry, Set<String> onlyTheseFields) throws IOException {\n    if (idBytes == null || (logEntry.size() != 5 && logEntry.size() != 6)) {\n      throw new SolrException(ErrorCode.INVALID_STATE, \"Either Id field not present in partial document or log entry doesn't have previous version.\");\n    }\n    long prevPointer = (long) logEntry.get(UpdateLog.PREV_POINTER_IDX);\n    long prevVersion = (long) logEntry.get(UpdateLog.PREV_VERSION_IDX);\n\n    // get the last full document from ulog\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    long lastPrevPointer = ulog.applyPartialUpdates(idBytes, prevPointer, prevVersion, onlyTheseFields, partialDoc);\n\n    if (lastPrevPointer == -1) { // full document was not found in tlog, but exists in index\n      SolrDocument mergedDoc = mergePartialDocWithFullDocFromIndex(core, idBytes, returnFields, onlyTheseFields, partialDoc);\n      return mergedDoc;\n    } else if (lastPrevPointer > 0) {\n      // We were supposed to have found the last full doc also in the tlogs, but the prevPointer links led to nowhere\n      // We should reopen a new RT searcher and get the doc. This should be a rare occurrence\n      Term idTerm = new Term(core.getLatestSchema().getUniqueKeyField().getName(), idBytes);\n      SolrDocument mergedDoc = reopenRealtimeSearcherAndGet(core, idTerm, returnFields);\n      if (mergedDoc == null) {\n        return null; // the document may have been deleted as the resolving was going on.\n      }\n      return mergedDoc;\n    } else { // i.e. lastPrevPointer==0\n      assert lastPrevPointer == 0;\n      // We have successfully resolved the document based off the tlogs\n\n      // determine whether we can use the in place document, if the caller specified onlyTheseFields\n      // and those fields are all supported for in-place updates\n      IndexSchema schema = core.getLatestSchema();\n      boolean forInPlaceUpdate = onlyTheseFields != null\n          && onlyTheseFields.stream().map(schema::getField)\n          .allMatch(f -> null!=f && AtomicUpdateDocumentMerger.isSupportedFieldForInPlaceUpdate(f));\n\n      return toSolrDoc(partialDoc, schema, forInPlaceUpdate);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"17e1bfbfa5a260860e3f12522fca45ec1240752f":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"57273019d2938b9b30faae55f6983a2e71a56ec5":["17e1bfbfa5a260860e3f12522fca45ec1240752f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["57273019d2938b9b30faae55f6983a2e71a56ec5"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["17e1bfbfa5a260860e3f12522fca45ec1240752f","598b5d23aa7c9732bf473c21a9cd309c44599394"],"17e1bfbfa5a260860e3f12522fca45ec1240752f":["57273019d2938b9b30faae55f6983a2e71a56ec5"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"57273019d2938b9b30faae55f6983a2e71a56ec5":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}