{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","commits":[{"id":"265e2d0799e876e7c751a97229b0d8007cd79f0a","date":1461779668,"type":1,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector).mjava","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n        \n      this.testPointCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n        \n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n        \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n      \n      assert aboveAbove.length + aboveBelow.length + belowBelow.length + belowAbove.length == 1 : \"Can be exactly one inside point\";\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, travelInsidePlane, insideIntersection);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideIntersection);\n\n    }\n\n","sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.testPointCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n      // Now, find the intersection of the check and test point planes.\n      final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointPlane, testPointCutoffPlane, checkPointCutoffPlane);\n      assert intersectionPoints != null : \"couldn't find any intersections\";\n      assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n      this.intersectionPoint = intersectionPoints[0];\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n        \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n      \n      assert aboveAbove.length + aboveBelow.length + belowBelow.length + belowAbove.length == 1 : \"Can be exactly one inside point\";\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, travelInsidePlane, insideIntersection);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideIntersection);\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6cd16979cf4189e32503a21875df68249a568ce","date":1461791970,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n        \n      this.testPointCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, travelPlane, -(travelPlane.x * intersectionPoint.x + travelPlane.y * intersectionPoint.y + travelPlane.z * intersectionPoint.z));\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, testPointPlane, -(testPointPlane.x * intersectionPoint.x + testPointPlane.y * intersectionPoint.y + testPointPlane.z * intersectionPoint.z));\n        \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n      \n      assert aboveAbove.length + aboveBelow.length + belowBelow.length + belowAbove.length == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, travelInsidePlane, insideIntersection);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideIntersection);\n\n    }\n\n","sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n        \n      this.testPointCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n        \n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n        \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n      \n      assert aboveAbove.length + aboveBelow.length + belowBelow.length + belowAbove.length == 1 : \"Can be exactly one inside point\";\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, travelInsidePlane, insideIntersection);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideIntersection);\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d2af739bccba3be9b36de4d0bdb45f169c0156f","date":1461802146,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n        \n      this.testPointCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n\n      // Convert travel plane to a sided plane\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n      // Convert testPoint plane to a sided plane\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n        \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n\n      assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n\n    }\n\n","sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n        \n      this.testPointCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, travelPlane, -(travelPlane.x * intersectionPoint.x + travelPlane.y * intersectionPoint.y + travelPlane.z * intersectionPoint.z));\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, testPointPlane, -(testPointPlane.x * intersectionPoint.x + testPointPlane.y * intersectionPoint.y + testPointPlane.z * intersectionPoint.z));\n        \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n      \n      assert aboveAbove.length + aboveBelow.length + belowBelow.length + belowAbove.length == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, travelInsidePlane, insideIntersection);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideIntersection);\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e36ad3a30dae8fc4711af30a236d83d6aa57c0f","date":1461870588,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n\n      // Convert travel plane to a sided plane\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n      // Convert testPoint plane to a sided plane\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      \n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n\n      assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n\n    }\n\n","sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n        \n      this.testPointCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n\n      // Convert travel plane to a sided plane\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n      // Convert testPoint plane to a sided plane\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n        \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n\n      assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"414d7bcd2f513d7e7162dae022e9a9f3cd930277","date":1461885603,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n\n      // Convert travel plane to a sided plane\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n      // Convert testPoint plane to a sided plane\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      \n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n\n      assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n\n    }\n\n","sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n\n      // Convert travel plane to a sided plane\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n      // Convert testPoint plane to a sided plane\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      \n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n\n      assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","date":1461888019,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","pathOld":"/dev/null","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n\n      // Convert travel plane to a sided plane\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n      // Convert testPoint plane to a sided plane\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      \n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n\n      assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c20c411df9b9bd89e7a3327f5fa0d3c70610cfd9","date":1462223095,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n\n      // Convert travel plane to a sided plane\n      final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n      // Convert testPoint plane to a sided plane\n      final Membership intersectionBound2 = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n      assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      \n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n\n      assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n\n    }\n\n","sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n\n      // Convert travel plane to a sided plane\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n      // Convert testPoint plane to a sided plane\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      \n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointOtherCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n\n      assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","pathOld":"/dev/null","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n\n      // Convert travel plane to a sided plane\n      final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n      // Convert testPoint plane to a sided plane\n      final Membership intersectionBound2 = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n      assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      \n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n\n      assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91d2c9ef44982358af4ac4600d8ac04f914c3ce4","date":1462431879,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.testPointAbovePlane = testPointAbovePlane;\n      this.testPointBelowPlane = testPointBelowPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      \n    }\n\n","sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n\n      // Convert travel plane to a sided plane\n      final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n      // Convert testPoint plane to a sided plane\n      final Membership intersectionBound2 = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n      assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      \n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n\n      assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dc71a6ca063b508a28bf5b68fedf25a945572a0","date":1462433813,"type":5,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.testPointAbovePlane = testPointAbovePlane;\n      this.testPointBelowPlane = testPointBelowPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      \n    }\n\n","sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.testPointAbovePlane = testPointAbovePlane;\n      this.testPointBelowPlane = testPointBelowPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      \n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.testPointAbovePlane = testPointAbovePlane;\n      this.testPointBelowPlane = testPointBelowPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      \n    }\n\n","sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n\n      // Convert travel plane to a sided plane\n      final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n      // Convert testPoint plane to a sided plane\n      final Membership intersectionBound2 = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n      assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      \n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n\n      assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":4,"author":"Mike McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","sourceNew":null,"sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n\n      // Convert travel plane to a sided plane\n      final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n      // Convert testPoint plane to a sided plane\n      final Membership intersectionBound2 = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n      assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      \n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n\n      assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3dc71a6ca063b508a28bf5b68fedf25a945572a0":["91d2c9ef44982358af4ac4600d8ac04f914c3ce4"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["55b50463286869f584cf849d1587a0fcd54d1dfa","3dc71a6ca063b508a28bf5b68fedf25a945572a0"],"7d2af739bccba3be9b36de4d0bdb45f169c0156f":["a6cd16979cf4189e32503a21875df68249a568ce"],"c20c411df9b9bd89e7a3327f5fa0d3c70610cfd9":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c20c411df9b9bd89e7a3327f5fa0d3c70610cfd9"],"a6cd16979cf4189e32503a21875df68249a568ce":["265e2d0799e876e7c751a97229b0d8007cd79f0a"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["c20c411df9b9bd89e7a3327f5fa0d3c70610cfd9","3dc71a6ca063b508a28bf5b68fedf25a945572a0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"91d2c9ef44982358af4ac4600d8ac04f914c3ce4":["c20c411df9b9bd89e7a3327f5fa0d3c70610cfd9"],"265e2d0799e876e7c751a97229b0d8007cd79f0a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","414d7bcd2f513d7e7162dae022e9a9f3cd930277"],"414d7bcd2f513d7e7162dae022e9a9f3cd930277":["4e36ad3a30dae8fc4711af30a236d83d6aa57c0f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3dc71a6ca063b508a28bf5b68fedf25a945572a0"],"4e36ad3a30dae8fc4711af30a236d83d6aa57c0f":["7d2af739bccba3be9b36de4d0bdb45f169c0156f"]},"commit2Childs":{"3dc71a6ca063b508a28bf5b68fedf25a945572a0":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":[],"7d2af739bccba3be9b36de4d0bdb45f169c0156f":["4e36ad3a30dae8fc4711af30a236d83d6aa57c0f"],"c20c411df9b9bd89e7a3327f5fa0d3c70610cfd9":["55b50463286869f584cf849d1587a0fcd54d1dfa","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","91d2c9ef44982358af4ac4600d8ac04f914c3ce4"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["7dc08f02757dd10637b16a5c65eaaef839a91a9a"],"a6cd16979cf4189e32503a21875df68249a568ce":["7d2af739bccba3be9b36de4d0bdb45f169c0156f"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55b50463286869f584cf849d1587a0fcd54d1dfa","265e2d0799e876e7c751a97229b0d8007cd79f0a","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"91d2c9ef44982358af4ac4600d8ac04f914c3ce4":["3dc71a6ca063b508a28bf5b68fedf25a945572a0"],"265e2d0799e876e7c751a97229b0d8007cd79f0a":["a6cd16979cf4189e32503a21875df68249a568ce"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["c20c411df9b9bd89e7a3327f5fa0d3c70610cfd9"],"414d7bcd2f513d7e7162dae022e9a9f3cd930277":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"4e36ad3a30dae8fc4711af30a236d83d6aa57c0f":["414d7bcd2f513d7e7162dae022e9a9f3cd930277"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}