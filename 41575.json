{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoProjectionUtils#pointFromLonLatBearingVincenty(double,double,double,double,double[]).mjava","commits":[{"id":"937923083e4d137932336fc80f3d78758ff698a6","date":1454691519,"type":1,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoProjectionUtils#pointFromLonLatBearingVincenty(double,double,double,double,double[]).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/util/GeoProjectionUtils#pointFromLonLatBearingVincenty(double,double,double,double,double[]).mjava","sourceNew":"  /**\n   * Finds a point along a bearing from a given lon,lat geolocation using vincenty's distance formula\n   *\n   * @param lon origin longitude in degrees\n   * @param lat origin latitude in degrees\n   * @param bearing azimuthal bearing in degrees\n   * @param dist distance in meters\n   * @param pt resulting point\n   * @return the point along a bearing at a given distance in meters\n   */\n  public static final double[] pointFromLonLatBearingVincenty(double lon, double lat, double bearing, double dist, double[] pt) {\n\n    if (pt == null) {\n      pt = new double[2];\n    }\n\n    final double alpha1 = TO_RADIANS * bearing;\n    final double cosA1 = cos(alpha1);\n    final double sinA1 = sin(alpha1);\n    final double tanU1 = (1-FLATTENING) * tan(TO_RADIANS * lat);\n    final double cosU1 = 1 / StrictMath.sqrt((1+tanU1*tanU1));\n    final double sinU1 = tanU1*cosU1;\n    final double sig1 = StrictMath.atan2(tanU1, cosA1);\n    final double sinAlpha = cosU1 * sinA1;\n    final double cosSqAlpha = 1 - sinAlpha*sinAlpha;\n    final double uSq = cosSqAlpha * EP2;\n    final double A = 1 + uSq/16384D*(4096D + uSq * (-768D + uSq * (320D - 175D*uSq)));\n    final double B = uSq/1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));\n\n    double sigma = dist / (SEMIMINOR_AXIS*A);\n    double sigmaP;\n    double sinSigma, cosSigma, cos2SigmaM, deltaSigma;\n\n    do {\n      cos2SigmaM = cos(2*sig1 + sigma);\n      sinSigma = sin(sigma);\n      cosSigma = cos(sigma);\n\n      deltaSigma = B * sinSigma * (cos2SigmaM + (B/4D) * (cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-\n          (B/6) * cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));\n      sigmaP = sigma;\n      sigma = dist / (SEMIMINOR_AXIS*A) + deltaSigma;\n    } while (StrictMath.abs(sigma-sigmaP) > 1E-12);\n\n    final double tmp = sinU1*sinSigma - cosU1*cosSigma*cosA1;\n    final double lat2 = StrictMath.atan2(sinU1*cosSigma + cosU1*sinSigma*cosA1,\n        (1-FLATTENING) * StrictMath.sqrt(sinAlpha*sinAlpha + tmp*tmp));\n    final double lambda = StrictMath.atan2(sinSigma*sinA1, cosU1*cosSigma - sinU1*sinSigma*cosA1);\n    final double c = FLATTENING/16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));\n\n    final double lam = lambda - (1-c) * FLATTENING * sinAlpha *\n        (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2* cos2SigmaM*cos2SigmaM)));\n    pt[0] = normalizeLon(lon + TO_DEGREES * lam);\n    pt[1] = normalizeLat(TO_DEGREES * lat2);\n\n    return pt;\n  }\n\n","sourceOld":"  /**\n   * Finds a point along a bearing from a given lon,lat geolocation using vincenty's distance formula\n   *\n   * @param lon origin longitude in degrees\n   * @param lat origin latitude in degrees\n   * @param bearing azimuthal bearing in degrees\n   * @param dist distance in meters\n   * @param pt resulting point\n   * @return the point along a bearing at a given distance in meters\n   */\n  public static final double[] pointFromLonLatBearingVincenty(double lon, double lat, double bearing, double dist, double[] pt) {\n\n    if (pt == null) {\n      pt = new double[2];\n    }\n\n    final double alpha1 = TO_RADIANS * bearing;\n    final double cosA1 = SloppyMath.cos(alpha1);\n    final double sinA1 = SloppyMath.sin(alpha1);\n    final double tanU1 = (1-FLATTENING) * SloppyMath.tan(TO_RADIANS * lat);\n    final double cosU1 = 1 / StrictMath.sqrt((1+tanU1*tanU1));\n    final double sinU1 = tanU1*cosU1;\n    final double sig1 = StrictMath.atan2(tanU1, cosA1);\n    final double sinAlpha = cosU1 * sinA1;\n    final double cosSqAlpha = 1 - sinAlpha*sinAlpha;\n    final double uSq = cosSqAlpha * EP2;\n    final double A = 1 + uSq/16384D*(4096D + uSq * (-768D + uSq * (320D - 175D*uSq)));\n    final double B = uSq/1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));\n\n    double sigma = dist / (SEMIMINOR_AXIS*A);\n    double sigmaP;\n    double sinSigma, cosSigma, cos2SigmaM, deltaSigma;\n\n    do {\n      cos2SigmaM = SloppyMath.cos(2*sig1 + sigma);\n      sinSigma = SloppyMath.sin(sigma);\n      cosSigma = SloppyMath.cos(sigma);\n\n      deltaSigma = B * sinSigma * (cos2SigmaM + (B/4D) * (cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-\n          (B/6) * cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));\n      sigmaP = sigma;\n      sigma = dist / (SEMIMINOR_AXIS*A) + deltaSigma;\n    } while (StrictMath.abs(sigma-sigmaP) > 1E-12);\n\n    final double tmp = sinU1*sinSigma - cosU1*cosSigma*cosA1;\n    final double lat2 = StrictMath.atan2(sinU1*cosSigma + cosU1*sinSigma*cosA1,\n        (1-FLATTENING) * StrictMath.sqrt(sinAlpha*sinAlpha + tmp*tmp));\n    final double lambda = StrictMath.atan2(sinSigma*sinA1, cosU1*cosSigma - sinU1*sinSigma*cosA1);\n    final double c = FLATTENING/16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));\n\n    final double lam = lambda - (1-c) * FLATTENING * sinAlpha *\n        (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2* cos2SigmaM*cos2SigmaM)));\n    pt[0] = GeoUtils.normalizeLon(lon + TO_DEGREES * lam);\n    pt[1] = GeoUtils.normalizeLat(TO_DEGREES * lat2);\n\n    return pt;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":1,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoProjectionUtils#pointFromLonLatBearingVincenty(double,double,double,double,double[]).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/util/GeoProjectionUtils#pointFromLonLatBearingVincenty(double,double,double,double,double[]).mjava","sourceNew":"  /**\n   * Finds a point along a bearing from a given lon,lat geolocation using vincenty's distance formula\n   *\n   * @param lon origin longitude in degrees\n   * @param lat origin latitude in degrees\n   * @param bearing azimuthal bearing in degrees\n   * @param dist distance in meters\n   * @param pt resulting point\n   * @return the point along a bearing at a given distance in meters\n   */\n  public static final double[] pointFromLonLatBearingVincenty(double lon, double lat, double bearing, double dist, double[] pt) {\n\n    if (pt == null) {\n      pt = new double[2];\n    }\n\n    final double alpha1 = TO_RADIANS * bearing;\n    final double cosA1 = cos(alpha1);\n    final double sinA1 = sin(alpha1);\n    final double tanU1 = (1-FLATTENING) * tan(TO_RADIANS * lat);\n    final double cosU1 = 1 / StrictMath.sqrt((1+tanU1*tanU1));\n    final double sinU1 = tanU1*cosU1;\n    final double sig1 = StrictMath.atan2(tanU1, cosA1);\n    final double sinAlpha = cosU1 * sinA1;\n    final double cosSqAlpha = 1 - sinAlpha*sinAlpha;\n    final double uSq = cosSqAlpha * EP2;\n    final double A = 1 + uSq/16384D*(4096D + uSq * (-768D + uSq * (320D - 175D*uSq)));\n    final double B = uSq/1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));\n\n    double sigma = dist / (SEMIMINOR_AXIS*A);\n    double sigmaP;\n    double sinSigma, cosSigma, cos2SigmaM, deltaSigma;\n\n    do {\n      cos2SigmaM = cos(2*sig1 + sigma);\n      sinSigma = sin(sigma);\n      cosSigma = cos(sigma);\n\n      deltaSigma = B * sinSigma * (cos2SigmaM + (B/4D) * (cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-\n          (B/6) * cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));\n      sigmaP = sigma;\n      sigma = dist / (SEMIMINOR_AXIS*A) + deltaSigma;\n    } while (StrictMath.abs(sigma-sigmaP) > 1E-12);\n\n    final double tmp = sinU1*sinSigma - cosU1*cosSigma*cosA1;\n    final double lat2 = StrictMath.atan2(sinU1*cosSigma + cosU1*sinSigma*cosA1,\n        (1-FLATTENING) * StrictMath.sqrt(sinAlpha*sinAlpha + tmp*tmp));\n    final double lambda = StrictMath.atan2(sinSigma*sinA1, cosU1*cosSigma - sinU1*sinSigma*cosA1);\n    final double c = FLATTENING/16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));\n\n    final double lam = lambda - (1-c) * FLATTENING * sinAlpha *\n        (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2* cos2SigmaM*cos2SigmaM)));\n    pt[0] = normalizeLon(lon + TO_DEGREES * lam);\n    pt[1] = normalizeLat(TO_DEGREES * lat2);\n\n    return pt;\n  }\n\n","sourceOld":"  /**\n   * Finds a point along a bearing from a given lon,lat geolocation using vincenty's distance formula\n   *\n   * @param lon origin longitude in degrees\n   * @param lat origin latitude in degrees\n   * @param bearing azimuthal bearing in degrees\n   * @param dist distance in meters\n   * @param pt resulting point\n   * @return the point along a bearing at a given distance in meters\n   */\n  public static final double[] pointFromLonLatBearingVincenty(double lon, double lat, double bearing, double dist, double[] pt) {\n\n    if (pt == null) {\n      pt = new double[2];\n    }\n\n    final double alpha1 = TO_RADIANS * bearing;\n    final double cosA1 = SloppyMath.cos(alpha1);\n    final double sinA1 = SloppyMath.sin(alpha1);\n    final double tanU1 = (1-FLATTENING) * SloppyMath.tan(TO_RADIANS * lat);\n    final double cosU1 = 1 / StrictMath.sqrt((1+tanU1*tanU1));\n    final double sinU1 = tanU1*cosU1;\n    final double sig1 = StrictMath.atan2(tanU1, cosA1);\n    final double sinAlpha = cosU1 * sinA1;\n    final double cosSqAlpha = 1 - sinAlpha*sinAlpha;\n    final double uSq = cosSqAlpha * EP2;\n    final double A = 1 + uSq/16384D*(4096D + uSq * (-768D + uSq * (320D - 175D*uSq)));\n    final double B = uSq/1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));\n\n    double sigma = dist / (SEMIMINOR_AXIS*A);\n    double sigmaP;\n    double sinSigma, cosSigma, cos2SigmaM, deltaSigma;\n\n    do {\n      cos2SigmaM = SloppyMath.cos(2*sig1 + sigma);\n      sinSigma = SloppyMath.sin(sigma);\n      cosSigma = SloppyMath.cos(sigma);\n\n      deltaSigma = B * sinSigma * (cos2SigmaM + (B/4D) * (cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-\n          (B/6) * cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));\n      sigmaP = sigma;\n      sigma = dist / (SEMIMINOR_AXIS*A) + deltaSigma;\n    } while (StrictMath.abs(sigma-sigmaP) > 1E-12);\n\n    final double tmp = sinU1*sinSigma - cosU1*cosSigma*cosA1;\n    final double lat2 = StrictMath.atan2(sinU1*cosSigma + cosU1*sinSigma*cosA1,\n        (1-FLATTENING) * StrictMath.sqrt(sinAlpha*sinAlpha + tmp*tmp));\n    final double lambda = StrictMath.atan2(sinSigma*sinA1, cosU1*cosSigma - sinU1*sinSigma*cosA1);\n    final double c = FLATTENING/16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));\n\n    final double lam = lambda - (1-c) * FLATTENING * sinAlpha *\n        (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2* cos2SigmaM*cos2SigmaM)));\n    pt[0] = GeoUtils.normalizeLon(lon + TO_DEGREES * lam);\n    pt[1] = GeoUtils.normalizeLat(TO_DEGREES * lat2);\n\n    return pt;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec60431d008a694828dacb4bc3cda775b6c44a9f","date":1458570843,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoProjectionUtils#pointFromLonLatBearingVincenty(double,double,double,double,double[]).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoProjectionUtils#pointFromLonLatBearingVincenty(double,double,double,double,double[]).mjava","sourceNew":"  /**\n   * Finds a point along a bearing from a given lon,lat geolocation using vincenty's distance formula\n   *\n   * @param lon origin longitude in degrees\n   * @param lat origin latitude in degrees\n   * @param bearing azimuthal bearing in degrees\n   * @param dist distance in meters\n   * @param pt resulting point\n   * @return the point along a bearing at a given distance in meters\n   */\n  public static final double[] pointFromLonLatBearingVincenty(double lon, double lat, double bearing, double dist, double[] pt) {\n\n    if (pt == null) {\n      pt = new double[2];\n    }\n\n    final double alpha1 = TO_RADIANS * bearing;\n    final double cosA1 = cos(alpha1);\n    final double sinA1 = sloppySin(alpha1);\n    final double tanU1 = (1-FLATTENING) * sloppyTan(TO_RADIANS * lat);\n    final double cosU1 = 1 / StrictMath.sqrt((1+tanU1*tanU1));\n    final double sinU1 = tanU1*cosU1;\n    final double sig1 = StrictMath.atan2(tanU1, cosA1);\n    final double sinAlpha = cosU1 * sinA1;\n    final double cosSqAlpha = 1 - sinAlpha*sinAlpha;\n    final double uSq = cosSqAlpha * EP2;\n    final double A = 1 + uSq/16384D*(4096D + uSq * (-768D + uSq * (320D - 175D*uSq)));\n    final double B = uSq/1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));\n\n    double sigma = dist / (SEMIMINOR_AXIS*A);\n    double sigmaP;\n    double sinSigma, cosSigma, cos2SigmaM, deltaSigma;\n\n    do {\n      cos2SigmaM = cos(2*sig1 + sigma);\n      sinSigma = sloppySin(sigma);\n      cosSigma = cos(sigma);\n\n      deltaSigma = B * sinSigma * (cos2SigmaM + (B/4D) * (cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-\n          (B/6) * cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));\n      sigmaP = sigma;\n      sigma = dist / (SEMIMINOR_AXIS*A) + deltaSigma;\n    } while (StrictMath.abs(sigma-sigmaP) > 1E-12);\n\n    final double tmp = sinU1*sinSigma - cosU1*cosSigma*cosA1;\n    final double lat2 = StrictMath.atan2(sinU1*cosSigma + cosU1*sinSigma*cosA1,\n        (1-FLATTENING) * StrictMath.sqrt(sinAlpha*sinAlpha + tmp*tmp));\n    final double lambda = StrictMath.atan2(sinSigma*sinA1, cosU1*cosSigma - sinU1*sinSigma*cosA1);\n    final double c = FLATTENING/16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));\n\n    final double lam = lambda - (1-c) * FLATTENING * sinAlpha *\n        (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2* cos2SigmaM*cos2SigmaM)));\n    pt[0] = normalizeLon(lon + TO_DEGREES * lam);\n    pt[1] = normalizeLat(TO_DEGREES * lat2);\n\n    return pt;\n  }\n\n","sourceOld":"  /**\n   * Finds a point along a bearing from a given lon,lat geolocation using vincenty's distance formula\n   *\n   * @param lon origin longitude in degrees\n   * @param lat origin latitude in degrees\n   * @param bearing azimuthal bearing in degrees\n   * @param dist distance in meters\n   * @param pt resulting point\n   * @return the point along a bearing at a given distance in meters\n   */\n  public static final double[] pointFromLonLatBearingVincenty(double lon, double lat, double bearing, double dist, double[] pt) {\n\n    if (pt == null) {\n      pt = new double[2];\n    }\n\n    final double alpha1 = TO_RADIANS * bearing;\n    final double cosA1 = cos(alpha1);\n    final double sinA1 = sin(alpha1);\n    final double tanU1 = (1-FLATTENING) * tan(TO_RADIANS * lat);\n    final double cosU1 = 1 / StrictMath.sqrt((1+tanU1*tanU1));\n    final double sinU1 = tanU1*cosU1;\n    final double sig1 = StrictMath.atan2(tanU1, cosA1);\n    final double sinAlpha = cosU1 * sinA1;\n    final double cosSqAlpha = 1 - sinAlpha*sinAlpha;\n    final double uSq = cosSqAlpha * EP2;\n    final double A = 1 + uSq/16384D*(4096D + uSq * (-768D + uSq * (320D - 175D*uSq)));\n    final double B = uSq/1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));\n\n    double sigma = dist / (SEMIMINOR_AXIS*A);\n    double sigmaP;\n    double sinSigma, cosSigma, cos2SigmaM, deltaSigma;\n\n    do {\n      cos2SigmaM = cos(2*sig1 + sigma);\n      sinSigma = sin(sigma);\n      cosSigma = cos(sigma);\n\n      deltaSigma = B * sinSigma * (cos2SigmaM + (B/4D) * (cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-\n          (B/6) * cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));\n      sigmaP = sigma;\n      sigma = dist / (SEMIMINOR_AXIS*A) + deltaSigma;\n    } while (StrictMath.abs(sigma-sigmaP) > 1E-12);\n\n    final double tmp = sinU1*sinSigma - cosU1*cosSigma*cosA1;\n    final double lat2 = StrictMath.atan2(sinU1*cosSigma + cosU1*sinSigma*cosA1,\n        (1-FLATTENING) * StrictMath.sqrt(sinAlpha*sinAlpha + tmp*tmp));\n    final double lambda = StrictMath.atan2(sinSigma*sinA1, cosU1*cosSigma - sinU1*sinSigma*cosA1);\n    final double c = FLATTENING/16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));\n\n    final double lam = lambda - (1-c) * FLATTENING * sinAlpha *\n        (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2* cos2SigmaM*cos2SigmaM)));\n    pt[0] = normalizeLon(lon + TO_DEGREES * lam);\n    pt[1] = normalizeLat(TO_DEGREES * lat2);\n\n    return pt;\n  }\n\n","bugFix":["937923083e4d137932336fc80f3d78758ff698a6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec996bf2daff09d61a876319e8fae4aebbea58e3","date":1458661946,"type":4,"author":"Mike McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoProjectionUtils#pointFromLonLatBearingVincenty(double,double,double,double,double[]).mjava","sourceNew":null,"sourceOld":"  /**\n   * Finds a point along a bearing from a given lon,lat geolocation using vincenty's distance formula\n   *\n   * @param lon origin longitude in degrees\n   * @param lat origin latitude in degrees\n   * @param bearing azimuthal bearing in degrees\n   * @param dist distance in meters\n   * @param pt resulting point\n   * @return the point along a bearing at a given distance in meters\n   */\n  public static final double[] pointFromLonLatBearingVincenty(double lon, double lat, double bearing, double dist, double[] pt) {\n\n    if (pt == null) {\n      pt = new double[2];\n    }\n\n    final double alpha1 = TO_RADIANS * bearing;\n    final double cosA1 = cos(alpha1);\n    final double sinA1 = sloppySin(alpha1);\n    final double tanU1 = (1-FLATTENING) * sloppyTan(TO_RADIANS * lat);\n    final double cosU1 = 1 / StrictMath.sqrt((1+tanU1*tanU1));\n    final double sinU1 = tanU1*cosU1;\n    final double sig1 = StrictMath.atan2(tanU1, cosA1);\n    final double sinAlpha = cosU1 * sinA1;\n    final double cosSqAlpha = 1 - sinAlpha*sinAlpha;\n    final double uSq = cosSqAlpha * EP2;\n    final double A = 1 + uSq/16384D*(4096D + uSq * (-768D + uSq * (320D - 175D*uSq)));\n    final double B = uSq/1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));\n\n    double sigma = dist / (SEMIMINOR_AXIS*A);\n    double sigmaP;\n    double sinSigma, cosSigma, cos2SigmaM, deltaSigma;\n\n    do {\n      cos2SigmaM = cos(2*sig1 + sigma);\n      sinSigma = sloppySin(sigma);\n      cosSigma = cos(sigma);\n\n      deltaSigma = B * sinSigma * (cos2SigmaM + (B/4D) * (cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-\n          (B/6) * cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));\n      sigmaP = sigma;\n      sigma = dist / (SEMIMINOR_AXIS*A) + deltaSigma;\n    } while (StrictMath.abs(sigma-sigmaP) > 1E-12);\n\n    final double tmp = sinU1*sinSigma - cosU1*cosSigma*cosA1;\n    final double lat2 = StrictMath.atan2(sinU1*cosSigma + cosU1*sinSigma*cosA1,\n        (1-FLATTENING) * StrictMath.sqrt(sinAlpha*sinAlpha + tmp*tmp));\n    final double lambda = StrictMath.atan2(sinSigma*sinA1, cosU1*cosSigma - sinU1*sinSigma*cosA1);\n    final double c = FLATTENING/16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));\n\n    final double lam = lambda - (1-c) * FLATTENING * sinAlpha *\n        (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2* cos2SigmaM*cos2SigmaM)));\n    pt[0] = normalizeLon(lon + TO_DEGREES * lam);\n    pt[1] = normalizeLat(TO_DEGREES * lat2);\n\n    return pt;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ec60431d008a694828dacb4bc3cda775b6c44a9f":["937923083e4d137932336fc80f3d78758ff698a6"],"ec996bf2daff09d61a876319e8fae4aebbea58e3":["ec60431d008a694828dacb4bc3cda775b6c44a9f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","937923083e4d137932336fc80f3d78758ff698a6"],"937923083e4d137932336fc80f3d78758ff698a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ec996bf2daff09d61a876319e8fae4aebbea58e3"]},"commit2Childs":{"ec60431d008a694828dacb4bc3cda775b6c44a9f":["ec996bf2daff09d61a876319e8fae4aebbea58e3"],"ec996bf2daff09d61a876319e8fae4aebbea58e3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","937923083e4d137932336fc80f3d78758ff698a6"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"937923083e4d137932336fc80f3d78758ff698a6":["ec60431d008a694828dacb4bc3cda775b6c44a9f","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}