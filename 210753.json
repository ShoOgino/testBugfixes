{"path":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","commits":[{"id":"2c705a0d590cf911e7c942df49563ca2ea176e22","date":1526916174,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testSimpleSKG() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // using relatedness() as a top level stat, not nested under any facet\n    // (not particularly useful, but shouldn't error either)\n    assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                 \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                 \"json.facet\", \" { skg: 'relatedness($fore,$back)' }\")\n             , \"facets=={\"\n             + \"   count:5, \"\n             + \"   skg : { relatedness: 0.00699,\"\n             + \"           foreground_popularity: 0.33333,\"\n             + \"           background_popularity: 0.83333,\"\n             + \"   } }\"\n             );\n    \n    // simple single level facet w/skg stat & sorting\n    for (String sort : Arrays.asList(\"index asc\", \"skg desc\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order\n      // so both of these sort options should produce identical output\n      // and testinging \"index\" sort allows the randomized use of \"stream\" processor as default to be tested\n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', sort: '\"+sort+\"', \"\n                   + \"      facet: { skg: 'relatedness($fore,$back)' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'A', count:2, \"\n               + \"     skg : { relatedness: 0.00554, \"\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 2, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.33333, },\"\n               + \"   }, \"\n               + \"   { val:'B', count:3, \"\n               + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   } ] } } \"\n               );\n    }\n    \n    // SKG used in multiple nested facets\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams nestedSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[-1000 TO 0]\", \"back\", \"*:*\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: 'relatedness($fore,$back)', \"\n       + \"               y:   { type: terms, field: 'where_s', sort: 'skg desc', \"\n       + \"                      facet: { skg: 'relatedness($fore,$back)' } } } } }\");\n       \n    // plain old request\n    assertJQ(req(nestedSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: 0.01539, \"\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 6, \"\n             + \"             foreground_popularity: 0.33333,\"\n             + \"             background_popularity: 0.5 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.00554, \" \n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:-0.01097, \"\n             //+ \"             foreground_count: 0, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 2, \"\n             //+ \"             background_size: 6,\"\n             + \"             foreground_popularity: 0.0,\"\n             + \"             background_popularity: 0.33333 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes\n    assertJQ(req(nestedSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\", \"shards.purpose\", \"2097216\")\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 6 }, \"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 0, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 2, \"\n             + \"             background_size: 6 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c5ec3c464e62e57df598ba20e010313bf6d5d7b4","c05b634713ca09b2267477408773904d4c69dd9d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c05b634713ca09b2267477408773904d4c69dd9d","date":1530894845,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","sourceNew":"  @Test\n  public void testSimpleSKG() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // using relatedness() as a top level stat, not nested under any facet\n    // (not particularly useful, but shouldn't error either)\n    assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                 \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                 \"json.facet\", \" { skg: 'relatedness($fore,$back)' }\")\n             , \"facets=={\"\n             + \"   count:5, \"\n             + \"   skg : { relatedness: 0.00699,\"\n             + \"           foreground_popularity: 0.33333,\"\n             + \"           background_popularity: 0.83333,\"\n             + \"   } }\"\n             );\n    \n    // simple single level facet w/skg stat & sorting\n    for (String sort : Arrays.asList(\"index asc\", \"skg desc\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order\n      // so both of these sort options should produce identical output\n      // and testinging \"index\" sort allows the randomized use of \"stream\" processor as default to be tested\n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', sort: '\"+sort+\"', \"\n                   + \"      facet: { skg: 'relatedness($fore,$back)' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'A', count:2, \"\n               + \"     skg : { relatedness: 0.00554, \"\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 2, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.33333, },\"\n               + \"   }, \"\n               + \"   { val:'B', count:3, \"\n               + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   } ] } } \"\n               );\n    }\n    \n    // SKG used in multiple nested facets\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams nestedSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[-1000 TO 0]\", \"back\", \"*:*\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: 'relatedness($fore,$back)', \"\n       + \"               y:   { type: terms, field: 'where_s', sort: 'skg desc', \"\n       + \"                      facet: { skg: 'relatedness($fore,$back)' } } } } }\");\n       \n    // plain old request\n    assertJQ(req(nestedSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: 0.01539, \"\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 6, \"\n             + \"             foreground_popularity: 0.33333,\"\n             + \"             background_popularity: 0.5 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.00554, \" \n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:-0.01097, \"\n             //+ \"             foreground_count: 0, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 2, \"\n             //+ \"             background_size: 6,\"\n             + \"             foreground_popularity: 0.0,\"\n             + \"             background_popularity: 0.33333 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes\n    assertJQ(req(nestedSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 6 }, \"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 0, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 2, \"\n             + \"             background_size: 6 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n    \n  }\n\n","sourceOld":"  @Test\n  public void testSimpleSKG() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // using relatedness() as a top level stat, not nested under any facet\n    // (not particularly useful, but shouldn't error either)\n    assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                 \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                 \"json.facet\", \" { skg: 'relatedness($fore,$back)' }\")\n             , \"facets=={\"\n             + \"   count:5, \"\n             + \"   skg : { relatedness: 0.00699,\"\n             + \"           foreground_popularity: 0.33333,\"\n             + \"           background_popularity: 0.83333,\"\n             + \"   } }\"\n             );\n    \n    // simple single level facet w/skg stat & sorting\n    for (String sort : Arrays.asList(\"index asc\", \"skg desc\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order\n      // so both of these sort options should produce identical output\n      // and testinging \"index\" sort allows the randomized use of \"stream\" processor as default to be tested\n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', sort: '\"+sort+\"', \"\n                   + \"      facet: { skg: 'relatedness($fore,$back)' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'A', count:2, \"\n               + \"     skg : { relatedness: 0.00554, \"\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 2, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.33333, },\"\n               + \"   }, \"\n               + \"   { val:'B', count:3, \"\n               + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   } ] } } \"\n               );\n    }\n    \n    // SKG used in multiple nested facets\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams nestedSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[-1000 TO 0]\", \"back\", \"*:*\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: 'relatedness($fore,$back)', \"\n       + \"               y:   { type: terms, field: 'where_s', sort: 'skg desc', \"\n       + \"                      facet: { skg: 'relatedness($fore,$back)' } } } } }\");\n       \n    // plain old request\n    assertJQ(req(nestedSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: 0.01539, \"\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 6, \"\n             + \"             foreground_popularity: 0.33333,\"\n             + \"             background_popularity: 0.5 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.00554, \" \n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:-0.01097, \"\n             //+ \"             foreground_count: 0, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 2, \"\n             //+ \"             background_size: 6,\"\n             + \"             foreground_popularity: 0.0,\"\n             + \"             background_popularity: 0.33333 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes\n    assertJQ(req(nestedSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\", \"shards.purpose\", \"2097216\")\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 6 }, \"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 0, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 2, \"\n             + \"             background_size: 6 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n    \n  }\n\n","bugFix":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","sourceNew":"  @Test\n  public void testSimpleSKG() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // using relatedness() as a top level stat, not nested under any facet\n    // (not particularly useful, but shouldn't error either)\n    assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                 \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                 \"json.facet\", \" { skg: 'relatedness($fore,$back)' }\")\n             , \"facets=={\"\n             + \"   count:5, \"\n             + \"   skg : { relatedness: 0.00699,\"\n             + \"           foreground_popularity: 0.33333,\"\n             + \"           background_popularity: 0.83333,\"\n             + \"   } }\"\n             );\n    \n    // simple single level facet w/skg stat & sorting\n    for (String sort : Arrays.asList(\"index asc\", \"skg desc\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order\n      // so both of these sort options should produce identical output\n      // and testinging \"index\" sort allows the randomized use of \"stream\" processor as default to be tested\n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', sort: '\"+sort+\"', \"\n                   + \"      facet: { skg: 'relatedness($fore,$back)' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'A', count:2, \"\n               + \"     skg : { relatedness: 0.00554, \"\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 2, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.33333, },\"\n               + \"   }, \"\n               + \"   { val:'B', count:3, \"\n               + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   } ] } } \"\n               );\n    }\n    \n    // SKG used in multiple nested facets\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams nestedSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[-1000 TO 0]\", \"back\", \"*:*\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: 'relatedness($fore,$back)', \"\n       + \"               y:   { type: terms, field: 'where_s', sort: 'skg desc', \"\n       + \"                      facet: { skg: 'relatedness($fore,$back)' } } } } }\");\n       \n    // plain old request\n    assertJQ(req(nestedSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: 0.01539, \"\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 6, \"\n             + \"             foreground_popularity: 0.33333,\"\n             + \"             background_popularity: 0.5 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.00554, \" \n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:-0.01097, \"\n             //+ \"             foreground_count: 0, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 2, \"\n             //+ \"             background_size: 6,\"\n             + \"             foreground_popularity: 0.0,\"\n             + \"             background_popularity: 0.33333 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes\n    assertJQ(req(nestedSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 6 }, \"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 0, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 2, \"\n             + \"             background_size: 6 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n    \n  }\n\n","sourceOld":"  @Test\n  public void testSimpleSKG() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // using relatedness() as a top level stat, not nested under any facet\n    // (not particularly useful, but shouldn't error either)\n    assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                 \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                 \"json.facet\", \" { skg: 'relatedness($fore,$back)' }\")\n             , \"facets=={\"\n             + \"   count:5, \"\n             + \"   skg : { relatedness: 0.00699,\"\n             + \"           foreground_popularity: 0.33333,\"\n             + \"           background_popularity: 0.83333,\"\n             + \"   } }\"\n             );\n    \n    // simple single level facet w/skg stat & sorting\n    for (String sort : Arrays.asList(\"index asc\", \"skg desc\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order\n      // so both of these sort options should produce identical output\n      // and testinging \"index\" sort allows the randomized use of \"stream\" processor as default to be tested\n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', sort: '\"+sort+\"', \"\n                   + \"      facet: { skg: 'relatedness($fore,$back)' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'A', count:2, \"\n               + \"     skg : { relatedness: 0.00554, \"\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 2, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.33333, },\"\n               + \"   }, \"\n               + \"   { val:'B', count:3, \"\n               + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   } ] } } \"\n               );\n    }\n    \n    // SKG used in multiple nested facets\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams nestedSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[-1000 TO 0]\", \"back\", \"*:*\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: 'relatedness($fore,$back)', \"\n       + \"               y:   { type: terms, field: 'where_s', sort: 'skg desc', \"\n       + \"                      facet: { skg: 'relatedness($fore,$back)' } } } } }\");\n       \n    // plain old request\n    assertJQ(req(nestedSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: 0.01539, \"\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 6, \"\n             + \"             foreground_popularity: 0.33333,\"\n             + \"             background_popularity: 0.5 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.00554, \" \n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:-0.01097, \"\n             //+ \"             foreground_count: 0, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 2, \"\n             //+ \"             background_size: 6,\"\n             + \"             foreground_popularity: 0.0,\"\n             + \"             background_popularity: 0.33333 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes\n    assertJQ(req(nestedSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\", \"shards.purpose\", \"2097216\")\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 6 }, \"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 0, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 2, \"\n             + \"             background_size: 6 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","sourceNew":"  @Test\n  public void testSimpleSKG() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // using relatedness() as a top level stat, not nested under any facet\n    // (not particularly useful, but shouldn't error either)\n    assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                 \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                 \"json.facet\", \" { skg: 'relatedness($fore,$back)' }\")\n             , \"facets=={\"\n             + \"   count:5, \"\n             + \"   skg : { relatedness: 0.00699,\"\n             + \"           foreground_popularity: 0.33333,\"\n             + \"           background_popularity: 0.83333,\"\n             + \"   } }\"\n             );\n    \n    // simple single level facet w/skg stat & sorting\n    for (String sort : Arrays.asList(\"index asc\", \"skg desc\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order\n      // so both of these sort options should produce identical output\n      // and testinging \"index\" sort allows the randomized use of \"stream\" processor as default to be tested\n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', sort: '\"+sort+\"', \"\n                   + \"      facet: { skg: 'relatedness($fore,$back)' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'A', count:2, \"\n               + \"     skg : { relatedness: 0.00554, \"\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 2, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.33333, },\"\n               + \"   }, \"\n               + \"   { val:'B', count:3, \"\n               + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   } ] } } \"\n               );\n    }\n    \n    // SKG used in multiple nested facets\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams nestedSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[-1000 TO 0]\", \"back\", \"*:*\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: 'relatedness($fore,$back)', \"\n       + \"               y:   { type: terms, field: 'where_s', sort: 'skg desc', \"\n       + \"                      facet: { skg: 'relatedness($fore,$back)' } } } } }\");\n       \n    // plain old request\n    assertJQ(req(nestedSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: 0.01539, \"\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 6, \"\n             + \"             foreground_popularity: 0.33333,\"\n             + \"             background_popularity: 0.5 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.00554, \" \n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:-0.01097, \"\n             //+ \"             foreground_count: 0, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 2, \"\n             //+ \"             background_size: 6,\"\n             + \"             foreground_popularity: 0.0,\"\n             + \"             background_popularity: 0.33333 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes\n    assertJQ(req(nestedSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 6 }, \"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 0, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 2, \"\n             + \"             background_size: 6 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n    \n  }\n\n","sourceOld":"  @Test\n  public void testSimpleSKG() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // using relatedness() as a top level stat, not nested under any facet\n    // (not particularly useful, but shouldn't error either)\n    assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                 \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                 \"json.facet\", \" { skg: 'relatedness($fore,$back)' }\")\n             , \"facets=={\"\n             + \"   count:5, \"\n             + \"   skg : { relatedness: 0.00699,\"\n             + \"           foreground_popularity: 0.33333,\"\n             + \"           background_popularity: 0.83333,\"\n             + \"   } }\"\n             );\n    \n    // simple single level facet w/skg stat & sorting\n    for (String sort : Arrays.asList(\"index asc\", \"skg desc\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order\n      // so both of these sort options should produce identical output\n      // and testinging \"index\" sort allows the randomized use of \"stream\" processor as default to be tested\n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', sort: '\"+sort+\"', \"\n                   + \"      facet: { skg: 'relatedness($fore,$back)' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'A', count:2, \"\n               + \"     skg : { relatedness: 0.00554, \"\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 2, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.33333, },\"\n               + \"   }, \"\n               + \"   { val:'B', count:3, \"\n               + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   } ] } } \"\n               );\n    }\n    \n    // SKG used in multiple nested facets\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams nestedSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[-1000 TO 0]\", \"back\", \"*:*\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: 'relatedness($fore,$back)', \"\n       + \"               y:   { type: terms, field: 'where_s', sort: 'skg desc', \"\n       + \"                      facet: { skg: 'relatedness($fore,$back)' } } } } }\");\n       \n    // plain old request\n    assertJQ(req(nestedSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: 0.01539, \"\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 6, \"\n             + \"             foreground_popularity: 0.33333,\"\n             + \"             background_popularity: 0.5 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.00554, \" \n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:-0.01097, \"\n             //+ \"             foreground_count: 0, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 2, \"\n             //+ \"             background_size: 6,\"\n             + \"             foreground_popularity: 0.0,\"\n             + \"             background_popularity: 0.33333 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes\n    assertJQ(req(nestedSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\", \"shards.purpose\", \"2097216\")\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 6 }, \"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 0, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 2, \"\n             + \"             background_size: 6 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"42009f1fefcc8f4d9e07b158e9415cbd6ca7247c","date":1532538390,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","sourceNew":"  @Test\n  public void testSimpleSKG() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // using relatedness() as a top level stat, not nested under any facet\n    // (not particularly useful, but shouldn't error either)\n    assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                 \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                 \"json.facet\", \" { skg: 'relatedness($fore,$back)' }\")\n             , \"facets=={\"\n             + \"   count:5, \"\n             + \"   skg : { relatedness: 0.00699,\"\n             + \"           foreground_popularity: 0.33333,\"\n             + \"           background_popularity: 0.83333,\"\n             + \"   } }\"\n             );\n    \n    // simple single level facet w/skg stat & sorting\n    for (String sort : Arrays.asList(\"index asc\", \"skg desc\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order\n      // so both of these sort options should produce identical output\n      // and testinging \"index\" sort allows the randomized use of \"stream\" processor as default to be tested\n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', sort: '\"+sort+\"', \"\n                   + \"      facet: { skg: 'relatedness($fore,$back)' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'A', count:2, \"\n               + \"     skg : { relatedness: 0.00554, \"\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 2, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.33333, },\"\n               + \"   }, \"\n               + \"   { val:'B', count:3, \"\n               + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   } ] } } \"\n               );\n    }\n    \n    // SKG used in multiple nested facets\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams nestedSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[-1000 TO 0]\", \"back\", \"*:*\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: 'relatedness($fore,$back)', \"\n       + \"               y:   { type: terms, field: 'where_s', sort: 'skg desc', \"\n       + \"                      facet: { skg: 'relatedness($fore,$back)' } } } } }\");\n       \n    // plain old request\n    assertJQ(req(nestedSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: 0.01539, \"\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 6, \"\n             + \"             foreground_popularity: 0.33333,\"\n             + \"             background_popularity: 0.5 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.00554, \" \n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:-0.01097, \"\n             //+ \"             foreground_count: 0, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 2, \"\n             //+ \"             background_size: 6,\"\n             + \"             foreground_popularity: 0.0,\"\n             + \"             background_popularity: 0.33333 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes\n    assertJQ(req(nestedSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 6 }, \"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 0, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 2, \"\n             + \"             background_size: 6 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    \n    // SKG w/min_pop (NOTE: incredibly contrived and not-useful fore/back for testing min_pop w/shard sorting)\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams minPopSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[0 TO 1000]\", \"back\", \"cat_s:B\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: { type:func, func:'relatedness($fore,$back)', \"\n       + \"                      min_popularity: 0.001 }\" \n       + \"             } } }\");\n\n    // plain old request\n    assertJQ(req(minPopSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: -1.0, \"\n             //+ \"             foreground_count: 1, \"\n             //+ \"             foreground_size: 3, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 3, \"\n             + \"             foreground_popularity: 0.33333,\" \n             + \"             background_popularity: 1.0,\" \n             + \"   } }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:'-Infinity', \" // bg_pop is below min_pop (otherwise 1.0)\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 3, \"\n             //+ \"             background_count: 0, \"\n             //+ \"             background_size: 3, \"\n             + \"             foreground_popularity: 0.66667,\"\n             + \"             background_popularity: 0.0,\"\n             + \"   } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes and that per-shard sorting doesn't pre-emptively sort \"A\" to the bottom\n    assertJQ(req(minPopSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 3, \"\n             + \"             background_count: 0, \"\n             + \"             background_size: 3, \"\n             + \"   } }, \"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 1, \"\n             + \"             foreground_size: 3, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 3, \"\n             + \"   } } ] } }\");\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleSKG() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // using relatedness() as a top level stat, not nested under any facet\n    // (not particularly useful, but shouldn't error either)\n    assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                 \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                 \"json.facet\", \" { skg: 'relatedness($fore,$back)' }\")\n             , \"facets=={\"\n             + \"   count:5, \"\n             + \"   skg : { relatedness: 0.00699,\"\n             + \"           foreground_popularity: 0.33333,\"\n             + \"           background_popularity: 0.83333,\"\n             + \"   } }\"\n             );\n    \n    // simple single level facet w/skg stat & sorting\n    for (String sort : Arrays.asList(\"index asc\", \"skg desc\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order\n      // so both of these sort options should produce identical output\n      // and testinging \"index\" sort allows the randomized use of \"stream\" processor as default to be tested\n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', sort: '\"+sort+\"', \"\n                   + \"      facet: { skg: 'relatedness($fore,$back)' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'A', count:2, \"\n               + \"     skg : { relatedness: 0.00554, \"\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 2, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.33333, },\"\n               + \"   }, \"\n               + \"   { val:'B', count:3, \"\n               + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   } ] } } \"\n               );\n    }\n    \n    // SKG used in multiple nested facets\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams nestedSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[-1000 TO 0]\", \"back\", \"*:*\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: 'relatedness($fore,$back)', \"\n       + \"               y:   { type: terms, field: 'where_s', sort: 'skg desc', \"\n       + \"                      facet: { skg: 'relatedness($fore,$back)' } } } } }\");\n       \n    // plain old request\n    assertJQ(req(nestedSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: 0.01539, \"\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 6, \"\n             + \"             foreground_popularity: 0.33333,\"\n             + \"             background_popularity: 0.5 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.00554, \" \n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:-0.01097, \"\n             //+ \"             foreground_count: 0, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 2, \"\n             //+ \"             background_size: 6,\"\n             + \"             foreground_popularity: 0.0,\"\n             + \"             background_popularity: 0.33333 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes\n    assertJQ(req(nestedSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 6 }, \"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 0, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 2, \"\n             + \"             background_size: 6 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"94ce69d020f939568b84a1dbbfbd11bfd9907b73","date":1543618146,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","sourceNew":"  @Test\n  public void testSimpleSKG() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // using relatedness() as a top level stat, not nested under any facet\n    // (not particularly useful, but shouldn't error either)\n    assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                 \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                 \"json.facet\", \" { skg: 'relatedness($fore,$back)' }\")\n             , \"facets=={\"\n             + \"   count:5, \"\n             + \"   skg : { relatedness: 0.00699,\"\n             + \"           foreground_popularity: 0.33333,\"\n             + \"           background_popularity: 0.83333,\"\n             + \"   } }\"\n             );\n    \n    // simple single level facet w/skg stat & (re)sorting\n    for (String sort : Arrays.asList(\"sort:'index asc'\",\n                                     \"sort:'y desc'\",\n                                     \"sort:'z desc'\",\n                                     \"sort:'skg desc'\",\n                                     \"prelim_sort:'count desc', sort:'index asc'\",\n                                     \"prelim_sort:'count desc', sort:'y desc'\",\n                                     \"prelim_sort:'count desc', sort:'z desc'\",\n                                     \"prelim_sort:'count desc', sort:'skg desc'\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order,\n      // (and the same order as 'sum(num_i) desc' & 'min(num_i) desc')\n      //\n      // So all of these re/sort options should produce identical output (since the num buckets is < limit)\n      // - Testing \"index\" sort allows the randomized use of \"stream\" processor as default to be tested.\n      // - Testing (re)sorts on other stats sanity checks code paths where relatedness() is a \"defered\" Agg\n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', \"+sort+\", \"\n                   + \"      facet: { skg: 'relatedness($fore,$back)', y:'sum(num_i)', z:'min(num_i)' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'A', count:2, y:5.0, z:2, \"\n               + \"     skg : { relatedness: 0.00554, \"\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 2, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.33333, },\"\n               + \"   }, \"\n               + \"   { val:'B', count:3, y:-3.0, z:-5, \"\n               + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   } ] } } \"\n               );\n    }\n    \n    // trivial sanity check that we can (re)sort on SKG after pre-sorting on count...\n    // ...and it's only computed for the top N buckets (based on our pre-sort)\n    for (int overrequest : Arrays.asList(0, 1, 42)) {\n      // based on our counts & relatedness values, the blackbox output should be the same for both\n      // overrequest values ... only DebugAgg stats should change...\n      DebugAgg.Acc.collectDocs.set(0);\n      DebugAgg.Acc.collectDocSets.set(0);\n      \n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NJ\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', prelim_sort: 'count desc', sort:'skg desc', \"\n                   + \"      limit: 1, overrequest: \" + overrequest + \", \"\n                   + \"      facet: { skg: 'debug(wrap,relatedness($fore,$back))' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'B', count:3, \"\n               + \"     skg : { relatedness: 0.00638, \" \n               //+ \"             foreground_count: 2, \"\n               //+ \"             foreground_size: 3, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.33333,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   }, \"\n               + \" ] } } \"\n               );\n      // at most 2 buckets, regardless of overrequest...\n      assertEqualsAndReset(0 < overrequest ? 2 : 1, DebugAgg.Acc.collectDocSets);\n      assertEqualsAndReset(0, DebugAgg.Acc.collectDocs);\n    }\n      \n    // SKG used in multiple nested facets\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams nestedSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[-1000 TO 0]\", \"back\", \"*:*\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: 'relatedness($fore,$back)', \"\n       + \"               y:   { type: terms, field: 'where_s', sort: 'skg desc', \"\n       + \"                      facet: { skg: 'relatedness($fore,$back)' } } } } }\");\n       \n    // plain old request\n    assertJQ(req(nestedSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: 0.01539, \"\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 6, \"\n             + \"             foreground_popularity: 0.33333,\"\n             + \"             background_popularity: 0.5 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.00554, \" \n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:-0.01097, \"\n             //+ \"             foreground_count: 0, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 2, \"\n             //+ \"             background_size: 6,\"\n             + \"             foreground_popularity: 0.0,\"\n             + \"             background_popularity: 0.33333 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes\n    assertJQ(req(nestedSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 6 }, \"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 0, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 2, \"\n             + \"             background_size: 6 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    \n    // SKG w/min_pop (NOTE: incredibly contrived and not-useful fore/back for testing min_pop w/shard sorting)\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams minPopSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[0 TO 1000]\", \"back\", \"cat_s:B\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: { type:func, func:'relatedness($fore,$back)', \"\n       + \"                      min_popularity: 0.001 }\" \n       + \"             } } }\");\n\n    // plain old request\n    assertJQ(req(minPopSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: -1.0, \"\n             //+ \"             foreground_count: 1, \"\n             //+ \"             foreground_size: 3, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 3, \"\n             + \"             foreground_popularity: 0.33333,\" \n             + \"             background_popularity: 1.0,\" \n             + \"   } }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:'-Infinity', \" // bg_pop is below min_pop (otherwise 1.0)\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 3, \"\n             //+ \"             background_count: 0, \"\n             //+ \"             background_size: 3, \"\n             + \"             foreground_popularity: 0.66667,\"\n             + \"             background_popularity: 0.0,\"\n             + \"   } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes and that per-shard sorting doesn't pre-emptively sort \"A\" to the bottom\n    assertJQ(req(minPopSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 3, \"\n             + \"             background_count: 0, \"\n             + \"             background_size: 3, \"\n             + \"   } }, \"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 1, \"\n             + \"             foreground_size: 3, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 3, \"\n             + \"   } } ] } }\");\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleSKG() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // using relatedness() as a top level stat, not nested under any facet\n    // (not particularly useful, but shouldn't error either)\n    assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                 \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                 \"json.facet\", \" { skg: 'relatedness($fore,$back)' }\")\n             , \"facets=={\"\n             + \"   count:5, \"\n             + \"   skg : { relatedness: 0.00699,\"\n             + \"           foreground_popularity: 0.33333,\"\n             + \"           background_popularity: 0.83333,\"\n             + \"   } }\"\n             );\n    \n    // simple single level facet w/skg stat & sorting\n    for (String sort : Arrays.asList(\"index asc\", \"skg desc\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order\n      // so both of these sort options should produce identical output\n      // and testinging \"index\" sort allows the randomized use of \"stream\" processor as default to be tested\n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', sort: '\"+sort+\"', \"\n                   + \"      facet: { skg: 'relatedness($fore,$back)' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'A', count:2, \"\n               + \"     skg : { relatedness: 0.00554, \"\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 2, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.33333, },\"\n               + \"   }, \"\n               + \"   { val:'B', count:3, \"\n               + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   } ] } } \"\n               );\n    }\n    \n    // SKG used in multiple nested facets\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams nestedSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[-1000 TO 0]\", \"back\", \"*:*\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: 'relatedness($fore,$back)', \"\n       + \"               y:   { type: terms, field: 'where_s', sort: 'skg desc', \"\n       + \"                      facet: { skg: 'relatedness($fore,$back)' } } } } }\");\n       \n    // plain old request\n    assertJQ(req(nestedSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: 0.01539, \"\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 6, \"\n             + \"             foreground_popularity: 0.33333,\"\n             + \"             background_popularity: 0.5 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.00554, \" \n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:-0.01097, \"\n             //+ \"             foreground_count: 0, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 2, \"\n             //+ \"             background_size: 6,\"\n             + \"             foreground_popularity: 0.0,\"\n             + \"             background_popularity: 0.33333 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes\n    assertJQ(req(nestedSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 6 }, \"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 0, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 2, \"\n             + \"             background_size: 6 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    \n    // SKG w/min_pop (NOTE: incredibly contrived and not-useful fore/back for testing min_pop w/shard sorting)\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams minPopSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[0 TO 1000]\", \"back\", \"cat_s:B\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: { type:func, func:'relatedness($fore,$back)', \"\n       + \"                      min_popularity: 0.001 }\" \n       + \"             } } }\");\n\n    // plain old request\n    assertJQ(req(minPopSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: -1.0, \"\n             //+ \"             foreground_count: 1, \"\n             //+ \"             foreground_size: 3, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 3, \"\n             + \"             foreground_popularity: 0.33333,\" \n             + \"             background_popularity: 1.0,\" \n             + \"   } }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:'-Infinity', \" // bg_pop is below min_pop (otherwise 1.0)\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 3, \"\n             //+ \"             background_count: 0, \"\n             //+ \"             background_size: 3, \"\n             + \"             foreground_popularity: 0.66667,\"\n             + \"             background_popularity: 0.0,\"\n             + \"   } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes and that per-shard sorting doesn't pre-emptively sort \"A\" to the bottom\n    assertJQ(req(minPopSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 3, \"\n             + \"             background_count: 0, \"\n             + \"             background_size: 3, \"\n             + \"   } }, \"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 1, \"\n             + \"             foreground_size: 3, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 3, \"\n             + \"   } } ] } }\");\n  }\n\n","bugFix":null,"bugIntro":["c5ec3c464e62e57df598ba20e010313bf6d5d7b4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5ec3c464e62e57df598ba20e010313bf6d5d7b4","date":1589998565,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","sourceNew":"  @Test\n  public void testSimpleSKG() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // using relatedness() as a top level stat, not nested under any facet\n    // (not particularly useful, but shouldn't error either)\n    assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                 \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                 \"json.facet\", \" { skg: 'relatedness($fore,$back)' }\")\n             , \"facets=={\"\n             + \"   count:5, \"\n             + \"   skg : { relatedness: 0.00699,\"\n             + \"           foreground_popularity: 0.33333,\"\n             + \"           background_popularity: 0.83333,\"\n             + \"   } }\"\n             );\n    \n    // simple single level facet w/skg stat & (re)sorting\n    for (String sort : Arrays.asList(\"sort:'index asc'\",\n                                     \"sort:'y desc'\",\n                                     \"sort:'z desc'\",\n                                     \"sort:'skg desc'\",\n                                     \"prelim_sort:'count desc', sort:'index asc'\",\n                                     \"prelim_sort:'count desc', sort:'y desc'\",\n                                     \"prelim_sort:'count desc', sort:'z desc'\",\n                                     \"prelim_sort:'count desc', sort:'skg desc'\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order,\n      // (and the same order as 'sum(num_i) desc' & 'min(num_i) desc')\n      //\n      // So all of these re/sort options should produce identical output (since the num buckets is < limit)\n      // - Testing \"index\" sort allows the randomized use of \"stream\" processor as default to be tested.\n      // - Testing (re)sorts on other stats sanity checks code paths where relatedness() is a \"defered\" Agg\n      for (String limit : Arrays.asList(\", \", \", limit:5, \", \", limit:-1, \")) {\n        // results shouldn't change regardless of our limit param\"\n        assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                     \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                     \"json.facet\", \"\"\n                     + \"{x: { type: terms, field: 'cat_s', \"+sort + limit\n                     + \"      facet: { skg: 'relatedness($fore,$back)', y:'sum(num_i)', z:'min(num_i)' } } }\")\n                 , \"facets=={count:5, x:{ buckets:[\"\n                 + \"   { val:'A', count:2, y:5.0, z:2, \"\n                 + \"     skg : { relatedness: 0.00554, \"\n                 //+ \"             foreground_count: 1, \"\n                 //+ \"             foreground_size: 2, \"\n                 //+ \"             background_count: 2, \"\n                 //+ \"             background_size: 6,\"\n                 + \"             foreground_popularity: 0.16667,\"\n                 + \"             background_popularity: 0.33333, },\"\n                 + \"   }, \"\n                 + \"   { val:'B', count:3, y:-3.0, z:-5, \"\n                 + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n                 //+ \"             foreground_count: 1, \"\n                 //+ \"             foreground_size: 2, \"\n                 //+ \"             background_count: 3, \"\n                 //+ \"             background_size: 6,\"\n                 + \"             foreground_popularity: 0.16667,\"\n                 + \"             background_popularity: 0.5 },\"\n                 + \"   } ] } } \"\n                 );\n        // same query with a prefix of 'B' should produce only a single bucket with exact same results\n        assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                     \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                     \"json.facet\", \"\"\n                     + \"{x: { type: terms, field: 'cat_s', prefix:'B', \"+sort + limit\n                     + \"      facet: { skg: 'relatedness($fore,$back)', y:'sum(num_i)', z:'min(num_i)' } } }\")\n                 , \"facets=={count:5, x:{ buckets:[\"\n                 + \"   { val:'B', count:3, y:-3.0, z:-5, \"\n                 + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n                 //+ \"             foreground_count: 1, \"\n                 //+ \"             foreground_size: 2, \"\n                 //+ \"             background_count: 3, \"\n                 //+ \"             background_size: 6,\"\n                 + \"             foreground_popularity: 0.16667,\"\n                 + \"             background_popularity: 0.5 },\"\n                 + \"   } ] } } \"\n                 );\n\n        \n      }\n    }\n    \n    // trivial sanity check that we can (re)sort on SKG after pre-sorting on count...\n    // ...and it's only computed for the top N buckets (based on our pre-sort)\n    for (int overrequest : Arrays.asList(0, 1, 42)) {\n      // based on our counts & relatedness values, the blackbox output should be the same for both\n      // overrequest values ... only DebugAgg stats should change...\n      DebugAgg.Acc.collectDocs.set(0);\n      DebugAgg.Acc.collectDocSets.set(0);\n      \n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NJ\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', prelim_sort: 'count desc', sort:'skg desc', \"\n                   + \"      limit: 1, overrequest: \" + overrequest + \", \"\n                   + \"      facet: { skg: 'debug(wrap,relatedness($fore,$back))' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'B', count:3, \"\n               + \"     skg : { relatedness: 0.00638, \" \n               //+ \"             foreground_count: 2, \"\n               //+ \"             foreground_size: 3, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.33333,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   }, \"\n               + \" ] } } \"\n               );\n      // at most 2 buckets, regardless of overrequest...\n      assertEqualsAndReset(0 < overrequest ? 2 : 1, DebugAgg.Acc.collectDocSets);\n      assertEqualsAndReset(0, DebugAgg.Acc.collectDocs);\n    }\n      \n    // SKG used in multiple nested facets\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams nestedSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[-1000 TO 0]\", \"back\", \"*:*\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: 'relatedness($fore,$back)', \"\n       + \"               y:   { type: terms, field: 'where_s', sort: 'skg desc', \"\n       + \"                      facet: { skg: 'relatedness($fore,$back)' } } } } }\");\n       \n    // plain old request\n    assertJQ(req(nestedSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: 0.01539, \"\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 6, \"\n             + \"             foreground_popularity: 0.33333,\"\n             + \"             background_popularity: 0.5 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.00554, \" \n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:-0.01097, \"\n             //+ \"             foreground_count: 0, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 2, \"\n             //+ \"             background_size: 6,\"\n             + \"             foreground_popularity: 0.0,\"\n             + \"             background_popularity: 0.33333 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes\n    assertJQ(req(nestedSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 6 }, \"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 0, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 2, \"\n             + \"             background_size: 6 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    \n    // SKG w/min_pop (NOTE: incredibly contrived and not-useful fore/back for testing min_pop w/shard sorting)\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams minPopSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[0 TO 1000]\", \"back\", \"cat_s:B\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: { type:func, func:'relatedness($fore,$back)', \"\n       + \"                      min_popularity: 0.001 }\" \n       + \"             } } }\");\n\n    // plain old request\n    assertJQ(req(minPopSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: -1.0, \"\n             //+ \"             foreground_count: 1, \"\n             //+ \"             foreground_size: 3, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 3, \"\n             + \"             foreground_popularity: 0.33333,\" \n             + \"             background_popularity: 1.0,\" \n             + \"   } }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:'-Infinity', \" // bg_pop is below min_pop (otherwise 1.0)\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 3, \"\n             //+ \"             background_count: 0, \"\n             //+ \"             background_size: 3, \"\n             + \"             foreground_popularity: 0.66667,\"\n             + \"             background_popularity: 0.0,\"\n             + \"   } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes and that per-shard sorting doesn't pre-emptively sort \"A\" to the bottom\n    assertJQ(req(minPopSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 3, \"\n             + \"             background_count: 0, \"\n             + \"             background_size: 3, \"\n             + \"   } }, \"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 1, \"\n             + \"             foreground_size: 3, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 3, \"\n             + \"   } } ] } }\");\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleSKG() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // using relatedness() as a top level stat, not nested under any facet\n    // (not particularly useful, but shouldn't error either)\n    assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                 \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                 \"json.facet\", \" { skg: 'relatedness($fore,$back)' }\")\n             , \"facets=={\"\n             + \"   count:5, \"\n             + \"   skg : { relatedness: 0.00699,\"\n             + \"           foreground_popularity: 0.33333,\"\n             + \"           background_popularity: 0.83333,\"\n             + \"   } }\"\n             );\n    \n    // simple single level facet w/skg stat & (re)sorting\n    for (String sort : Arrays.asList(\"sort:'index asc'\",\n                                     \"sort:'y desc'\",\n                                     \"sort:'z desc'\",\n                                     \"sort:'skg desc'\",\n                                     \"prelim_sort:'count desc', sort:'index asc'\",\n                                     \"prelim_sort:'count desc', sort:'y desc'\",\n                                     \"prelim_sort:'count desc', sort:'z desc'\",\n                                     \"prelim_sort:'count desc', sort:'skg desc'\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order,\n      // (and the same order as 'sum(num_i) desc' & 'min(num_i) desc')\n      //\n      // So all of these re/sort options should produce identical output (since the num buckets is < limit)\n      // - Testing \"index\" sort allows the randomized use of \"stream\" processor as default to be tested.\n      // - Testing (re)sorts on other stats sanity checks code paths where relatedness() is a \"defered\" Agg\n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', \"+sort+\", \"\n                   + \"      facet: { skg: 'relatedness($fore,$back)', y:'sum(num_i)', z:'min(num_i)' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'A', count:2, y:5.0, z:2, \"\n               + \"     skg : { relatedness: 0.00554, \"\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 2, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.33333, },\"\n               + \"   }, \"\n               + \"   { val:'B', count:3, y:-3.0, z:-5, \"\n               + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n               //+ \"             foreground_count: 1, \"\n               //+ \"             foreground_size: 2, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.16667,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   } ] } } \"\n               );\n    }\n    \n    // trivial sanity check that we can (re)sort on SKG after pre-sorting on count...\n    // ...and it's only computed for the top N buckets (based on our pre-sort)\n    for (int overrequest : Arrays.asList(0, 1, 42)) {\n      // based on our counts & relatedness values, the blackbox output should be the same for both\n      // overrequest values ... only DebugAgg stats should change...\n      DebugAgg.Acc.collectDocs.set(0);\n      DebugAgg.Acc.collectDocSets.set(0);\n      \n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NJ\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', prelim_sort: 'count desc', sort:'skg desc', \"\n                   + \"      limit: 1, overrequest: \" + overrequest + \", \"\n                   + \"      facet: { skg: 'debug(wrap,relatedness($fore,$back))' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'B', count:3, \"\n               + \"     skg : { relatedness: 0.00638, \" \n               //+ \"             foreground_count: 2, \"\n               //+ \"             foreground_size: 3, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.33333,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   }, \"\n               + \" ] } } \"\n               );\n      // at most 2 buckets, regardless of overrequest...\n      assertEqualsAndReset(0 < overrequest ? 2 : 1, DebugAgg.Acc.collectDocSets);\n      assertEqualsAndReset(0, DebugAgg.Acc.collectDocs);\n    }\n      \n    // SKG used in multiple nested facets\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams nestedSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[-1000 TO 0]\", \"back\", \"*:*\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: 'relatedness($fore,$back)', \"\n       + \"               y:   { type: terms, field: 'where_s', sort: 'skg desc', \"\n       + \"                      facet: { skg: 'relatedness($fore,$back)' } } } } }\");\n       \n    // plain old request\n    assertJQ(req(nestedSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: 0.01539, \"\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 6, \"\n             + \"             foreground_popularity: 0.33333,\"\n             + \"             background_popularity: 0.5 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.00554, \" \n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:-0.01097, \"\n             //+ \"             foreground_count: 0, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 2, \"\n             //+ \"             background_size: 6,\"\n             + \"             foreground_popularity: 0.0,\"\n             + \"             background_popularity: 0.33333 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes\n    assertJQ(req(nestedSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 6 }, \"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 0, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 2, \"\n             + \"             background_size: 6 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    \n    // SKG w/min_pop (NOTE: incredibly contrived and not-useful fore/back for testing min_pop w/shard sorting)\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams minPopSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[0 TO 1000]\", \"back\", \"cat_s:B\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: { type:func, func:'relatedness($fore,$back)', \"\n       + \"                      min_popularity: 0.001 }\" \n       + \"             } } }\");\n\n    // plain old request\n    assertJQ(req(minPopSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: -1.0, \"\n             //+ \"             foreground_count: 1, \"\n             //+ \"             foreground_size: 3, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 3, \"\n             + \"             foreground_popularity: 0.33333,\" \n             + \"             background_popularity: 1.0,\" \n             + \"   } }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:'-Infinity', \" // bg_pop is below min_pop (otherwise 1.0)\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 3, \"\n             //+ \"             background_count: 0, \"\n             //+ \"             background_size: 3, \"\n             + \"             foreground_popularity: 0.66667,\"\n             + \"             background_popularity: 0.0,\"\n             + \"   } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes and that per-shard sorting doesn't pre-emptively sort \"A\" to the bottom\n    assertJQ(req(minPopSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 3, \"\n             + \"             background_count: 0, \"\n             + \"             background_size: 3, \"\n             + \"   } }, \"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 1, \"\n             + \"             foreground_size: 3, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 3, \"\n             + \"   } } ] } }\");\n  }\n\n","bugFix":["2c705a0d590cf911e7c942df49563ca2ea176e22","94ce69d020f939568b84a1dbbfbd11bfd9907b73"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22d2c45da6e47ff0ada29a8f98566b76f0b278de","date":1591372739,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testSimpleSKG().mjava","sourceNew":"  @Test\n  public void testSimpleSKG() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // using relatedness() as a top level stat, not nested under any facet\n    // (not particularly useful, but shouldn't error either)\n    assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                 \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                 \"json.facet\", \" { skg: 'relatedness($fore,$back)' }\")\n             , \"facets=={\"\n             + \"   count:5, \"\n             + \"   skg : { relatedness: 0.00699,\"\n             + \"           foreground_popularity: 0.33333,\"\n             + \"           background_popularity: 0.83333,\"\n             + \"   } }\"\n             );\n    \n    // simple single level facet w/skg stat & (re)sorting\n    for (String sort : Arrays.asList(\"sort:'index asc'\",\n                                     \"sort:'y desc'\",\n                                     \"sort:'z desc'\",\n                                     \"sort:'skg desc'\",\n                                     \"prelim_sort:'count desc', sort:'index asc'\",\n                                     \"prelim_sort:'count desc', sort:'y desc'\",\n                                     \"prelim_sort:'count desc', sort:'z desc'\",\n                                     \"prelim_sort:'count desc', sort:'skg desc'\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order,\n      // (and the same order as 'sum(num_i) desc' & 'min(num_i) desc')\n      //\n      // So all of these re/sort options should produce identical output (since the num buckets is < limit)\n      // - Testing \"index\" sort allows the randomized use of \"stream\" processor as default to be tested.\n      // - Testing (re)sorts on other stats sanity checks code paths where relatedness() is a \"defered\" Agg\n      for (String limit : Arrays.asList(\", \", \", limit:5, \", \", limit:-1, \")) {\n        // results shouldn't change regardless of our limit param\"\n        assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                     \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                     \"json.facet\", \"\"\n                     + \"{x: { type: terms, field: 'cat_s', \"+sort + limit\n                     + \"      facet: { skg: 'relatedness($fore,$back)', y:'sum(num_i)', z:'min(num_i)' } } }\")\n                 , \"facets=={count:5, x:{ buckets:[\"\n                 + \"   { val:'A', count:2, y:5.0, z:2, \"\n                 + \"     skg : { relatedness: 0.00554, \"\n                 //+ \"             foreground_count: 1, \"\n                 //+ \"             foreground_size: 2, \"\n                 //+ \"             background_count: 2, \"\n                 //+ \"             background_size: 6,\"\n                 + \"             foreground_popularity: 0.16667,\"\n                 + \"             background_popularity: 0.33333, },\"\n                 + \"   }, \"\n                 + \"   { val:'B', count:3, y:-3.0, z:-5, \"\n                 + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n                 //+ \"             foreground_count: 1, \"\n                 //+ \"             foreground_size: 2, \"\n                 //+ \"             background_count: 3, \"\n                 //+ \"             background_size: 6,\"\n                 + \"             foreground_popularity: 0.16667,\"\n                 + \"             background_popularity: 0.5 },\"\n                 + \"   } ] } } \"\n                 );\n        // same query with a prefix of 'B' should produce only a single bucket with exact same results\n        assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                     \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                     \"json.facet\", \"\"\n                     + \"{x: { type: terms, field: 'cat_s', prefix:'B', \"+sort + limit\n                     + \"      facet: { skg: 'relatedness($fore,$back)', y:'sum(num_i)', z:'min(num_i)' } } }\")\n                 , \"facets=={count:5, x:{ buckets:[\"\n                 + \"   { val:'B', count:3, y:-3.0, z:-5, \"\n                 + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n                 //+ \"             foreground_count: 1, \"\n                 //+ \"             foreground_size: 2, \"\n                 //+ \"             background_count: 3, \"\n                 //+ \"             background_size: 6,\"\n                 + \"             foreground_popularity: 0.16667,\"\n                 + \"             background_popularity: 0.5 },\"\n                 + \"   } ] } } \"\n                 );\n      }\n    }\n\n    // relatedness shouldn't be computed for allBuckets, but it also shouldn't cause any problems\n    //\n    // NOTE: we can't test this with 'index asc' because STREAM processor\n    // (which test may randomize as default) doesn't support allBuckets\n    // see: https://issues.apache.org/jira/browse/SOLR-14514\n    //\n    for (String sort : Arrays.asList(\"sort:'y desc'\",\n                                     \"sort:'z desc'\",\n                                     \"sort:'skg desc'\",\n                                     \"prelim_sort:'count desc', sort:'skg desc'\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order,\n      // (and the same order as 'sum(num_i) desc' & 'min(num_i) desc')\n      //\n      // So all of these re/sort options should produce identical output (since the num buckets is < limit)\n      // - Testing \"index\" sort allows the randomized use of \"stream\" processor as default to be tested.\n      // - Testing (re)sorts on other stats sanity checks code paths where relatedness() is a \"defered\" Agg\n      for (String limit : Arrays.asList(\", \", \", limit:5, \", \", limit:-1, \")) {\n        // results shouldn't change regardless of our limit param\"\n        assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                     \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                     \"json.facet\", \"\"\n                     + \"{x: { type: terms, field: 'cat_s', allBuckets:true, \"+sort + limit\n                     + \"      facet: { skg: 'relatedness($fore,$back)', y:'sum(num_i)', z:'min(num_i)' } } }\")\n                 , \"facets=={count:5, x:{ \"\n                 // 'skg' key must not exist in th allBuckets bucket\n                 + \"                      allBuckets: { count:5, y:2.0, z:-5 },\"\n                 + \"buckets:[\"\n                 + \"   { val:'A', count:2, y:5.0, z:2, \"\n                 + \"     skg : { relatedness: 0.00554, \"\n                 //+ \"             foreground_count: 1, \"\n                 //+ \"             foreground_size: 2, \"\n                 //+ \"             background_count: 2, \"\n                 //+ \"             background_size: 6,\"\n                 + \"             foreground_popularity: 0.16667,\"\n                 + \"             background_popularity: 0.33333, },\"\n                 + \"   }, \"\n                 + \"   { val:'B', count:3, y:-3.0, z:-5, \"\n                 + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n                 //+ \"             foreground_count: 1, \"\n                 //+ \"             foreground_size: 2, \"\n                 //+ \"             background_count: 3, \"\n                 //+ \"             background_size: 6,\"\n                 + \"             foreground_popularity: 0.16667,\"\n                 + \"             background_popularity: 0.5 },\"\n                 + \"   } ] } } \"\n                 );\n        \n        // really special case: allBuckets when there are no regular buckets...\n        assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                     \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                     \"json.facet\", \"\"\n                     + \"{x: { type: terms, field: 'bogus_field_s', allBuckets:true, \"+sort + limit\n                     + \"      facet: { skg: 'relatedness($fore,$back)', y:'sum(num_i)', z:'min(num_i)' } } }\")\n                 , \"facets=={count:5, x:{ \"\n                 // 'skg' key (as well as 'z' since it's a min) must not exist in the allBuckets bucket\n                 + \"                      allBuckets: { count:0, y:0.0 },\"\n                 + \"buckets:[ ]\"\n                 + \"   } } \"\n                 );\n\n        \n      }\n    }\n\n    \n    // trivial sanity check that we can (re)sort on SKG after pre-sorting on count...\n    // ...and it's only computed for the top N buckets (based on our pre-sort)\n    for (int overrequest : Arrays.asList(0, 1, 42)) {\n      // based on our counts & relatedness values, the blackbox output should be the same for both\n      // overrequest values ... only DebugAgg stats should change...\n      DebugAgg.Acc.collectDocs.set(0);\n      DebugAgg.Acc.collectDocSets.set(0);\n      \n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NJ\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', prelim_sort: 'count desc', sort:'skg desc', \"\n                   + \"      limit: 1, overrequest: \" + overrequest + \", \"\n                   + \"      facet: { skg: 'debug(wrap,relatedness($fore,$back))' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'B', count:3, \"\n               + \"     skg : { relatedness: 0.00638, \" \n               //+ \"             foreground_count: 2, \"\n               //+ \"             foreground_size: 3, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.33333,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   }, \"\n               + \" ] } } \"\n               );\n      // at most 2 buckets, regardless of overrequest...\n      assertEqualsAndReset(0 < overrequest ? 2 : 1, DebugAgg.Acc.collectDocSets);\n      assertEqualsAndReset(0, DebugAgg.Acc.collectDocs);\n    }\n      \n    // SKG used in multiple nested facets\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams nestedSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[-1000 TO 0]\", \"back\", \"*:*\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: 'relatedness($fore,$back)', \"\n       + \"               y:   { type: terms, field: 'where_s', sort: 'skg desc', \"\n       + \"                      facet: { skg: 'relatedness($fore,$back)' } } } } }\");\n       \n    // plain old request\n    assertJQ(req(nestedSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: 0.01539, \"\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 6, \"\n             + \"             foreground_popularity: 0.33333,\"\n             + \"             background_popularity: 0.5 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.00554, \" \n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:-0.01097, \"\n             //+ \"             foreground_count: 0, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 2, \"\n             //+ \"             background_size: 6,\"\n             + \"             foreground_popularity: 0.0,\"\n             + \"             background_popularity: 0.33333 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes\n    assertJQ(req(nestedSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 6 }, \"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 0, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 2, \"\n             + \"             background_size: 6 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    \n    // SKG w/min_pop (NOTE: incredibly contrived and not-useful fore/back for testing min_pop w/shard sorting)\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams minPopSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[0 TO 1000]\", \"back\", \"cat_s:B\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: { type:func, func:'relatedness($fore,$back)', \"\n       + \"                      min_popularity: 0.001 }\" \n       + \"             } } }\");\n\n    // plain old request\n    assertJQ(req(minPopSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: -1.0, \"\n             //+ \"             foreground_count: 1, \"\n             //+ \"             foreground_size: 3, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 3, \"\n             + \"             foreground_popularity: 0.33333,\" \n             + \"             background_popularity: 1.0,\" \n             + \"   } }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:'-Infinity', \" // bg_pop is below min_pop (otherwise 1.0)\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 3, \"\n             //+ \"             background_count: 0, \"\n             //+ \"             background_size: 3, \"\n             + \"             foreground_popularity: 0.66667,\"\n             + \"             background_popularity: 0.0,\"\n             + \"   } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes and that per-shard sorting doesn't pre-emptively sort \"A\" to the bottom\n    assertJQ(req(minPopSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 3, \"\n             + \"             background_count: 0, \"\n             + \"             background_size: 3, \"\n             + \"   } }, \"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 1, \"\n             + \"             foreground_size: 3, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 3, \"\n             + \"   } } ] } }\");\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleSKG() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // using relatedness() as a top level stat, not nested under any facet\n    // (not particularly useful, but shouldn't error either)\n    assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                 \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                 \"json.facet\", \" { skg: 'relatedness($fore,$back)' }\")\n             , \"facets=={\"\n             + \"   count:5, \"\n             + \"   skg : { relatedness: 0.00699,\"\n             + \"           foreground_popularity: 0.33333,\"\n             + \"           background_popularity: 0.83333,\"\n             + \"   } }\"\n             );\n    \n    // simple single level facet w/skg stat & (re)sorting\n    for (String sort : Arrays.asList(\"sort:'index asc'\",\n                                     \"sort:'y desc'\",\n                                     \"sort:'z desc'\",\n                                     \"sort:'skg desc'\",\n                                     \"prelim_sort:'count desc', sort:'index asc'\",\n                                     \"prelim_sort:'count desc', sort:'y desc'\",\n                                     \"prelim_sort:'count desc', sort:'z desc'\",\n                                     \"prelim_sort:'count desc', sort:'skg desc'\")) {\n      // the relatedness score of each of our cat_s values is (conviniently) also alphabetical order,\n      // (and the same order as 'sum(num_i) desc' & 'min(num_i) desc')\n      //\n      // So all of these re/sort options should produce identical output (since the num buckets is < limit)\n      // - Testing \"index\" sort allows the randomized use of \"stream\" processor as default to be tested.\n      // - Testing (re)sorts on other stats sanity checks code paths where relatedness() is a \"defered\" Agg\n      for (String limit : Arrays.asList(\", \", \", limit:5, \", \", limit:-1, \")) {\n        // results shouldn't change regardless of our limit param\"\n        assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                     \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                     \"json.facet\", \"\"\n                     + \"{x: { type: terms, field: 'cat_s', \"+sort + limit\n                     + \"      facet: { skg: 'relatedness($fore,$back)', y:'sum(num_i)', z:'min(num_i)' } } }\")\n                 , \"facets=={count:5, x:{ buckets:[\"\n                 + \"   { val:'A', count:2, y:5.0, z:2, \"\n                 + \"     skg : { relatedness: 0.00554, \"\n                 //+ \"             foreground_count: 1, \"\n                 //+ \"             foreground_size: 2, \"\n                 //+ \"             background_count: 2, \"\n                 //+ \"             background_size: 6,\"\n                 + \"             foreground_popularity: 0.16667,\"\n                 + \"             background_popularity: 0.33333, },\"\n                 + \"   }, \"\n                 + \"   { val:'B', count:3, y:-3.0, z:-5, \"\n                 + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n                 //+ \"             foreground_count: 1, \"\n                 //+ \"             foreground_size: 2, \"\n                 //+ \"             background_count: 3, \"\n                 //+ \"             background_size: 6,\"\n                 + \"             foreground_popularity: 0.16667,\"\n                 + \"             background_popularity: 0.5 },\"\n                 + \"   } ] } } \"\n                 );\n        // same query with a prefix of 'B' should produce only a single bucket with exact same results\n        assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                     \"fore\", \"where_s:NY\", \"back\", \"*:*\",\n                     \"json.facet\", \"\"\n                     + \"{x: { type: terms, field: 'cat_s', prefix:'B', \"+sort + limit\n                     + \"      facet: { skg: 'relatedness($fore,$back)', y:'sum(num_i)', z:'min(num_i)' } } }\")\n                 , \"facets=={count:5, x:{ buckets:[\"\n                 + \"   { val:'B', count:3, y:-3.0, z:-5, \"\n                 + \"     skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n                 //+ \"             foreground_count: 1, \"\n                 //+ \"             foreground_size: 2, \"\n                 //+ \"             background_count: 3, \"\n                 //+ \"             background_size: 6,\"\n                 + \"             foreground_popularity: 0.16667,\"\n                 + \"             background_popularity: 0.5 },\"\n                 + \"   } ] } } \"\n                 );\n\n        \n      }\n    }\n    \n    // trivial sanity check that we can (re)sort on SKG after pre-sorting on count...\n    // ...and it's only computed for the top N buckets (based on our pre-sort)\n    for (int overrequest : Arrays.asList(0, 1, 42)) {\n      // based on our counts & relatedness values, the blackbox output should be the same for both\n      // overrequest values ... only DebugAgg stats should change...\n      DebugAgg.Acc.collectDocs.set(0);\n      DebugAgg.Acc.collectDocSets.set(0);\n      \n      assertJQ(req(\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\",\n                   \"fore\", \"where_s:NJ\", \"back\", \"*:*\",\n                   \"json.facet\", \"\"\n                   + \"{x: { type: terms, field: 'cat_s', prelim_sort: 'count desc', sort:'skg desc', \"\n                   + \"      limit: 1, overrequest: \" + overrequest + \", \"\n                   + \"      facet: { skg: 'debug(wrap,relatedness($fore,$back))' } } }\")\n               , \"facets=={count:5, x:{ buckets:[\"\n               + \"   { val:'B', count:3, \"\n               + \"     skg : { relatedness: 0.00638, \" \n               //+ \"             foreground_count: 2, \"\n               //+ \"             foreground_size: 3, \"\n               //+ \"             background_count: 3, \"\n               //+ \"             background_size: 6,\"\n               + \"             foreground_popularity: 0.33333,\"\n               + \"             background_popularity: 0.5 },\"\n               + \"   }, \"\n               + \" ] } } \"\n               );\n      // at most 2 buckets, regardless of overrequest...\n      assertEqualsAndReset(0 < overrequest ? 2 : 1, DebugAgg.Acc.collectDocSets);\n      assertEqualsAndReset(0, DebugAgg.Acc.collectDocs);\n    }\n      \n    // SKG used in multiple nested facets\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams nestedSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[-1000 TO 0]\", \"back\", \"*:*\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: 'relatedness($fore,$back)', \"\n       + \"               y:   { type: terms, field: 'where_s', sort: 'skg desc', \"\n       + \"                      facet: { skg: 'relatedness($fore,$back)' } } } } }\");\n       \n    // plain old request\n    assertJQ(req(nestedSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: 0.01539, \"\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 6, \"\n             + \"             foreground_popularity: 0.33333,\"\n             + \"             background_popularity: 0.5 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.00554, \" \n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 1, \"\n             //+ \"                       foreground_size: 2, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.16667, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:-0.01097, \"\n             //+ \"             foreground_count: 0, \"\n             //+ \"             foreground_size: 2, \"\n             //+ \"             background_count: 2, \"\n             //+ \"             background_size: 6,\"\n             + \"             foreground_popularity: 0.0,\"\n             + \"             background_popularity: 0.33333 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 3, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.5, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { relatedness: 0.0, \" // perfectly average and uncorrolated\n             //+ \"                       foreground_count: 0, \"\n             //+ \"                       foreground_size: 0, \"\n             //+ \"                       background_count: 2, \"\n             //+ \"                       background_size: 6, \"\n             + \"                       foreground_popularity: 0.0, \"\n             + \"                       background_popularity: 0.33333, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes\n    assertJQ(req(nestedSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 6 }, \"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NJ', count: 2, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 1, \"\n             + \"                       foreground_size: 2, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"     ] } \"\n             + \"   }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 0, \"\n             + \"             foreground_size: 2, \"\n             + \"             background_count: 2, \"\n             + \"             background_size: 6 },\"\n             + \"     y : { buckets:[\"\n             + \"            {  val:'NJ', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 3, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"            {  val:'NY', count: 1, \"\n             + \"               skg : { \" \n             + \"                       foreground_count: 0, \"\n             + \"                       foreground_size: 0, \"\n             + \"                       background_count: 2, \"\n             + \"                       background_size: 6, \"\n             + \"            } }, \"\n             + \"   ] } } ] } } \");\n\n    \n    // SKG w/min_pop (NOTE: incredibly contrived and not-useful fore/back for testing min_pop w/shard sorting)\n    //\n    // we'll re-use these params in 2 requests, one will simulate a shard request\n    final SolrParams minPopSKG = params\n      (\"q\", \"cat_s:[* TO *]\", \"rows\", \"0\", \"fore\", \"num_i:[0 TO 1000]\", \"back\", \"cat_s:B\", \"json.facet\"\n       , \"{x: { type: terms, field: 'cat_s', sort: 'skg desc', \"\n       + \"      facet: { skg: { type:func, func:'relatedness($fore,$back)', \"\n       + \"                      min_popularity: 0.001 }\" \n       + \"             } } }\");\n\n    // plain old request\n    assertJQ(req(minPopSKG)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { relatedness: -1.0, \"\n             //+ \"             foreground_count: 1, \"\n             //+ \"             foreground_size: 3, \"\n             //+ \"             background_count: 3, \"\n             //+ \"             background_size: 3, \"\n             + \"             foreground_popularity: 0.33333,\" \n             + \"             background_popularity: 1.0,\" \n             + \"   } }, \"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { relatedness:'-Infinity', \" // bg_pop is below min_pop (otherwise 1.0)\n             //+ \"             foreground_count: 2, \"\n             //+ \"             foreground_size: 3, \"\n             //+ \"             background_count: 0, \"\n             //+ \"             background_size: 3, \"\n             + \"             foreground_popularity: 0.66667,\"\n             + \"             background_popularity: 0.0,\"\n             + \"   } } ] } } \");\n\n    // same request, but with whitebox params testing isShard\n    // to verify the raw counts/sizes and that per-shard sorting doesn't pre-emptively sort \"A\" to the bottom\n    assertJQ(req(minPopSKG,\n                 // fake an initial shard request\n                 \"distrib\", \"false\", \"isShard\", \"true\", \"_facet_\", \"{}\",\n                 \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS)\n             , \"facets=={count:5, x:{ buckets:[\"\n             + \"   { val:'A', count:2, \"\n             + \"     skg : { \" \n             + \"             foreground_count: 2, \"\n             + \"             foreground_size: 3, \"\n             + \"             background_count: 0, \"\n             + \"             background_size: 3, \"\n             + \"   } }, \"\n             + \"   { val:'B', count:3, \"\n             + \"     skg : { \"\n             + \"             foreground_count: 1, \"\n             + \"             foreground_size: 3, \"\n             + \"             background_count: 3, \"\n             + \"             background_size: 3, \"\n             + \"   } } ] } }\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c5ec3c464e62e57df598ba20e010313bf6d5d7b4":["94ce69d020f939568b84a1dbbfbd11bfd9907b73"],"2c705a0d590cf911e7c942df49563ca2ea176e22":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"22d2c45da6e47ff0ada29a8f98566b76f0b278de":["c5ec3c464e62e57df598ba20e010313bf6d5d7b4"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["2c705a0d590cf911e7c942df49563ca2ea176e22","c05b634713ca09b2267477408773904d4c69dd9d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"42009f1fefcc8f4d9e07b158e9415cbd6ca7247c":["c05b634713ca09b2267477408773904d4c69dd9d"],"94ce69d020f939568b84a1dbbfbd11bfd9907b73":["42009f1fefcc8f4d9e07b158e9415cbd6ca7247c"],"c05b634713ca09b2267477408773904d4c69dd9d":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["22d2c45da6e47ff0ada29a8f98566b76f0b278de"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["2c705a0d590cf911e7c942df49563ca2ea176e22","c05b634713ca09b2267477408773904d4c69dd9d"]},"commit2Childs":{"c5ec3c464e62e57df598ba20e010313bf6d5d7b4":["22d2c45da6e47ff0ada29a8f98566b76f0b278de"],"2c705a0d590cf911e7c942df49563ca2ea176e22":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","c05b634713ca09b2267477408773904d4c69dd9d","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"22d2c45da6e47ff0ada29a8f98566b76f0b278de":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"42009f1fefcc8f4d9e07b158e9415cbd6ca7247c":["94ce69d020f939568b84a1dbbfbd11bfd9907b73"],"94ce69d020f939568b84a1dbbfbd11bfd9907b73":["c5ec3c464e62e57df598ba20e010313bf6d5d7b4"],"c05b634713ca09b2267477408773904d4c69dd9d":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","42009f1fefcc8f4d9e07b158e9415cbd6ca7247c","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}