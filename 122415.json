{"path":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int).mjava","commits":[{"id":"8be6e1e4fbbc94d90b78f175c03ff389b6949373","date":1306674752,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs.FSTTester#doTest(int,int).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {\n        IndexOutput out = dir.createOutput(\"fst.bin\");\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\");\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {\n        IndexOutput out = dir.createOutput(\"fst.bin\");\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\");\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs.FSTTester#doTest(int,int).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {\n        IndexOutput out = dir.createOutput(\"fst.bin\");\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\");\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {\n        IndexOutput out = dir.createOutput(\"fst.bin\");\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\");\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs.FSTTester#doTest(int,int).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {\n        IndexOutput out = dir.createOutput(\"fst.bin\");\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\");\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {\n        IndexOutput out = dir.createOutput(\"fst.bin\");\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\");\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"639c36565ce03aed5b0fce7c9e4448e53a1f7efd","date":1308580104,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {\n        IndexOutput out = dir.createOutput(\"fst.bin\", IOContext.DEFAULT);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", IOContext.DEFAULT);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {\n        IndexOutput out = dir.createOutput(\"fst.bin\");\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\");\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6f9be74ca7baaef11857ad002cad40419979516","date":1309449808,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {        \n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {\n        IndexOutput out = dir.createOutput(\"fst.bin\", IOContext.DEFAULT);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", IOContext.DEFAULT);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {        \n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {\n        IndexOutput out = dir.createOutput(\"fst.bin\");\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\");\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {        \n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {\n        IndexOutput out = dir.createOutput(\"fst.bin\");\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\");\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f2bf10c11daad40c1e46fabd0d414c19a3e605b","date":1310410393,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {        \n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {        \n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b6f9be74ca7baaef11857ad002cad40419979516":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd"],"4f2bf10c11daad40c1e46fabd0d414c19a3e605b":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["8be6e1e4fbbc94d90b78f175c03ff389b6949373","b6f9be74ca7baaef11857ad002cad40419979516"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4f2bf10c11daad40c1e46fabd0d414c19a3e605b"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8be6e1e4fbbc94d90b78f175c03ff389b6949373"]},"commit2Childs":{"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","639c36565ce03aed5b0fce7c9e4448e53a1f7efd","ddc4c914be86e34b54f70023f45a60fa7f04e929","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["5d004d0e0b3f65bb40da76d476d659d7888270e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8be6e1e4fbbc94d90b78f175c03ff389b6949373","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"b6f9be74ca7baaef11857ad002cad40419979516":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["b6f9be74ca7baaef11857ad002cad40419979516"],"4f2bf10c11daad40c1e46fabd0d414c19a3e605b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["4f2bf10c11daad40c1e46fabd0d414c19a3e605b","5d004d0e0b3f65bb40da76d476d659d7888270e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}