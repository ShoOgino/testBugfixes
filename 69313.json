{"path":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#assertSegmentInfos(MergePolicy,SegmentInfos).mjava","commits":[{"id":"da0d58b6bf72ebfd4d6722289ea725809c20c987","date":1531207054,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#assertSegmentInfos(MergePolicy,SegmentInfos).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  protected void assertSegmentInfos(MergePolicy policy, SegmentInfos infos) throws IOException {\n    TieredMergePolicy tmp = (TieredMergePolicy) policy;\n\n    final long maxMergedSegmentBytes = (long) (tmp.getMaxMergedSegmentMB() * 1024 * 1024);\n\n    long minSegmentBytes = Long.MAX_VALUE;\n    long totalBytes = 0;\n    for (SegmentCommitInfo sci : infos) {\n      long byteSize = sci.sizeInBytes();\n      double liveRatio = 1 - (double) sci.getDelCount() / sci.info.maxDoc();\n      long weightedByteSize = (long) Math.round(liveRatio * byteSize);\n      totalBytes += weightedByteSize;\n      minSegmentBytes = Math.min(minSegmentBytes, weightedByteSize);\n    }\n\n    long levelSize = Math.max(minSegmentBytes, (long) (tmp.getFloorSegmentMB() * 1024 * 1024));\n    long bytesLeft = totalBytes;\n    double allowedSegCount = 0;\n    // below we make the assumption that segments that reached the max segment\n    // size divided by 2 don't need merging anymore\n    int mergeFactor = (int) Math.min(tmp.getSegmentsPerTier(), tmp.getMaxMergeAtOnce());\n    while (true) {\n      final double segCountLevel = bytesLeft / (double) levelSize;\n      if (segCountLevel < tmp.getSegmentsPerTier() || levelSize > maxMergedSegmentBytes / 2) {\n        allowedSegCount += Math.ceil(segCountLevel);\n        break;\n      }\n      allowedSegCount += tmp.getSegmentsPerTier();\n      bytesLeft -= tmp.getSegmentsPerTier() * levelSize;\n      levelSize = Math.min(levelSize * mergeFactor, maxMergedSegmentBytes / 2);\n    }\n    allowedSegCount = Math.max(allowedSegCount, tmp.getSegmentsPerTier());\n\n    int numSegments = infos.asList().size();\n    assertTrue(\"numSegments=\" + numSegments + \", allowed=\" + allowedSegCount, numSegments <= allowedSegCount);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#assertSegmentInfos(MergePolicy,SegmentInfos).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  protected void assertSegmentInfos(MergePolicy policy, SegmentInfos infos) throws IOException {\n    TieredMergePolicy tmp = (TieredMergePolicy) policy;\n\n    final long maxMergedSegmentBytes = (long) (tmp.getMaxMergedSegmentMB() * 1024 * 1024);\n\n    long minSegmentBytes = Long.MAX_VALUE;\n    long totalBytes = 0;\n    for (SegmentCommitInfo sci : infos) {\n      long byteSize = sci.sizeInBytes();\n      double liveRatio = 1 - (double) sci.getDelCount() / sci.info.maxDoc();\n      long weightedByteSize = (long) Math.round(liveRatio * byteSize);\n      totalBytes += weightedByteSize;\n      minSegmentBytes = Math.min(minSegmentBytes, weightedByteSize);\n    }\n\n    long levelSize = Math.max(minSegmentBytes, (long) (tmp.getFloorSegmentMB() * 1024 * 1024));\n    long bytesLeft = totalBytes;\n    double allowedSegCount = 0;\n    // below we make the assumption that segments that reached the max segment\n    // size divided by 2 don't need merging anymore\n    int mergeFactor = (int) Math.min(tmp.getSegmentsPerTier(), tmp.getMaxMergeAtOnce());\n    while (true) {\n      final double segCountLevel = bytesLeft / (double) levelSize;\n      if (segCountLevel < tmp.getSegmentsPerTier() || levelSize > maxMergedSegmentBytes / 2) {\n        allowedSegCount += Math.ceil(segCountLevel);\n        break;\n      }\n      allowedSegCount += tmp.getSegmentsPerTier();\n      bytesLeft -= tmp.getSegmentsPerTier() * levelSize;\n      levelSize = Math.min(levelSize * mergeFactor, maxMergedSegmentBytes / 2);\n    }\n    allowedSegCount = Math.max(allowedSegCount, tmp.getSegmentsPerTier());\n\n    int numSegments = infos.asList().size();\n    assertTrue(\"numSegments=\" + numSegments + \", allowed=\" + allowedSegCount, numSegments <= allowedSegCount);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a90cc8c90aa53ddf51fbd15019989ac269514a3","date":1531845066,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#assertSegmentInfos(MergePolicy,SegmentInfos).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#assertSegmentInfos(MergePolicy,SegmentInfos).mjava","sourceNew":"  @Override\n  protected void assertSegmentInfos(MergePolicy policy, SegmentInfos infos) throws IOException {\n    TieredMergePolicy tmp = (TieredMergePolicy) policy;\n\n    final long maxMergedSegmentBytes = (long) (tmp.getMaxMergedSegmentMB() * 1024 * 1024);\n\n    long minSegmentBytes = Long.MAX_VALUE;\n    int totalDelCount = 0;\n    int totalMaxDoc = 0;\n    long totalBytes = 0;\n    for (SegmentCommitInfo sci : infos) {\n      totalDelCount += sci.getDelCount();\n      totalMaxDoc += sci.info.maxDoc();\n      long byteSize = sci.sizeInBytes();\n      double liveRatio = 1 - (double) sci.getDelCount() / sci.info.maxDoc();\n      long weightedByteSize = (long) Math.round(liveRatio * byteSize);\n      totalBytes += weightedByteSize;\n      minSegmentBytes = Math.min(minSegmentBytes, weightedByteSize);\n    }\n\n    final double delPercentage = 100.0 * totalDelCount / totalMaxDoc;\n    assertTrue(\"Percentage of deleted docs \" + delPercentage + \" is larger than the target: \" + tmp.getDeletesPctAllowed(),\n        delPercentage <= tmp.getDeletesPctAllowed());\n\n    long levelSize = Math.max(minSegmentBytes, (long) (tmp.getFloorSegmentMB() * 1024 * 1024));\n    long bytesLeft = totalBytes;\n    double allowedSegCount = 0;\n    // below we make the assumption that segments that reached the max segment\n    // size divided by 2 don't need merging anymore\n    int mergeFactor = (int) Math.min(tmp.getSegmentsPerTier(), tmp.getMaxMergeAtOnce());\n    while (true) {\n      final double segCountLevel = bytesLeft / (double) levelSize;\n      if (segCountLevel < tmp.getSegmentsPerTier() || levelSize >= maxMergedSegmentBytes / 2) {\n        allowedSegCount += Math.ceil(segCountLevel);\n        break;\n      }\n      allowedSegCount += tmp.getSegmentsPerTier();\n      bytesLeft -= tmp.getSegmentsPerTier() * levelSize;\n      levelSize = Math.min(levelSize * mergeFactor, maxMergedSegmentBytes / 2);\n    }\n    allowedSegCount = Math.max(allowedSegCount, tmp.getSegmentsPerTier());\n\n    int numSegments = infos.asList().size();\n    assertTrue(\"numSegments=\" + numSegments + \", allowed=\" + allowedSegCount, numSegments <= allowedSegCount);\n  }\n\n","sourceOld":"  @Override\n  protected void assertSegmentInfos(MergePolicy policy, SegmentInfos infos) throws IOException {\n    TieredMergePolicy tmp = (TieredMergePolicy) policy;\n\n    final long maxMergedSegmentBytes = (long) (tmp.getMaxMergedSegmentMB() * 1024 * 1024);\n\n    long minSegmentBytes = Long.MAX_VALUE;\n    long totalBytes = 0;\n    for (SegmentCommitInfo sci : infos) {\n      long byteSize = sci.sizeInBytes();\n      double liveRatio = 1 - (double) sci.getDelCount() / sci.info.maxDoc();\n      long weightedByteSize = (long) Math.round(liveRatio * byteSize);\n      totalBytes += weightedByteSize;\n      minSegmentBytes = Math.min(minSegmentBytes, weightedByteSize);\n    }\n\n    long levelSize = Math.max(minSegmentBytes, (long) (tmp.getFloorSegmentMB() * 1024 * 1024));\n    long bytesLeft = totalBytes;\n    double allowedSegCount = 0;\n    // below we make the assumption that segments that reached the max segment\n    // size divided by 2 don't need merging anymore\n    int mergeFactor = (int) Math.min(tmp.getSegmentsPerTier(), tmp.getMaxMergeAtOnce());\n    while (true) {\n      final double segCountLevel = bytesLeft / (double) levelSize;\n      if (segCountLevel < tmp.getSegmentsPerTier() || levelSize > maxMergedSegmentBytes / 2) {\n        allowedSegCount += Math.ceil(segCountLevel);\n        break;\n      }\n      allowedSegCount += tmp.getSegmentsPerTier();\n      bytesLeft -= tmp.getSegmentsPerTier() * levelSize;\n      levelSize = Math.min(levelSize * mergeFactor, maxMergedSegmentBytes / 2);\n    }\n    allowedSegCount = Math.max(allowedSegCount, tmp.getSegmentsPerTier());\n\n    int numSegments = infos.asList().size();\n    assertTrue(\"numSegments=\" + numSegments + \", allowed=\" + allowedSegCount, numSegments <= allowedSegCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#assertSegmentInfos(MergePolicy,SegmentInfos).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  protected void assertSegmentInfos(MergePolicy policy, SegmentInfos infos) throws IOException {\n    TieredMergePolicy tmp = (TieredMergePolicy) policy;\n\n    final long maxMergedSegmentBytes = (long) (tmp.getMaxMergedSegmentMB() * 1024 * 1024);\n\n    long minSegmentBytes = Long.MAX_VALUE;\n    int totalDelCount = 0;\n    int totalMaxDoc = 0;\n    long totalBytes = 0;\n    for (SegmentCommitInfo sci : infos) {\n      totalDelCount += sci.getDelCount();\n      totalMaxDoc += sci.info.maxDoc();\n      long byteSize = sci.sizeInBytes();\n      double liveRatio = 1 - (double) sci.getDelCount() / sci.info.maxDoc();\n      long weightedByteSize = (long) Math.round(liveRatio * byteSize);\n      totalBytes += weightedByteSize;\n      minSegmentBytes = Math.min(minSegmentBytes, weightedByteSize);\n    }\n\n    final double delPercentage = 100.0 * totalDelCount / totalMaxDoc;\n    assertTrue(\"Percentage of deleted docs \" + delPercentage + \" is larger than the target: \" + tmp.getDeletesPctAllowed(),\n        delPercentage <= tmp.getDeletesPctAllowed());\n\n    long levelSize = Math.max(minSegmentBytes, (long) (tmp.getFloorSegmentMB() * 1024 * 1024));\n    long bytesLeft = totalBytes;\n    double allowedSegCount = 0;\n    // below we make the assumption that segments that reached the max segment\n    // size divided by 2 don't need merging anymore\n    int mergeFactor = (int) Math.min(tmp.getSegmentsPerTier(), tmp.getMaxMergeAtOnce());\n    while (true) {\n      final double segCountLevel = bytesLeft / (double) levelSize;\n      if (segCountLevel < tmp.getSegmentsPerTier() || levelSize >= maxMergedSegmentBytes / 2) {\n        allowedSegCount += Math.ceil(segCountLevel);\n        break;\n      }\n      allowedSegCount += tmp.getSegmentsPerTier();\n      bytesLeft -= tmp.getSegmentsPerTier() * levelSize;\n      levelSize = Math.min(levelSize * mergeFactor, maxMergedSegmentBytes / 2);\n    }\n    allowedSegCount = Math.max(allowedSegCount, tmp.getSegmentsPerTier());\n\n    int numSegments = infos.asList().size();\n    assertTrue(\"numSegments=\" + numSegments + \", allowed=\" + allowedSegCount, numSegments <= allowedSegCount);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70544d57ad77b2a0111e979c54096a9b191c99df","date":1533061790,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#assertSegmentInfos(MergePolicy,SegmentInfos).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#assertSegmentInfos(MergePolicy,SegmentInfos).mjava","sourceNew":"  @Override\n  protected void assertSegmentInfos(MergePolicy policy, SegmentInfos infos) throws IOException {\n    TieredMergePolicy tmp = (TieredMergePolicy) policy;\n\n    final long maxMergedSegmentBytes = (long) (tmp.getMaxMergedSegmentMB() * 1024 * 1024);\n\n    long minSegmentBytes = Long.MAX_VALUE;\n    int totalDelCount = 0;\n    int totalMaxDoc = 0;\n    long totalBytes = 0;\n    for (SegmentCommitInfo sci : infos) {\n      totalDelCount += sci.getDelCount();\n      totalMaxDoc += sci.info.maxDoc();\n      long byteSize = sci.sizeInBytes();\n      double liveRatio = 1 - (double) sci.getDelCount() / sci.info.maxDoc();\n      long weightedByteSize = Math.round(liveRatio * byteSize);\n      totalBytes += weightedByteSize;\n      minSegmentBytes = Math.min(minSegmentBytes, weightedByteSize);\n    }\n\n    final double delPercentage = 100.0 * totalDelCount / totalMaxDoc;\n    assertTrue(\"Percentage of deleted docs \" + delPercentage + \" is larger than the target: \" + tmp.getDeletesPctAllowed(),\n        delPercentage <= tmp.getDeletesPctAllowed());\n\n    long levelSize = Math.max(minSegmentBytes, (long) (tmp.getFloorSegmentMB() * 1024 * 1024));\n    long bytesLeft = totalBytes;\n    double allowedSegCount = 0;\n    // below we make the assumption that segments that reached the max segment\n    // size divided by 2 don't need merging anymore\n    int mergeFactor = (int) Math.min(tmp.getSegmentsPerTier(), tmp.getMaxMergeAtOnce());\n    while (true) {\n      final double segCountLevel = bytesLeft / (double) levelSize;\n      if (segCountLevel < tmp.getSegmentsPerTier() || levelSize >= maxMergedSegmentBytes / 2) {\n        allowedSegCount += Math.ceil(segCountLevel);\n        break;\n      }\n      allowedSegCount += tmp.getSegmentsPerTier();\n      bytesLeft -= tmp.getSegmentsPerTier() * levelSize;\n      levelSize = Math.min(levelSize * mergeFactor, maxMergedSegmentBytes / 2);\n    }\n    allowedSegCount = Math.max(allowedSegCount, tmp.getSegmentsPerTier());\n\n    int numSegments = infos.asList().size();\n    assertTrue(\"numSegments=\" + numSegments + \", allowed=\" + allowedSegCount, numSegments <= allowedSegCount);\n  }\n\n","sourceOld":"  @Override\n  protected void assertSegmentInfos(MergePolicy policy, SegmentInfos infos) throws IOException {\n    TieredMergePolicy tmp = (TieredMergePolicy) policy;\n\n    final long maxMergedSegmentBytes = (long) (tmp.getMaxMergedSegmentMB() * 1024 * 1024);\n\n    long minSegmentBytes = Long.MAX_VALUE;\n    int totalDelCount = 0;\n    int totalMaxDoc = 0;\n    long totalBytes = 0;\n    for (SegmentCommitInfo sci : infos) {\n      totalDelCount += sci.getDelCount();\n      totalMaxDoc += sci.info.maxDoc();\n      long byteSize = sci.sizeInBytes();\n      double liveRatio = 1 - (double) sci.getDelCount() / sci.info.maxDoc();\n      long weightedByteSize = (long) Math.round(liveRatio * byteSize);\n      totalBytes += weightedByteSize;\n      minSegmentBytes = Math.min(minSegmentBytes, weightedByteSize);\n    }\n\n    final double delPercentage = 100.0 * totalDelCount / totalMaxDoc;\n    assertTrue(\"Percentage of deleted docs \" + delPercentage + \" is larger than the target: \" + tmp.getDeletesPctAllowed(),\n        delPercentage <= tmp.getDeletesPctAllowed());\n\n    long levelSize = Math.max(minSegmentBytes, (long) (tmp.getFloorSegmentMB() * 1024 * 1024));\n    long bytesLeft = totalBytes;\n    double allowedSegCount = 0;\n    // below we make the assumption that segments that reached the max segment\n    // size divided by 2 don't need merging anymore\n    int mergeFactor = (int) Math.min(tmp.getSegmentsPerTier(), tmp.getMaxMergeAtOnce());\n    while (true) {\n      final double segCountLevel = bytesLeft / (double) levelSize;\n      if (segCountLevel < tmp.getSegmentsPerTier() || levelSize >= maxMergedSegmentBytes / 2) {\n        allowedSegCount += Math.ceil(segCountLevel);\n        break;\n      }\n      allowedSegCount += tmp.getSegmentsPerTier();\n      bytesLeft -= tmp.getSegmentsPerTier() * levelSize;\n      levelSize = Math.min(levelSize * mergeFactor, maxMergedSegmentBytes / 2);\n    }\n    allowedSegCount = Math.max(allowedSegCount, tmp.getSegmentsPerTier());\n\n    int numSegments = infos.asList().size();\n    assertTrue(\"numSegments=\" + numSegments + \", allowed=\" + allowedSegCount, numSegments <= allowedSegCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1cddcfccab27b3211b29120b51033ab04e569ff9","date":1580914291,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#assertSegmentInfos(MergePolicy,SegmentInfos).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#assertSegmentInfos(MergePolicy,SegmentInfos).mjava","sourceNew":"  @Override\n  protected void assertSegmentInfos(MergePolicy policy, SegmentInfos infos) throws IOException {\n    TieredMergePolicy tmp = (TieredMergePolicy) policy;\n\n    final long maxMergedSegmentBytes = (long) (tmp.getMaxMergedSegmentMB() * 1024 * 1024);\n\n    long minSegmentBytes = Long.MAX_VALUE;\n    int totalDelCount = 0;\n    int totalMaxDoc = 0;\n    long totalBytes = 0;\n    for (SegmentCommitInfo sci : infos) {\n      totalDelCount += sci.getDelCount();\n      totalMaxDoc += sci.info.maxDoc();\n      long byteSize = sci.sizeInBytes();\n      double liveRatio = 1 - (double) sci.getDelCount() / sci.info.maxDoc();\n      long weightedByteSize = (long) (liveRatio * byteSize);\n      totalBytes += weightedByteSize;\n      minSegmentBytes = Math.min(minSegmentBytes, weightedByteSize);\n    }\n\n    final double delPercentage = 100.0 * totalDelCount / totalMaxDoc;\n    assertTrue(\"Percentage of deleted docs \" + delPercentage + \" is larger than the target: \" + tmp.getDeletesPctAllowed(),\n        delPercentage <= tmp.getDeletesPctAllowed());\n\n    long levelSizeBytes = Math.max(minSegmentBytes, (long) (tmp.getFloorSegmentMB() * 1024 * 1024));\n    long bytesLeft = totalBytes;\n    double allowedSegCount = 0;\n    // below we make the assumption that segments that reached the max segment\n    // size divided by 2 don't need merging anymore\n    int mergeFactor = (int) Math.min(tmp.getSegmentsPerTier(), tmp.getMaxMergeAtOnce());\n    while (true) {\n      final double segCountLevel = bytesLeft / (double) levelSizeBytes;\n      if (segCountLevel < tmp.getSegmentsPerTier() || levelSizeBytes >= maxMergedSegmentBytes / 2) {\n        allowedSegCount += Math.ceil(segCountLevel);\n        break;\n      }\n      allowedSegCount += tmp.getSegmentsPerTier();\n      bytesLeft -= tmp.getSegmentsPerTier() * levelSizeBytes;\n      levelSizeBytes = Math.min(levelSizeBytes * mergeFactor, maxMergedSegmentBytes / 2);\n    }\n    allowedSegCount = Math.max(allowedSegCount, tmp.getSegmentsPerTier());\n\n    int numSegments = infos.asList().size();\n    assertTrue(String.format(Locale.ROOT,\n                             \"mergeFactor=%d minSegmentBytes=%,d maxMergedSegmentBytes=%,d segmentsPerTier=%g maxMergeAtOnce=%d numSegments=%d allowed=%g totalBytes=%,d delPercentage=%g deletesPctAllowed=%g\",\n                             mergeFactor,\n                             minSegmentBytes,\n                             maxMergedSegmentBytes,\n                             tmp.getSegmentsPerTier(),\n                             tmp.getMaxMergeAtOnce(),\n                             numSegments,\n                             allowedSegCount,\n                             totalBytes,\n                             delPercentage,\n                             tmp.getDeletesPctAllowed()),\n                             numSegments <= allowedSegCount);\n  }\n\n","sourceOld":"  @Override\n  protected void assertSegmentInfos(MergePolicy policy, SegmentInfos infos) throws IOException {\n    TieredMergePolicy tmp = (TieredMergePolicy) policy;\n\n    final long maxMergedSegmentBytes = (long) (tmp.getMaxMergedSegmentMB() * 1024 * 1024);\n\n    long minSegmentBytes = Long.MAX_VALUE;\n    int totalDelCount = 0;\n    int totalMaxDoc = 0;\n    long totalBytes = 0;\n    for (SegmentCommitInfo sci : infos) {\n      totalDelCount += sci.getDelCount();\n      totalMaxDoc += sci.info.maxDoc();\n      long byteSize = sci.sizeInBytes();\n      double liveRatio = 1 - (double) sci.getDelCount() / sci.info.maxDoc();\n      long weightedByteSize = Math.round(liveRatio * byteSize);\n      totalBytes += weightedByteSize;\n      minSegmentBytes = Math.min(minSegmentBytes, weightedByteSize);\n    }\n\n    final double delPercentage = 100.0 * totalDelCount / totalMaxDoc;\n    assertTrue(\"Percentage of deleted docs \" + delPercentage + \" is larger than the target: \" + tmp.getDeletesPctAllowed(),\n        delPercentage <= tmp.getDeletesPctAllowed());\n\n    long levelSize = Math.max(minSegmentBytes, (long) (tmp.getFloorSegmentMB() * 1024 * 1024));\n    long bytesLeft = totalBytes;\n    double allowedSegCount = 0;\n    // below we make the assumption that segments that reached the max segment\n    // size divided by 2 don't need merging anymore\n    int mergeFactor = (int) Math.min(tmp.getSegmentsPerTier(), tmp.getMaxMergeAtOnce());\n    while (true) {\n      final double segCountLevel = bytesLeft / (double) levelSize;\n      if (segCountLevel < tmp.getSegmentsPerTier() || levelSize >= maxMergedSegmentBytes / 2) {\n        allowedSegCount += Math.ceil(segCountLevel);\n        break;\n      }\n      allowedSegCount += tmp.getSegmentsPerTier();\n      bytesLeft -= tmp.getSegmentsPerTier() * levelSize;\n      levelSize = Math.min(levelSize * mergeFactor, maxMergedSegmentBytes / 2);\n    }\n    allowedSegCount = Math.max(allowedSegCount, tmp.getSegmentsPerTier());\n\n    int numSegments = infos.asList().size();\n    assertTrue(\"numSegments=\" + numSegments + \", allowed=\" + allowedSegCount, numSegments <= allowedSegCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70544d57ad77b2a0111e979c54096a9b191c99df":["4a90cc8c90aa53ddf51fbd15019989ac269514a3"],"da0d58b6bf72ebfd4d6722289ea725809c20c987":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4a90cc8c90aa53ddf51fbd15019989ac269514a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1cddcfccab27b3211b29120b51033ab04e569ff9":["70544d57ad77b2a0111e979c54096a9b191c99df"],"4a90cc8c90aa53ddf51fbd15019989ac269514a3":["da0d58b6bf72ebfd4d6722289ea725809c20c987"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1cddcfccab27b3211b29120b51033ab04e569ff9"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","da0d58b6bf72ebfd4d6722289ea725809c20c987"]},"commit2Childs":{"70544d57ad77b2a0111e979c54096a9b191c99df":["1cddcfccab27b3211b29120b51033ab04e569ff9"],"da0d58b6bf72ebfd4d6722289ea725809c20c987":["4a90cc8c90aa53ddf51fbd15019989ac269514a3","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["da0d58b6bf72ebfd4d6722289ea725809c20c987","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"4a90cc8c90aa53ddf51fbd15019989ac269514a3":["70544d57ad77b2a0111e979c54096a9b191c99df","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"1cddcfccab27b3211b29120b51033ab04e569ff9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}