{"path":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","commits":[{"id":"83ede60c0b5bb96ad193414bbd663193b56689b3","date":1338331478,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","pathOld":"/dev/null","sourceNew":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setIndexed(false);\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    SlowCompositeReaderWrapper slow = new SlowCompositeReaderWrapper(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392","date":1377503666,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","sourceNew":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setIndexed(false);\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    AtomicReader slow = SlowCompositeReaderWrapper.wrap(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setIndexed(false);\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    SlowCompositeReaderWrapper slow = new SlowCompositeReaderWrapper(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","sourceNew":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setIndexed(false);\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    AtomicReader slow = SlowCompositeReaderWrapper.wrap(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setIndexed(false);\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    SlowCompositeReaderWrapper slow = new SlowCompositeReaderWrapper(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","sourceNew":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setIndexed(false);\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    AtomicReader slow = SlowCompositeReaderWrapper.wrap(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.shutdown();\n    dir.close();\n  }\n\n","sourceOld":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setIndexed(false);\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    AtomicReader slow = SlowCompositeReaderWrapper.wrap(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","sourceNew":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setIndexed(false);\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    AtomicReader slow = SlowCompositeReaderWrapper.wrap(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setIndexed(false);\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    AtomicReader slow = SlowCompositeReaderWrapper.wrap(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.shutdown();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","sourceNew":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setIndexed(false);\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    LeafReader slow = SlowCompositeReaderWrapper.wrap(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setIndexed(false);\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    AtomicReader slow = SlowCompositeReaderWrapper.wrap(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3184874f7f3aca850248483485b4995343066875","date":1413876758,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","sourceNew":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    LeafReader slow = SlowCompositeReaderWrapper.wrap(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setIndexed(false);\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    LeafReader slow = SlowCompositeReaderWrapper.wrap(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","sourceNew":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    LeafReader slow = SlowCompositeReaderWrapper.wrap(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setIndexed(false);\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    LeafReader slow = SlowCompositeReaderWrapper.wrap(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","date":1457644139,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","sourceNew":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    FieldInfos fis = MultiFields.getMergedFieldInfos(ir);\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    ir.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    LeafReader slow = SlowCompositeReaderWrapper.wrap(ir);\n    FieldInfos fis = slow.getFieldInfos();\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    slow.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","bugFix":["c9fb5f46e264daf5ba3860defe623a89d202dd87","83ede60c0b5bb96ad193414bbd663193b56689b3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets#testWithUnindexedFields().mjava","sourceNew":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    FieldInfos fis = FieldInfos.getMergedFieldInfos(ir);\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    ir.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testWithUnindexedFields() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);\n    for (int i = 0; i < 100; i++) {\n      Document doc = new Document();\n      // ensure at least one doc is indexed with offsets\n      if (i < 99 && random().nextInt(2) == 0) {\n        // stored only\n        FieldType ft = new FieldType();\n        ft.setStored(true);\n        doc.add(new Field(\"foo\", \"boo!\", ft));\n      } else {\n        FieldType ft = new FieldType(TextField.TYPE_STORED);\n        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n        if (random().nextBoolean()) {\n          // store some term vectors for the checkindex cross-check\n          ft.setStoreTermVectors(true);\n          ft.setStoreTermVectorPositions(true);\n          ft.setStoreTermVectorOffsets(true);\n        }\n        doc.add(new Field(\"foo\", \"bar\", ft));\n      }\n      riw.addDocument(doc);\n    }\n    CompositeReader ir = riw.getReader();\n    FieldInfos fis = MultiFields.getMergedFieldInfos(ir);\n    assertEquals(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS, fis.fieldInfo(\"foo\").getIndexOptions());\n    ir.close();\n    ir.close();\n    riw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["3184874f7f3aca850248483485b4995343066875"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["c9fb5f46e264daf5ba3860defe623a89d202dd87","3184874f7f3aca850248483485b4995343066875"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["83ede60c0b5bb96ad193414bbd663193b56689b3","df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392":["83ede60c0b5bb96ad193414bbd663193b56689b3"],"83ede60c0b5bb96ad193414bbd663193b56689b3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392"],"3184874f7f3aca850248483485b4995343066875":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["04e775de416dd2d8067b10db1c8af975a1d5017e"]},"commit2Childs":{"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["83ede60c0b5bb96ad193414bbd663193b56689b3"],"83ede60c0b5bb96ad193414bbd663193b56689b3":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392"],"df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3184874f7f3aca850248483485b4995343066875":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","3184874f7f3aca850248483485b4995343066875"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}