{"path":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f08557cdb6c60ac7b88a9342c983a20cd236e74f","date":1330954480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = LuceneTestCase.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = LuceneTestCase.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b0f649857e40b1429ab946a302da32f695eed9f","date":1339002543,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        IOContext context = LuceneTestCase.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = LuceneTestCase.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"edb74c83fff94196b864e08ca033d92823252cb7","date":1339593164,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        IOContext context = LuceneTestCase.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        IOContext context = LuceneTestCase.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ebe14aae60589c9bb6423f3cce02d5f599e1540","date":1348361556,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","sourceNew":null,"sourceOld":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        IOContext context = LuceneTestCase.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2b0f649857e40b1429ab946a302da32f695eed9f":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"edb74c83fff94196b864e08ca033d92823252cb7":["2b0f649857e40b1429ab946a302da32f695eed9f"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["edb74c83fff94196b864e08ca033d92823252cb7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"]},"commit2Childs":{"2b0f649857e40b1429ab946a302da32f695eed9f":["edb74c83fff94196b864e08ca033d92823252cb7"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["2b0f649857e40b1429ab946a302da32f695eed9f","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"edb74c83fff94196b864e08ca033d92823252cb7":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}