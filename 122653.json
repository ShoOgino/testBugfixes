{"path":"src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","commits":[{"id":"455aeff4fef915340c5b19d71d5e147034e83093","date":1210099270,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.  This also clears a\n   * previous call to {@link #prepareCommit}.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void rollback() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    boolean doClose;\n    synchronized(this) {\n\n      if (pendingCommit != null) {\n        pendingCommit.rollbackCommit(directory);\n        deleter.decRef(pendingCommit);\n        pendingCommit = null;\n        notifyAll();\n      }\n\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n\n    if (doClose) {\n\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort(null);\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      lastCommitChangeCount = changeCount;\n      closeInternal(false);\n    } else\n      waitForClose();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c619aff1490fbcbfb8aee81049da5e5120a986d6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5350389bf83287111f7760b9e3db3af8e3648474","date":1216372812,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.  This also clears a\n   * previous call to {@link #prepareCommit}.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void rollback() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    boolean doClose;\n    synchronized(this) {\n\n      if (pendingCommit != null) {\n        pendingCommit.rollbackCommit(directory);\n        deleter.decRef(pendingCommit);\n        pendingCommit = null;\n        notifyAll();\n      }\n\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n\n    if (doClose) {\n\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n        \n        docWriter.abort();\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      lastCommitChangeCount = changeCount;\n      closeInternal(false);\n    } else\n      waitForClose();\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.  This also clears a\n   * previous call to {@link #prepareCommit}.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void rollback() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    boolean doClose;\n    synchronized(this) {\n\n      if (pendingCommit != null) {\n        pendingCommit.rollbackCommit(directory);\n        deleter.decRef(pendingCommit);\n        pendingCommit = null;\n        notifyAll();\n      }\n\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n\n    if (doClose) {\n\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort(null);\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      lastCommitChangeCount = changeCount;\n      closeInternal(false);\n    } else\n      waitForClose();\n  }\n\n","bugFix":null,"bugIntro":["c619aff1490fbcbfb8aee81049da5e5120a986d6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c619aff1490fbcbfb8aee81049da5e5120a986d6","date":1217432296,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.  This also clears a\n   * previous call to {@link #prepareCommit}.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void rollback() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"rollback() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose())\n      rollbackInternal();\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.  This also clears a\n   * previous call to {@link #prepareCommit}.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void rollback() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    boolean doClose;\n    synchronized(this) {\n\n      if (pendingCommit != null) {\n        pendingCommit.rollbackCommit(directory);\n        deleter.decRef(pendingCommit);\n        pendingCommit = null;\n        notifyAll();\n      }\n\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n\n    if (doClose) {\n\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n        \n        docWriter.abort();\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      lastCommitChangeCount = changeCount;\n      closeInternal(false);\n    } else\n      waitForClose();\n  }\n\n","bugFix":["5350389bf83287111f7760b9e3db3af8e3648474","455aeff4fef915340c5b19d71d5e147034e83093"],"bugIntro":["f241b963c5bcd6c2293a928059dd2d64988a6042"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"21f42c5119845e5fc16b67d61fa8926d1d8220ef","date":1235438411,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any changes that have occurred since the last commit\n   * (or since it was opened, if commit hasn't been called).\n   * This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.  This also clears a\n   * previous call to {@link #prepareCommit}.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void rollback() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"rollback() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose())\n      rollbackInternal();\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.  This also clears a\n   * previous call to {@link #prepareCommit}.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void rollback() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"rollback() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose())\n      rollbackInternal();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3215ae1377fc1ca1790921d75dd39cb764743b85","date":1237371771,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any changes that have occurred since the last commit\n   * (or since it was opened, if commit hasn't been called).\n   * This removes any temporary files that had been created,\n   * after which the state of the index will be the same as\n   * it was when commit() was last called or when this\n   * writer was first opened.  This can only be called when\n   * this IndexWriter was opened with\n   * <code>autoCommit=false</code>.  This also clears a\n   * previous call to {@link #prepareCommit}.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void rollback() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"rollback() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose())\n      rollbackInternal();\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any changes that have occurred since the last commit\n   * (or since it was opened, if commit hasn't been called).\n   * This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.  This also clears a\n   * previous call to {@link #prepareCommit}.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void rollback() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"rollback() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose())\n      rollbackInternal();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"87c966e9308847938a7c905c2e46a56d8df788b8","date":1255035452,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any changes that have occurred since the last commit\n   * (or since it was opened, if commit hasn't been called).\n   * This removes any temporary files that had been created,\n   * after which the state of the index will be the same as\n   * it was when commit() was last called or when this\n   * writer was first opened.  This also clears a previous\n   * call to {@link #prepareCommit}.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void rollback() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"rollback() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose())\n      rollbackInternal();\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any changes that have occurred since the last commit\n   * (or since it was opened, if commit hasn't been called).\n   * This removes any temporary files that had been created,\n   * after which the state of the index will be the same as\n   * it was when commit() was last called or when this\n   * writer was first opened.  This can only be called when\n   * this IndexWriter was opened with\n   * <code>autoCommit=false</code>.  This also clears a\n   * previous call to {@link #prepareCommit}.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void rollback() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"rollback() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose())\n      rollbackInternal();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ce99e2b80b5a9cb2b9b59c01219e5397b081dcd8","date":1255049357,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any changes that have occurred since the last commit\n   * (or since it was opened, if commit hasn't been called).\n   * This removes any temporary files that had been created,\n   * after which the state of the index will be the same as\n   * it was when commit() was last called or when this\n   * writer was first opened.  This also clears a previous\n   * call to {@link #prepareCommit}.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void rollback() throws IOException {\n    ensureOpen();\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose())\n      rollbackInternal();\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any changes that have occurred since the last commit\n   * (or since it was opened, if commit hasn't been called).\n   * This removes any temporary files that had been created,\n   * after which the state of the index will be the same as\n   * it was when commit() was last called or when this\n   * writer was first opened.  This also clears a previous\n   * call to {@link #prepareCommit}.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void rollback() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"rollback() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose())\n      rollbackInternal();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#rollback().mjava","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any changes that have occurred since the last commit\n   * (or since it was opened, if commit hasn't been called).\n   * This removes any temporary files that had been created,\n   * after which the state of the index will be the same as\n   * it was when commit() was last called or when this\n   * writer was first opened.  This also clears a previous\n   * call to {@link #prepareCommit}.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void rollback() throws IOException {\n    ensureOpen();\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose())\n      rollbackInternal();\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any changes that have occurred since the last commit\n   * (or since it was opened, if commit hasn't been called).\n   * This removes any temporary files that had been created,\n   * after which the state of the index will be the same as\n   * it was when commit() was last called or when this\n   * writer was first opened.  This also clears a previous\n   * call to {@link #prepareCommit}.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void rollback() throws IOException {\n    ensureOpen();\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose())\n      rollbackInternal();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"21f42c5119845e5fc16b67d61fa8926d1d8220ef":["c619aff1490fbcbfb8aee81049da5e5120a986d6"],"c619aff1490fbcbfb8aee81049da5e5120a986d6":["5350389bf83287111f7760b9e3db3af8e3648474"],"455aeff4fef915340c5b19d71d5e147034e83093":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3215ae1377fc1ca1790921d75dd39cb764743b85":["21f42c5119845e5fc16b67d61fa8926d1d8220ef"],"ce99e2b80b5a9cb2b9b59c01219e5397b081dcd8":["87c966e9308847938a7c905c2e46a56d8df788b8"],"87c966e9308847938a7c905c2e46a56d8df788b8":["3215ae1377fc1ca1790921d75dd39cb764743b85"],"5350389bf83287111f7760b9e3db3af8e3648474":["455aeff4fef915340c5b19d71d5e147034e83093"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["ce99e2b80b5a9cb2b9b59c01219e5397b081dcd8"]},"commit2Childs":{"21f42c5119845e5fc16b67d61fa8926d1d8220ef":["3215ae1377fc1ca1790921d75dd39cb764743b85"],"c619aff1490fbcbfb8aee81049da5e5120a986d6":["21f42c5119845e5fc16b67d61fa8926d1d8220ef"],"455aeff4fef915340c5b19d71d5e147034e83093":["5350389bf83287111f7760b9e3db3af8e3648474"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["455aeff4fef915340c5b19d71d5e147034e83093"],"3215ae1377fc1ca1790921d75dd39cb764743b85":["87c966e9308847938a7c905c2e46a56d8df788b8"],"ce99e2b80b5a9cb2b9b59c01219e5397b081dcd8":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"87c966e9308847938a7c905c2e46a56d8df788b8":["ce99e2b80b5a9cb2b9b59c01219e5397b081dcd8"],"5350389bf83287111f7760b9e3db3af8e3648474":["c619aff1490fbcbfb8aee81049da5e5120a986d6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}