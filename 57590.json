{"path":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/Plane#recordBounds(PlanetModel,LatLonBounds,Membership...).mjava","commits":[{"id":"f64b7098768253180859cd8faeae6b1a185b06ed","date":1441223971,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/Plane#recordBounds(PlanetModel,LatLonBounds,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/Plane#recordBounds(PlanetModel,Bounds,Membership...).mjava","sourceNew":"  /**\n   * Accumulate bounds information for this plane, intersected with the unit sphere.\n   * Updates both latitude and longitude information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the lat/lon info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final LatLonBounds boundsInfo, final Membership... bounds) {\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Now compute latitude min/max points\n    if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n      //System.err.println(\"Looking at latitude for plane \"+this);\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a horizontal circle!\n        //System.err.println(\" Not a horizontal circle\");\n        final Plane verticalPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, verticalPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Horizontal circle.  Since a==b, any vertical plane suffices.\n        final GeoPoint[] points = findIntersections(planetModel, normalXPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n      //System.err.println(\"Done latitude bounds\");\n    }\n\n    // First, figure out our longitude bounds, unless we no longer need to consider that\n    if (!boundsInfo.checkNoLongitudeBound()) {\n      //System.err.println(\"Computing longitude bounds for \"+this);\n      //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n      // Compute longitude bounds\n\n      double a;\n      double b;\n      double c;\n\n      if (Math.abs(C) < MINIMUM_RESOLUTION) {\n        // Degenerate; the equation describes a line\n        //System.out.println(\"It's a zero-width ellipse\");\n        // Ax + By + D = 0\n        if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n          if (Math.abs(A) > Math.abs(B)) {\n            // Use equation suitable for A != 0\n            // We need to find the endpoints of the zero-width ellipse.\n            // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n            // of that line.  But luckily, we know some things: specifically, since it is a\n            // degenerate situation in projection, the C value had to have been 0.  That\n            // means that our line's endpoints will coincide with the projected ellipse.  All we\n            // need to do then is to find the intersection of the projected ellipse and the line\n            // equation:\n            //\n            // A x + B y + D = 0\n            //\n            // Since A != 0:\n            // x = (-By - D)/A\n            //\n            // The projected ellipse:\n            // x^2/a^2 + y^2/b^2 - 1 = 0\n            // Substitute:\n            // [(-By-D)/A]^2/a^2 + y^2/b^2 -1 = 0\n            // Multiply through by A^2:\n            // [-By - D]^2/a^2 + A^2*y^2/b^2 - A^2 = 0\n            // Multiply out:\n            // B^2*y^2/a^2 + 2BDy/a^2 + D^2/a^2 + A^2*y^2/b^2 - A^2 = 0\n            // Group:\n            // y^2 * [B^2/a^2 + A^2/b^2] + y [2BD/a^2] + [D^2/a^2-A^2] = 0\n\n            a = B * B * planetModel.inverseAbSquared + A * A * planetModel.inverseAbSquared;\n            b = 2.0 * B * D * planetModel.inverseAbSquared;\n            c = D * D * planetModel.inverseAbSquared - A * A;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double y0 = -b / (2.0 * a);\n              double x0 = (-D - B * y0) / A;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, new GeoPoint(x0, y0, z0));\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / A;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n\n              double x0a = (-D - B * y0a) * Hdenom;\n              double x0b = (-D - B * y0b) * Hdenom;\n\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, new GeoPoint(x0a, y0a, z0a));\n              addPoint(boundsInfo, bounds, new GeoPoint(x0b, y0b, z0b));\n            }\n\n          } else {\n            // Use equation suitable for B != 0\n            // Since I != 0, we rewrite:\n            // y = (-Ax - D)/B\n            a = B * B * planetModel.inverseAbSquared + A * A * planetModel.inverseAbSquared;\n            b = 2.0 * A * D * planetModel.inverseAbSquared;\n            c = D * D * planetModel.inverseAbSquared - B * B;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double x0 = -b / (2.0 * a);\n              double y0 = (-D - A * x0) / B;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, new GeoPoint(x0, y0, z0));\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / B;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-D - A * x0a) * Idenom;\n              double y0b = (-D - A * x0b) * Idenom;\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, new GeoPoint(x0a, y0a, z0a));\n              addPoint(boundsInfo, bounds, new GeoPoint(x0b, y0b, z0b));\n            }\n          }\n        }\n\n      } else {\n        //System.err.println(\"General longitude bounds...\");\n\n        // NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.\n        // They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,\n        // and z for latitude, and that's all the values are good for.\n\n        // (1) Intersect the plane and the ellipsoid, and project the results into the x-y plane:\n        // From plane:\n        // z = (-Ax - By - D) / C\n        // From ellipsoid:\n        // x^2/a^2 + y^2/b^2 + [(-Ax - By - D) / C]^2/c^2 = 1\n        // Simplify/expand:\n        // C^2*x^2/a^2 + C^2*y^2/b^2 + (-Ax - By - D)^2/c^2 = C^2\n        //\n        // x^2 * C^2/a^2 + y^2 * C^2/b^2 + x^2 * A^2/c^2 + ABxy/c^2 + ADx/c^2 + ABxy/c^2 + y^2 * B^2/c^2 + BDy/c^2 + ADx/c^2 + BDy/c^2 + D^2/c^2 = C^2\n        // Group:\n        // [A^2/c^2 + C^2/a^2] x^2 + [B^2/c^2 + C^2/b^2] y^2 + [2AB/c^2]xy + [2AD/c^2]x + [2BD/c^2]y + [D^2/c^2-C^2] = 0\n        // For convenience, introduce post-projection coefficient variables to make life easier.\n        // E x^2 + F y^2 + G xy + H x + I y + J = 0\n        double E = A * A * planetModel.inverseCSquared + C * C * planetModel.inverseAbSquared;\n        double F = B * B * planetModel.inverseCSquared + C * C * planetModel.inverseAbSquared;\n        double G = 2.0 * A * B * planetModel.inverseCSquared;\n        double H = 2.0 * A * D * planetModel.inverseCSquared;\n        double I = 2.0 * B * D * planetModel.inverseCSquared;\n        double J = D * D * planetModel.inverseCSquared - C * C;\n\n        //System.err.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n\n        // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n        if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {\n          // The derivative of the curve above is:\n          // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n          // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n          // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n          //\n          // The equation of a line going through the origin with the slope dy/dx is:\n          // y = dy/dx x\n          // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n          // Rearrange:\n          // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n          // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n          // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n          //\n          // Multiply the original equation by 2:\n          // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n          // Subtract one from the other, to remove the high-order terms:\n          // Hx + Iy + 2J = 0\n          // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n          // But we will need to base this on which coefficient is non-zero\n\n          if (Math.abs(H) > Math.abs(I)) {\n            //System.err.println(\" Using the y quadratic\");\n            // x = (-2J - Iy)/H\n\n            // Plug into the original equation:\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n            // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n\n            // Plug into derivative equation:\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n            // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n            // Multiply by H^2 to make manipulation easier\n            // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n            // Do the square\n            // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n            // Multiply it out\n            // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n            // Group:\n            // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * E * I * J - 2.0 * G * H * J;\n            c = 4.0 * E * J * J - J * H * H;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution\");\n              double y0 = -b / (2.0 * a);\n              double x0 = (-2.0 * J - I * y0) / H;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n\n              addPoint(boundsInfo, bounds, new GeoPoint(x0, y0, z0));\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / H;\n              double Cdenom = 1.0 / C;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n              double x0a = (-2.0 * J - I * y0a) * Hdenom;\n              double x0b = (-2.0 * J - I * y0b) * Hdenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, new GeoPoint(x0a, y0a, z0a));\n              addPoint(boundsInfo, bounds, new GeoPoint(x0b, y0b, z0b));\n            }\n\n          } else {\n            //System.err.println(\" Using the x quadratic\");\n            // y = (-2J - Hx)/I\n\n            // Plug into the original equation:\n            // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n            // Multiply by I^2 to make manipulation easier\n            // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n            // Do the square\n            // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n            // Multiply it out\n            // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n            // Group:\n            // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n            // E x^2 + F y^2 + G xy + H x + I y + J = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * F * H * J - 2.0 * G * I * J;\n            c = 4.0 * F * J * J - J * I * I;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution; sqrt clause was \"+sqrtClause);\n              double x0 = -b / (2.0 * a);\n              double y0 = (-2.0 * J - H * x0) / I;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n              // Verify that x&y fulfill the equation\n              // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n              addPoint(boundsInfo, bounds, new GeoPoint(x0, y0, z0));\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / I;\n              double Cdenom = 1.0 / C;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-2.0 * J - H * x0a) * Idenom;\n              double y0b = (-2.0 * J - H * x0b) * Idenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, new GeoPoint(x0a, y0a, z0a));\n              addPoint(boundsInfo, bounds, new GeoPoint(x0b, y0b, z0b));\n            }\n          }\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Accumulate bounds information for this plane, intersected with the unit sphere.\n   * Updates both latitude and longitude information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final Bounds boundsInfo, final Membership... bounds) {\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Now compute latitude min/max points\n    if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n      //System.err.println(\"Looking at latitude for plane \"+this);\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a horizontal circle!\n        //System.err.println(\" Not a horizontal circle\");\n        final Plane verticalPlane = constructNormalizedVerticalPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, verticalPlane, NO_BOUNDS, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          addPoint(boundsInfo, bounds, point.x, point.y, point.z);\n        }\n      } else {\n        // Horizontal circle.  Since a==b, one vertical plane suffices.\n        final Plane verticalPlane = new Plane(1.0,0.0);\n        final GeoPoint[] points = findIntersections(planetModel, verticalPlane, NO_BOUNDS, NO_BOUNDS);\n        // There will always be two points; we only need one.\n        final GeoPoint point = points[0];\n        boundsInfo.addHorizontalCircle(point.z/Math.sqrt(point.x * point.x + point.y * point.y + point.z * point.z));\n      }\n      //System.err.println(\"Done latitude bounds\");\n    }\n\n    // First, figure out our longitude bounds, unless we no longer need to consider that\n    if (!boundsInfo.checkNoLongitudeBound()) {\n      //System.err.println(\"Computing longitude bounds for \"+this);\n      //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n      // Compute longitude bounds\n\n      double a;\n      double b;\n      double c;\n\n      if (Math.abs(C) < MINIMUM_RESOLUTION) {\n        // Degenerate; the equation describes a line\n        //System.out.println(\"It's a zero-width ellipse\");\n        // Ax + By + D = 0\n        if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n          if (Math.abs(A) > Math.abs(B)) {\n            // Use equation suitable for A != 0\n            // We need to find the endpoints of the zero-width ellipse.\n            // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n            // of that line.  But luckily, we know some things: specifically, since it is a\n            // degenerate situation in projection, the C value had to have been 0.  That\n            // means that our line's endpoints will coincide with the projected ellipse.  All we\n            // need to do then is to find the intersection of the projected ellipse and the line\n            // equation:\n            //\n            // A x + B y + D = 0\n            //\n            // Since A != 0:\n            // x = (-By - D)/A\n            //\n            // The projected ellipse:\n            // x^2/a^2 + y^2/b^2 - 1 = 0\n            // Substitute:\n            // [(-By-D)/A]^2/a^2 + y^2/b^2 -1 = 0\n            // Multiply through by A^2:\n            // [-By - D]^2/a^2 + A^2*y^2/b^2 - A^2 = 0\n            // Multiply out:\n            // B^2*y^2/a^2 + 2BDy/a^2 + D^2/a^2 + A^2*y^2/b^2 - A^2 = 0\n            // Group:\n            // y^2 * [B^2/a^2 + A^2/b^2] + y [2BD/a^2] + [D^2/a^2-A^2] = 0\n\n            a = B * B * planetModel.inverseAbSquared + A * A * planetModel.inverseAbSquared;\n            b = 2.0 * B * D * planetModel.inverseAbSquared;\n            c = D * D * planetModel.inverseAbSquared - A * A;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double y0 = -b / (2.0 * a);\n              double x0 = (-D - B * y0) / A;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / A;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n\n              double x0a = (-D - B * y0a) * Hdenom;\n              double x0b = (-D - B * y0b) * Hdenom;\n\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            // Use equation suitable for B != 0\n            // Since I != 0, we rewrite:\n            // y = (-Ax - D)/B\n            a = B * B * planetModel.inverseAbSquared + A * A * planetModel.inverseAbSquared;\n            b = 2.0 * A * D * planetModel.inverseAbSquared;\n            c = D * D * planetModel.inverseAbSquared - B * B;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double x0 = -b / (2.0 * a);\n              double y0 = (-D - A * x0) / B;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / B;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-D - A * x0a) * Idenom;\n              double y0b = (-D - A * x0b) * Idenom;\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n\n      } else {\n        //System.err.println(\"General longitude bounds...\");\n\n        // NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.\n        // They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,\n        // and z for latitude, and that's all the values are good for.\n\n        // (1) Intersect the plane and the ellipsoid, and project the results into the x-y plane:\n        // From plane:\n        // z = (-Ax - By - D) / C\n        // From ellipsoid:\n        // x^2/a^2 + y^2/b^2 + [(-Ax - By - D) / C]^2/c^2 = 1\n        // Simplify/expand:\n        // C^2*x^2/a^2 + C^2*y^2/b^2 + (-Ax - By - D)^2/c^2 = C^2\n        //\n        // x^2 * C^2/a^2 + y^2 * C^2/b^2 + x^2 * A^2/c^2 + ABxy/c^2 + ADx/c^2 + ABxy/c^2 + y^2 * B^2/c^2 + BDy/c^2 + ADx/c^2 + BDy/c^2 + D^2/c^2 = C^2\n        // Group:\n        // [A^2/c^2 + C^2/a^2] x^2 + [B^2/c^2 + C^2/b^2] y^2 + [2AB/c^2]xy + [2AD/c^2]x + [2BD/c^2]y + [D^2/c^2-C^2] = 0\n        // For convenience, introduce post-projection coefficient variables to make life easier.\n        // E x^2 + F y^2 + G xy + H x + I y + J = 0\n        double E = A * A * planetModel.inverseCSquared + C * C * planetModel.inverseAbSquared;\n        double F = B * B * planetModel.inverseCSquared + C * C * planetModel.inverseAbSquared;\n        double G = 2.0 * A * B * planetModel.inverseCSquared;\n        double H = 2.0 * A * D * planetModel.inverseCSquared;\n        double I = 2.0 * B * D * planetModel.inverseCSquared;\n        double J = D * D * planetModel.inverseCSquared - C * C;\n\n        //System.err.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n\n        // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n        if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {\n          // The derivative of the curve above is:\n          // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n          // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n          // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n          //\n          // The equation of a line going through the origin with the slope dy/dx is:\n          // y = dy/dx x\n          // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n          // Rearrange:\n          // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n          // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n          // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n          //\n          // Multiply the original equation by 2:\n          // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n          // Subtract one from the other, to remove the high-order terms:\n          // Hx + Iy + 2J = 0\n          // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n          // But we will need to base this on which coefficient is non-zero\n\n          if (Math.abs(H) > Math.abs(I)) {\n            //System.err.println(\" Using the y quadratic\");\n            // x = (-2J - Iy)/H\n\n            // Plug into the original equation:\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n            // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n\n            // Plug into derivative equation:\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n            // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n            // Multiply by H^2 to make manipulation easier\n            // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n            // Do the square\n            // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n            // Multiply it out\n            // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n            // Group:\n            // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * E * I * J - 2.0 * G * H * J;\n            c = 4.0 * E * J * J - J * H * H;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution\");\n              double y0 = -b / (2.0 * a);\n              double x0 = (-2.0 * J - I * y0) / H;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / H;\n              double Cdenom = 1.0 / C;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n              double x0a = (-2.0 * J - I * y0a) * Hdenom;\n              double x0b = (-2.0 * J - I * y0b) * Hdenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            //System.err.println(\" Using the x quadratic\");\n            // y = (-2J - Hx)/I\n\n            // Plug into the original equation:\n            // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n            // Multiply by I^2 to make manipulation easier\n            // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n            // Do the square\n            // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n            // Multiply it out\n            // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n            // Group:\n            // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n            // E x^2 + F y^2 + G xy + H x + I y + J = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * F * H * J - 2.0 * G * I * J;\n            c = 4.0 * F * J * J - J * I * I;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution; sqrt clause was \"+sqrtClause);\n              double x0 = -b / (2.0 * a);\n              double y0 = (-2.0 * J - H * x0) / I;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n              // Verify that x&y fulfill the equation\n              // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / I;\n              double Cdenom = 1.0 / C;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-2.0 * J - H * x0a) * Idenom;\n              double y0b = (-2.0 * J - H * x0b) * Idenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b4e444678504caf66a8060b1d514383aa4feac0c","date":1457399659,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,LatLonBounds,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/Plane#recordBounds(PlanetModel,LatLonBounds,Membership...).mjava","sourceNew":"  /**\n   * Accumulate bounds information for this plane, intersected with the unit sphere.\n   * Updates both latitude and longitude information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the lat/lon info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final LatLonBounds boundsInfo, final Membership... bounds) {\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Now compute latitude min/max points\n    if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n      //System.err.println(\"Looking at latitude for plane \"+this);\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a horizontal circle!\n        //System.err.println(\" Not a horizontal circle\");\n        final Plane verticalPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, verticalPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Horizontal circle.  Since a==b, any vertical plane suffices.\n        final GeoPoint[] points = findIntersections(planetModel, normalXPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n      //System.err.println(\"Done latitude bounds\");\n    }\n\n    // First, figure out our longitude bounds, unless we no longer need to consider that\n    if (!boundsInfo.checkNoLongitudeBound()) {\n      //System.err.println(\"Computing longitude bounds for \"+this);\n      //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n      // Compute longitude bounds\n\n      double a;\n      double b;\n      double c;\n\n      if (Math.abs(C) < MINIMUM_RESOLUTION) {\n        // Degenerate; the equation describes a line\n        //System.out.println(\"It's a zero-width ellipse\");\n        // Ax + By + D = 0\n        if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n          if (Math.abs(A) > Math.abs(B)) {\n            // Use equation suitable for A != 0\n            // We need to find the endpoints of the zero-width ellipse.\n            // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n            // of that line.  But luckily, we know some things: specifically, since it is a\n            // degenerate situation in projection, the C value had to have been 0.  That\n            // means that our line's endpoints will coincide with the projected ellipse.  All we\n            // need to do then is to find the intersection of the projected ellipse and the line\n            // equation:\n            //\n            // A x + B y + D = 0\n            //\n            // Since A != 0:\n            // x = (-By - D)/A\n            //\n            // The projected ellipse:\n            // x^2/a^2 + y^2/b^2 - 1 = 0\n            // Substitute:\n            // [(-By-D)/A]^2/a^2 + y^2/b^2 -1 = 0\n            // Multiply through by A^2:\n            // [-By - D]^2/a^2 + A^2*y^2/b^2 - A^2 = 0\n            // Multiply out:\n            // B^2*y^2/a^2 + 2BDy/a^2 + D^2/a^2 + A^2*y^2/b^2 - A^2 = 0\n            // Group:\n            // y^2 * [B^2/a^2 + A^2/b^2] + y [2BD/a^2] + [D^2/a^2-A^2] = 0\n\n            a = B * B * planetModel.inverseAbSquared + A * A * planetModel.inverseAbSquared;\n            b = 2.0 * B * D * planetModel.inverseAbSquared;\n            c = D * D * planetModel.inverseAbSquared - A * A;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double y0 = -b / (2.0 * a);\n              double x0 = (-D - B * y0) / A;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, new GeoPoint(x0, y0, z0));\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / A;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n\n              double x0a = (-D - B * y0a) * Hdenom;\n              double x0b = (-D - B * y0b) * Hdenom;\n\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, new GeoPoint(x0a, y0a, z0a));\n              addPoint(boundsInfo, bounds, new GeoPoint(x0b, y0b, z0b));\n            }\n\n          } else {\n            // Use equation suitable for B != 0\n            // Since I != 0, we rewrite:\n            // y = (-Ax - D)/B\n            a = B * B * planetModel.inverseAbSquared + A * A * planetModel.inverseAbSquared;\n            b = 2.0 * A * D * planetModel.inverseAbSquared;\n            c = D * D * planetModel.inverseAbSquared - B * B;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double x0 = -b / (2.0 * a);\n              double y0 = (-D - A * x0) / B;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, new GeoPoint(x0, y0, z0));\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / B;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-D - A * x0a) * Idenom;\n              double y0b = (-D - A * x0b) * Idenom;\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, new GeoPoint(x0a, y0a, z0a));\n              addPoint(boundsInfo, bounds, new GeoPoint(x0b, y0b, z0b));\n            }\n          }\n        }\n\n      } else {\n        //System.err.println(\"General longitude bounds...\");\n\n        // NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.\n        // They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,\n        // and z for latitude, and that's all the values are good for.\n\n        // (1) Intersect the plane and the ellipsoid, and project the results into the x-y plane:\n        // From plane:\n        // z = (-Ax - By - D) / C\n        // From ellipsoid:\n        // x^2/a^2 + y^2/b^2 + [(-Ax - By - D) / C]^2/c^2 = 1\n        // Simplify/expand:\n        // C^2*x^2/a^2 + C^2*y^2/b^2 + (-Ax - By - D)^2/c^2 = C^2\n        //\n        // x^2 * C^2/a^2 + y^2 * C^2/b^2 + x^2 * A^2/c^2 + ABxy/c^2 + ADx/c^2 + ABxy/c^2 + y^2 * B^2/c^2 + BDy/c^2 + ADx/c^2 + BDy/c^2 + D^2/c^2 = C^2\n        // Group:\n        // [A^2/c^2 + C^2/a^2] x^2 + [B^2/c^2 + C^2/b^2] y^2 + [2AB/c^2]xy + [2AD/c^2]x + [2BD/c^2]y + [D^2/c^2-C^2] = 0\n        // For convenience, introduce post-projection coefficient variables to make life easier.\n        // E x^2 + F y^2 + G xy + H x + I y + J = 0\n        double E = A * A * planetModel.inverseCSquared + C * C * planetModel.inverseAbSquared;\n        double F = B * B * planetModel.inverseCSquared + C * C * planetModel.inverseAbSquared;\n        double G = 2.0 * A * B * planetModel.inverseCSquared;\n        double H = 2.0 * A * D * planetModel.inverseCSquared;\n        double I = 2.0 * B * D * planetModel.inverseCSquared;\n        double J = D * D * planetModel.inverseCSquared - C * C;\n\n        //System.err.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n\n        // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n        if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {\n          // The derivative of the curve above is:\n          // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n          // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n          // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n          //\n          // The equation of a line going through the origin with the slope dy/dx is:\n          // y = dy/dx x\n          // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n          // Rearrange:\n          // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n          // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n          // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n          //\n          // Multiply the original equation by 2:\n          // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n          // Subtract one from the other, to remove the high-order terms:\n          // Hx + Iy + 2J = 0\n          // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n          // But we will need to base this on which coefficient is non-zero\n\n          if (Math.abs(H) > Math.abs(I)) {\n            //System.err.println(\" Using the y quadratic\");\n            // x = (-2J - Iy)/H\n\n            // Plug into the original equation:\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n            // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n\n            // Plug into derivative equation:\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n            // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n            // Multiply by H^2 to make manipulation easier\n            // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n            // Do the square\n            // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n            // Multiply it out\n            // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n            // Group:\n            // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * E * I * J - 2.0 * G * H * J;\n            c = 4.0 * E * J * J - J * H * H;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution\");\n              double y0 = -b / (2.0 * a);\n              double x0 = (-2.0 * J - I * y0) / H;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n\n              addPoint(boundsInfo, bounds, new GeoPoint(x0, y0, z0));\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / H;\n              double Cdenom = 1.0 / C;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n              double x0a = (-2.0 * J - I * y0a) * Hdenom;\n              double x0b = (-2.0 * J - I * y0b) * Hdenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, new GeoPoint(x0a, y0a, z0a));\n              addPoint(boundsInfo, bounds, new GeoPoint(x0b, y0b, z0b));\n            }\n\n          } else {\n            //System.err.println(\" Using the x quadratic\");\n            // y = (-2J - Hx)/I\n\n            // Plug into the original equation:\n            // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n            // Multiply by I^2 to make manipulation easier\n            // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n            // Do the square\n            // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n            // Multiply it out\n            // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n            // Group:\n            // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n            // E x^2 + F y^2 + G xy + H x + I y + J = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * F * H * J - 2.0 * G * I * J;\n            c = 4.0 * F * J * J - J * I * I;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution; sqrt clause was \"+sqrtClause);\n              double x0 = -b / (2.0 * a);\n              double y0 = (-2.0 * J - H * x0) / I;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n              // Verify that x&y fulfill the equation\n              // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n              addPoint(boundsInfo, bounds, new GeoPoint(x0, y0, z0));\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / I;\n              double Cdenom = 1.0 / C;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-2.0 * J - H * x0a) * Idenom;\n              double y0b = (-2.0 * J - H * x0b) * Idenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, new GeoPoint(x0a, y0a, z0a));\n              addPoint(boundsInfo, bounds, new GeoPoint(x0b, y0b, z0b));\n            }\n          }\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Accumulate bounds information for this plane, intersected with the unit sphere.\n   * Updates both latitude and longitude information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the lat/lon info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final LatLonBounds boundsInfo, final Membership... bounds) {\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Now compute latitude min/max points\n    if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n      //System.err.println(\"Looking at latitude for plane \"+this);\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a horizontal circle!\n        //System.err.println(\" Not a horizontal circle\");\n        final Plane verticalPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, verticalPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Horizontal circle.  Since a==b, any vertical plane suffices.\n        final GeoPoint[] points = findIntersections(planetModel, normalXPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n      //System.err.println(\"Done latitude bounds\");\n    }\n\n    // First, figure out our longitude bounds, unless we no longer need to consider that\n    if (!boundsInfo.checkNoLongitudeBound()) {\n      //System.err.println(\"Computing longitude bounds for \"+this);\n      //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n      // Compute longitude bounds\n\n      double a;\n      double b;\n      double c;\n\n      if (Math.abs(C) < MINIMUM_RESOLUTION) {\n        // Degenerate; the equation describes a line\n        //System.out.println(\"It's a zero-width ellipse\");\n        // Ax + By + D = 0\n        if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n          if (Math.abs(A) > Math.abs(B)) {\n            // Use equation suitable for A != 0\n            // We need to find the endpoints of the zero-width ellipse.\n            // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n            // of that line.  But luckily, we know some things: specifically, since it is a\n            // degenerate situation in projection, the C value had to have been 0.  That\n            // means that our line's endpoints will coincide with the projected ellipse.  All we\n            // need to do then is to find the intersection of the projected ellipse and the line\n            // equation:\n            //\n            // A x + B y + D = 0\n            //\n            // Since A != 0:\n            // x = (-By - D)/A\n            //\n            // The projected ellipse:\n            // x^2/a^2 + y^2/b^2 - 1 = 0\n            // Substitute:\n            // [(-By-D)/A]^2/a^2 + y^2/b^2 -1 = 0\n            // Multiply through by A^2:\n            // [-By - D]^2/a^2 + A^2*y^2/b^2 - A^2 = 0\n            // Multiply out:\n            // B^2*y^2/a^2 + 2BDy/a^2 + D^2/a^2 + A^2*y^2/b^2 - A^2 = 0\n            // Group:\n            // y^2 * [B^2/a^2 + A^2/b^2] + y [2BD/a^2] + [D^2/a^2-A^2] = 0\n\n            a = B * B * planetModel.inverseAbSquared + A * A * planetModel.inverseAbSquared;\n            b = 2.0 * B * D * planetModel.inverseAbSquared;\n            c = D * D * planetModel.inverseAbSquared - A * A;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double y0 = -b / (2.0 * a);\n              double x0 = (-D - B * y0) / A;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, new GeoPoint(x0, y0, z0));\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / A;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n\n              double x0a = (-D - B * y0a) * Hdenom;\n              double x0b = (-D - B * y0b) * Hdenom;\n\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, new GeoPoint(x0a, y0a, z0a));\n              addPoint(boundsInfo, bounds, new GeoPoint(x0b, y0b, z0b));\n            }\n\n          } else {\n            // Use equation suitable for B != 0\n            // Since I != 0, we rewrite:\n            // y = (-Ax - D)/B\n            a = B * B * planetModel.inverseAbSquared + A * A * planetModel.inverseAbSquared;\n            b = 2.0 * A * D * planetModel.inverseAbSquared;\n            c = D * D * planetModel.inverseAbSquared - B * B;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double x0 = -b / (2.0 * a);\n              double y0 = (-D - A * x0) / B;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, new GeoPoint(x0, y0, z0));\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / B;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-D - A * x0a) * Idenom;\n              double y0b = (-D - A * x0b) * Idenom;\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, new GeoPoint(x0a, y0a, z0a));\n              addPoint(boundsInfo, bounds, new GeoPoint(x0b, y0b, z0b));\n            }\n          }\n        }\n\n      } else {\n        //System.err.println(\"General longitude bounds...\");\n\n        // NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.\n        // They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,\n        // and z for latitude, and that's all the values are good for.\n\n        // (1) Intersect the plane and the ellipsoid, and project the results into the x-y plane:\n        // From plane:\n        // z = (-Ax - By - D) / C\n        // From ellipsoid:\n        // x^2/a^2 + y^2/b^2 + [(-Ax - By - D) / C]^2/c^2 = 1\n        // Simplify/expand:\n        // C^2*x^2/a^2 + C^2*y^2/b^2 + (-Ax - By - D)^2/c^2 = C^2\n        //\n        // x^2 * C^2/a^2 + y^2 * C^2/b^2 + x^2 * A^2/c^2 + ABxy/c^2 + ADx/c^2 + ABxy/c^2 + y^2 * B^2/c^2 + BDy/c^2 + ADx/c^2 + BDy/c^2 + D^2/c^2 = C^2\n        // Group:\n        // [A^2/c^2 + C^2/a^2] x^2 + [B^2/c^2 + C^2/b^2] y^2 + [2AB/c^2]xy + [2AD/c^2]x + [2BD/c^2]y + [D^2/c^2-C^2] = 0\n        // For convenience, introduce post-projection coefficient variables to make life easier.\n        // E x^2 + F y^2 + G xy + H x + I y + J = 0\n        double E = A * A * planetModel.inverseCSquared + C * C * planetModel.inverseAbSquared;\n        double F = B * B * planetModel.inverseCSquared + C * C * planetModel.inverseAbSquared;\n        double G = 2.0 * A * B * planetModel.inverseCSquared;\n        double H = 2.0 * A * D * planetModel.inverseCSquared;\n        double I = 2.0 * B * D * planetModel.inverseCSquared;\n        double J = D * D * planetModel.inverseCSquared - C * C;\n\n        //System.err.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n\n        // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n        if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {\n          // The derivative of the curve above is:\n          // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n          // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n          // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n          //\n          // The equation of a line going through the origin with the slope dy/dx is:\n          // y = dy/dx x\n          // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n          // Rearrange:\n          // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n          // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n          // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n          //\n          // Multiply the original equation by 2:\n          // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n          // Subtract one from the other, to remove the high-order terms:\n          // Hx + Iy + 2J = 0\n          // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n          // But we will need to base this on which coefficient is non-zero\n\n          if (Math.abs(H) > Math.abs(I)) {\n            //System.err.println(\" Using the y quadratic\");\n            // x = (-2J - Iy)/H\n\n            // Plug into the original equation:\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n            // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n\n            // Plug into derivative equation:\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n            // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n            // Multiply by H^2 to make manipulation easier\n            // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n            // Do the square\n            // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n            // Multiply it out\n            // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n            // Group:\n            // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * E * I * J - 2.0 * G * H * J;\n            c = 4.0 * E * J * J - J * H * H;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution\");\n              double y0 = -b / (2.0 * a);\n              double x0 = (-2.0 * J - I * y0) / H;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n\n              addPoint(boundsInfo, bounds, new GeoPoint(x0, y0, z0));\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / H;\n              double Cdenom = 1.0 / C;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n              double x0a = (-2.0 * J - I * y0a) * Hdenom;\n              double x0b = (-2.0 * J - I * y0b) * Hdenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, new GeoPoint(x0a, y0a, z0a));\n              addPoint(boundsInfo, bounds, new GeoPoint(x0b, y0b, z0b));\n            }\n\n          } else {\n            //System.err.println(\" Using the x quadratic\");\n            // y = (-2J - Hx)/I\n\n            // Plug into the original equation:\n            // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n            // Multiply by I^2 to make manipulation easier\n            // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n            // Do the square\n            // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n            // Multiply it out\n            // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n            // Group:\n            // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n            // E x^2 + F y^2 + G xy + H x + I y + J = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * F * H * J - 2.0 * G * I * J;\n            c = 4.0 * F * J * J - J * I * I;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution; sqrt clause was \"+sqrtClause);\n              double x0 = -b / (2.0 * a);\n              double y0 = (-2.0 * J - H * x0) / I;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n              // Verify that x&y fulfill the equation\n              // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n              addPoint(boundsInfo, bounds, new GeoPoint(x0, y0, z0));\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / I;\n              double Cdenom = 1.0 / C;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-2.0 * J - H * x0a) * Idenom;\n              double y0b = (-2.0 * J - H * x0b) * Idenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, new GeoPoint(x0a, y0a, z0a));\n              addPoint(boundsInfo, bounds, new GeoPoint(x0b, y0b, z0b));\n            }\n          }\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f64b7098768253180859cd8faeae6b1a185b06ed":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b4e444678504caf66a8060b1d514383aa4feac0c":["f64b7098768253180859cd8faeae6b1a185b06ed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b4e444678504caf66a8060b1d514383aa4feac0c"]},"commit2Childs":{"f64b7098768253180859cd8faeae6b1a185b06ed":["b4e444678504caf66a8060b1d514383aa4feac0c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f64b7098768253180859cd8faeae6b1a185b06ed"],"b4e444678504caf66a8060b1d514383aa4feac0c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}