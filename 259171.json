{"path":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ccc08aa684aee4964baee0644a6ba047bfd70829","date":1316263707,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d66363068e87a246ce08fee4a42f30f126b92723","date":1329988051,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = (NamedList<Object>) rb.rsp.getValues().get(ShardParams.SHARDS_INFO);\n        if(shardInfo==null) {\n          shardInfo = new SimpleOrderedMap<Object>();\n          rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n        }\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          nl.add(\"numFound\", docs.getNumFound());\n          nl.add(\"maxScore\", docs.getMaxScore());\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e6dd476b943b132ecfa6b3ffc72e439eb2d9e061","date":1330500722,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = (NamedList<Object>) rb.rsp.getValues().get(ShardParams.SHARDS_INFO);\n        if(shardInfo==null) {\n          shardInfo = new SimpleOrderedMap<Object>();\n          rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n        }\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          nl.add(\"numFound\", docs.getNumFound());\n          nl.add(\"maxScore\", docs.getMaxScore());\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9502d4db5ace80cee97f9ee35b2e36d1bf425f9c","date":1331831562,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":["c1af881a1691e32ac2275b4008656709aa96e369"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae56db85dd1cd5b93e54f4caddb9f443b19da009","date":1347061537,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","bugFix":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"84ff6ee622c2ea761ee0030e860506ee1d08afd7","date":1385474712,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"faff74992839549208db29d95b9ad4a1d3846c79","date":1385672428,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalSortValues(sortFieldValues, schema);\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02453e8d9fe1bde22dc7676145ad809cb1dbfcad","date":1386084179,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalSortValues(sortFieldValues, schema);\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","bugFix":null,"bugIntro":["2c24a5370d60b538b222b819c0034062dadbd8d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5bc8e25f59990525f5beb14afe9c96240dcf4a2","date":1389042945,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"167c9d3137acf706f53c875de69f3165df85fd3b","date":1391327271,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c24a5370d60b538b222b819c0034062dadbd8d4","date":1395069894,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","bugFix":["02453e8d9fe1bde22dc7676145ad809cb1dbfcad"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6c70567cc1ae757045c80cb458b0b2a2ffcf0141","date":1400098332,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ccc69a67d5c846a04c7f71e28cb1914e3af895f3","date":1400252660,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1af881a1691e32ac2275b4008656709aa96e369","date":1404496493,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n  }\n\n","bugFix":["9502d4db5ace80cee97f9ee35b2e36d1bf425f9c"],"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83b038ad0480d5e81e058bf9fafb2dd85399985d","date":1450812495,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"35d59689803f4ad27f96148bb7c7167e373c6770","date":1454297137,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a9c2b42591c0db6f85041d5cfc9cba17fe45e0b","date":1455308162,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = (responseHeader == null ? null : responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY));\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        if (responseHeader != null) {\n          if (Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n            partialResults = true;\n          }\n          if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n            final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (Boolean.TRUE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.TRUE;\n            } else if (Boolean.FALSE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.FALSE;\n            }\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","sourceOld":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n          partialResults = true;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":["68f345f3b4bee014d571c564dac11b519febe85f","a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0b707c74e1653cb9034de647516ba98e55318f3a","date":1478605309,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      final ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = (responseHeader == null ? null : responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY));\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        if (responseHeader != null) {\n          if (Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n            partialResults = true;\n          }\n          if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n            final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (Boolean.TRUE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.TRUE;\n            } else if (Boolean.FALSE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.FALSE;\n            }\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","sourceOld":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = (responseHeader == null ? null : responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY));\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        if (responseHeader != null) {\n          if (Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n            partialResults = true;\n          }\n          if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n            final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (Boolean.TRUE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.TRUE;\n            } else if (Boolean.FALSE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.FALSE;\n            }\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b85269f842629cb75c98f851207a1b9c4239bcdb","date":1478610699,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      final ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = (responseHeader == null ? null : responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY));\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        if (responseHeader != null) {\n          if (Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n            partialResults = true;\n          }\n          if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n            final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (Boolean.TRUE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.TRUE;\n            } else if (Boolean.FALSE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.FALSE;\n            }\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","sourceOld":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = (responseHeader == null ? null : responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY));\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        if (responseHeader != null) {\n          if (Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n            partialResults = true;\n          }\n          if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n            final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (Boolean.TRUE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.TRUE;\n            } else if (Boolean.FALSE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.FALSE;\n            }\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fe15a42e904812683ef9365c28389e14f639466","date":1478615818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      final ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = (responseHeader == null ? null : responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY));\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        if (responseHeader != null) {\n          if (Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n            partialResults = true;\n          }\n          if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n            final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (Boolean.TRUE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.TRUE;\n            } else if (Boolean.FALSE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.FALSE;\n            }\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","sourceOld":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = (responseHeader == null ? null : responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY));\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        if (responseHeader != null) {\n          if (Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n            partialResults = true;\n          }\n          if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n            final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (Boolean.TRUE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.TRUE;\n            } else if (Boolean.FALSE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.FALSE;\n            }\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      final ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = (responseHeader == null ? null : responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY));\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        if (responseHeader != null) {\n          if (Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n            partialResults = true;\n          }\n          if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n            final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (Boolean.TRUE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.TRUE;\n            } else if (Boolean.FALSE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.FALSE;\n            }\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","sourceOld":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = (responseHeader == null ? null : responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY));\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        if (responseHeader != null) {\n          if (Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n            partialResults = true;\n          }\n          if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n            final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (Boolean.TRUE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.TRUE;\n            } else if (Boolean.FALSE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.FALSE;\n            }\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3584d3db8b472772e3329d9d95d584b68ae997e","date":1551710517,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      final ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = (responseHeader == null ? null : responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY));\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        if (responseHeader != null) {\n          if (Boolean.TRUE.equals(responseHeader.getBooleanArg(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n            partialResults = true;\n          }\n          if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n            final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (Boolean.TRUE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.TRUE;\n            } else if (Boolean.FALSE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.FALSE;\n            }\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        if (sortFieldValues.size()==0 && partialResults) {\n          continue; //fsv timeout yields empty sort_vlaues\n        }\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n         rb.rsp.getResponseHeader().asShallowMap()\n                   .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","sourceOld":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      final ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = (responseHeader == null ? null : responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY));\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        if (responseHeader != null) {\n          if (Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n            partialResults = true;\n          }\n          if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n            final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (Boolean.TRUE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.TRUE;\n            } else if (Boolean.FALSE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.FALSE;\n            }\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","bugFix":["83b038ad0480d5e81e058bf9fafb2dd85399985d","1a9c2b42591c0db6f85041d5cfc9cba17fe45e0b","c1af881a1691e32ac2275b4008656709aa96e369"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"88124658128e8c06b5dc460e5126ed75aae03079","date":1551817607,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      final ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean thereArePartialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = (responseHeader == null ? null : responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY));\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          thereArePartialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        final boolean thisResponseIsPartial;\n        if (responseHeader != null) {\n          thisResponseIsPartial = Boolean.TRUE.equals(responseHeader.getBooleanArg(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY));\n          thereArePartialResults |= thisResponseIsPartial;\n          \n          if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n            final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (Boolean.TRUE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.TRUE;\n            } else if (Boolean.FALSE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.FALSE;\n            }\n          }\n        } else {\n          thisResponseIsPartial = false;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        if (sortFieldValues.size()==0 && // we bypass merging this response only if it's partial itself\n                            thisResponseIsPartial) { // but not the previous one!!\n          continue; //fsv timeout yields empty sort_vlaues\n        }\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (thereArePartialResults) {\n         rb.rsp.getResponseHeader().asShallowMap()\n                   .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","sourceOld":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      final ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = (responseHeader == null ? null : responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY));\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        if (responseHeader != null) {\n          if (Boolean.TRUE.equals(responseHeader.getBooleanArg(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n            partialResults = true;\n          }\n          if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n            final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (Boolean.TRUE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.TRUE;\n            } else if (Boolean.FALSE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.FALSE;\n            }\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        if (sortFieldValues.size()==0 && partialResults) {\n          continue; //fsv timeout yields empty sort_vlaues\n        }\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (partialResults) {\n         rb.rsp.getResponseHeader().asShallowMap()\n                   .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":["68f345f3b4bee014d571c564dac11b519febe85f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68f345f3b4bee014d571c564dac11b519febe85f","date":1560355769,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      final ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean thereArePartialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          thereArePartialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        final boolean thisResponseIsPartial;\n        thisResponseIsPartial = Boolean.TRUE.equals(responseHeader.getBooleanArg(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY));\n        thereArePartialResults |= thisResponseIsPartial;\n        \n        if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          if (Boolean.TRUE.equals(ste)) {\n            segmentTerminatedEarly = Boolean.TRUE;\n          } else if (Boolean.FALSE.equals(ste)) {\n            segmentTerminatedEarly = Boolean.FALSE;\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        if (sortFieldValues.size()==0 && // we bypass merging this response only if it's partial itself\n                            thisResponseIsPartial) { // but not the previous one!!\n          continue; //fsv timeout yields empty sort_vlaues\n        }\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (thereArePartialResults) {\n         rb.rsp.getResponseHeader().asShallowMap()\n                   .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","sourceOld":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      final ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean thereArePartialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = (responseHeader == null ? null : responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY));\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          thereArePartialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        final boolean thisResponseIsPartial;\n        if (responseHeader != null) {\n          thisResponseIsPartial = Boolean.TRUE.equals(responseHeader.getBooleanArg(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY));\n          thereArePartialResults |= thisResponseIsPartial;\n          \n          if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n            final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (Boolean.TRUE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.TRUE;\n            } else if (Boolean.FALSE.equals(ste)) {\n              segmentTerminatedEarly = Boolean.FALSE;\n            }\n          }\n        } else {\n          thisResponseIsPartial = false;\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        if (sortFieldValues.size()==0 && // we bypass merging this response only if it's partial itself\n                            thisResponseIsPartial) { // but not the previous one!!\n          continue; //fsv timeout yields empty sort_vlaues\n        }\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (thereArePartialResults) {\n         rb.rsp.getResponseHeader().asShallowMap()\n                   .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","bugFix":["88124658128e8c06b5dc460e5126ed75aae03079","1a9c2b42591c0db6f85041d5cfc9cba17fe45e0b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"640ded7811e1b7d29236a5e2934ec3cd266a8199","date":1588973147,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      final ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      boolean hitCountIsExact = true;\n      Float maxScore=null;\n      boolean thereArePartialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"numFoundExact\", docs.getNumFoundExact());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          thereArePartialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        final boolean thisResponseIsPartial;\n        thisResponseIsPartial = Boolean.TRUE.equals(responseHeader.getBooleanArg(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY));\n        thereArePartialResults |= thisResponseIsPartial;\n        \n        if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          if (Boolean.TRUE.equals(ste)) {\n            segmentTerminatedEarly = Boolean.TRUE;\n          } else if (Boolean.FALSE.equals(ste)) {\n            segmentTerminatedEarly = Boolean.FALSE;\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n        \n        if (hitCountIsExact && Boolean.FALSE.equals(docs.getNumFoundExact())) {\n          hitCountIsExact = false;\n        }\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        if (sortFieldValues.size()==0 && // we bypass merging this response only if it's partial itself\n                            thisResponseIsPartial) { // but not the previous one!!\n          continue; //fsv timeout yields empty sort_vlaues\n        }\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setNumFoundExact(hitCountIsExact);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (thereArePartialResults) {\n         rb.rsp.getResponseHeader().asShallowMap()\n                   .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","sourceOld":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      final ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      Float maxScore=null;\n      boolean thereArePartialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          thereArePartialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        final boolean thisResponseIsPartial;\n        thisResponseIsPartial = Boolean.TRUE.equals(responseHeader.getBooleanArg(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY));\n        thereArePartialResults |= thisResponseIsPartial;\n        \n        if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          if (Boolean.TRUE.equals(ste)) {\n            segmentTerminatedEarly = Boolean.TRUE;\n          } else if (Boolean.FALSE.equals(ste)) {\n            segmentTerminatedEarly = Boolean.FALSE;\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        if (sortFieldValues.size()==0 && // we bypass merging this response only if it's partial itself\n                            thisResponseIsPartial) { // but not the previous one!!\n          continue; //fsv timeout yields empty sort_vlaues\n        }\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (thereArePartialResults) {\n         rb.rsp.getResponseHeader().asShallowMap()\n                   .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8582f07e9350eaeb33bf6c4617b8c9895d99c839","date":1591307386,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      final ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      boolean hitCountIsExact = true;\n      Float maxScore=null;\n      boolean thereArePartialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"numFoundExact\", docs.getNumFoundExact());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          thereArePartialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        final boolean thisResponseIsPartial;\n        thisResponseIsPartial = Boolean.TRUE.equals(responseHeader.getBooleanArg(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY));\n        thereArePartialResults |= thisResponseIsPartial;\n        \n        if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          if (Boolean.TRUE.equals(ste)) {\n            segmentTerminatedEarly = Boolean.TRUE;\n          } else if (Boolean.FALSE.equals(ste)) {\n            segmentTerminatedEarly = Boolean.FALSE;\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n        \n        if (hitCountIsExact && Boolean.FALSE.equals(docs.getNumFoundExact())) {\n          hitCountIsExact = false;\n        }\n\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        if (sortFieldValues.size()==0 && // we bypass merging this response only if it's partial itself\n                            thisResponseIsPartial) { // but not the previous one!!\n          continue; //fsv timeout yields empty sort_vlaues\n        }\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setNumFoundExact(hitCountIsExact);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (thereArePartialResults) {\n         rb.rsp.getResponseHeader().asShallowMap()\n                   .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","sourceOld":"  protected void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      List<MergeStrategy> mergeStrategies = rb.getMergeStrategies();\n      if(mergeStrategies != null) {\n        Collections.sort(mergeStrategies, MergeStrategy.MERGE_COMP);\n        boolean idsMerged = false;\n        for(MergeStrategy mergeStrategy : mergeStrategies) {\n          mergeStrategy.merge(rb, sreq);\n          if(mergeStrategy.mergesIds()) {\n            idsMerged = true;\n          }\n        }\n\n        if(idsMerged) {\n          return; //ids were merged above so return.\n        }\n      }\n\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      final ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount(), rb.req.getSearcher());\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n      \n      long numFound = 0;\n      boolean hitCountIsExact = true;\n      Float maxScore=null;\n      boolean thereArePartialResults = false;\n      Boolean segmentTerminatedEarly = null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n        NamedList<?> responseHeader = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n          \n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n            final Object rhste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n            if (rhste != null) {\n              nl.add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, rhste);\n            }\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"numFoundExact\", docs.getNumFoundExact());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          thereArePartialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n        \n        if (responseHeader == null) { // could have been initialized in the shards info block above\n          responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        }\n\n        final boolean thisResponseIsPartial;\n        thisResponseIsPartial = Boolean.TRUE.equals(responseHeader.getBooleanArg(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY));\n        thereArePartialResults |= thisResponseIsPartial;\n        \n        if (!Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          final Object ste = responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          if (Boolean.TRUE.equals(ste)) {\n            segmentTerminatedEarly = Boolean.TRUE;\n          } else if (Boolean.FALSE.equals(ste)) {\n            segmentTerminatedEarly = Boolean.FALSE;\n          }\n        }\n        \n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n        \n        if (hitCountIsExact && Boolean.FALSE.equals(docs.getNumFoundExact())) {\n          hitCountIsExact = false;\n        }\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n        if (sortFieldValues.size()==0 && // we bypass merging this response only if it's partial itself\n                            thisResponseIsPartial) { // but not the previous one!!\n          continue; //fsv timeout yields empty sort_vlaues\n        }\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = unmarshalledSortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n      \n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setNumFoundExact(hitCountIsExact);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      populateNextCursorMarkFromMergedShards(rb);\n\n      if (thereArePartialResults) {\n         rb.rsp.getResponseHeader().asShallowMap()\n                   .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      }\n      if (segmentTerminatedEarly != null) {\n        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n        if (existingSegmentTerminatedEarly == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1a9c2b42591c0db6f85041d5cfc9cba17fe45e0b":["35d59689803f4ad27f96148bb7c7167e373c6770"],"640ded7811e1b7d29236a5e2934ec3cd266a8199":["68f345f3b4bee014d571c564dac11b519febe85f"],"6c70567cc1ae757045c80cb458b0b2a2ffcf0141":["2c24a5370d60b538b222b819c0034062dadbd8d4"],"9502d4db5ace80cee97f9ee35b2e36d1bf425f9c":["e6dd476b943b132ecfa6b3ffc72e439eb2d9e061"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["ccc08aa684aee4964baee0644a6ba047bfd70829","e6dd476b943b132ecfa6b3ffc72e439eb2d9e061"],"ccc08aa684aee4964baee0644a6ba047bfd70829":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"8fe15a42e904812683ef9365c28389e14f639466":["1a9c2b42591c0db6f85041d5cfc9cba17fe45e0b","b85269f842629cb75c98f851207a1b9c4239bcdb"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["02453e8d9fe1bde22dc7676145ad809cb1dbfcad"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["1a9c2b42591c0db6f85041d5cfc9cba17fe45e0b","8fe15a42e904812683ef9365c28389e14f639466"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["8fe15a42e904812683ef9365c28389e14f639466"],"b85269f842629cb75c98f851207a1b9c4239bcdb":["1a9c2b42591c0db6f85041d5cfc9cba17fe45e0b","0b707c74e1653cb9034de647516ba98e55318f3a"],"83b038ad0480d5e81e058bf9fafb2dd85399985d":["c1af881a1691e32ac2275b4008656709aa96e369"],"ccc69a67d5c846a04c7f71e28cb1914e3af895f3":["2c24a5370d60b538b222b819c0034062dadbd8d4","6c70567cc1ae757045c80cb458b0b2a2ffcf0141"],"02453e8d9fe1bde22dc7676145ad809cb1dbfcad":["faff74992839549208db29d95b9ad4a1d3846c79"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0b707c74e1653cb9034de647516ba98e55318f3a":["1a9c2b42591c0db6f85041d5cfc9cba17fe45e0b"],"d66363068e87a246ce08fee4a42f30f126b92723":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["167c9d3137acf706f53c875de69f3165df85fd3b"],"84ff6ee622c2ea761ee0030e860506ee1d08afd7":["ae56db85dd1cd5b93e54f4caddb9f443b19da009"],"e6dd476b943b132ecfa6b3ffc72e439eb2d9e061":["d66363068e87a246ce08fee4a42f30f126b92723"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["83b038ad0480d5e81e058bf9fafb2dd85399985d","35d59689803f4ad27f96148bb7c7167e373c6770"],"167c9d3137acf706f53c875de69f3165df85fd3b":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"faff74992839549208db29d95b9ad4a1d3846c79":["84ff6ee622c2ea761ee0030e860506ee1d08afd7"],"ae56db85dd1cd5b93e54f4caddb9f443b19da009":["9502d4db5ace80cee97f9ee35b2e36d1bf425f9c"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["640ded7811e1b7d29236a5e2934ec3cd266a8199"],"68f345f3b4bee014d571c564dac11b519febe85f":["88124658128e8c06b5dc460e5126ed75aae03079"],"2c24a5370d60b538b222b819c0034062dadbd8d4":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["ae56db85dd1cd5b93e54f4caddb9f443b19da009","02453e8d9fe1bde22dc7676145ad809cb1dbfcad"],"35d59689803f4ad27f96148bb7c7167e373c6770":["83b038ad0480d5e81e058bf9fafb2dd85399985d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"88124658128e8c06b5dc460e5126ed75aae03079":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"c1af881a1691e32ac2275b4008656709aa96e369":["6c70567cc1ae757045c80cb458b0b2a2ffcf0141"]},"commit2Childs":{"1a9c2b42591c0db6f85041d5cfc9cba17fe45e0b":["8fe15a42e904812683ef9365c28389e14f639466","199dfa410f1fdbfd3294106b04096cce5ed34b21","b85269f842629cb75c98f851207a1b9c4239bcdb","0b707c74e1653cb9034de647516ba98e55318f3a"],"640ded7811e1b7d29236a5e2934ec3cd266a8199":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"6c70567cc1ae757045c80cb458b0b2a2ffcf0141":["ccc69a67d5c846a04c7f71e28cb1914e3af895f3","c1af881a1691e32ac2275b4008656709aa96e369"],"9502d4db5ace80cee97f9ee35b2e36d1bf425f9c":["ae56db85dd1cd5b93e54f4caddb9f443b19da009"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"ccc08aa684aee4964baee0644a6ba047bfd70829":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d66363068e87a246ce08fee4a42f30f126b92723"],"c26f00b574427b55127e869b935845554afde1fa":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"8fe15a42e904812683ef9365c28389e14f639466":["199dfa410f1fdbfd3294106b04096cce5ed34b21","a3584d3db8b472772e3329d9d95d584b68ae997e"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["167c9d3137acf706f53c875de69f3165df85fd3b"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"a3584d3db8b472772e3329d9d95d584b68ae997e":["88124658128e8c06b5dc460e5126ed75aae03079"],"b85269f842629cb75c98f851207a1b9c4239bcdb":["8fe15a42e904812683ef9365c28389e14f639466"],"83b038ad0480d5e81e058bf9fafb2dd85399985d":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","35d59689803f4ad27f96148bb7c7167e373c6770"],"ccc69a67d5c846a04c7f71e28cb1914e3af895f3":[],"02453e8d9fe1bde22dc7676145ad809cb1dbfcad":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"0b707c74e1653cb9034de647516ba98e55318f3a":["b85269f842629cb75c98f851207a1b9c4239bcdb"],"d66363068e87a246ce08fee4a42f30f126b92723":["e6dd476b943b132ecfa6b3ffc72e439eb2d9e061"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["2c24a5370d60b538b222b819c0034062dadbd8d4"],"84ff6ee622c2ea761ee0030e860506ee1d08afd7":["faff74992839549208db29d95b9ad4a1d3846c79"],"e6dd476b943b132ecfa6b3ffc72e439eb2d9e061":["9502d4db5ace80cee97f9ee35b2e36d1bf425f9c","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"167c9d3137acf706f53c875de69f3165df85fd3b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"faff74992839549208db29d95b9ad4a1d3846c79":["02453e8d9fe1bde22dc7676145ad809cb1dbfcad"],"ae56db85dd1cd5b93e54f4caddb9f443b19da009":["84ff6ee622c2ea761ee0030e860506ee1d08afd7","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"68f345f3b4bee014d571c564dac11b519febe85f":["640ded7811e1b7d29236a5e2934ec3cd266a8199"],"2c24a5370d60b538b222b819c0034062dadbd8d4":["6c70567cc1ae757045c80cb458b0b2a2ffcf0141","ccc69a67d5c846a04c7f71e28cb1914e3af895f3"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"35d59689803f4ad27f96148bb7c7167e373c6770":["1a9c2b42591c0db6f85041d5cfc9cba17fe45e0b","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"88124658128e8c06b5dc460e5126ed75aae03079":["68f345f3b4bee014d571c564dac11b519febe85f"],"c1af881a1691e32ac2275b4008656709aa96e369":["83b038ad0480d5e81e058bf9fafb2dd85399985d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","199dfa410f1fdbfd3294106b04096cce5ed34b21","ccc69a67d5c846a04c7f71e28cb1914e3af895f3","1e6acbaae7af722f17204ceccf0f7db5753eccf3","74f45af4339b0daf7a95c820ab88c1aea74fbce0","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}