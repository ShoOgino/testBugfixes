{"path":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"/dev/null","sourceNew":"  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//str[@name='str_s'][.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":null,"sourceOld":"  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//str[@name='str_s'][.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//str[@name='str_s'][.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//str[@name='str_s'][.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"/dev/null","sourceNew":"  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//str[@name='str_s'][.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b6689fa15093482d61e1254f656c079bd840042","date":1269093637,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//str[@name='str_s'][.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//str[@name='str_s'][.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ce6aae13e6441cf187f083d13afaf8e9a2884e3","date":1299700113,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//str[@name='str_s'][.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//str[@name='str_s'][.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//str[@name='str_s'][.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"2ce6aae13e6441cf187f083d13afaf8e9a2884e3":["4b6689fa15093482d61e1254f656c079bd840042"],"c26f00b574427b55127e869b935845554afde1fa":["2ce6aae13e6441cf187f083d13afaf8e9a2884e3","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"4b6689fa15093482d61e1254f656c079bd840042":["1da8d55113b689b06716246649de6f62430f15c0"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["4b6689fa15093482d61e1254f656c079bd840042","2ce6aae13e6441cf187f083d13afaf8e9a2884e3"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["2ce6aae13e6441cf187f083d13afaf8e9a2884e3"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["4b6689fa15093482d61e1254f656c079bd840042","2ce6aae13e6441cf187f083d13afaf8e9a2884e3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["2ce6aae13e6441cf187f083d13afaf8e9a2884e3"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"2ce6aae13e6441cf187f083d13afaf8e9a2884e3":["c26f00b574427b55127e869b935845554afde1fa","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","c903c3d15906a3da96b8c0c2fb704491005fdbdb","d619839baa8ce5503e496b94a9e42ad6f079293f","a258fbb26824fd104ed795e5d9033d2d040049ee"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"4b6689fa15093482d61e1254f656c079bd840042":["2ce6aae13e6441cf187f083d13afaf8e9a2884e3","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f"],"1da8d55113b689b06716246649de6f62430f15c0":["4b6689fa15093482d61e1254f656c079bd840042"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":[],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"d619839baa8ce5503e496b94a9e42ad6f079293f":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}