{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeLargeGeoPolygon(PlanetModel,List[PolygonDescription]).mjava","commits":[{"id":"06729f5a814f91b46fa06d668ae86a5d257ba644","date":1461675413,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeLargeGeoPolygon(PlanetModel,List[PolygonDescription]).mjava","pathOld":"/dev/null","sourceNew":"  /** Create a large GeoPolygon.  This is one which has more than 100 sides and/or may have resolution problems\n   * with very closely spaced points, which often occurs when the polygon was constructed to approximate curves.  No tiling\n   * is done, and intersections and membership are optimized for having large numbers of sides.\n   *\n   * This method does very little checking for legality.  It expects the incoming shapes to not intersect\n   * each other.  The shapes can be disjoint or nested.  If the shapes listed are nested, then we are describing holes.\n   * There is no limit to the depth of holes.  However, if a shape is nested within another it must be explicitly\n   * described as being a child of the other shape.\n   *\n   * Membership in any given shape is described by the clockwise/counterclockwise direction of the points.  The\n   * clockwise direction indicates that a point inside is \"in-set\", while a counter-clockwise direction implies that\n   * a point inside is \"out-of-set\".\n   * \n   * @param planetModel is the planet model.\n   * @param shapesList is the list of polygons we should be making.\n   * @return the GeoPolygon, or null if it cannot be constructed.\n   */\n  public static GeoPolygon makeLargeGeoPolygon(final PlanetModel planetModel,\n    final List<PolygonDescription> shapesList) {\n      \n    // We're going to be building a single-level list of shapes in the end, with a single point that we know to be inside/outside, which is\n    // not on an edge.\n    \n    final List<List<GeoPoint>> pointsList = new ArrayList<>();\n    \n    List<GeoPoint> testPointShape = null;\n    for (final PolygonDescription shape : shapesList) {\n      // Convert this shape and its holes to a general list of shapes.  We also need to identify exactly one\n      // legal, non-degenerate shape with no children that we can use to find a test point.  We also optimize\n      // to choose as small as possible a polygon for determining the in-set-ness of the test point.\n      testPointShape = convertPolygon(pointsList, shape, testPointShape);\n    }\n    \n    // If there's no polygon we can use to determine a test point, we throw up.\n    if (testPointShape == null) {\n      throw new IllegalArgumentException(\"couldn't find a non-degenerate polygon for in-set determination\");\n    }\n    \n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, testPointShape);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, testPointShape);\n      if (isPoleInside != null) {\n        // Legal pole\n        return new GeoComplexPolygon(planetModel, pointsList, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+testPointShape);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","date":1461888019,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeLargeGeoPolygon(PlanetModel,List[PolygonDescription]).mjava","pathOld":"/dev/null","sourceNew":"  /** Create a large GeoPolygon.  This is one which has more than 100 sides and/or may have resolution problems\n   * with very closely spaced points, which often occurs when the polygon was constructed to approximate curves.  No tiling\n   * is done, and intersections and membership are optimized for having large numbers of sides.\n   *\n   * This method does very little checking for legality.  It expects the incoming shapes to not intersect\n   * each other.  The shapes can be disjoint or nested.  If the shapes listed are nested, then we are describing holes.\n   * There is no limit to the depth of holes.  However, if a shape is nested within another it must be explicitly\n   * described as being a child of the other shape.\n   *\n   * Membership in any given shape is described by the clockwise/counterclockwise direction of the points.  The\n   * clockwise direction indicates that a point inside is \"in-set\", while a counter-clockwise direction implies that\n   * a point inside is \"out-of-set\".\n   * \n   * @param planetModel is the planet model.\n   * @param shapesList is the list of polygons we should be making.\n   * @return the GeoPolygon, or null if it cannot be constructed.\n   */\n  public static GeoPolygon makeLargeGeoPolygon(final PlanetModel planetModel,\n    final List<PolygonDescription> shapesList) {\n      \n    // We're going to be building a single-level list of shapes in the end, with a single point that we know to be inside/outside, which is\n    // not on an edge.\n    \n    final List<List<GeoPoint>> pointsList = new ArrayList<>();\n    \n    List<GeoPoint> testPointShape = null;\n    for (final PolygonDescription shape : shapesList) {\n      // Convert this shape and its holes to a general list of shapes.  We also need to identify exactly one\n      // legal, non-degenerate shape with no children that we can use to find a test point.  We also optimize\n      // to choose as small as possible a polygon for determining the in-set-ness of the test point.\n      testPointShape = convertPolygon(pointsList, shape, testPointShape);\n    }\n    \n    // If there's no polygon we can use to determine a test point, we throw up.\n    if (testPointShape == null) {\n      throw new IllegalArgumentException(\"couldn't find a non-degenerate polygon for in-set determination\");\n    }\n    \n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, testPointShape);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, testPointShape);\n      if (isPoleInside != null) {\n        // Legal pole\n        return new GeoComplexPolygon(planetModel, pointsList, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+testPointShape);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8825024cedab6612bf17c2b808f4f86abe6e45bb","date":1462272353,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeLargeGeoPolygon(PlanetModel,List[PolygonDescription]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeLargeGeoPolygon(PlanetModel,List[PolygonDescription]).mjava","sourceNew":"  /** Create a large GeoPolygon.  This is one which has more than 100 sides and/or may have resolution problems\n   * with very closely spaced points, which often occurs when the polygon was constructed to approximate curves.  No tiling\n   * is done, and intersections and membership are optimized for having large numbers of sides.\n   *\n   * This method does very little checking for legality.  It expects the incoming shapes to not intersect\n   * each other.  The shapes can be disjoint or nested.  If the shapes listed are nested, then we are describing holes.\n   * There is no limit to the depth of holes.  However, if a shape is nested within another it must be explicitly\n   * described as being a child of the other shape.\n   *\n   * Membership in any given shape is described by the clockwise/counterclockwise direction of the points.  The\n   * clockwise direction indicates that a point inside is \"in-set\", while a counter-clockwise direction implies that\n   * a point inside is \"out-of-set\".\n   * \n   * @param planetModel is the planet model.\n   * @param shapesList is the list of polygons we should be making.\n   * @return the GeoPolygon, or null if it cannot be constructed.\n   */\n  public static GeoPolygon makeLargeGeoPolygon(final PlanetModel planetModel,\n    final List<PolygonDescription> shapesList) {\n      \n    // We're going to be building a single-level list of shapes in the end, with a single point that we know to be inside/outside, which is\n    // not on an edge.\n    \n    final List<List<GeoPoint>> pointsList = new ArrayList<>();\n    \n    BestShape testPointShape = null;\n    for (final PolygonDescription shape : shapesList) {\n      // Convert this shape and its holes to a general list of shapes.  We also need to identify exactly one\n      // legal, non-degenerate shape with no children that we can use to find a test point.  We also optimize\n      // to choose as small as possible a polygon for determining the in-set-ness of the test point.\n      testPointShape = convertPolygon(pointsList, shape, testPointShape, true);\n    }\n    \n    // If there's no polygon we can use to determine a test point, we throw up.\n    if (testPointShape == null) {\n      throw new IllegalArgumentException(\"couldn't find a non-degenerate polygon for in-set determination\");\n    }\n    \n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, testPointShape.points);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, testPointShape.points);\n      if (isPoleInside != null) {\n        // Legal pole\n        if (isPoleInside == testPointShape.poleMustBeInside) {\n          return new GeoComplexPolygon(planetModel, pointsList, pole, isPoleInside);\n        } else {\n          return new GeoComplexPolygon(planetModel, pointsList, new GeoPoint(-pole.x, -pole.y, -pole.z), !isPoleInside);\n        }\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+testPointShape);\n\n  }\n\n","sourceOld":"  /** Create a large GeoPolygon.  This is one which has more than 100 sides and/or may have resolution problems\n   * with very closely spaced points, which often occurs when the polygon was constructed to approximate curves.  No tiling\n   * is done, and intersections and membership are optimized for having large numbers of sides.\n   *\n   * This method does very little checking for legality.  It expects the incoming shapes to not intersect\n   * each other.  The shapes can be disjoint or nested.  If the shapes listed are nested, then we are describing holes.\n   * There is no limit to the depth of holes.  However, if a shape is nested within another it must be explicitly\n   * described as being a child of the other shape.\n   *\n   * Membership in any given shape is described by the clockwise/counterclockwise direction of the points.  The\n   * clockwise direction indicates that a point inside is \"in-set\", while a counter-clockwise direction implies that\n   * a point inside is \"out-of-set\".\n   * \n   * @param planetModel is the planet model.\n   * @param shapesList is the list of polygons we should be making.\n   * @return the GeoPolygon, or null if it cannot be constructed.\n   */\n  public static GeoPolygon makeLargeGeoPolygon(final PlanetModel planetModel,\n    final List<PolygonDescription> shapesList) {\n      \n    // We're going to be building a single-level list of shapes in the end, with a single point that we know to be inside/outside, which is\n    // not on an edge.\n    \n    final List<List<GeoPoint>> pointsList = new ArrayList<>();\n    \n    List<GeoPoint> testPointShape = null;\n    for (final PolygonDescription shape : shapesList) {\n      // Convert this shape and its holes to a general list of shapes.  We also need to identify exactly one\n      // legal, non-degenerate shape with no children that we can use to find a test point.  We also optimize\n      // to choose as small as possible a polygon for determining the in-set-ness of the test point.\n      testPointShape = convertPolygon(pointsList, shape, testPointShape);\n    }\n    \n    // If there's no polygon we can use to determine a test point, we throw up.\n    if (testPointShape == null) {\n      throw new IllegalArgumentException(\"couldn't find a non-degenerate polygon for in-set determination\");\n    }\n    \n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, testPointShape);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, testPointShape);\n      if (isPoleInside != null) {\n        // Legal pole\n        return new GeoComplexPolygon(planetModel, pointsList, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+testPointShape);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeLargeGeoPolygon(PlanetModel,List[PolygonDescription]).mjava","pathOld":"/dev/null","sourceNew":"  /** Create a large GeoPolygon.  This is one which has more than 100 sides and/or may have resolution problems\n   * with very closely spaced points, which often occurs when the polygon was constructed to approximate curves.  No tiling\n   * is done, and intersections and membership are optimized for having large numbers of sides.\n   *\n   * This method does very little checking for legality.  It expects the incoming shapes to not intersect\n   * each other.  The shapes can be disjoint or nested.  If the shapes listed are nested, then we are describing holes.\n   * There is no limit to the depth of holes.  However, if a shape is nested within another it must be explicitly\n   * described as being a child of the other shape.\n   *\n   * Membership in any given shape is described by the clockwise/counterclockwise direction of the points.  The\n   * clockwise direction indicates that a point inside is \"in-set\", while a counter-clockwise direction implies that\n   * a point inside is \"out-of-set\".\n   * \n   * @param planetModel is the planet model.\n   * @param shapesList is the list of polygons we should be making.\n   * @return the GeoPolygon, or null if it cannot be constructed.\n   */\n  public static GeoPolygon makeLargeGeoPolygon(final PlanetModel planetModel,\n    final List<PolygonDescription> shapesList) {\n      \n    // We're going to be building a single-level list of shapes in the end, with a single point that we know to be inside/outside, which is\n    // not on an edge.\n    \n    final List<List<GeoPoint>> pointsList = new ArrayList<>();\n    \n    BestShape testPointShape = null;\n    for (final PolygonDescription shape : shapesList) {\n      // Convert this shape and its holes to a general list of shapes.  We also need to identify exactly one\n      // legal, non-degenerate shape with no children that we can use to find a test point.  We also optimize\n      // to choose as small as possible a polygon for determining the in-set-ness of the test point.\n      testPointShape = convertPolygon(pointsList, shape, testPointShape, true);\n    }\n    \n    // If there's no polygon we can use to determine a test point, we throw up.\n    if (testPointShape == null) {\n      throw new IllegalArgumentException(\"couldn't find a non-degenerate polygon for in-set determination\");\n    }\n    \n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, testPointShape.points);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, testPointShape.points);\n      if (isPoleInside != null) {\n        // Legal pole\n        if (isPoleInside == testPointShape.poleMustBeInside) {\n          return new GeoComplexPolygon(planetModel, pointsList, pole, isPoleInside);\n        } else {\n          return new GeoComplexPolygon(planetModel, pointsList, new GeoPoint(-pole.x, -pole.y, -pole.z), !isPoleInside);\n        }\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+testPointShape);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8dc2dbc28de286321b0c897c64f47895835e0df2","date":1521403949,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeLargeGeoPolygon(PlanetModel,List[PolygonDescription]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeLargeGeoPolygon(PlanetModel,List[PolygonDescription]).mjava","sourceNew":"  /** Create a large GeoPolygon.  This is one which has more than 100 sides and/or may have resolution problems\n   * with very closely spaced points, which often occurs when the polygon was constructed to approximate curves.  No tiling\n   * is done, and intersections and membership are optimized for having large numbers of sides.\n   *\n   * This method does very little checking for legality.  It expects the incoming shapes to not intersect\n   * each other.  The shapes can be disjoint or nested.  If the shapes listed are nested, then we are describing holes.\n   * There is no limit to the depth of holes.  However, if a shape is nested within another it must be explicitly\n   * described as being a child of the other shape.\n   *\n   * Membership in any given shape is described by the clockwise/counterclockwise direction of the points.  The\n   * clockwise direction indicates that a point inside is \"in-set\", while a counter-clockwise direction implies that\n   * a point inside is \"out-of-set\".\n   * \n   * @param planetModel is the planet model.\n   * @param shapesList is the list of polygons we should be making.\n   * @return the GeoPolygon, or null if it cannot be constructed.\n   */\n  public static GeoPolygon makeLargeGeoPolygon(final PlanetModel planetModel,\n    final List<PolygonDescription> shapesList) {\n      \n    // We're going to be building a single-level list of shapes in the end, with a single point that we know to be inside/outside, which is\n    // not on an edge.\n    \n    final List<List<GeoPoint>> pointsList = new ArrayList<>();\n    \n    BestShape testPointShape = null;\n    for (final PolygonDescription shape : shapesList) {\n      // Convert this shape and its holes to a general list of shapes.  We also need to identify exactly one\n      // legal, non-degenerate shape with no children that we can use to find a test point.  We also optimize\n      // to choose as small as possible a polygon for determining the in-set-ness of the test point.\n      testPointShape = convertPolygon(pointsList, shape, testPointShape, true);\n    }\n    \n    // If there's no polygon we can use to determine a test point, we throw up.\n    if (testPointShape == null) {\n      throw new IllegalArgumentException(\"couldn't find a non-degenerate polygon for in-set determination\");\n    }\n\n    final GeoPoint centerOfMass = getCenterOfMass(planetModel, testPointShape.points);\n    final Boolean isCenterOfMassInside = isInsidePolygon(centerOfMass, testPointShape.points);\n    if (isCenterOfMassInside != null) {\n      if (isCenterOfMassInside == testPointShape.poleMustBeInside) {\n        return new GeoComplexPolygon(planetModel, pointsList, centerOfMass, isCenterOfMassInside);\n      } else {\n        return new GeoComplexPolygon(planetModel, pointsList, new GeoPoint(-centerOfMass.x, -centerOfMass.y, -centerOfMass.z), !isCenterOfMassInside);\n      }\n    }\n    \n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, testPointShape.points);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, testPointShape.points);\n      if (isPoleInside != null) {\n        // Legal pole\n        if (isPoleInside == testPointShape.poleMustBeInside) {\n          return new GeoComplexPolygon(planetModel, pointsList, pole, isPoleInside);\n        } else {\n          return new GeoComplexPolygon(planetModel, pointsList, new GeoPoint(-pole.x, -pole.y, -pole.z), !isPoleInside);\n        }\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+testPointShape);\n\n  }\n\n","sourceOld":"  /** Create a large GeoPolygon.  This is one which has more than 100 sides and/or may have resolution problems\n   * with very closely spaced points, which often occurs when the polygon was constructed to approximate curves.  No tiling\n   * is done, and intersections and membership are optimized for having large numbers of sides.\n   *\n   * This method does very little checking for legality.  It expects the incoming shapes to not intersect\n   * each other.  The shapes can be disjoint or nested.  If the shapes listed are nested, then we are describing holes.\n   * There is no limit to the depth of holes.  However, if a shape is nested within another it must be explicitly\n   * described as being a child of the other shape.\n   *\n   * Membership in any given shape is described by the clockwise/counterclockwise direction of the points.  The\n   * clockwise direction indicates that a point inside is \"in-set\", while a counter-clockwise direction implies that\n   * a point inside is \"out-of-set\".\n   * \n   * @param planetModel is the planet model.\n   * @param shapesList is the list of polygons we should be making.\n   * @return the GeoPolygon, or null if it cannot be constructed.\n   */\n  public static GeoPolygon makeLargeGeoPolygon(final PlanetModel planetModel,\n    final List<PolygonDescription> shapesList) {\n      \n    // We're going to be building a single-level list of shapes in the end, with a single point that we know to be inside/outside, which is\n    // not on an edge.\n    \n    final List<List<GeoPoint>> pointsList = new ArrayList<>();\n    \n    BestShape testPointShape = null;\n    for (final PolygonDescription shape : shapesList) {\n      // Convert this shape and its holes to a general list of shapes.  We also need to identify exactly one\n      // legal, non-degenerate shape with no children that we can use to find a test point.  We also optimize\n      // to choose as small as possible a polygon for determining the in-set-ness of the test point.\n      testPointShape = convertPolygon(pointsList, shape, testPointShape, true);\n    }\n    \n    // If there's no polygon we can use to determine a test point, we throw up.\n    if (testPointShape == null) {\n      throw new IllegalArgumentException(\"couldn't find a non-degenerate polygon for in-set determination\");\n    }\n    \n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, testPointShape.points);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, testPointShape.points);\n      if (isPoleInside != null) {\n        // Legal pole\n        if (isPoleInside == testPointShape.poleMustBeInside) {\n          return new GeoComplexPolygon(planetModel, pointsList, pole, isPoleInside);\n        } else {\n          return new GeoComplexPolygon(planetModel, pointsList, new GeoPoint(-pole.x, -pole.y, -pole.z), !isPoleInside);\n        }\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+testPointShape);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa84f2e67c008e40814f776b740022701f3f553f","date":1521978080,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeLargeGeoPolygon(PlanetModel,List[PolygonDescription]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeLargeGeoPolygon(PlanetModel,List[PolygonDescription]).mjava","sourceNew":"  /** Create a large GeoPolygon.  This is one which has more than 100 sides and/or may have resolution problems\n   * with very closely spaced points, which often occurs when the polygon was constructed to approximate curves.  No tiling\n   * is done, and intersections and membership are optimized for having large numbers of sides.\n   *\n   * This method does very little checking for legality.  It expects the incoming shapes to not intersect\n   * each other.  The shapes can be disjoint or nested.  If the shapes listed are nested, then we are describing holes.\n   * There is no limit to the depth of holes.  However, if a shape is nested within another it must be explicitly\n   * described as being a child of the other shape.\n   *\n   * Membership in any given shape is described by the clockwise/counterclockwise direction of the points.  The\n   * clockwise direction indicates that a point inside is \"in-set\", while a counter-clockwise direction implies that\n   * a point inside is \"out-of-set\".\n   * \n   * @param planetModel is the planet model.\n   * @param shapesList is the list of polygons we should be making.\n   * @return the GeoPolygon, or null if it cannot be constructed.\n   */\n  public static GeoPolygon makeLargeGeoPolygon(final PlanetModel planetModel,\n    final List<PolygonDescription> shapesList) {\n      \n    // We're going to be building a single-level list of shapes in the end, with a single point that we know to be inside/outside, which is\n    // not on an edge.\n    \n    final List<List<GeoPoint>> pointsList = new ArrayList<>();\n    \n    BestShape testPointShape = null;\n    for (final PolygonDescription shape : shapesList) {\n      // Convert this shape and its holes to a general list of shapes.  We also need to identify exactly one\n      // legal, non-degenerate shape with no children that we can use to find a test point.  We also optimize\n      // to choose as small as possible a polygon for determining the in-set-ness of the test point.\n      testPointShape = convertPolygon(pointsList, shape, testPointShape, true);\n    }\n    \n    // If there's no polygon we can use to determine a test point, we throw up.\n    if (testPointShape == null) {\n      throw new IllegalArgumentException(\"couldn't find a non-degenerate polygon for in-set determination\");\n    }\n\n    final GeoPoint centerOfMass = getCenterOfMass(planetModel, testPointShape.points);\n    final GeoComplexPolygon comRval = testPointShape.createGeoComplexPolygon(planetModel, pointsList, centerOfMass);\n    if (comRval != null) {\n      return comRval;\n    }\n\n    // Center of mass didn't work.\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, testPointShape.points);\n      final GeoComplexPolygon rval = testPointShape.createGeoComplexPolygon(planetModel, pointsList, pole);\n      if (rval != null) {\n          return rval;\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+testPointShape);\n\n  }\n\n","sourceOld":"  /** Create a large GeoPolygon.  This is one which has more than 100 sides and/or may have resolution problems\n   * with very closely spaced points, which often occurs when the polygon was constructed to approximate curves.  No tiling\n   * is done, and intersections and membership are optimized for having large numbers of sides.\n   *\n   * This method does very little checking for legality.  It expects the incoming shapes to not intersect\n   * each other.  The shapes can be disjoint or nested.  If the shapes listed are nested, then we are describing holes.\n   * There is no limit to the depth of holes.  However, if a shape is nested within another it must be explicitly\n   * described as being a child of the other shape.\n   *\n   * Membership in any given shape is described by the clockwise/counterclockwise direction of the points.  The\n   * clockwise direction indicates that a point inside is \"in-set\", while a counter-clockwise direction implies that\n   * a point inside is \"out-of-set\".\n   * \n   * @param planetModel is the planet model.\n   * @param shapesList is the list of polygons we should be making.\n   * @return the GeoPolygon, or null if it cannot be constructed.\n   */\n  public static GeoPolygon makeLargeGeoPolygon(final PlanetModel planetModel,\n    final List<PolygonDescription> shapesList) {\n      \n    // We're going to be building a single-level list of shapes in the end, with a single point that we know to be inside/outside, which is\n    // not on an edge.\n    \n    final List<List<GeoPoint>> pointsList = new ArrayList<>();\n    \n    BestShape testPointShape = null;\n    for (final PolygonDescription shape : shapesList) {\n      // Convert this shape and its holes to a general list of shapes.  We also need to identify exactly one\n      // legal, non-degenerate shape with no children that we can use to find a test point.  We also optimize\n      // to choose as small as possible a polygon for determining the in-set-ness of the test point.\n      testPointShape = convertPolygon(pointsList, shape, testPointShape, true);\n    }\n    \n    // If there's no polygon we can use to determine a test point, we throw up.\n    if (testPointShape == null) {\n      throw new IllegalArgumentException(\"couldn't find a non-degenerate polygon for in-set determination\");\n    }\n\n    final GeoPoint centerOfMass = getCenterOfMass(planetModel, testPointShape.points);\n    final Boolean isCenterOfMassInside = isInsidePolygon(centerOfMass, testPointShape.points);\n    if (isCenterOfMassInside != null) {\n      if (isCenterOfMassInside == testPointShape.poleMustBeInside) {\n        return new GeoComplexPolygon(planetModel, pointsList, centerOfMass, isCenterOfMassInside);\n      } else {\n        return new GeoComplexPolygon(planetModel, pointsList, new GeoPoint(-centerOfMass.x, -centerOfMass.y, -centerOfMass.z), !isCenterOfMassInside);\n      }\n    }\n    \n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, testPointShape.points);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, testPointShape.points);\n      if (isPoleInside != null) {\n        // Legal pole\n        if (isPoleInside == testPointShape.poleMustBeInside) {\n          return new GeoComplexPolygon(planetModel, pointsList, pole, isPoleInside);\n        } else {\n          return new GeoComplexPolygon(planetModel, pointsList, new GeoPoint(-pole.x, -pole.y, -pole.z), !isPoleInside);\n        }\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+testPointShape);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fa84f2e67c008e40814f776b740022701f3f553f":["8dc2dbc28de286321b0c897c64f47895835e0df2"],"06729f5a814f91b46fa06d668ae86a5d257ba644":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8dc2dbc28de286321b0c897c64f47895835e0df2":["8825024cedab6612bf17c2b808f4f86abe6e45bb"],"8825024cedab6612bf17c2b808f4f86abe6e45bb":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","06729f5a814f91b46fa06d668ae86a5d257ba644"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fa84f2e67c008e40814f776b740022701f3f553f"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8825024cedab6612bf17c2b808f4f86abe6e45bb"]},"commit2Childs":{"fa84f2e67c008e40814f776b740022701f3f553f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"06729f5a814f91b46fa06d668ae86a5d257ba644":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"8dc2dbc28de286321b0c897c64f47895835e0df2":["fa84f2e67c008e40814f776b740022701f3f553f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["06729f5a814f91b46fa06d668ae86a5d257ba644","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","55b50463286869f584cf849d1587a0fcd54d1dfa"],"8825024cedab6612bf17c2b808f4f86abe6e45bb":["8dc2dbc28de286321b0c897c64f47895835e0df2","55b50463286869f584cf849d1587a0fcd54d1dfa"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["8825024cedab6612bf17c2b808f4f86abe6e45bb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}