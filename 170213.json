{"path":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next().mjava","commits":[{"id":"0c3e228bf650e96f3002a8fb73dd0c13d55af077","date":1138253849,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next().mjava","pathOld":"/dev/null","sourceNew":"  public final Token next() throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    while(true) {\n      Token t = input.next();\n      if (t == null) return null;\n\n      String s = t.termText();\n      int off=t.startOffset();\n      int start=0;\n      int end=s.length();\n      if (end==0) continue;\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=s.charAt(start);\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start<end) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start<end) {\n          ch=s.charAt(start);\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos<end) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1<end\n                      && (s.charAt(pos+1)=='s' || s.charAt(pos+1)=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>=end) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = s.charAt(pos+2);\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= end) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = s.charAt(pos);\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        break;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        break;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        break;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    return queue.get(0);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c1ed809566041553006ceafee9618c9c07f2ed15","c1781d63ce2d5e979c8b3f35682b60a86f5df553"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a817c5efd0d36cbf334b211e29e06d5995fe98b","date":1152128168,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next().mjava","pathOld":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next().mjava","sourceNew":"  public final Token next() throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement;\n    while(true) {\n      Token t = input.next();\n      if (t == null) return null;\n\n      String s = t.termText();\n      int start=0;\n      int end=s.length();\n      if (end==0) continue;\n\n      origPosIncrement = t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=s.charAt(start);\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start<end) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start<end) {\n          ch=s.charAt(start);\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos<end) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1<end\n                      && (s.charAt(pos+1)=='s' || s.charAt(pos+1)=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>=end) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = s.charAt(pos+2);\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= end) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              newtok.setPositionIncrement(origPosIncrement);\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = s.charAt(pos);\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        break;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        break;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        break;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    Token tok = queue.get(0);\n    tok.setPositionIncrement(origPosIncrement);\n    return tok;\n  }\n\n","sourceOld":"  public final Token next() throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    while(true) {\n      Token t = input.next();\n      if (t == null) return null;\n\n      String s = t.termText();\n      int off=t.startOffset();\n      int start=0;\n      int end=s.length();\n      if (end==0) continue;\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=s.charAt(start);\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start<end) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start<end) {\n          ch=s.charAt(start);\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos<end) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1<end\n                      && (s.charAt(pos+1)=='s' || s.charAt(pos+1)=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>=end) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = s.charAt(pos+2);\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= end) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = s.charAt(pos);\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        break;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        break;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        break;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    return queue.get(0);\n  }\n\n","bugFix":null,"bugIntro":["1d786062be6da940351591ec2372ddd0ae56bd39"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1781d63ce2d5e979c8b3f35682b60a86f5df553","date":1153254917,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next().mjava","pathOld":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next().mjava","sourceNew":"  public final Token next() throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement;\n    while(true) {\n      Token t = input.next();\n      if (t == null) return null;\n\n      String s = t.termText();\n      int start=0;\n      int end=s.length();\n      if (end==0) continue;\n\n      origPosIncrement = t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=s.charAt(start);\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start<end) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start<end) {\n          ch=s.charAt(start);\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos<end) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1<end\n                      && (s.charAt(pos+1)=='s' || s.charAt(pos+1)=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>=end) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = s.charAt(pos+2);\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= end) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              newtok.setPositionIncrement(origPosIncrement);\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = s.charAt(pos);\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  In this case, we should proceed\n      // to next token rather than throwing ArrayOutOfBounds\n      if (queue.size() > 0) break; else continue;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    Token tok = queue.get(0);\n    tok.setPositionIncrement(origPosIncrement);\n    return tok;\n  }\n\n","sourceOld":"  public final Token next() throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement;\n    while(true) {\n      Token t = input.next();\n      if (t == null) return null;\n\n      String s = t.termText();\n      int start=0;\n      int end=s.length();\n      if (end==0) continue;\n\n      origPosIncrement = t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=s.charAt(start);\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start<end) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start<end) {\n          ch=s.charAt(start);\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos<end) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1<end\n                      && (s.charAt(pos+1)=='s' || s.charAt(pos+1)=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>=end) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = s.charAt(pos+2);\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= end) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              newtok.setPositionIncrement(origPosIncrement);\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = s.charAt(pos);\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        break;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        break;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        break;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    Token tok = queue.get(0);\n    tok.setPositionIncrement(origPosIncrement);\n    return tok;\n  }\n\n","bugFix":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9dc742c2b65c42d7b5a9b1b7b2eb5c6d3e5e01d4","date":1153841692,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next().mjava","pathOld":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next().mjava","sourceNew":"  public final Token next() throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement;\n    while(true) {\n      Token t = input.next();\n      if (t == null) return null;\n\n      String s = t.termText();\n      int start=0;\n      int end=s.length();\n      if (end==0) continue;\n\n      origPosIncrement = t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=s.charAt(start);\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start<end) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start<end) {\n          ch=s.charAt(start);\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos<end) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1<end\n                      && (s.charAt(pos+1)=='s' || s.charAt(pos+1)=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>=end) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = s.charAt(pos+2);\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= end) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              newtok.setPositionIncrement(origPosIncrement);\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = s.charAt(pos);\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    Token tok = queue.get(0);\n    tok.setPositionIncrement(origPosIncrement);\n    return tok;\n  }\n\n","sourceOld":"  public final Token next() throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement;\n    while(true) {\n      Token t = input.next();\n      if (t == null) return null;\n\n      String s = t.termText();\n      int start=0;\n      int end=s.length();\n      if (end==0) continue;\n\n      origPosIncrement = t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=s.charAt(start);\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start<end) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start<end) {\n          ch=s.charAt(start);\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos<end) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1<end\n                      && (s.charAt(pos+1)=='s' || s.charAt(pos+1)=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>=end) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = s.charAt(pos+2);\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= end) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              newtok.setPositionIncrement(origPosIncrement);\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = s.charAt(pos);\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  In this case, we should proceed\n      // to next token rather than throwing ArrayOutOfBounds\n      if (queue.size() > 0) break; else continue;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    Token tok = queue.get(0);\n    tok.setPositionIncrement(origPosIncrement);\n    return tok;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"32765564f95f9c4beea3e121f7f8831ce1a89539","date":1181329347,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next().mjava","pathOld":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next().mjava","sourceNew":"  public final Token next() throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement;\n    while(true) {\n      Token t = input.next();\n      if (t == null) return null;\n\n      String s = t.termText();\n      int start=0;\n      int end=s.length();\n      if (end==0) continue;\n\n      origPosIncrement = t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=s.charAt(start);\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start<end) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start<end) {\n          ch=s.charAt(start);\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos<end) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1<end\n                      && (s.charAt(pos+1)=='s' || s.charAt(pos+1)=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>=end) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = s.charAt(pos+2);\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n\n            } else if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= end) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              newtok.setPositionIncrement(origPosIncrement);\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = s.charAt(pos);\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    Token tok = queue.get(0);\n    tok.setPositionIncrement(origPosIncrement);\n    return tok;\n  }\n\n","sourceOld":"  public final Token next() throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement;\n    while(true) {\n      Token t = input.next();\n      if (t == null) return null;\n\n      String s = t.termText();\n      int start=0;\n      int end=s.length();\n      if (end==0) continue;\n\n      origPosIncrement = t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=s.charAt(start);\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start<end) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start<end) {\n          ch=s.charAt(start);\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos<end) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1<end\n                      && (s.charAt(pos+1)=='s' || s.charAt(pos+1)=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>=end) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = s.charAt(pos+2);\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= end) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              newtok.setPositionIncrement(origPosIncrement);\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = s.charAt(pos);\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    Token tok = queue.get(0);\n    tok.setPositionIncrement(origPosIncrement);\n    return tok;\n  }\n\n","bugFix":null,"bugIntro":["c1ed809566041553006ceafee9618c9c07f2ed15"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe8ae1ed027200f075b0de9f264776fa32c4862f","date":1207066219,"type":5,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","pathOld":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next().mjava","sourceNew":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement;\n    while(true) {\n      Token t = input.next();\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      origPosIncrement = t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n\n            } else if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              newtok.setPositionIncrement(origPosIncrement);\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    Token tok = queue.get(0);\n    tok.setPositionIncrement(origPosIncrement);\n    return tok;\n  }\n\n","sourceOld":"  public final Token next() throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement;\n    while(true) {\n      Token t = input.next();\n      if (t == null) return null;\n\n      String s = t.termText();\n      int start=0;\n      int end=s.length();\n      if (end==0) continue;\n\n      origPosIncrement = t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=s.charAt(start);\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start<end) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start<end) {\n          ch=s.charAt(start);\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos<end) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1<end\n                      && (s.charAt(pos+1)=='s' || s.charAt(pos+1)=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>=end) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = s.charAt(pos+2);\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n\n            } else if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= end) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              newtok.setPositionIncrement(origPosIncrement);\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = s.charAt(pos);\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    Token tok = queue.get(0);\n    tok.setPositionIncrement(origPosIncrement);\n    return tok;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"fe8ae1ed027200f075b0de9f264776fa32c4862f":["32765564f95f9c4beea3e121f7f8831ce1a89539"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"9dc742c2b65c42d7b5a9b1b7b2eb5c6d3e5e01d4":["c1781d63ce2d5e979c8b3f35682b60a86f5df553"],"c1781d63ce2d5e979c8b3f35682b60a86f5df553":["1a817c5efd0d36cbf334b211e29e06d5995fe98b"],"1a817c5efd0d36cbf334b211e29e06d5995fe98b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"32765564f95f9c4beea3e121f7f8831ce1a89539":["9dc742c2b65c42d7b5a9b1b7b2eb5c6d3e5e01d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"fe8ae1ed027200f075b0de9f264776fa32c4862f":[],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["1a817c5efd0d36cbf334b211e29e06d5995fe98b"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9dc742c2b65c42d7b5a9b1b7b2eb5c6d3e5e01d4":["32765564f95f9c4beea3e121f7f8831ce1a89539"],"c1781d63ce2d5e979c8b3f35682b60a86f5df553":["9dc742c2b65c42d7b5a9b1b7b2eb5c6d3e5e01d4"],"1a817c5efd0d36cbf334b211e29e06d5995fe98b":["c1781d63ce2d5e979c8b3f35682b60a86f5df553"],"32765564f95f9c4beea3e121f7f8831ce1a89539":["fe8ae1ed027200f075b0de9f264776fa32c4862f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe8ae1ed027200f075b0de9f264776fa32c4862f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}