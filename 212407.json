{"path":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","commits":[{"id":"d0492616b11aace806d95ec9df44f57a60160bf7","date":1327803775,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","pathOld":"/dev/null","sourceNew":"      @Override\n      public void run() {\n        while (amILeader()) {\n          \n          \n          LinkedList<CloudStateUpdateRequest> requests = new LinkedList<Overseer.CloudStateUpdateRequest>();\n          while (!fifo.isEmpty()) {\n            // collect all queued requests\n            CloudStateUpdateRequest req;\n            req = fifo.poll();\n            if (req == null) {\n              break;\n            }\n            requests.add(req);\n          }\n\n          if (requests.size() > 0) {\n            // process updates\n            synchronized (reader.getUpdateLock()) {\n              try {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                for (CloudStateUpdateRequest request : requests) {\n\n                  switch (request.operation) {\n                  case LeaderChange:\n                    cloudState = setShardLeader(cloudState,\n                        (String) request.args[0], (String) request.args[1],\n                        (String) request.args[2]);\n\n                    break;\n                  case StateChange:\n                    cloudState = updateState(cloudState,\n                        (String) request.args[0], (CoreState) request.args[1]);\n                    break;\n\n                  }\n                }\n\n                log.info(\"Announcing new cluster state\");\n                zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                    ZkStateReader.toJSON(cloudState), true);\n\n              } catch (KeeperException e) {\n                // XXX stop processing, exit\n                return;\n              } catch (InterruptedException e) {\n                // XXX stop processing, exit\n                return;\n              }\n            }\n          }\n\n          try {\n            Thread.sleep(STATE_UPDATE_DELAY);\n          } catch (InterruptedException e) {\n            //\n          }\n        }\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["f0ebe4956ab158d9fbe10c7101f3992656b48a22","f0ebe4956ab158d9fbe10c7101f3992656b48a22"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8f4a0c306589f8607dc4b33f7abaf753db19f76e","date":1327836084,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","pathOld":"/dev/null","sourceNew":"      @Override\n      public void run() {\n        while (amILeader()) {\n          \n          \n          LinkedList<CloudStateUpdateRequest> requests = new LinkedList<Overseer.CloudStateUpdateRequest>();\n          while (!fifo.isEmpty()) {\n            // collect all queued requests\n            CloudStateUpdateRequest req;\n            req = fifo.poll();\n            if (req == null) {\n              break;\n            }\n            requests.add(req);\n          }\n\n          if (requests.size() > 0) {\n            // process updates\n            synchronized (reader.getUpdateLock()) {\n              try {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                for (CloudStateUpdateRequest request : requests) {\n\n                  switch (request.operation) {\n                  case LeaderChange:\n                    cloudState = setShardLeader(cloudState,\n                        (String) request.args[0], (String) request.args[1],\n                        (String) request.args[2]);\n\n                    break;\n                  case StateChange:\n                    cloudState = updateState(cloudState,\n                        (String) request.args[0], (CoreState) request.args[1]);\n                    break;\n\n                  }\n                }\n\n                log.info(\"Announcing new cluster state\");\n                zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                    ZkStateReader.toJSON(cloudState), true);\n\n              } catch (KeeperException e) {\n                // XXX stop processing, exit\n                return;\n              } catch (InterruptedException e) {\n                // XXX stop processing, exit\n                return;\n              }\n            }\n          }\n\n          try {\n            Thread.sleep(STATE_UPDATE_DELAY);\n          } catch (InterruptedException e) {\n            //\n          }\n        }\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","pathOld":"/dev/null","sourceNew":"      @Override\n      public void run() {\n        while (amILeader()) {\n          \n          \n          LinkedList<CloudStateUpdateRequest> requests = new LinkedList<Overseer.CloudStateUpdateRequest>();\n          while (!fifo.isEmpty()) {\n            // collect all queued requests\n            CloudStateUpdateRequest req;\n            req = fifo.poll();\n            if (req == null) {\n              break;\n            }\n            requests.add(req);\n          }\n\n          if (requests.size() > 0) {\n            // process updates\n            synchronized (reader.getUpdateLock()) {\n              try {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                for (CloudStateUpdateRequest request : requests) {\n\n                  switch (request.operation) {\n                  case LeaderChange:\n                    cloudState = setShardLeader(cloudState,\n                        (String) request.args[0], (String) request.args[1],\n                        (String) request.args[2]);\n\n                    break;\n                  case StateChange:\n                    cloudState = updateState(cloudState,\n                        (String) request.args[0], (CoreState) request.args[1]);\n                    break;\n\n                  }\n                }\n\n                log.info(\"Announcing new cluster state\");\n                zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                    ZkStateReader.toJSON(cloudState), true);\n\n              } catch (KeeperException e) {\n                // XXX stop processing, exit\n                return;\n              } catch (InterruptedException e) {\n                // XXX stop processing, exit\n                return;\n              }\n            }\n          }\n\n          try {\n            Thread.sleep(STATE_UPDATE_DELAY);\n          } catch (InterruptedException e) {\n            //\n          }\n        }\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8dd2b430bd970d889d5c094962234669067b7736","date":1328111530,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","sourceNew":"      @Override\n      public void run() {\n        while (amILeader()) {\n          \n          \n          LinkedList<CloudStateUpdateRequest> requests = new LinkedList<Overseer.CloudStateUpdateRequest>();\n          while (!fifo.isEmpty()) {\n            // collect all queued requests\n            CloudStateUpdateRequest req;\n            req = fifo.poll();\n            if (req == null) {\n              break;\n            }\n            requests.add(req);\n          }\n\n          if (requests.size() > 0) {\n            // process updates\n            synchronized (reader.getUpdateLock()) {\n              try {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                for (CloudStateUpdateRequest request : requests) {\n\n                  switch (request.operation) {\n                  case LeaderChange:\n                    cloudState = setShardLeader(cloudState,\n                        (String) request.args[0], (String) request.args[1],\n                        (String) request.args[2]);\n\n                    break;\n                  case StateChange:\n                    cloudState = updateState(cloudState,\n                        (String) request.args[0], (CoreState) request.args[1]);\n                    break;\n\n                  }\n                }\n\n                log.info(\"Announcing new cluster state\");\n                zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                    ZkStateReader.toJSON(cloudState), true);\n\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                SolrException.log(log, \"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                return;\n              }\n            }\n          }\n\n          try {\n            Thread.sleep(STATE_UPDATE_DELAY);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n\n","sourceOld":"      @Override\n      public void run() {\n        while (amILeader()) {\n          \n          \n          LinkedList<CloudStateUpdateRequest> requests = new LinkedList<Overseer.CloudStateUpdateRequest>();\n          while (!fifo.isEmpty()) {\n            // collect all queued requests\n            CloudStateUpdateRequest req;\n            req = fifo.poll();\n            if (req == null) {\n              break;\n            }\n            requests.add(req);\n          }\n\n          if (requests.size() > 0) {\n            // process updates\n            synchronized (reader.getUpdateLock()) {\n              try {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                for (CloudStateUpdateRequest request : requests) {\n\n                  switch (request.operation) {\n                  case LeaderChange:\n                    cloudState = setShardLeader(cloudState,\n                        (String) request.args[0], (String) request.args[1],\n                        (String) request.args[2]);\n\n                    break;\n                  case StateChange:\n                    cloudState = updateState(cloudState,\n                        (String) request.args[0], (CoreState) request.args[1]);\n                    break;\n\n                  }\n                }\n\n                log.info(\"Announcing new cluster state\");\n                zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                    ZkStateReader.toJSON(cloudState), true);\n\n              } catch (KeeperException e) {\n                // XXX stop processing, exit\n                return;\n              } catch (InterruptedException e) {\n                // XXX stop processing, exit\n                return;\n              }\n            }\n          }\n\n          try {\n            Thread.sleep(STATE_UPDATE_DELAY);\n          } catch (InterruptedException e) {\n            //\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c51a2dcb8b4e1820a44f35f11961110201e06cdb","date":1329994529,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","sourceNew":"      @Override\n      public void run() {\n        while (amILeader()) {\n          \n          \n          LinkedList<CloudStateUpdateRequest> requests = new LinkedList<Overseer.CloudStateUpdateRequest>();\n          while (!fifo.isEmpty()) {\n            // collect all queued requests\n            CloudStateUpdateRequest req;\n            req = fifo.poll();\n            if (req == null) {\n              break;\n            }\n            requests.add(req);\n          }\n\n          if (requests.size() > 0) {\n            // process updates\n            synchronized (reader.getUpdateLock()) {\n              try {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                for (CloudStateUpdateRequest request : requests) {\n\n                  switch (request.operation) {\n                  case LeaderChange:\n                    cloudState = setShardLeader(cloudState,\n                        (String) request.args[0], (String) request.args[1],\n                        (String) request.args[2]);\n\n                    break;\n                  case StateChange:\n                    cloudState = updateState(cloudState,\n                        (String) request.args[0], (CoreState) request.args[1]);\n                    break;\n\n                  case CoreDeleted:\n                    cloudState = removeCore(cloudState, (String) request.args[0], (String) request.args[1]);\n                    break;\n                  }\n                }\n\n                log.info(\"Announcing new cluster state\");\n                zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                    ZkStateReader.toJSON(cloudState), true);\n\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                SolrException.log(log, \"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                return;\n              }\n            }\n          }\n\n          try {\n            Thread.sleep(STATE_UPDATE_DELAY);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n\n","sourceOld":"      @Override\n      public void run() {\n        while (amILeader()) {\n          \n          \n          LinkedList<CloudStateUpdateRequest> requests = new LinkedList<Overseer.CloudStateUpdateRequest>();\n          while (!fifo.isEmpty()) {\n            // collect all queued requests\n            CloudStateUpdateRequest req;\n            req = fifo.poll();\n            if (req == null) {\n              break;\n            }\n            requests.add(req);\n          }\n\n          if (requests.size() > 0) {\n            // process updates\n            synchronized (reader.getUpdateLock()) {\n              try {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                for (CloudStateUpdateRequest request : requests) {\n\n                  switch (request.operation) {\n                  case LeaderChange:\n                    cloudState = setShardLeader(cloudState,\n                        (String) request.args[0], (String) request.args[1],\n                        (String) request.args[2]);\n\n                    break;\n                  case StateChange:\n                    cloudState = updateState(cloudState,\n                        (String) request.args[0], (CoreState) request.args[1]);\n                    break;\n\n                  }\n                }\n\n                log.info(\"Announcing new cluster state\");\n                zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                    ZkStateReader.toJSON(cloudState), true);\n\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                SolrException.log(log, \"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                return;\n              }\n            }\n          }\n\n          try {\n            Thread.sleep(STATE_UPDATE_DELAY);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","sourceNew":"      @Override\n      public void run() {\n        while (amILeader()) {\n          \n          \n          LinkedList<CloudStateUpdateRequest> requests = new LinkedList<Overseer.CloudStateUpdateRequest>();\n          while (!fifo.isEmpty()) {\n            // collect all queued requests\n            CloudStateUpdateRequest req;\n            req = fifo.poll();\n            if (req == null) {\n              break;\n            }\n            requests.add(req);\n          }\n\n          if (requests.size() > 0) {\n            // process updates\n            synchronized (reader.getUpdateLock()) {\n              try {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                for (CloudStateUpdateRequest request : requests) {\n\n                  switch (request.operation) {\n                  case LeaderChange:\n                    cloudState = setShardLeader(cloudState,\n                        (String) request.args[0], (String) request.args[1],\n                        (String) request.args[2]);\n\n                    break;\n                  case StateChange:\n                    cloudState = updateState(cloudState,\n                        (String) request.args[0], (CoreState) request.args[1]);\n                    break;\n\n                  case CoreDeleted:\n                    cloudState = removeCore(cloudState, (String) request.args[0], (String) request.args[1]);\n                    break;\n                  }\n                }\n\n                log.info(\"Announcing new cluster state\");\n                zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                    ZkStateReader.toJSON(cloudState), true);\n\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                SolrException.log(log, \"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                return;\n              }\n            }\n          }\n\n          try {\n            Thread.sleep(STATE_UPDATE_DELAY);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n\n","sourceOld":"      @Override\n      public void run() {\n        while (amILeader()) {\n          \n          \n          LinkedList<CloudStateUpdateRequest> requests = new LinkedList<Overseer.CloudStateUpdateRequest>();\n          while (!fifo.isEmpty()) {\n            // collect all queued requests\n            CloudStateUpdateRequest req;\n            req = fifo.poll();\n            if (req == null) {\n              break;\n            }\n            requests.add(req);\n          }\n\n          if (requests.size() > 0) {\n            // process updates\n            synchronized (reader.getUpdateLock()) {\n              try {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                for (CloudStateUpdateRequest request : requests) {\n\n                  switch (request.operation) {\n                  case LeaderChange:\n                    cloudState = setShardLeader(cloudState,\n                        (String) request.args[0], (String) request.args[1],\n                        (String) request.args[2]);\n\n                    break;\n                  case StateChange:\n                    cloudState = updateState(cloudState,\n                        (String) request.args[0], (CoreState) request.args[1]);\n                    break;\n\n                  }\n                }\n\n                log.info(\"Announcing new cluster state\");\n                zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                    ZkStateReader.toJSON(cloudState), true);\n\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                SolrException.log(log, \"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                return;\n              }\n            }\n          }\n\n          try {\n            Thread.sleep(STATE_UPDATE_DELAY);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5093a9e893633cc091cf2f729d7863671c2b715","date":1339132888,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if(amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  cloudState = processMessage(cloudState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(cloudState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateCloudState(true);\n              CloudState cloudState = reader.getCloudState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                cloudState = processMessage(cloudState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(cloudState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"      @Override\n      public void run() {\n        while (amILeader()) {\n          \n          \n          LinkedList<CloudStateUpdateRequest> requests = new LinkedList<Overseer.CloudStateUpdateRequest>();\n          while (!fifo.isEmpty()) {\n            // collect all queued requests\n            CloudStateUpdateRequest req;\n            req = fifo.poll();\n            if (req == null) {\n              break;\n            }\n            requests.add(req);\n          }\n\n          if (requests.size() > 0) {\n            // process updates\n            synchronized (reader.getUpdateLock()) {\n              try {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                for (CloudStateUpdateRequest request : requests) {\n\n                  switch (request.operation) {\n                  case LeaderChange:\n                    cloudState = setShardLeader(cloudState,\n                        (String) request.args[0], (String) request.args[1],\n                        (String) request.args[2]);\n\n                    break;\n                  case StateChange:\n                    cloudState = updateState(cloudState,\n                        (String) request.args[0], (CoreState) request.args[1]);\n                    break;\n\n                  case CoreDeleted:\n                    cloudState = removeCore(cloudState, (String) request.args[0], (String) request.args[1]);\n                    break;\n                  }\n                }\n\n                log.info(\"Announcing new cluster state\");\n                zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                    ZkStateReader.toJSON(cloudState), true);\n\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                SolrException.log(log, \"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                return;\n              }\n            }\n          }\n\n          try {\n            Thread.sleep(STATE_UPDATE_DELAY);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":["314edcfba84a78d1a59020136cd92031e76a6bed","314edcfba84a78d1a59020136cd92031e76a6bed","f0ebe4956ab158d9fbe10c7101f3992656b48a22","f0ebe4956ab158d9fbe10c7101f3992656b48a22"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7fc3dbbe93b8019e6a9343b07d0a2fe503282f32","date":1339406523,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if(amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  cloudState = processMessage(cloudState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(cloudState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateCloudState(true);\n              CloudState cloudState = reader.getCloudState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                cloudState = processMessage(cloudState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(cloudState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  cloudState = processMessage(cloudState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(cloudState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateCloudState(true);\n              CloudState cloudState = reader.getCloudState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                cloudState = processMessage(cloudState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(cloudState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["f0ebe4956ab158d9fbe10c7101f3992656b48a22","f0ebe4956ab158d9fbe10c7101f3992656b48a22"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"938e4fd7b1e4b34da1650edba7471764bbfaefde","date":1344033248,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if(amILeader() && !Overseer.this.isClosed) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  cloudState = processMessage(cloudState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(cloudState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader() && !isClosed) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateCloudState(true);\n              CloudState cloudState = reader.getCloudState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                cloudState = processMessage(cloudState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(cloudState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  cloudState = processMessage(cloudState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(cloudState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateCloudState(true);\n              CloudState cloudState = reader.getCloudState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                cloudState = processMessage(cloudState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(cloudState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if(amILeader() && !Overseer.this.isClosed) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader() && !isClosed) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(amILeader() && !Overseer.this.isClosed) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  cloudState = processMessage(cloudState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(cloudState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader() && !isClosed) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateCloudState(true);\n              CloudState cloudState = reader.getCloudState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                cloudState = processMessage(cloudState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(cloudState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["f0ebe4956ab158d9fbe10c7101f3992656b48a22","f0ebe4956ab158d9fbe10c7101f3992656b48a22"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if(amILeader() && !Overseer.this.isClosed) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader() && !isClosed) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  cloudState = processMessage(cloudState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(cloudState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateCloudState(true);\n              CloudState cloudState = reader.getCloudState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                cloudState = processMessage(cloudState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(cloudState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","sourceNew":null,"sourceOld":"    @Override\n    public void run() {\n        \n      if(amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  cloudState = processMessage(cloudState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(cloudState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateCloudState(true);\n              CloudState cloudState = reader.getCloudState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                cloudState = processMessage(cloudState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(cloudState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["8dd2b430bd970d889d5c094962234669067b7736","c51a2dcb8b4e1820a44f35f11961110201e06cdb"],"938e4fd7b1e4b34da1650edba7471764bbfaefde":["7fc3dbbe93b8019e6a9343b07d0a2fe503282f32"],"8dd2b430bd970d889d5c094962234669067b7736":["d0492616b11aace806d95ec9df44f57a60160bf7"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d0492616b11aace806d95ec9df44f57a60160bf7"],"d0492616b11aace806d95ec9df44f57a60160bf7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["7fc3dbbe93b8019e6a9343b07d0a2fe503282f32","3f767f8c99eaedb984df754fe61f21c5de260f94"],"c51a2dcb8b4e1820a44f35f11961110201e06cdb":["8dd2b430bd970d889d5c094962234669067b7736"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["938e4fd7b1e4b34da1650edba7471764bbfaefde"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a5093a9e893633cc091cf2f729d7863671c2b715":["c51a2dcb8b4e1820a44f35f11961110201e06cdb"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["7fc3dbbe93b8019e6a9343b07d0a2fe503282f32","3f767f8c99eaedb984df754fe61f21c5de260f94"],"8f4a0c306589f8607dc4b33f7abaf753db19f76e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d0492616b11aace806d95ec9df44f57a60160bf7"],"7fc3dbbe93b8019e6a9343b07d0a2fe503282f32":["a5093a9e893633cc091cf2f729d7863671c2b715"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f767f8c99eaedb984df754fe61f21c5de260f94"]},"commit2Childs":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"8dd2b430bd970d889d5c094962234669067b7736":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","c51a2dcb8b4e1820a44f35f11961110201e06cdb"],"938e4fd7b1e4b34da1650edba7471764bbfaefde":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"fd92b8bcc88e969302510acf77bd6970da3994c4":[],"d0492616b11aace806d95ec9df44f57a60160bf7":["8dd2b430bd970d889d5c094962234669067b7736","fd92b8bcc88e969302510acf77bd6970da3994c4","8f4a0c306589f8607dc4b33f7abaf753db19f76e"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"c51a2dcb8b4e1820a44f35f11961110201e06cdb":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","a5093a9e893633cc091cf2f729d7863671c2b715"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fd92b8bcc88e969302510acf77bd6970da3994c4","d0492616b11aace806d95ec9df44f57a60160bf7","8f4a0c306589f8607dc4b33f7abaf753db19f76e"],"a5093a9e893633cc091cf2f729d7863671c2b715":["7fc3dbbe93b8019e6a9343b07d0a2fe503282f32"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"8f4a0c306589f8607dc4b33f7abaf753db19f76e":[],"7fc3dbbe93b8019e6a9343b07d0a2fe503282f32":["938e4fd7b1e4b34da1650edba7471764bbfaefde","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","fd92b8bcc88e969302510acf77bd6970da3994c4","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b","8f4a0c306589f8607dc4b33f7abaf753db19f76e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}