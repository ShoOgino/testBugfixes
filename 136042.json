{"path":"lucene/monitor/src/java/org/apache/lucene/monitor/QueryIndex#purgeCache(CachePopulator).mjava","commits":[{"id":"7c529b189e09de25455d82ebd7260748cf11ee14","date":1560415257,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/monitor/src/java/org/apache/lucene/monitor/QueryIndex#purgeCache(CachePopulator).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Remove unused queries from the query cache.\n   * <p>\n   * This is normally called from a background thread at a rate set by configurePurgeFrequency().\n   *\n   * @throws IOException on IO errors\n   */\n  private synchronized void purgeCache(CachePopulator populator) throws IOException {\n\n    // Note on implementation\n\n    // The purge works by scanning the query index and creating a new query cache populated\n    // for each query in the index.  When the scan is complete, the old query cache is swapped\n    // for the new, allowing it to be garbage-collected.\n\n    // In order to not drop cached queries that have been added while a purge is ongoing,\n    // we use a ReadWriteLock to guard the creation and removal of an register log.  Commits take\n    // the read lock.  If the register log has been created, then a purge is ongoing, and queries\n    // are added to the register log within the read lock guard.\n\n    // The purge takes the write lock when creating the register log, and then when swapping out\n    // the old query cache.  Within the second write lock guard, the contents of the register log\n    // are added to the new query cache, and the register log itself is removed.\n\n    final ConcurrentMap<String, QueryCacheEntry> newCache = new ConcurrentHashMap<>();\n\n    purgeLock.writeLock().lock();\n    try {\n      purgeCache = new ConcurrentHashMap<>();\n    } finally {\n      purgeLock.writeLock().unlock();\n    }\n\n    populator.populateCacheWithIndex(newCache);\n\n    purgeLock.writeLock().lock();\n    try {\n      newCache.putAll(purgeCache);\n      purgeCache = null;\n      queries = newCache;\n    } finally {\n      purgeLock.writeLock().unlock();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7c529b189e09de25455d82ebd7260748cf11ee14":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7c529b189e09de25455d82ebd7260748cf11ee14"]},"commit2Childs":{"7c529b189e09de25455d82ebd7260748cf11ee14":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7c529b189e09de25455d82ebd7260748cf11ee14"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}