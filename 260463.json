{"path":"contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer#addEntry(StorageEntryWrapper).mjava","commits":[{"id":"5d43e216d757e2276d180eba8a192e300c4bfadb","date":1149717385,"type":0,"author":"Doug Cutting","isMerge":false,"pathNew":"contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer#addEntry(StorageEntryWrapper).mjava","pathOld":"/dev/null","sourceNew":"    /** \n     * Adds a {@link StorageEntryWrapper} to the buffer. If a wrapper \n     * representing the same entry are already in the buffer the wrapper will be \n     * replaced. \n     *  \n     * @param wrapper - \n     *            the wrapper to buffer \n     */ \n    public void addEntry(final StorageEntryWrapper wrapper) { \n        this.writeLock.lock(); \n        try { \n            if (LOG.isInfoEnabled()) \n                LOG.info(\" Buffering wrapper - \" + wrapper.getOperation() \n                        + \" ID: \" + wrapper.getEntryId() + \" FeedID: \" \n                        + wrapper.getFeedId()); \n            if (wrapper.getOperation().equals(StorageOperation.DELETE)) \n                return; \n \n            String feedId = wrapper.getFeedId(); \n            if (this.bufferMap.containsKey(feedId)) \n                this.bufferMap.get(feedId).put(wrapper.getEntryId(), wrapper); \n            else { \n                Map<String, StorageEntryWrapper> newFeedMap = new HashMap<String, StorageEntryWrapper>( \n                        20); \n                newFeedMap.put(wrapper.getEntryId(), wrapper); \n                this.bufferMap.put(feedId, newFeedMap); \n            } \n        } finally { \n            /* \n             * add all to exclude from searches doc will be available via the \n             * buffer \n             */ \n            this.excludeList.add(wrapper.getEntryId()); \n            this.writeLock.unlock(); \n        } \n    } \n\n","sourceOld":null,"bugFix":null,"bugIntro":["02a7f04a7293ea604e17892ba0bded7341adf3af"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"52754a40a1550056d5637c8992b4076b5ed77328","date":1151345693,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer#addEntry(StorageEntryWrapper).mjava","pathOld":"contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer#addEntry(StorageEntryWrapper).mjava","sourceNew":"    /** \n     * Adds a {@link StorageEntryWrapper} to the buffer. If a wrapper \n     * representing the same entry are already in the buffer the wrapper will be \n     * replaced. \n     *  \n     * @param wrapper - \n     *            the wrapper to buffer \n     */ \n    public void addEntry(final StorageEntryWrapper wrapper) { \n        this.writeLock.lock(); \n        try { \n            if (LOG.isInfoEnabled()) \n                LOG.info(\" Buffering wrapper - \" + wrapper.getOperation() \n                        + \" ID: \" + wrapper.getEntryId() + \" FeedID: \" \n                        + wrapper.getFeedId()); \n            if (wrapper.getOperation().equals(StorageOperation.DELETE)) \n                return; \n \n            String feedId = wrapper.getFeedId(); \n            if (this.bufferMap.containsKey(feedId)) \n                this.bufferMap.get(feedId).put(wrapper.getEntryId(), wrapper); \n            else { \n                Map<String, StorageEntryWrapper> newFeedMap = new HashMap<String, StorageEntryWrapper>( \n                        20); \n                newFeedMap.put(wrapper.getEntryId(), wrapper); \n                this.bufferMap.put(feedId, newFeedMap); \n                \n            } \n            addLastModified(wrapper.getFeedId(),wrapper.getTimestamp());\n        } finally { \n            /* \n             * add all to exclude from searches doc will be available via the \n             * buffer \n             */ \n            this.excludeList.add(wrapper.getEntryId()); \n            this.writeLock.unlock(); \n        } \n    } \n\n","sourceOld":"    /** \n     * Adds a {@link StorageEntryWrapper} to the buffer. If a wrapper \n     * representing the same entry are already in the buffer the wrapper will be \n     * replaced. \n     *  \n     * @param wrapper - \n     *            the wrapper to buffer \n     */ \n    public void addEntry(final StorageEntryWrapper wrapper) { \n        this.writeLock.lock(); \n        try { \n            if (LOG.isInfoEnabled()) \n                LOG.info(\" Buffering wrapper - \" + wrapper.getOperation() \n                        + \" ID: \" + wrapper.getEntryId() + \" FeedID: \" \n                        + wrapper.getFeedId()); \n            if (wrapper.getOperation().equals(StorageOperation.DELETE)) \n                return; \n \n            String feedId = wrapper.getFeedId(); \n            if (this.bufferMap.containsKey(feedId)) \n                this.bufferMap.get(feedId).put(wrapper.getEntryId(), wrapper); \n            else { \n                Map<String, StorageEntryWrapper> newFeedMap = new HashMap<String, StorageEntryWrapper>( \n                        20); \n                newFeedMap.put(wrapper.getEntryId(), wrapper); \n                this.bufferMap.put(feedId, newFeedMap); \n            } \n        } finally { \n            /* \n             * add all to exclude from searches doc will be available via the \n             * buffer \n             */ \n            this.excludeList.add(wrapper.getEntryId()); \n            this.writeLock.unlock(); \n        } \n    } \n\n","bugFix":null,"bugIntro":["02a7f04a7293ea604e17892ba0bded7341adf3af"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02a7f04a7293ea604e17892ba0bded7341adf3af","date":1151695892,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer#addEntry(StorageEntryWrapper).mjava","pathOld":"contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer#addEntry(StorageEntryWrapper).mjava","sourceNew":"\t/**\n\t * Adds a {@link StorageEntryWrapper} to the buffer. If a wrapper\n\t * representing the same entry are already in the buffer the wrapper will be\n\t * replaced.\n\t * \n\t * @param wrapper -\n\t *            the wrapper to buffer\n\t */\n\tpublic void addEntry(final StorageEntryWrapper wrapper) {\n\t\tthis.writeLock.lock();\n\t\ttry {\n\t\t\tif (LOG.isInfoEnabled())\n\t\t\t\tLOG.info(\" Buffering wrapper - \" + wrapper.getOperation()\n\t\t\t\t\t\t+ \" ID: \" + wrapper.getEntryId() + \" FeedID: \"\n\t\t\t\t\t\t+ wrapper.getFeedId());\n\t\t\tif (wrapper.getOperation().equals(StorageOperation.DELETE))\n\t\t\t\treturn;\n\n\t\t\tString feedId = wrapper.getFeedId();\n\t\t\tif (this.bufferMap.containsKey(feedId))\n\t\t\t\tthis.bufferMap.get(feedId).put(wrapper.getEntryId(), wrapper);\n\t\t\telse {\n\t\t\t\tMap<String, StorageEntryWrapper> newFeedMap = new HashMap<String, StorageEntryWrapper>(\n\t\t\t\t\t\t20);\n\t\t\t\tnewFeedMap.put(wrapper.getEntryId(), wrapper);\n\t\t\t\tthis.bufferMap.put(feedId, newFeedMap);\n\n\t\t\t}\n\t\t\taddLastModified(wrapper.getFeedId(), wrapper.getTimestamp());\n\t\t} finally {\n\t\t\t/*\n\t\t\t * add all to exclude from searches doc will be available via the\n\t\t\t * buffer\n\t\t\t */\n\t\t\tthis.excludeList.add(wrapper.getEntryId());\n\t\t\tthis.writeLock.unlock();\n\t\t}\n\t}\n\n","sourceOld":"    /** \n     * Adds a {@link StorageEntryWrapper} to the buffer. If a wrapper \n     * representing the same entry are already in the buffer the wrapper will be \n     * replaced. \n     *  \n     * @param wrapper - \n     *            the wrapper to buffer \n     */ \n    public void addEntry(final StorageEntryWrapper wrapper) { \n        this.writeLock.lock(); \n        try { \n            if (LOG.isInfoEnabled()) \n                LOG.info(\" Buffering wrapper - \" + wrapper.getOperation() \n                        + \" ID: \" + wrapper.getEntryId() + \" FeedID: \" \n                        + wrapper.getFeedId()); \n            if (wrapper.getOperation().equals(StorageOperation.DELETE)) \n                return; \n \n            String feedId = wrapper.getFeedId(); \n            if (this.bufferMap.containsKey(feedId)) \n                this.bufferMap.get(feedId).put(wrapper.getEntryId(), wrapper); \n            else { \n                Map<String, StorageEntryWrapper> newFeedMap = new HashMap<String, StorageEntryWrapper>( \n                        20); \n                newFeedMap.put(wrapper.getEntryId(), wrapper); \n                this.bufferMap.put(feedId, newFeedMap); \n                \n            } \n            addLastModified(wrapper.getFeedId(),wrapper.getTimestamp());\n        } finally { \n            /* \n             * add all to exclude from searches doc will be available via the \n             * buffer \n             */ \n            this.excludeList.add(wrapper.getEntryId()); \n            this.writeLock.unlock(); \n        } \n    } \n\n","bugFix":["5d43e216d757e2276d180eba8a192e300c4bfadb","52754a40a1550056d5637c8992b4076b5ed77328"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"303ca293666286b4ae2b0b4dbf10d3bf60ed727c","date":1153866181,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer#addEntry(StorageEntryWrapper).mjava","pathOld":"contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer#addEntry(StorageEntryWrapper).mjava","sourceNew":"    /**\n     * Adds a {@link StorageEntryWrapper} to the buffer. If a wrapper\n     * representing the same entry are already in the buffer the wrapper will be\n     * replaced.\n     * <p>\n     * This method does ignore already delted entries. This should before the\n     * entry is added to the buffer.\n     * </p>\n     * \n     * @param wrapper -\n     *            the wrapper to buffer\n     */\n    public void addEntry(final StorageEntryWrapper wrapper) {\n        this.writeLock.lock();\n        try {\n            if (LOG.isInfoEnabled())\n                LOG.info(\" Buffering wrapper - \" + wrapper.getOperation()\n                        + \" ID: \" + wrapper.getEntryId() + \" FeedID: \"\n                        + wrapper.getFeedId());\n            if (wrapper.getOperation().equals(StorageOperation.DELETE))\n                return;\n            String feedId = wrapper.getFeedId();\n            if (this.bufferMap.containsKey(feedId))\n                this.bufferMap.get(feedId).put(wrapper.getEntryId(), wrapper);\n            else {\n                Map<String, StorageEntryWrapper> newFeedMap = new HashMap<String, StorageEntryWrapper>(\n                        20);\n                newFeedMap.put(wrapper.getEntryId(), wrapper);\n                this.bufferMap.put(feedId, newFeedMap);\n\n            }\n            addLastModified(wrapper.getFeedId(), wrapper.getTimestamp());\n            /*\n             * add to exclude from searches doc will be available via the buffer\n             * if the entry is not already in the buffer\n             */\n            if (!this.excludeList.contains(wrapper.getEntryId()))\n                this.excludeList.add(wrapper.getEntryId());\n        } finally {\n            this.writeLock.unlock();\n        }\n    }\n\n","sourceOld":"\t/**\n\t * Adds a {@link StorageEntryWrapper} to the buffer. If a wrapper\n\t * representing the same entry are already in the buffer the wrapper will be\n\t * replaced.\n\t * \n\t * @param wrapper -\n\t *            the wrapper to buffer\n\t */\n\tpublic void addEntry(final StorageEntryWrapper wrapper) {\n\t\tthis.writeLock.lock();\n\t\ttry {\n\t\t\tif (LOG.isInfoEnabled())\n\t\t\t\tLOG.info(\" Buffering wrapper - \" + wrapper.getOperation()\n\t\t\t\t\t\t+ \" ID: \" + wrapper.getEntryId() + \" FeedID: \"\n\t\t\t\t\t\t+ wrapper.getFeedId());\n\t\t\tif (wrapper.getOperation().equals(StorageOperation.DELETE))\n\t\t\t\treturn;\n\n\t\t\tString feedId = wrapper.getFeedId();\n\t\t\tif (this.bufferMap.containsKey(feedId))\n\t\t\t\tthis.bufferMap.get(feedId).put(wrapper.getEntryId(), wrapper);\n\t\t\telse {\n\t\t\t\tMap<String, StorageEntryWrapper> newFeedMap = new HashMap<String, StorageEntryWrapper>(\n\t\t\t\t\t\t20);\n\t\t\t\tnewFeedMap.put(wrapper.getEntryId(), wrapper);\n\t\t\t\tthis.bufferMap.put(feedId, newFeedMap);\n\n\t\t\t}\n\t\t\taddLastModified(wrapper.getFeedId(), wrapper.getTimestamp());\n\t\t} finally {\n\t\t\t/*\n\t\t\t * add all to exclude from searches doc will be available via the\n\t\t\t * buffer\n\t\t\t */\n\t\t\tthis.excludeList.add(wrapper.getEntryId());\n\t\t\tthis.writeLock.unlock();\n\t\t}\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5824af871ba6863399636aa5989bfc0ef2ea448c","date":1166013128,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"contrib/gdata-server/src/core/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer#addEntry(StorageEntryWrapper).mjava","pathOld":"contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageBuffer#addEntry(StorageEntryWrapper).mjava","sourceNew":"    /**\n     * Adds a {@link StorageEntryWrapper} to the buffer. If a wrapper\n     * representing the same entry are already in the buffer the wrapper will be\n     * replaced.\n     * <p>\n     * This method does ignore already delted entries. This should before the\n     * entry is added to the buffer.\n     * </p>\n     * \n     * @param wrapper -\n     *            the wrapper to buffer\n     */\n    public void addEntry(final StorageEntryWrapper wrapper) {\n        this.writeLock.lock();\n        try {\n            if (LOG.isInfoEnabled())\n                LOG.info(\" Buffering wrapper - \" + wrapper.getOperation()\n                        + \" ID: \" + wrapper.getEntryId() + \" FeedID: \"\n                        + wrapper.getFeedId());\n            if (wrapper.getOperation().equals(StorageOperation.DELETE))\n                return;\n            String feedId = wrapper.getFeedId();\n            if (this.bufferMap.containsKey(feedId))\n                this.bufferMap.get(feedId).put(wrapper.getEntryId(), wrapper);\n            else {\n                Map<String, StorageEntryWrapper> newFeedMap = new HashMap<String, StorageEntryWrapper>(\n                        20);\n                newFeedMap.put(wrapper.getEntryId(), wrapper);\n                this.bufferMap.put(feedId, newFeedMap);\n\n            }\n            addLastModified(wrapper.getFeedId(), wrapper.getTimestamp());\n            /*\n             * add to exclude from searches doc will be available via the buffer\n             * if the entry is not already in the buffer\n             */\n            if (!this.excludeList.contains(wrapper.getEntryId()))\n                this.excludeList.add(wrapper.getEntryId());\n        } finally {\n            this.writeLock.unlock();\n        }\n    }\n\n","sourceOld":"    /**\n     * Adds a {@link StorageEntryWrapper} to the buffer. If a wrapper\n     * representing the same entry are already in the buffer the wrapper will be\n     * replaced.\n     * <p>\n     * This method does ignore already delted entries. This should before the\n     * entry is added to the buffer.\n     * </p>\n     * \n     * @param wrapper -\n     *            the wrapper to buffer\n     */\n    public void addEntry(final StorageEntryWrapper wrapper) {\n        this.writeLock.lock();\n        try {\n            if (LOG.isInfoEnabled())\n                LOG.info(\" Buffering wrapper - \" + wrapper.getOperation()\n                        + \" ID: \" + wrapper.getEntryId() + \" FeedID: \"\n                        + wrapper.getFeedId());\n            if (wrapper.getOperation().equals(StorageOperation.DELETE))\n                return;\n            String feedId = wrapper.getFeedId();\n            if (this.bufferMap.containsKey(feedId))\n                this.bufferMap.get(feedId).put(wrapper.getEntryId(), wrapper);\n            else {\n                Map<String, StorageEntryWrapper> newFeedMap = new HashMap<String, StorageEntryWrapper>(\n                        20);\n                newFeedMap.put(wrapper.getEntryId(), wrapper);\n                this.bufferMap.put(feedId, newFeedMap);\n\n            }\n            addLastModified(wrapper.getFeedId(), wrapper.getTimestamp());\n            /*\n             * add to exclude from searches doc will be available via the buffer\n             * if the entry is not already in the buffer\n             */\n            if (!this.excludeList.contains(wrapper.getEntryId()))\n                this.excludeList.add(wrapper.getEntryId());\n        } finally {\n            this.writeLock.unlock();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"02a7f04a7293ea604e17892ba0bded7341adf3af":["52754a40a1550056d5637c8992b4076b5ed77328"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5824af871ba6863399636aa5989bfc0ef2ea448c":["303ca293666286b4ae2b0b4dbf10d3bf60ed727c"],"303ca293666286b4ae2b0b4dbf10d3bf60ed727c":["02a7f04a7293ea604e17892ba0bded7341adf3af"],"5d43e216d757e2276d180eba8a192e300c4bfadb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5824af871ba6863399636aa5989bfc0ef2ea448c"],"52754a40a1550056d5637c8992b4076b5ed77328":["5d43e216d757e2276d180eba8a192e300c4bfadb"]},"commit2Childs":{"02a7f04a7293ea604e17892ba0bded7341adf3af":["303ca293666286b4ae2b0b4dbf10d3bf60ed727c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5d43e216d757e2276d180eba8a192e300c4bfadb"],"5824af871ba6863399636aa5989bfc0ef2ea448c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"303ca293666286b4ae2b0b4dbf10d3bf60ed727c":["5824af871ba6863399636aa5989bfc0ef2ea448c"],"5d43e216d757e2276d180eba8a192e300c4bfadb":["52754a40a1550056d5637c8992b4076b5ed77328"],"52754a40a1550056d5637c8992b4076b5ed77328":["02a7f04a7293ea604e17892ba0bded7341adf3af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}