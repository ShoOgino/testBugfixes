{"path":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeQuery.VisitorTemplate#getDocIdSet().mjava","commits":[{"id":"112d77ac8d3e10a362516ad834c9a11d35c94234","date":1456784319,"type":1,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeQuery.VisitorTemplate#getDocIdSet().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeQuery.VisitorTemplate#getDocIdSet().mjava","sourceNew":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      if (!nextTerm()) {//advances\n        return null;\n      }\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        final int compare = indexedCell.compareToNoLeaf(curVNode.cell);\n        if (compare > 0) {\n          // The indexed cell is after; continue loop to next query cell\n          continue;\n        }\n        if (compare < 0) {\n          // The indexed cell is before; seek ahead to query cell:\n          //      Seek !\n          curVNode.cell.getTokenBytesNoLeaf(curVNodeTerm);\n          TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n          if (seekStatus == TermsEnum.SeekStatus.END)\n            break; // all done\n          thisTerm = termsEnum.term();\n          indexedCell = grid.readCell(thisTerm, indexedCell);\n          if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n            // Did we find a leaf of the cell we were looking for or something after?\n            if (!indexedCell.isLeaf() || indexedCell.compareToNoLeaf(curVNode.cell) != 0)\n              continue; // The indexed cell is after; continue loop to next query cell\n          }\n        }\n        // indexedCell == queryCell (disregarding leaf).\n\n        // If indexedCell is a leaf then there's no prefix (prefix sorts before) -- just visit and continue\n        if (indexedCell.isLeaf()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n          continue;\n        }\n        // If a prefix (non-leaf) then visit; see if we descend.\n        final boolean descend = visitPrefix(curVNode.cell);//need to use curVNode.cell not indexedCell\n        if (!nextTerm()) break;\n        // Check for adjacent leaf with the same prefix\n        if (indexedCell.isLeaf() && indexedCell.getLevel() == curVNode.cell.getLevel()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n        }\n\n\n        if (descend) {\n          addIntersectingChildren();\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","sourceOld":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      if (!nextTerm()) {//advances\n        return null;\n      }\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        final int compare = indexedCell.compareToNoLeaf(curVNode.cell);\n        if (compare > 0) {\n          // The indexed cell is after; continue loop to next query cell\n          continue;\n        }\n        if (compare < 0) {\n          // The indexed cell is before; seek ahead to query cell:\n          //      Seek !\n          curVNode.cell.getTokenBytesNoLeaf(curVNodeTerm);\n          TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n          if (seekStatus == TermsEnum.SeekStatus.END)\n            break; // all done\n          thisTerm = termsEnum.term();\n          indexedCell = grid.readCell(thisTerm, indexedCell);\n          if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n            // Did we find a leaf of the cell we were looking for or something after?\n            if (!indexedCell.isLeaf() || indexedCell.compareToNoLeaf(curVNode.cell) != 0)\n              continue; // The indexed cell is after; continue loop to next query cell\n          }\n        }\n        // indexedCell == queryCell (disregarding leaf).\n\n        // If indexedCell is a leaf then there's no prefix (prefix sorts before) -- just visit and continue\n        if (indexedCell.isLeaf()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n          continue;\n        }\n        // If a prefix (non-leaf) then visit; see if we descend.\n        final boolean descend = visitPrefix(curVNode.cell);//need to use curVNode.cell not indexedCell\n        if (!nextTerm()) break;\n        // Check for adjacent leaf with the same prefix\n        if (indexedCell.isLeaf() && indexedCell.getLevel() == curVNode.cell.getLevel()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n        }\n\n\n        if (descend) {\n          addIntersectingChildren();\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeQuery.VisitorTemplate#getDocIdSet().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeQuery.VisitorTemplate#getDocIdSet().mjava","sourceNew":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      if (!nextTerm()) {//advances\n        return null;\n      }\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        final int compare = indexedCell.compareToNoLeaf(curVNode.cell);\n        if (compare > 0) {\n          // The indexed cell is after; continue loop to next query cell\n          continue;\n        }\n        if (compare < 0) {\n          // The indexed cell is before; seek ahead to query cell:\n          //      Seek !\n          curVNode.cell.getTokenBytesNoLeaf(curVNodeTerm);\n          TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n          if (seekStatus == TermsEnum.SeekStatus.END)\n            break; // all done\n          thisTerm = termsEnum.term();\n          indexedCell = grid.readCell(thisTerm, indexedCell);\n          if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n            // Did we find a leaf of the cell we were looking for or something after?\n            if (!indexedCell.isLeaf() || indexedCell.compareToNoLeaf(curVNode.cell) != 0)\n              continue; // The indexed cell is after; continue loop to next query cell\n          }\n        }\n        // indexedCell == queryCell (disregarding leaf).\n\n        // If indexedCell is a leaf then there's no prefix (prefix sorts before) -- just visit and continue\n        if (indexedCell.isLeaf()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n          continue;\n        }\n        // If a prefix (non-leaf) then visit; see if we descend.\n        final boolean descend = visitPrefix(curVNode.cell);//need to use curVNode.cell not indexedCell\n        if (!nextTerm()) break;\n        // Check for adjacent leaf with the same prefix\n        if (indexedCell.isLeaf() && indexedCell.getLevel() == curVNode.cell.getLevel()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n        }\n\n\n        if (descend) {\n          addIntersectingChildren();\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","sourceOld":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      if (!nextTerm()) {//advances\n        return null;\n      }\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        final int compare = indexedCell.compareToNoLeaf(curVNode.cell);\n        if (compare > 0) {\n          // The indexed cell is after; continue loop to next query cell\n          continue;\n        }\n        if (compare < 0) {\n          // The indexed cell is before; seek ahead to query cell:\n          //      Seek !\n          curVNode.cell.getTokenBytesNoLeaf(curVNodeTerm);\n          TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n          if (seekStatus == TermsEnum.SeekStatus.END)\n            break; // all done\n          thisTerm = termsEnum.term();\n          indexedCell = grid.readCell(thisTerm, indexedCell);\n          if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n            // Did we find a leaf of the cell we were looking for or something after?\n            if (!indexedCell.isLeaf() || indexedCell.compareToNoLeaf(curVNode.cell) != 0)\n              continue; // The indexed cell is after; continue loop to next query cell\n          }\n        }\n        // indexedCell == queryCell (disregarding leaf).\n\n        // If indexedCell is a leaf then there's no prefix (prefix sorts before) -- just visit and continue\n        if (indexedCell.isLeaf()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n          continue;\n        }\n        // If a prefix (non-leaf) then visit; see if we descend.\n        final boolean descend = visitPrefix(curVNode.cell);//need to use curVNode.cell not indexedCell\n        if (!nextTerm()) break;\n        // Check for adjacent leaf with the same prefix\n        if (indexedCell.isLeaf() && indexedCell.getLevel() == curVNode.cell.getLevel()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n        }\n\n\n        if (descend) {\n          addIntersectingChildren();\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","112d77ac8d3e10a362516ad834c9a11d35c94234"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"112d77ac8d3e10a362516ad834c9a11d35c94234":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["af2638813028b254a88b418ebeafb541afb49653"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["af2638813028b254a88b418ebeafb541afb49653","112d77ac8d3e10a362516ad834c9a11d35c94234"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["af2638813028b254a88b418ebeafb541afb49653"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}