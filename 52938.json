{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree#recursiveGetNodes(Node,Shape,int,boolean,boolean,List[Node]).mjava","commits":[{"id":"6b43aca0f70aef9b914114574de1d0916ad2a32b","date":1360908147,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree#recursiveGetNodes(Node,Shape,int,boolean,boolean,List[Node]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns true if node was added as a leaf. If it wasn't it recursively\n   * descends.\n   */\n  private boolean recursiveGetNodes(Node node, Shape shape, int detailLevel,\n                                    boolean inclParents, boolean simplify,\n                                    List<Node> result) {\n    if (node.getLevel() == detailLevel) {\n      node.setLeaf();//FYI might already be a leaf\n    }\n    if (node.isLeaf()) {\n      result.add(node);\n      return true;\n    }\n    if (inclParents && node.getLevel() != 0)\n      result.add(node);\n\n    Collection<Node> subCells = node.getSubCells(shape);\n    int leaves = 0;\n    for (Node subCell : subCells) {\n      if (recursiveGetNodes(subCell, shape, detailLevel, inclParents, simplify, result))\n        leaves++;\n    }\n    //can we simplify?\n    if (simplify && leaves == node.getSubCellsSize() && node.getLevel() != 0) {\n      //Optimization: substitute the parent as a leaf instead of adding all\n      // children as leaves\n\n      //remove the leaves\n      do {\n        result.remove(result.size() - 1);//remove last\n      } while (--leaves > 0);\n      //add node as the leaf\n      node.setLeaf();\n      if (!inclParents) // otherwise it was already added up above\n        result.add(node);\n      return true;\n    }\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b41f996b22bd5518650f897d050088ff808ec03","date":1360969107,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree#recursiveGetNodes(Node,Shape,int,boolean,boolean,List[Node]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns true if node was added as a leaf. If it wasn't it recursively\n   * descends.\n   */\n  private boolean recursiveGetNodes(Node node, Shape shape, int detailLevel,\n                                    boolean inclParents, boolean simplify,\n                                    List<Node> result) {\n    if (node.getLevel() == detailLevel) {\n      node.setLeaf();//FYI might already be a leaf\n    }\n    if (node.isLeaf()) {\n      result.add(node);\n      return true;\n    }\n    if (inclParents && node.getLevel() != 0)\n      result.add(node);\n\n    Collection<Node> subCells = node.getSubCells(shape);\n    int leaves = 0;\n    for (Node subCell : subCells) {\n      if (recursiveGetNodes(subCell, shape, detailLevel, inclParents, simplify, result))\n        leaves++;\n    }\n    //can we simplify?\n    if (simplify && leaves == node.getSubCellsSize() && node.getLevel() != 0) {\n      //Optimization: substitute the parent as a leaf instead of adding all\n      // children as leaves\n\n      //remove the leaves\n      do {\n        result.remove(result.size() - 1);//remove last\n      } while (--leaves > 0);\n      //add node as the leaf\n      node.setLeaf();\n      if (!inclParents) // otherwise it was already added up above\n        result.add(node);\n      return true;\n    }\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8259c159da2de2e8528524fb76b244b46cbded59","date":1364478249,"type":5,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree#recursiveGetCells(Cell,Shape,int,boolean,boolean,List[Cell]).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree#recursiveGetNodes(Node,Shape,int,boolean,boolean,List[Node]).mjava","sourceNew":"  /**\n   * Returns true if cell was added as a leaf. If it wasn't it recursively\n   * descends.\n   */\n  private boolean recursiveGetCells(Cell cell, Shape shape, int detailLevel,\n                                    boolean inclParents, boolean simplify,\n                                    List<Cell> result) {\n    if (cell.getLevel() == detailLevel) {\n      cell.setLeaf();//FYI might already be a leaf\n    }\n    if (cell.isLeaf()) {\n      result.add(cell);\n      return true;\n    }\n    if (inclParents && cell.getLevel() != 0)\n      result.add(cell);\n\n    Collection<Cell> subCells = cell.getSubCells(shape);\n    int leaves = 0;\n    for (Cell subCell : subCells) {\n      if (recursiveGetCells(subCell, shape, detailLevel, inclParents, simplify, result))\n        leaves++;\n    }\n    //can we simplify?\n    if (simplify && leaves == cell.getSubCellsSize() && cell.getLevel() != 0) {\n      //Optimization: substitute the parent as a leaf instead of adding all\n      // children as leaves\n\n      //remove the leaves\n      do {\n        result.remove(result.size() - 1);//remove last\n      } while (--leaves > 0);\n      //add cell as the leaf\n      cell.setLeaf();\n      if (!inclParents) // otherwise it was already added up above\n        result.add(cell);\n      return true;\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns true if node was added as a leaf. If it wasn't it recursively\n   * descends.\n   */\n  private boolean recursiveGetNodes(Node node, Shape shape, int detailLevel,\n                                    boolean inclParents, boolean simplify,\n                                    List<Node> result) {\n    if (node.getLevel() == detailLevel) {\n      node.setLeaf();//FYI might already be a leaf\n    }\n    if (node.isLeaf()) {\n      result.add(node);\n      return true;\n    }\n    if (inclParents && node.getLevel() != 0)\n      result.add(node);\n\n    Collection<Node> subCells = node.getSubCells(shape);\n    int leaves = 0;\n    for (Node subCell : subCells) {\n      if (recursiveGetNodes(subCell, shape, detailLevel, inclParents, simplify, result))\n        leaves++;\n    }\n    //can we simplify?\n    if (simplify && leaves == node.getSubCellsSize() && node.getLevel() != 0) {\n      //Optimization: substitute the parent as a leaf instead of adding all\n      // children as leaves\n\n      //remove the leaves\n      do {\n        result.remove(result.size() - 1);//remove last\n      } while (--leaves > 0);\n      //add node as the leaf\n      node.setLeaf();\n      if (!inclParents) // otherwise it was already added up above\n        result.add(node);\n      return true;\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3b41f996b22bd5518650f897d050088ff808ec03":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6b43aca0f70aef9b914114574de1d0916ad2a32b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6b43aca0f70aef9b914114574de1d0916ad2a32b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8259c159da2de2e8528524fb76b244b46cbded59"],"8259c159da2de2e8528524fb76b244b46cbded59":["6b43aca0f70aef9b914114574de1d0916ad2a32b"]},"commit2Childs":{"3b41f996b22bd5518650f897d050088ff808ec03":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b41f996b22bd5518650f897d050088ff808ec03","6b43aca0f70aef9b914114574de1d0916ad2a32b"],"6b43aca0f70aef9b914114574de1d0916ad2a32b":["3b41f996b22bd5518650f897d050088ff808ec03","8259c159da2de2e8528524fb76b244b46cbded59"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"8259c159da2de2e8528524fb76b244b46cbded59":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["3b41f996b22bd5518650f897d050088ff808ec03","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}