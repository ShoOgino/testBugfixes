{"path":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene62/Lucene62RWSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","commits":[{"id":"31741cf1390044e38a2ec3127cf302ba841bfd75","date":1491292636,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene62/Lucene62RWSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output,\n                                   Lucene62SegmentInfoFormat.CODEC_NAME,\n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        SortField.Type sortType = sortField.getType();\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          case CUSTOM:\n            if (sortField instanceof SortedSetSortField) {\n              sortTypeID = 5;\n              sortType = SortField.Type.STRING;\n            } else if (sortField instanceof SortedNumericSortField) {\n              sortTypeID = 6;\n              sortType = ((SortedNumericSortField) sortField).getNumericType();\n            } else {\n              throw new IllegalStateException(\"Unexpected SortedNumericSortField \" + sortField);\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        if (sortTypeID == 5) {\n          SortedSetSortField ssf = (SortedSetSortField) sortField;\n          if (ssf.getSelector() == SortedSetSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MIN) {\n            output.writeByte((byte) 2);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MAX) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type: \" + ssf.getSelector());\n          }\n        } else if (sortTypeID == 6) {\n          SortedNumericSortField snsf = (SortedNumericSortField) sortField;\n          if (snsf.getNumericType() == SortField.Type.LONG) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getNumericType() == SortField.Type.INT) {\n            output.writeByte((byte) 1);\n          } else if (snsf.getNumericType() == SortField.Type.DOUBLE) {\n            output.writeByte((byte) 2);\n          } else if (snsf.getNumericType() == SortField.Type.FLOAT) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type: \" + snsf.getNumericType());\n          }\n          if (snsf.getSelector() == SortedNumericSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getSelector() == SortedNumericSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else {\n            throw new IllegalStateException(\"Unexpected sorted numeric selector type: \" + snsf.getSelector());\n          }\n        }\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortType) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92212fd254551a0b1156aafc3a1a6ed1a43932ad","date":1491296431,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene62/Lucene62RWSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output,\n                                   Lucene62SegmentInfoFormat.CODEC_NAME,\n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        SortField.Type sortType = sortField.getType();\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          case CUSTOM:\n            if (sortField instanceof SortedSetSortField) {\n              sortTypeID = 5;\n              sortType = SortField.Type.STRING;\n            } else if (sortField instanceof SortedNumericSortField) {\n              sortTypeID = 6;\n              sortType = ((SortedNumericSortField) sortField).getNumericType();\n            } else {\n              throw new IllegalStateException(\"Unexpected SortedNumericSortField \" + sortField);\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        if (sortTypeID == 5) {\n          SortedSetSortField ssf = (SortedSetSortField) sortField;\n          if (ssf.getSelector() == SortedSetSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MIN) {\n            output.writeByte((byte) 2);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MAX) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type: \" + ssf.getSelector());\n          }\n        } else if (sortTypeID == 6) {\n          SortedNumericSortField snsf = (SortedNumericSortField) sortField;\n          if (snsf.getNumericType() == SortField.Type.LONG) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getNumericType() == SortField.Type.INT) {\n            output.writeByte((byte) 1);\n          } else if (snsf.getNumericType() == SortField.Type.DOUBLE) {\n            output.writeByte((byte) 2);\n          } else if (snsf.getNumericType() == SortField.Type.FLOAT) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type: \" + snsf.getNumericType());\n          }\n          if (snsf.getSelector() == SortedNumericSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getSelector() == SortedNumericSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else {\n            throw new IllegalStateException(\"Unexpected sorted numeric selector type: \" + snsf.getSelector());\n          }\n        }\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortType) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fe05f332e77cbf262172227a8ab7b0c396db6fe","date":1499084178,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene62/Lucene62RWSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output,\n                                   Lucene62SegmentInfoFormat.CODEC_NAME,\n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        SortField.Type sortType = sortField.getType();\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          case CUSTOM:\n            if (sortField instanceof SortedSetSortField) {\n              sortTypeID = 5;\n              sortType = SortField.Type.STRING;\n            } else if (sortField instanceof SortedNumericSortField) {\n              sortTypeID = 6;\n              sortType = ((SortedNumericSortField) sortField).getNumericType();\n            } else {\n              throw new IllegalStateException(\"Unexpected SortedNumericSortField \" + sortField);\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        if (sortTypeID == 5) {\n          SortedSetSortField ssf = (SortedSetSortField) sortField;\n          if (ssf.getSelector() == SortedSetSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MIN) {\n            output.writeByte((byte) 2);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MAX) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type: \" + ssf.getSelector());\n          }\n        } else if (sortTypeID == 6) {\n          SortedNumericSortField snsf = (SortedNumericSortField) sortField;\n          if (snsf.getNumericType() == SortField.Type.LONG) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getNumericType() == SortField.Type.INT) {\n            output.writeByte((byte) 1);\n          } else if (snsf.getNumericType() == SortField.Type.DOUBLE) {\n            output.writeByte((byte) 2);\n          } else if (snsf.getNumericType() == SortField.Type.FLOAT) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type: \" + snsf.getNumericType());\n          }\n          if (snsf.getSelector() == SortedNumericSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getSelector() == SortedNumericSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else {\n            throw new IllegalStateException(\"Unexpected sorted numeric selector type: \" + snsf.getSelector());\n          }\n        }\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortType) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc018b79379c67835b40b1259cd3dc931df60944","date":1499109112,"type":4,"author":"Anshum Gupta","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene62/Lucene62RWSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output,\n                                   Lucene62SegmentInfoFormat.CODEC_NAME,\n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        SortField.Type sortType = sortField.getType();\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          case CUSTOM:\n            if (sortField instanceof SortedSetSortField) {\n              sortTypeID = 5;\n              sortType = SortField.Type.STRING;\n            } else if (sortField instanceof SortedNumericSortField) {\n              sortTypeID = 6;\n              sortType = ((SortedNumericSortField) sortField).getNumericType();\n            } else {\n              throw new IllegalStateException(\"Unexpected SortedNumericSortField \" + sortField);\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        if (sortTypeID == 5) {\n          SortedSetSortField ssf = (SortedSetSortField) sortField;\n          if (ssf.getSelector() == SortedSetSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MIN) {\n            output.writeByte((byte) 2);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MAX) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type: \" + ssf.getSelector());\n          }\n        } else if (sortTypeID == 6) {\n          SortedNumericSortField snsf = (SortedNumericSortField) sortField;\n          if (snsf.getNumericType() == SortField.Type.LONG) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getNumericType() == SortField.Type.INT) {\n            output.writeByte((byte) 1);\n          } else if (snsf.getNumericType() == SortField.Type.DOUBLE) {\n            output.writeByte((byte) 2);\n          } else if (snsf.getNumericType() == SortField.Type.FLOAT) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type: \" + snsf.getNumericType());\n          }\n          if (snsf.getSelector() == SortedNumericSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getSelector() == SortedNumericSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else {\n            throw new IllegalStateException(\"Unexpected sorted numeric selector type: \" + snsf.getSelector());\n          }\n        }\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortType) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":4,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene62/Lucene62RWSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output,\n                                   Lucene62SegmentInfoFormat.CODEC_NAME,\n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        SortField.Type sortType = sortField.getType();\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          case CUSTOM:\n            if (sortField instanceof SortedSetSortField) {\n              sortTypeID = 5;\n              sortType = SortField.Type.STRING;\n            } else if (sortField instanceof SortedNumericSortField) {\n              sortTypeID = 6;\n              sortType = ((SortedNumericSortField) sortField).getNumericType();\n            } else {\n              throw new IllegalStateException(\"Unexpected SortedNumericSortField \" + sortField);\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        if (sortTypeID == 5) {\n          SortedSetSortField ssf = (SortedSetSortField) sortField;\n          if (ssf.getSelector() == SortedSetSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MIN) {\n            output.writeByte((byte) 2);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MAX) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type: \" + ssf.getSelector());\n          }\n        } else if (sortTypeID == 6) {\n          SortedNumericSortField snsf = (SortedNumericSortField) sortField;\n          if (snsf.getNumericType() == SortField.Type.LONG) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getNumericType() == SortField.Type.INT) {\n            output.writeByte((byte) 1);\n          } else if (snsf.getNumericType() == SortField.Type.DOUBLE) {\n            output.writeByte((byte) 2);\n          } else if (snsf.getNumericType() == SortField.Type.FLOAT) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type: \" + snsf.getNumericType());\n          }\n          if (snsf.getSelector() == SortedNumericSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getSelector() == SortedNumericSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else {\n            throw new IllegalStateException(\"Unexpected sorted numeric selector type: \" + snsf.getSelector());\n          }\n        }\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortType) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cc018b79379c67835b40b1259cd3dc931df60944":["31741cf1390044e38a2ec3127cf302ba841bfd75","1fe05f332e77cbf262172227a8ab7b0c396db6fe"],"30c8e5574b55d57947e989443dfde611646530ee":["92212fd254551a0b1156aafc3a1a6ed1a43932ad","cc018b79379c67835b40b1259cd3dc931df60944"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1fe05f332e77cbf262172227a8ab7b0c396db6fe":["31741cf1390044e38a2ec3127cf302ba841bfd75"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cc018b79379c67835b40b1259cd3dc931df60944"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["92212fd254551a0b1156aafc3a1a6ed1a43932ad","31741cf1390044e38a2ec3127cf302ba841bfd75"],"cc018b79379c67835b40b1259cd3dc931df60944":["30c8e5574b55d57947e989443dfde611646530ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"30c8e5574b55d57947e989443dfde611646530ee":[],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["30c8e5574b55d57947e989443dfde611646530ee"],"1fe05f332e77cbf262172227a8ab7b0c396db6fe":["cc018b79379c67835b40b1259cd3dc931df60944"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["cc018b79379c67835b40b1259cd3dc931df60944","1fe05f332e77cbf262172227a8ab7b0c396db6fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["30c8e5574b55d57947e989443dfde611646530ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}