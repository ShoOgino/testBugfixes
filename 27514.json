{"path":"lucene/core/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","commits":[{"id":"88b0212386fe531136816706dc37dc49b9dbf7dc","date":1532560226,"type":1,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. must not be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    // exact double values of lat=90.0D and lon=180.0D must be treated special as they are not represented in the encoding\n    // and should not drag in extra bogus junk! TODO: should encodeCeil just throw ArithmeticException to be less trappy here?\n    if (minLatitude == 90.0) {\n      // range cannot match as 90.0 can never exist\n      return new MatchNoDocsQuery(\"LatLonPoint.newBoxQuery with minLatitude=90.0\");\n    }\n    if (minLongitude == 180.0) {\n      if (maxLongitude == 180.0) {\n        // range cannot match as 180.0 can never exist\n        return new MatchNoDocsQuery(\"LatLonPoint.newBoxQuery with minLongitude=maxLongitude=180.0\");\n      } else if (maxLongitude < minLongitude) {\n        // encodeCeil() with dateline wrapping!\n        minLongitude = -180.0;\n      }\n    }\n    byte[] lower = encodeCeil(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. must not be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    // exact double values of lat=90.0D and lon=180.0D must be treated special as they are not represented in the encoding\n    // and should not drag in extra bogus junk! TODO: should encodeCeil just throw ArithmeticException to be less trappy here?\n    if (minLatitude == 90.0) {\n      // range cannot match as 90.0 can never exist\n      return new MatchNoDocsQuery(\"LatLonPoint.newBoxQuery with minLatitude=90.0\");\n    }\n    if (minLongitude == 180.0) {\n      if (maxLongitude == 180.0) {\n        // range cannot match as 180.0 can never exist\n        return new MatchNoDocsQuery(\"LatLonPoint.newBoxQuery with minLongitude=maxLongitude=180.0\");\n      } else if (maxLongitude < minLongitude) {\n        // encodeCeil() with dateline wrapping!\n        minLongitude = -180.0;\n      }\n    }\n    byte[] lower = encodeCeil(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"88b0212386fe531136816706dc37dc49b9dbf7dc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["88b0212386fe531136816706dc37dc49b9dbf7dc"]},"commit2Childs":{"88b0212386fe531136816706dc37dc49b9dbf7dc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["88b0212386fe531136816706dc37dc49b9dbf7dc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}