{"path":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#testRandom().mjava","commits":[{"id":"87e78f3c129251e74ecc2ff73a32de0f27cf09d5","date":1358006150,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws Exception {\n\n    final int iters = atLeast(10);\n    for(int iter=0;iter<iters;iter++) {\n      final int numBytes = _TestUtil.nextInt(random(), 1, 200000);\n      final byte[] expected = new byte[numBytes];\n      final int blockBits = _TestUtil.nextInt(random(), 8, 15);\n      final BytesStore bytes = new BytesStore(blockBits);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numBytes=\" + numBytes + \" blockBits=\" + blockBits);\n      }\n\n      int pos = 0;\n      while(pos < numBytes) {\n        int op = random().nextInt(7);\n        if (VERBOSE) {\n          System.out.println(\"  cycle pos=\" + pos);\n        }\n        switch(op) {\n\n        case 0:\n          {\n            // write random byte\n            byte b = (byte) random().nextInt(256);\n            if (VERBOSE) {\n              System.out.println(\"    writeByte b=\" + b);\n            }\n\n            expected[pos++] = b;\n            bytes.writeByte(b);\n          }\n          break;\n\n        case 1:\n          {\n            // write random byte[]\n            int len = random().nextInt(Math.min(numBytes - pos, 100));\n            byte[] temp = new byte[len];\n            random().nextBytes(temp);\n            if (VERBOSE) {\n              System.out.println(\"    writeBytes len=\" + len + \" bytes=\" + Arrays.toString(temp));\n            }\n            System.arraycopy(temp, 0, expected, pos, temp.length);\n            bytes.writeBytes(temp, 0, temp.length);\n            pos += len;\n          }\n          break;\n\n        case 2:\n          {\n            // write int @ absolute pos\n            if (pos > 4) {\n              int x = random().nextInt();\n              int randomPos = random().nextInt(pos-4);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeInt pos=\" + randomPos + \" x=\" + x);\n              }\n              bytes.writeInt(randomPos, x);\n              expected[randomPos++] = (byte) (x >> 24);\n              expected[randomPos++] = (byte) (x >> 16);\n              expected[randomPos++] = (byte) (x >> 8);\n              expected[randomPos++] = (byte) x;\n            }\n          }\n          break;\n\n        case 3:\n          {\n            // reverse bytes\n            if (pos > 0) {\n              int len = _TestUtil.nextInt(random(), 1, Math.min(100, pos));\n              int start;\n              if (len == pos) {\n                start = 0;\n              } else {\n                start = random().nextInt(pos - len);\n              }\n              int end = start + len;\n              if (VERBOSE) {\n                System.out.println(\"    reverse start=\" + start + \" end=\" + end + \" len=\" + len);\n              }\n              bytes.reverse(start, end);\n\n              while(start < end) {\n                byte b = expected[end];\n                expected[end] = expected[start];\n                expected[start] = b;\n                start++;\n                end--;\n              }\n            }\n          }\n          break;\n\n        case 4:\n          {\n            // abs write random byte[]\n            if (pos > 2) {\n              int randomPos = random().nextInt(pos-1);\n              int len = _TestUtil.nextInt(random(), 1, Math.min(pos - randomPos - 1, 100));\n              byte[] temp = new byte[len];\n              random().nextBytes(temp);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeBytes pos=\" + randomPos + \" len=\" + len + \" bytes=\" + Arrays.toString(temp));\n              }\n              System.arraycopy(temp, 0, expected, randomPos, temp.length);\n              bytes.writeBytes(randomPos, temp, 0, temp.length);\n            }\n          }\n          break;\n\n        case 5:\n          {\n            // copyBytes\n            if (pos > 1) {\n              int src = random().nextInt(pos-1);\n              int dest = _TestUtil.nextInt(random(), src+1, pos-1);\n              int len = _TestUtil.nextInt(random(), 1, Math.min(300, pos - dest));\n              if (VERBOSE) {\n                System.out.println(\"    copyBytes src=\" + src + \" dest=\" + dest + \" len=\" + len);\n              }\n              System.arraycopy(expected, src, expected, dest, len);\n              bytes.copyBytes(src, dest, len);\n            }\n          }\n          break;\n\n        case 6:\n          {\n            // skip\n            int len = random().nextInt(Math.min(100, numBytes - pos));\n            pos += len;\n            bytes.skip(len);\n            if (VERBOSE) {\n              System.out.println(\"    skip len=\" + len);\n            }\n          }\n          break;\n        }\n\n        assertEquals(pos, bytes.getPosition());\n\n        if ((pos > 0 && random().nextInt(200) == 17)) {\n          verify(bytes, expected, pos);\n        }\n      }\n\n      BytesStore bytesToVerify;\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: save/load final bytes\");\n        }\n        Directory dir = newDirectory();\n        IndexOutput out = dir.createOutput(\"bytes\", IOContext.DEFAULT);\n        bytes.writeTo(out);\n        out.close();\n        IndexInput in = dir.openInput(\"bytes\", IOContext.DEFAULT);\n        bytesToVerify = new BytesStore(in, numBytes, _TestUtil.nextInt(random(), 256, Integer.MAX_VALUE));\n        in.close();\n        dir.close();\n      } else {\n        bytesToVerify = bytes;\n      }\n\n      verify(bytesToVerify, expected, numBytes);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73e44327cb5401cc5098da2f488c899954c9bfbc","date":1358092175,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    final int iters = atLeast(10);\n    for(int iter=0;iter<iters;iter++) {\n      final int numBytes = _TestUtil.nextInt(random(), 1, 200000);\n      final byte[] expected = new byte[numBytes];\n      final int blockBits = _TestUtil.nextInt(random(), 8, 15);\n      final BytesStore bytes = new BytesStore(blockBits);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numBytes=\" + numBytes + \" blockBits=\" + blockBits);\n      }\n\n      int pos = 0;\n      while(pos < numBytes) {\n        int op = random().nextInt(8);\n        if (VERBOSE) {\n          System.out.println(\"  cycle pos=\" + pos);\n        }\n        switch(op) {\n\n        case 0:\n          {\n            // write random byte\n            byte b = (byte) random().nextInt(256);\n            if (VERBOSE) {\n              System.out.println(\"    writeByte b=\" + b);\n            }\n\n            expected[pos++] = b;\n            bytes.writeByte(b);\n          }\n          break;\n\n        case 1:\n          {\n            // write random byte[]\n            int len = random().nextInt(Math.min(numBytes - pos, 100));\n            byte[] temp = new byte[len];\n            random().nextBytes(temp);\n            if (VERBOSE) {\n              System.out.println(\"    writeBytes len=\" + len + \" bytes=\" + Arrays.toString(temp));\n            }\n            System.arraycopy(temp, 0, expected, pos, temp.length);\n            bytes.writeBytes(temp, 0, temp.length);\n            pos += len;\n          }\n          break;\n\n        case 2:\n          {\n            // write int @ absolute pos\n            if (pos > 4) {\n              int x = random().nextInt();\n              int randomPos = random().nextInt(pos-4);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeInt pos=\" + randomPos + \" x=\" + x);\n              }\n              bytes.writeInt(randomPos, x);\n              expected[randomPos++] = (byte) (x >> 24);\n              expected[randomPos++] = (byte) (x >> 16);\n              expected[randomPos++] = (byte) (x >> 8);\n              expected[randomPos++] = (byte) x;\n            }\n          }\n          break;\n\n        case 3:\n          {\n            // reverse bytes\n            if (pos > 1) {\n              int len = _TestUtil.nextInt(random(), 2, Math.min(100, pos));\n              int start;\n              if (len == pos) {\n                start = 0;\n              } else {\n                start = random().nextInt(pos - len);\n              }\n              int end = start + len - 1;\n              if (VERBOSE) {\n                System.out.println(\"    reverse start=\" + start + \" end=\" + end + \" len=\" + len + \" pos=\" + pos);\n              }\n              bytes.reverse(start, end);\n\n              while(start <= end) {\n                byte b = expected[end];\n                expected[end] = expected[start];\n                expected[start] = b;\n                start++;\n                end--;\n              }\n            }\n          }\n          break;\n\n        case 4:\n          {\n            // abs write random byte[]\n            if (pos > 2) {\n              int randomPos = random().nextInt(pos-1);\n              int len = _TestUtil.nextInt(random(), 1, Math.min(pos - randomPos - 1, 100));\n              byte[] temp = new byte[len];\n              random().nextBytes(temp);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeBytes pos=\" + randomPos + \" len=\" + len + \" bytes=\" + Arrays.toString(temp));\n              }\n              System.arraycopy(temp, 0, expected, randomPos, temp.length);\n              bytes.writeBytes(randomPos, temp, 0, temp.length);\n            }\n          }\n          break;\n\n        case 5:\n          {\n            // copyBytes\n            if (pos > 1) {\n              int src = random().nextInt(pos-1);\n              int dest = _TestUtil.nextInt(random(), src+1, pos-1);\n              int len = _TestUtil.nextInt(random(), 1, Math.min(300, pos - dest));\n              if (VERBOSE) {\n                System.out.println(\"    copyBytes src=\" + src + \" dest=\" + dest + \" len=\" + len);\n              }\n              System.arraycopy(expected, src, expected, dest, len);\n              bytes.copyBytes(src, dest, len);\n            }\n          }\n          break;\n\n        case 6:\n          {\n            // skip\n            int len = random().nextInt(Math.min(100, numBytes - pos));\n\n            if (VERBOSE) {\n              System.out.println(\"    skip len=\" + len);\n            }\n\n            pos += len;\n            bytes.skipBytes(len);\n\n            // NOTE: must fill in zeros in case truncate was\n            // used, else we get false fails:\n            if (len > 0) {\n              byte[] zeros = new byte[len];\n              bytes.writeBytes(pos-len, zeros, 0, len);\n            }\n          }\n          break;\n\n        case 7:\n          {\n            // absWriteByte\n            if (pos > 0) {\n              int dest = random().nextInt(pos);\n              byte b = (byte) random().nextInt(256);\n              expected[dest] = b;\n              bytes.writeByte(dest, b);\n            }\n            break;\n          }\n        }\n\n        assertEquals(pos, bytes.getPosition());\n\n        if (pos > 0 && random().nextInt(50) == 17) {\n          // truncate\n          int len = _TestUtil.nextInt(random(), 1, Math.min(pos, 100));\n          bytes.truncate(pos - len);\n          pos -= len;\n          Arrays.fill(expected, pos, pos+len, (byte) 0);\n          if (VERBOSE) {\n            System.out.println(\"    truncate len=\" + len + \" newPos=\" + pos);\n          }\n        }\n\n        if ((pos > 0 && random().nextInt(200) == 17)) {\n          verify(bytes, expected, pos);\n        }\n      }\n\n      BytesStore bytesToVerify;\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: save/load final bytes\");\n        }\n        Directory dir = newDirectory();\n        IndexOutput out = dir.createOutput(\"bytes\", IOContext.DEFAULT);\n        bytes.writeTo(out);\n        out.close();\n        IndexInput in = dir.openInput(\"bytes\", IOContext.DEFAULT);\n        bytesToVerify = new BytesStore(in, numBytes, _TestUtil.nextInt(random(), 256, Integer.MAX_VALUE));\n        in.close();\n        dir.close();\n      } else {\n        bytesToVerify = bytes;\n      }\n\n      verify(bytesToVerify, expected, numBytes);\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    final int iters = atLeast(10);\n    for(int iter=0;iter<iters;iter++) {\n      final int numBytes = _TestUtil.nextInt(random(), 1, 200000);\n      final byte[] expected = new byte[numBytes];\n      final int blockBits = _TestUtil.nextInt(random(), 8, 15);\n      final BytesStore bytes = new BytesStore(blockBits);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numBytes=\" + numBytes + \" blockBits=\" + blockBits);\n      }\n\n      int pos = 0;\n      while(pos < numBytes) {\n        int op = random().nextInt(7);\n        if (VERBOSE) {\n          System.out.println(\"  cycle pos=\" + pos);\n        }\n        switch(op) {\n\n        case 0:\n          {\n            // write random byte\n            byte b = (byte) random().nextInt(256);\n            if (VERBOSE) {\n              System.out.println(\"    writeByte b=\" + b);\n            }\n\n            expected[pos++] = b;\n            bytes.writeByte(b);\n          }\n          break;\n\n        case 1:\n          {\n            // write random byte[]\n            int len = random().nextInt(Math.min(numBytes - pos, 100));\n            byte[] temp = new byte[len];\n            random().nextBytes(temp);\n            if (VERBOSE) {\n              System.out.println(\"    writeBytes len=\" + len + \" bytes=\" + Arrays.toString(temp));\n            }\n            System.arraycopy(temp, 0, expected, pos, temp.length);\n            bytes.writeBytes(temp, 0, temp.length);\n            pos += len;\n          }\n          break;\n\n        case 2:\n          {\n            // write int @ absolute pos\n            if (pos > 4) {\n              int x = random().nextInt();\n              int randomPos = random().nextInt(pos-4);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeInt pos=\" + randomPos + \" x=\" + x);\n              }\n              bytes.writeInt(randomPos, x);\n              expected[randomPos++] = (byte) (x >> 24);\n              expected[randomPos++] = (byte) (x >> 16);\n              expected[randomPos++] = (byte) (x >> 8);\n              expected[randomPos++] = (byte) x;\n            }\n          }\n          break;\n\n        case 3:\n          {\n            // reverse bytes\n            if (pos > 0) {\n              int len = _TestUtil.nextInt(random(), 1, Math.min(100, pos));\n              int start;\n              if (len == pos) {\n                start = 0;\n              } else {\n                start = random().nextInt(pos - len);\n              }\n              int end = start + len;\n              if (VERBOSE) {\n                System.out.println(\"    reverse start=\" + start + \" end=\" + end + \" len=\" + len);\n              }\n              bytes.reverse(start, end);\n\n              while(start < end) {\n                byte b = expected[end];\n                expected[end] = expected[start];\n                expected[start] = b;\n                start++;\n                end--;\n              }\n            }\n          }\n          break;\n\n        case 4:\n          {\n            // abs write random byte[]\n            if (pos > 2) {\n              int randomPos = random().nextInt(pos-1);\n              int len = _TestUtil.nextInt(random(), 1, Math.min(pos - randomPos - 1, 100));\n              byte[] temp = new byte[len];\n              random().nextBytes(temp);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeBytes pos=\" + randomPos + \" len=\" + len + \" bytes=\" + Arrays.toString(temp));\n              }\n              System.arraycopy(temp, 0, expected, randomPos, temp.length);\n              bytes.writeBytes(randomPos, temp, 0, temp.length);\n            }\n          }\n          break;\n\n        case 5:\n          {\n            // copyBytes\n            if (pos > 1) {\n              int src = random().nextInt(pos-1);\n              int dest = _TestUtil.nextInt(random(), src+1, pos-1);\n              int len = _TestUtil.nextInt(random(), 1, Math.min(300, pos - dest));\n              if (VERBOSE) {\n                System.out.println(\"    copyBytes src=\" + src + \" dest=\" + dest + \" len=\" + len);\n              }\n              System.arraycopy(expected, src, expected, dest, len);\n              bytes.copyBytes(src, dest, len);\n            }\n          }\n          break;\n\n        case 6:\n          {\n            // skip\n            int len = random().nextInt(Math.min(100, numBytes - pos));\n            pos += len;\n            bytes.skip(len);\n            if (VERBOSE) {\n              System.out.println(\"    skip len=\" + len);\n            }\n          }\n          break;\n        }\n\n        assertEquals(pos, bytes.getPosition());\n\n        if ((pos > 0 && random().nextInt(200) == 17)) {\n          verify(bytes, expected, pos);\n        }\n      }\n\n      BytesStore bytesToVerify;\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: save/load final bytes\");\n        }\n        Directory dir = newDirectory();\n        IndexOutput out = dir.createOutput(\"bytes\", IOContext.DEFAULT);\n        bytes.writeTo(out);\n        out.close();\n        IndexInput in = dir.openInput(\"bytes\", IOContext.DEFAULT);\n        bytesToVerify = new BytesStore(in, numBytes, _TestUtil.nextInt(random(), 256, Integer.MAX_VALUE));\n        in.close();\n        dir.close();\n      } else {\n        bytesToVerify = bytes;\n      }\n\n      verify(bytesToVerify, expected, numBytes);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws Exception {\n\n    final int iters = atLeast(10);\n    for(int iter=0;iter<iters;iter++) {\n      final int numBytes = _TestUtil.nextInt(random(), 1, 200000);\n      final byte[] expected = new byte[numBytes];\n      final int blockBits = _TestUtil.nextInt(random(), 8, 15);\n      final BytesStore bytes = new BytesStore(blockBits);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numBytes=\" + numBytes + \" blockBits=\" + blockBits);\n      }\n\n      int pos = 0;\n      while(pos < numBytes) {\n        int op = random().nextInt(8);\n        if (VERBOSE) {\n          System.out.println(\"  cycle pos=\" + pos);\n        }\n        switch(op) {\n\n        case 0:\n          {\n            // write random byte\n            byte b = (byte) random().nextInt(256);\n            if (VERBOSE) {\n              System.out.println(\"    writeByte b=\" + b);\n            }\n\n            expected[pos++] = b;\n            bytes.writeByte(b);\n          }\n          break;\n\n        case 1:\n          {\n            // write random byte[]\n            int len = random().nextInt(Math.min(numBytes - pos, 100));\n            byte[] temp = new byte[len];\n            random().nextBytes(temp);\n            if (VERBOSE) {\n              System.out.println(\"    writeBytes len=\" + len + \" bytes=\" + Arrays.toString(temp));\n            }\n            System.arraycopy(temp, 0, expected, pos, temp.length);\n            bytes.writeBytes(temp, 0, temp.length);\n            pos += len;\n          }\n          break;\n\n        case 2:\n          {\n            // write int @ absolute pos\n            if (pos > 4) {\n              int x = random().nextInt();\n              int randomPos = random().nextInt(pos-4);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeInt pos=\" + randomPos + \" x=\" + x);\n              }\n              bytes.writeInt(randomPos, x);\n              expected[randomPos++] = (byte) (x >> 24);\n              expected[randomPos++] = (byte) (x >> 16);\n              expected[randomPos++] = (byte) (x >> 8);\n              expected[randomPos++] = (byte) x;\n            }\n          }\n          break;\n\n        case 3:\n          {\n            // reverse bytes\n            if (pos > 1) {\n              int len = _TestUtil.nextInt(random(), 2, Math.min(100, pos));\n              int start;\n              if (len == pos) {\n                start = 0;\n              } else {\n                start = random().nextInt(pos - len);\n              }\n              int end = start + len - 1;\n              if (VERBOSE) {\n                System.out.println(\"    reverse start=\" + start + \" end=\" + end + \" len=\" + len + \" pos=\" + pos);\n              }\n              bytes.reverse(start, end);\n\n              while(start <= end) {\n                byte b = expected[end];\n                expected[end] = expected[start];\n                expected[start] = b;\n                start++;\n                end--;\n              }\n            }\n          }\n          break;\n\n        case 4:\n          {\n            // abs write random byte[]\n            if (pos > 2) {\n              int randomPos = random().nextInt(pos-1);\n              int len = _TestUtil.nextInt(random(), 1, Math.min(pos - randomPos - 1, 100));\n              byte[] temp = new byte[len];\n              random().nextBytes(temp);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeBytes pos=\" + randomPos + \" len=\" + len + \" bytes=\" + Arrays.toString(temp));\n              }\n              System.arraycopy(temp, 0, expected, randomPos, temp.length);\n              bytes.writeBytes(randomPos, temp, 0, temp.length);\n            }\n          }\n          break;\n\n        case 5:\n          {\n            // copyBytes\n            if (pos > 1) {\n              int src = random().nextInt(pos-1);\n              int dest = _TestUtil.nextInt(random(), src+1, pos-1);\n              int len = _TestUtil.nextInt(random(), 1, Math.min(300, pos - dest));\n              if (VERBOSE) {\n                System.out.println(\"    copyBytes src=\" + src + \" dest=\" + dest + \" len=\" + len);\n              }\n              System.arraycopy(expected, src, expected, dest, len);\n              bytes.copyBytes(src, dest, len);\n            }\n          }\n          break;\n\n        case 6:\n          {\n            // skip\n            int len = random().nextInt(Math.min(100, numBytes - pos));\n\n            if (VERBOSE) {\n              System.out.println(\"    skip len=\" + len);\n            }\n\n            pos += len;\n            bytes.skipBytes(len);\n\n            // NOTE: must fill in zeros in case truncate was\n            // used, else we get false fails:\n            if (len > 0) {\n              byte[] zeros = new byte[len];\n              bytes.writeBytes(pos-len, zeros, 0, len);\n            }\n          }\n          break;\n\n        case 7:\n          {\n            // absWriteByte\n            if (pos > 0) {\n              int dest = random().nextInt(pos);\n              byte b = (byte) random().nextInt(256);\n              expected[dest] = b;\n              bytes.writeByte(dest, b);\n            }\n            break;\n          }\n        }\n\n        assertEquals(pos, bytes.getPosition());\n\n        if (pos > 0 && random().nextInt(50) == 17) {\n          // truncate\n          int len = _TestUtil.nextInt(random(), 1, Math.min(pos, 100));\n          bytes.truncate(pos - len);\n          pos -= len;\n          Arrays.fill(expected, pos, pos+len, (byte) 0);\n          if (VERBOSE) {\n            System.out.println(\"    truncate len=\" + len + \" newPos=\" + pos);\n          }\n        }\n\n        if ((pos > 0 && random().nextInt(200) == 17)) {\n          verify(bytes, expected, pos);\n        }\n      }\n\n      BytesStore bytesToVerify;\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: save/load final bytes\");\n        }\n        Directory dir = newDirectory();\n        IndexOutput out = dir.createOutput(\"bytes\", IOContext.DEFAULT);\n        bytes.writeTo(out);\n        out.close();\n        IndexInput in = dir.openInput(\"bytes\", IOContext.DEFAULT);\n        bytesToVerify = new BytesStore(in, numBytes, _TestUtil.nextInt(random(), 256, Integer.MAX_VALUE));\n        in.close();\n        dir.close();\n      } else {\n        bytesToVerify = bytes;\n      }\n\n      verify(bytesToVerify, expected, numBytes);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    final int iters = atLeast(10);\n    for(int iter=0;iter<iters;iter++) {\n      final int numBytes = TestUtil.nextInt(random(), 1, 200000);\n      final byte[] expected = new byte[numBytes];\n      final int blockBits = TestUtil.nextInt(random(), 8, 15);\n      final BytesStore bytes = new BytesStore(blockBits);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numBytes=\" + numBytes + \" blockBits=\" + blockBits);\n      }\n\n      int pos = 0;\n      while(pos < numBytes) {\n        int op = random().nextInt(8);\n        if (VERBOSE) {\n          System.out.println(\"  cycle pos=\" + pos);\n        }\n        switch(op) {\n\n        case 0:\n          {\n            // write random byte\n            byte b = (byte) random().nextInt(256);\n            if (VERBOSE) {\n              System.out.println(\"    writeByte b=\" + b);\n            }\n\n            expected[pos++] = b;\n            bytes.writeByte(b);\n          }\n          break;\n\n        case 1:\n          {\n            // write random byte[]\n            int len = random().nextInt(Math.min(numBytes - pos, 100));\n            byte[] temp = new byte[len];\n            random().nextBytes(temp);\n            if (VERBOSE) {\n              System.out.println(\"    writeBytes len=\" + len + \" bytes=\" + Arrays.toString(temp));\n            }\n            System.arraycopy(temp, 0, expected, pos, temp.length);\n            bytes.writeBytes(temp, 0, temp.length);\n            pos += len;\n          }\n          break;\n\n        case 2:\n          {\n            // write int @ absolute pos\n            if (pos > 4) {\n              int x = random().nextInt();\n              int randomPos = random().nextInt(pos-4);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeInt pos=\" + randomPos + \" x=\" + x);\n              }\n              bytes.writeInt(randomPos, x);\n              expected[randomPos++] = (byte) (x >> 24);\n              expected[randomPos++] = (byte) (x >> 16);\n              expected[randomPos++] = (byte) (x >> 8);\n              expected[randomPos++] = (byte) x;\n            }\n          }\n          break;\n\n        case 3:\n          {\n            // reverse bytes\n            if (pos > 1) {\n              int len = TestUtil.nextInt(random(), 2, Math.min(100, pos));\n              int start;\n              if (len == pos) {\n                start = 0;\n              } else {\n                start = random().nextInt(pos - len);\n              }\n              int end = start + len - 1;\n              if (VERBOSE) {\n                System.out.println(\"    reverse start=\" + start + \" end=\" + end + \" len=\" + len + \" pos=\" + pos);\n              }\n              bytes.reverse(start, end);\n\n              while(start <= end) {\n                byte b = expected[end];\n                expected[end] = expected[start];\n                expected[start] = b;\n                start++;\n                end--;\n              }\n            }\n          }\n          break;\n\n        case 4:\n          {\n            // abs write random byte[]\n            if (pos > 2) {\n              int randomPos = random().nextInt(pos-1);\n              int len = TestUtil.nextInt(random(), 1, Math.min(pos - randomPos - 1, 100));\n              byte[] temp = new byte[len];\n              random().nextBytes(temp);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeBytes pos=\" + randomPos + \" len=\" + len + \" bytes=\" + Arrays.toString(temp));\n              }\n              System.arraycopy(temp, 0, expected, randomPos, temp.length);\n              bytes.writeBytes(randomPos, temp, 0, temp.length);\n            }\n          }\n          break;\n\n        case 5:\n          {\n            // copyBytes\n            if (pos > 1) {\n              int src = random().nextInt(pos-1);\n              int dest = TestUtil.nextInt(random(), src + 1, pos - 1);\n              int len = TestUtil.nextInt(random(), 1, Math.min(300, pos - dest));\n              if (VERBOSE) {\n                System.out.println(\"    copyBytes src=\" + src + \" dest=\" + dest + \" len=\" + len);\n              }\n              System.arraycopy(expected, src, expected, dest, len);\n              bytes.copyBytes(src, dest, len);\n            }\n          }\n          break;\n\n        case 6:\n          {\n            // skip\n            int len = random().nextInt(Math.min(100, numBytes - pos));\n\n            if (VERBOSE) {\n              System.out.println(\"    skip len=\" + len);\n            }\n\n            pos += len;\n            bytes.skipBytes(len);\n\n            // NOTE: must fill in zeros in case truncate was\n            // used, else we get false fails:\n            if (len > 0) {\n              byte[] zeros = new byte[len];\n              bytes.writeBytes(pos-len, zeros, 0, len);\n            }\n          }\n          break;\n\n        case 7:\n          {\n            // absWriteByte\n            if (pos > 0) {\n              int dest = random().nextInt(pos);\n              byte b = (byte) random().nextInt(256);\n              expected[dest] = b;\n              bytes.writeByte(dest, b);\n            }\n            break;\n          }\n        }\n\n        assertEquals(pos, bytes.getPosition());\n\n        if (pos > 0 && random().nextInt(50) == 17) {\n          // truncate\n          int len = TestUtil.nextInt(random(), 1, Math.min(pos, 100));\n          bytes.truncate(pos - len);\n          pos -= len;\n          Arrays.fill(expected, pos, pos+len, (byte) 0);\n          if (VERBOSE) {\n            System.out.println(\"    truncate len=\" + len + \" newPos=\" + pos);\n          }\n        }\n\n        if ((pos > 0 && random().nextInt(200) == 17)) {\n          verify(bytes, expected, pos);\n        }\n      }\n\n      BytesStore bytesToVerify;\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: save/load final bytes\");\n        }\n        Directory dir = newDirectory();\n        IndexOutput out = dir.createOutput(\"bytes\", IOContext.DEFAULT);\n        bytes.writeTo(out);\n        out.close();\n        IndexInput in = dir.openInput(\"bytes\", IOContext.DEFAULT);\n        bytesToVerify = new BytesStore(in, numBytes, TestUtil.nextInt(random(), 256, Integer.MAX_VALUE));\n        in.close();\n        dir.close();\n      } else {\n        bytesToVerify = bytes;\n      }\n\n      verify(bytesToVerify, expected, numBytes);\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    final int iters = atLeast(10);\n    for(int iter=0;iter<iters;iter++) {\n      final int numBytes = _TestUtil.nextInt(random(), 1, 200000);\n      final byte[] expected = new byte[numBytes];\n      final int blockBits = _TestUtil.nextInt(random(), 8, 15);\n      final BytesStore bytes = new BytesStore(blockBits);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numBytes=\" + numBytes + \" blockBits=\" + blockBits);\n      }\n\n      int pos = 0;\n      while(pos < numBytes) {\n        int op = random().nextInt(8);\n        if (VERBOSE) {\n          System.out.println(\"  cycle pos=\" + pos);\n        }\n        switch(op) {\n\n        case 0:\n          {\n            // write random byte\n            byte b = (byte) random().nextInt(256);\n            if (VERBOSE) {\n              System.out.println(\"    writeByte b=\" + b);\n            }\n\n            expected[pos++] = b;\n            bytes.writeByte(b);\n          }\n          break;\n\n        case 1:\n          {\n            // write random byte[]\n            int len = random().nextInt(Math.min(numBytes - pos, 100));\n            byte[] temp = new byte[len];\n            random().nextBytes(temp);\n            if (VERBOSE) {\n              System.out.println(\"    writeBytes len=\" + len + \" bytes=\" + Arrays.toString(temp));\n            }\n            System.arraycopy(temp, 0, expected, pos, temp.length);\n            bytes.writeBytes(temp, 0, temp.length);\n            pos += len;\n          }\n          break;\n\n        case 2:\n          {\n            // write int @ absolute pos\n            if (pos > 4) {\n              int x = random().nextInt();\n              int randomPos = random().nextInt(pos-4);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeInt pos=\" + randomPos + \" x=\" + x);\n              }\n              bytes.writeInt(randomPos, x);\n              expected[randomPos++] = (byte) (x >> 24);\n              expected[randomPos++] = (byte) (x >> 16);\n              expected[randomPos++] = (byte) (x >> 8);\n              expected[randomPos++] = (byte) x;\n            }\n          }\n          break;\n\n        case 3:\n          {\n            // reverse bytes\n            if (pos > 1) {\n              int len = _TestUtil.nextInt(random(), 2, Math.min(100, pos));\n              int start;\n              if (len == pos) {\n                start = 0;\n              } else {\n                start = random().nextInt(pos - len);\n              }\n              int end = start + len - 1;\n              if (VERBOSE) {\n                System.out.println(\"    reverse start=\" + start + \" end=\" + end + \" len=\" + len + \" pos=\" + pos);\n              }\n              bytes.reverse(start, end);\n\n              while(start <= end) {\n                byte b = expected[end];\n                expected[end] = expected[start];\n                expected[start] = b;\n                start++;\n                end--;\n              }\n            }\n          }\n          break;\n\n        case 4:\n          {\n            // abs write random byte[]\n            if (pos > 2) {\n              int randomPos = random().nextInt(pos-1);\n              int len = _TestUtil.nextInt(random(), 1, Math.min(pos - randomPos - 1, 100));\n              byte[] temp = new byte[len];\n              random().nextBytes(temp);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeBytes pos=\" + randomPos + \" len=\" + len + \" bytes=\" + Arrays.toString(temp));\n              }\n              System.arraycopy(temp, 0, expected, randomPos, temp.length);\n              bytes.writeBytes(randomPos, temp, 0, temp.length);\n            }\n          }\n          break;\n\n        case 5:\n          {\n            // copyBytes\n            if (pos > 1) {\n              int src = random().nextInt(pos-1);\n              int dest = _TestUtil.nextInt(random(), src+1, pos-1);\n              int len = _TestUtil.nextInt(random(), 1, Math.min(300, pos - dest));\n              if (VERBOSE) {\n                System.out.println(\"    copyBytes src=\" + src + \" dest=\" + dest + \" len=\" + len);\n              }\n              System.arraycopy(expected, src, expected, dest, len);\n              bytes.copyBytes(src, dest, len);\n            }\n          }\n          break;\n\n        case 6:\n          {\n            // skip\n            int len = random().nextInt(Math.min(100, numBytes - pos));\n\n            if (VERBOSE) {\n              System.out.println(\"    skip len=\" + len);\n            }\n\n            pos += len;\n            bytes.skipBytes(len);\n\n            // NOTE: must fill in zeros in case truncate was\n            // used, else we get false fails:\n            if (len > 0) {\n              byte[] zeros = new byte[len];\n              bytes.writeBytes(pos-len, zeros, 0, len);\n            }\n          }\n          break;\n\n        case 7:\n          {\n            // absWriteByte\n            if (pos > 0) {\n              int dest = random().nextInt(pos);\n              byte b = (byte) random().nextInt(256);\n              expected[dest] = b;\n              bytes.writeByte(dest, b);\n            }\n            break;\n          }\n        }\n\n        assertEquals(pos, bytes.getPosition());\n\n        if (pos > 0 && random().nextInt(50) == 17) {\n          // truncate\n          int len = _TestUtil.nextInt(random(), 1, Math.min(pos, 100));\n          bytes.truncate(pos - len);\n          pos -= len;\n          Arrays.fill(expected, pos, pos+len, (byte) 0);\n          if (VERBOSE) {\n            System.out.println(\"    truncate len=\" + len + \" newPos=\" + pos);\n          }\n        }\n\n        if ((pos > 0 && random().nextInt(200) == 17)) {\n          verify(bytes, expected, pos);\n        }\n      }\n\n      BytesStore bytesToVerify;\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: save/load final bytes\");\n        }\n        Directory dir = newDirectory();\n        IndexOutput out = dir.createOutput(\"bytes\", IOContext.DEFAULT);\n        bytes.writeTo(out);\n        out.close();\n        IndexInput in = dir.openInput(\"bytes\", IOContext.DEFAULT);\n        bytesToVerify = new BytesStore(in, numBytes, _TestUtil.nextInt(random(), 256, Integer.MAX_VALUE));\n        in.close();\n        dir.close();\n      } else {\n        bytesToVerify = bytes;\n      }\n\n      verify(bytesToVerify, expected, numBytes);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5445f368ca115295b7969017bb7c8983bbec0a18","date":1417101894,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    final int iters = atLeast(10);\n    final int maxBytes = TEST_NIGHTLY ? 200000 : 20000;\n    for(int iter=0;iter<iters;iter++) {\n      final int numBytes = TestUtil.nextInt(random(), 1, maxBytes);\n      final byte[] expected = new byte[numBytes];\n      final int blockBits = TestUtil.nextInt(random(), 8, 15);\n      final BytesStore bytes = new BytesStore(blockBits);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numBytes=\" + numBytes + \" blockBits=\" + blockBits);\n      }\n\n      int pos = 0;\n      while(pos < numBytes) {\n        int op = random().nextInt(8);\n        if (VERBOSE) {\n          System.out.println(\"  cycle pos=\" + pos);\n        }\n        switch(op) {\n\n        case 0:\n          {\n            // write random byte\n            byte b = (byte) random().nextInt(256);\n            if (VERBOSE) {\n              System.out.println(\"    writeByte b=\" + b);\n            }\n\n            expected[pos++] = b;\n            bytes.writeByte(b);\n          }\n          break;\n\n        case 1:\n          {\n            // write random byte[]\n            int len = random().nextInt(Math.min(numBytes - pos, 100));\n            byte[] temp = new byte[len];\n            random().nextBytes(temp);\n            if (VERBOSE) {\n              System.out.println(\"    writeBytes len=\" + len + \" bytes=\" + Arrays.toString(temp));\n            }\n            System.arraycopy(temp, 0, expected, pos, temp.length);\n            bytes.writeBytes(temp, 0, temp.length);\n            pos += len;\n          }\n          break;\n\n        case 2:\n          {\n            // write int @ absolute pos\n            if (pos > 4) {\n              int x = random().nextInt();\n              int randomPos = random().nextInt(pos-4);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeInt pos=\" + randomPos + \" x=\" + x);\n              }\n              bytes.writeInt(randomPos, x);\n              expected[randomPos++] = (byte) (x >> 24);\n              expected[randomPos++] = (byte) (x >> 16);\n              expected[randomPos++] = (byte) (x >> 8);\n              expected[randomPos++] = (byte) x;\n            }\n          }\n          break;\n\n        case 3:\n          {\n            // reverse bytes\n            if (pos > 1) {\n              int len = TestUtil.nextInt(random(), 2, Math.min(100, pos));\n              int start;\n              if (len == pos) {\n                start = 0;\n              } else {\n                start = random().nextInt(pos - len);\n              }\n              int end = start + len - 1;\n              if (VERBOSE) {\n                System.out.println(\"    reverse start=\" + start + \" end=\" + end + \" len=\" + len + \" pos=\" + pos);\n              }\n              bytes.reverse(start, end);\n\n              while(start <= end) {\n                byte b = expected[end];\n                expected[end] = expected[start];\n                expected[start] = b;\n                start++;\n                end--;\n              }\n            }\n          }\n          break;\n\n        case 4:\n          {\n            // abs write random byte[]\n            if (pos > 2) {\n              int randomPos = random().nextInt(pos-1);\n              int len = TestUtil.nextInt(random(), 1, Math.min(pos - randomPos - 1, 100));\n              byte[] temp = new byte[len];\n              random().nextBytes(temp);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeBytes pos=\" + randomPos + \" len=\" + len + \" bytes=\" + Arrays.toString(temp));\n              }\n              System.arraycopy(temp, 0, expected, randomPos, temp.length);\n              bytes.writeBytes(randomPos, temp, 0, temp.length);\n            }\n          }\n          break;\n\n        case 5:\n          {\n            // copyBytes\n            if (pos > 1) {\n              int src = random().nextInt(pos-1);\n              int dest = TestUtil.nextInt(random(), src + 1, pos - 1);\n              int len = TestUtil.nextInt(random(), 1, Math.min(300, pos - dest));\n              if (VERBOSE) {\n                System.out.println(\"    copyBytes src=\" + src + \" dest=\" + dest + \" len=\" + len);\n              }\n              System.arraycopy(expected, src, expected, dest, len);\n              bytes.copyBytes(src, dest, len);\n            }\n          }\n          break;\n\n        case 6:\n          {\n            // skip\n            int len = random().nextInt(Math.min(100, numBytes - pos));\n\n            if (VERBOSE) {\n              System.out.println(\"    skip len=\" + len);\n            }\n\n            pos += len;\n            bytes.skipBytes(len);\n\n            // NOTE: must fill in zeros in case truncate was\n            // used, else we get false fails:\n            if (len > 0) {\n              byte[] zeros = new byte[len];\n              bytes.writeBytes(pos-len, zeros, 0, len);\n            }\n          }\n          break;\n\n        case 7:\n          {\n            // absWriteByte\n            if (pos > 0) {\n              int dest = random().nextInt(pos);\n              byte b = (byte) random().nextInt(256);\n              expected[dest] = b;\n              bytes.writeByte(dest, b);\n            }\n            break;\n          }\n        }\n\n        assertEquals(pos, bytes.getPosition());\n\n        if (pos > 0 && random().nextInt(50) == 17) {\n          // truncate\n          int len = TestUtil.nextInt(random(), 1, Math.min(pos, 100));\n          bytes.truncate(pos - len);\n          pos -= len;\n          Arrays.fill(expected, pos, pos+len, (byte) 0);\n          if (VERBOSE) {\n            System.out.println(\"    truncate len=\" + len + \" newPos=\" + pos);\n          }\n        }\n\n        if ((pos > 0 && random().nextInt(200) == 17)) {\n          verify(bytes, expected, pos);\n        }\n      }\n\n      BytesStore bytesToVerify;\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: save/load final bytes\");\n        }\n        Directory dir = newDirectory();\n        IndexOutput out = dir.createOutput(\"bytes\", IOContext.DEFAULT);\n        bytes.writeTo(out);\n        out.close();\n        IndexInput in = dir.openInput(\"bytes\", IOContext.DEFAULT);\n        bytesToVerify = new BytesStore(in, numBytes, TestUtil.nextInt(random(), 256, Integer.MAX_VALUE));\n        in.close();\n        dir.close();\n      } else {\n        bytesToVerify = bytes;\n      }\n\n      verify(bytesToVerify, expected, numBytes);\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    final int iters = atLeast(10);\n    for(int iter=0;iter<iters;iter++) {\n      final int numBytes = TestUtil.nextInt(random(), 1, 200000);\n      final byte[] expected = new byte[numBytes];\n      final int blockBits = TestUtil.nextInt(random(), 8, 15);\n      final BytesStore bytes = new BytesStore(blockBits);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numBytes=\" + numBytes + \" blockBits=\" + blockBits);\n      }\n\n      int pos = 0;\n      while(pos < numBytes) {\n        int op = random().nextInt(8);\n        if (VERBOSE) {\n          System.out.println(\"  cycle pos=\" + pos);\n        }\n        switch(op) {\n\n        case 0:\n          {\n            // write random byte\n            byte b = (byte) random().nextInt(256);\n            if (VERBOSE) {\n              System.out.println(\"    writeByte b=\" + b);\n            }\n\n            expected[pos++] = b;\n            bytes.writeByte(b);\n          }\n          break;\n\n        case 1:\n          {\n            // write random byte[]\n            int len = random().nextInt(Math.min(numBytes - pos, 100));\n            byte[] temp = new byte[len];\n            random().nextBytes(temp);\n            if (VERBOSE) {\n              System.out.println(\"    writeBytes len=\" + len + \" bytes=\" + Arrays.toString(temp));\n            }\n            System.arraycopy(temp, 0, expected, pos, temp.length);\n            bytes.writeBytes(temp, 0, temp.length);\n            pos += len;\n          }\n          break;\n\n        case 2:\n          {\n            // write int @ absolute pos\n            if (pos > 4) {\n              int x = random().nextInt();\n              int randomPos = random().nextInt(pos-4);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeInt pos=\" + randomPos + \" x=\" + x);\n              }\n              bytes.writeInt(randomPos, x);\n              expected[randomPos++] = (byte) (x >> 24);\n              expected[randomPos++] = (byte) (x >> 16);\n              expected[randomPos++] = (byte) (x >> 8);\n              expected[randomPos++] = (byte) x;\n            }\n          }\n          break;\n\n        case 3:\n          {\n            // reverse bytes\n            if (pos > 1) {\n              int len = TestUtil.nextInt(random(), 2, Math.min(100, pos));\n              int start;\n              if (len == pos) {\n                start = 0;\n              } else {\n                start = random().nextInt(pos - len);\n              }\n              int end = start + len - 1;\n              if (VERBOSE) {\n                System.out.println(\"    reverse start=\" + start + \" end=\" + end + \" len=\" + len + \" pos=\" + pos);\n              }\n              bytes.reverse(start, end);\n\n              while(start <= end) {\n                byte b = expected[end];\n                expected[end] = expected[start];\n                expected[start] = b;\n                start++;\n                end--;\n              }\n            }\n          }\n          break;\n\n        case 4:\n          {\n            // abs write random byte[]\n            if (pos > 2) {\n              int randomPos = random().nextInt(pos-1);\n              int len = TestUtil.nextInt(random(), 1, Math.min(pos - randomPos - 1, 100));\n              byte[] temp = new byte[len];\n              random().nextBytes(temp);\n              if (VERBOSE) {\n                System.out.println(\"    abs writeBytes pos=\" + randomPos + \" len=\" + len + \" bytes=\" + Arrays.toString(temp));\n              }\n              System.arraycopy(temp, 0, expected, randomPos, temp.length);\n              bytes.writeBytes(randomPos, temp, 0, temp.length);\n            }\n          }\n          break;\n\n        case 5:\n          {\n            // copyBytes\n            if (pos > 1) {\n              int src = random().nextInt(pos-1);\n              int dest = TestUtil.nextInt(random(), src + 1, pos - 1);\n              int len = TestUtil.nextInt(random(), 1, Math.min(300, pos - dest));\n              if (VERBOSE) {\n                System.out.println(\"    copyBytes src=\" + src + \" dest=\" + dest + \" len=\" + len);\n              }\n              System.arraycopy(expected, src, expected, dest, len);\n              bytes.copyBytes(src, dest, len);\n            }\n          }\n          break;\n\n        case 6:\n          {\n            // skip\n            int len = random().nextInt(Math.min(100, numBytes - pos));\n\n            if (VERBOSE) {\n              System.out.println(\"    skip len=\" + len);\n            }\n\n            pos += len;\n            bytes.skipBytes(len);\n\n            // NOTE: must fill in zeros in case truncate was\n            // used, else we get false fails:\n            if (len > 0) {\n              byte[] zeros = new byte[len];\n              bytes.writeBytes(pos-len, zeros, 0, len);\n            }\n          }\n          break;\n\n        case 7:\n          {\n            // absWriteByte\n            if (pos > 0) {\n              int dest = random().nextInt(pos);\n              byte b = (byte) random().nextInt(256);\n              expected[dest] = b;\n              bytes.writeByte(dest, b);\n            }\n            break;\n          }\n        }\n\n        assertEquals(pos, bytes.getPosition());\n\n        if (pos > 0 && random().nextInt(50) == 17) {\n          // truncate\n          int len = TestUtil.nextInt(random(), 1, Math.min(pos, 100));\n          bytes.truncate(pos - len);\n          pos -= len;\n          Arrays.fill(expected, pos, pos+len, (byte) 0);\n          if (VERBOSE) {\n            System.out.println(\"    truncate len=\" + len + \" newPos=\" + pos);\n          }\n        }\n\n        if ((pos > 0 && random().nextInt(200) == 17)) {\n          verify(bytes, expected, pos);\n        }\n      }\n\n      BytesStore bytesToVerify;\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: save/load final bytes\");\n        }\n        Directory dir = newDirectory();\n        IndexOutput out = dir.createOutput(\"bytes\", IOContext.DEFAULT);\n        bytes.writeTo(out);\n        out.close();\n        IndexInput in = dir.openInput(\"bytes\", IOContext.DEFAULT);\n        bytesToVerify = new BytesStore(in, numBytes, TestUtil.nextInt(random(), 256, Integer.MAX_VALUE));\n        in.close();\n        dir.close();\n      } else {\n        bytesToVerify = bytes;\n      }\n\n      verify(bytesToVerify, expected, numBytes);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"73e44327cb5401cc5098da2f488c899954c9bfbc":["87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"6613659748fe4411a7dcf85266e55db1f95f7315":["73e44327cb5401cc5098da2f488c899954c9bfbc"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","73e44327cb5401cc5098da2f488c899954c9bfbc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5445f368ca115295b7969017bb7c8983bbec0a18":["6613659748fe4411a7dcf85266e55db1f95f7315"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5445f368ca115295b7969017bb7c8983bbec0a18"]},"commit2Childs":{"73e44327cb5401cc5098da2f488c899954c9bfbc":["6613659748fe4411a7dcf85266e55db1f95f7315","8917bfede3b4ca30f4305c1e391e9218959cd723"],"6613659748fe4411a7dcf85266e55db1f95f7315":["5445f368ca115295b7969017bb7c8983bbec0a18"],"8917bfede3b4ca30f4305c1e391e9218959cd723":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8917bfede3b4ca30f4305c1e391e9218959cd723","87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["73e44327cb5401cc5098da2f488c899954c9bfbc"],"5445f368ca115295b7969017bb7c8983bbec0a18":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8917bfede3b4ca30f4305c1e391e9218959cd723","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}