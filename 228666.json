{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","commits":[{"id":"7af110b00ea8df9429309d83e38e0533d82e144f","date":1376924768,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    final Set<String> newFilesSet = new HashSet<String>();\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadState();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread, newFilesSet);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes(newFilesSet);\n      putEvent(new DeleteNewFilesEvent(newFilesSet));\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + newFilesSet + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() {\n    boolean success = false;\n\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n\n      final int limit = perThreadPool.getActiveThreadState();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.dwpt.abort();\n            } finally {\n              perThread.dwpt.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    final Set<String> newFilesSet = new HashSet<String>();\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadState();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread, newFilesSet);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes(newFilesSet);\n      putEvent(new DeleteNewFilesEvent(newFilesSet));\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + newFilesSet + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() {\n    boolean success = false;\n\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n\n      final int limit = perThreadPool.getActiveThreadState();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.dwpt.abort();\n            } finally {\n              perThread.dwpt.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","pathOld":"/dev/null","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    final Set<String> newFilesSet = new HashSet<String>();\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadState();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread, newFilesSet);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes(newFilesSet);\n      putEvent(new DeleteNewFilesEvent(newFilesSet));\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + newFilesSet + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    final Set<String> newFilesSet = new HashSet<>();\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadState();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread, newFilesSet);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes(newFilesSet);\n      putEvent(new DeleteNewFilesEvent(newFilesSet));\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + newFilesSet + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    final Set<String> newFilesSet = new HashSet<String>();\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadState();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread, newFilesSet);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes(newFilesSet);\n      putEvent(new DeleteNewFilesEvent(newFilesSet));\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + newFilesSet + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9299079153fd7895bf3cf6835cf7019af2ba89b3","date":1417813477,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadState();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    final Set<String> newFilesSet = new HashSet<>();\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadState();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread, newFilesSet);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes(newFilesSet);\n      putEvent(new DeleteNewFilesEvent(newFilesSet));\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + newFilesSet + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c02b804ab16489b95429791a2d8fb0e0728354d4","date":1436551798,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadStateCount();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadState();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f11f03fdb6e013cb2da7aa973c84bf9de326c56d","date":1436880767,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadStateCount();\n      perThreadPool.setAbort();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadStateCount();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["41e6e2c132608605ce2fe847d7d20d30064a971a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"41e6e2c132608605ce2fe847d7d20d30064a971a","date":1437182290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadStateCount();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadStateCount();\n      perThreadPool.setAbort();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort success=\" + success);\n      }\n    }\n  }\n\n","bugFix":["f11f03fdb6e013cb2da7aa973c84bf9de326c56d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab08f09eb919a4eea12a75333606380199db57b1","date":1521493705,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) throws IOException {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadStateCount();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadStateCount();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","date":1521731438,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) throws IOException {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadStateCount();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadStateCount();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b8498afacfc8322268ca0d659d274fcce08d557","date":1524577248,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort(IndexWriter).mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadStateCount();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort(IndexWriter writer) throws IOException {\n    assert !Thread.holdsLock(writer) : \"IndexWriter lock should never be hold when aborting\";\n    boolean success = false;\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      final int limit = perThreadPool.getActiveThreadStateCount();\n      for (int i = 0; i < limit; i++) {\n        final ThreadState perThread = perThreadPool.getThreadState(i);\n        perThread.lock();\n        try {\n          abortThreadState(perThread);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7af110b00ea8df9429309d83e38e0533d82e144f"],"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["41e6e2c132608605ce2fe847d7d20d30064a971a","ab08f09eb919a4eea12a75333606380199db57b1"],"7af110b00ea8df9429309d83e38e0533d82e144f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ab08f09eb919a4eea12a75333606380199db57b1":["41e6e2c132608605ce2fe847d7d20d30064a971a"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7af110b00ea8df9429309d83e38e0533d82e144f"],"31d4861802ca404d78ca1d15f4550eec415b9199":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7af110b00ea8df9429309d83e38e0533d82e144f"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"6b8498afacfc8322268ca0d659d274fcce08d557":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"41e6e2c132608605ce2fe847d7d20d30064a971a":["f11f03fdb6e013cb2da7aa973c84bf9de326c56d"],"f11f03fdb6e013cb2da7aa973c84bf9de326c56d":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6b8498afacfc8322268ca0d659d274fcce08d557"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["6b8498afacfc8322268ca0d659d274fcce08d557"],"7af110b00ea8df9429309d83e38e0533d82e144f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"ab08f09eb919a4eea12a75333606380199db57b1":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"c02b804ab16489b95429791a2d8fb0e0728354d4":["f11f03fdb6e013cb2da7aa973c84bf9de326c56d"],"6b8498afacfc8322268ca0d659d274fcce08d557":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"41e6e2c132608605ce2fe847d7d20d30064a971a":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","ab08f09eb919a4eea12a75333606380199db57b1"],"f11f03fdb6e013cb2da7aa973c84bf9de326c56d":["41e6e2c132608605ce2fe847d7d20d30064a971a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7af110b00ea8df9429309d83e38e0533d82e144f","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}