{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","commits":[{"id":"9d70e774cb25c8a8d2c3e5e84200f235f9168d87","date":1553016391,"type":1,"author":"Bar Rotstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#MIGRATE} */\n  protected List<SolrCmdDistributor.Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<SolrCmdDistributor.Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Map.Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlicesArr().length > 0) {\n              final Slice[] activeSlices = docCollection.getActiveSlicesArr();\n              Slice any = activeSlices[0];\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new SolrCmdDistributor.StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new SolrCmdDistributor.StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      zkController.getOverseer().offerStateUpdate(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#MIGRATE} */\n  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlicesArr().length > 0) {\n              final Slice[] activeSlices = docCollection.getActiveSlicesArr();\n              Slice any = activeSlices[0];\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      zkController.getOverseer().offerStateUpdate(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#MIGRATE} */\n  protected List<SolrCmdDistributor.Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<SolrCmdDistributor.Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Map.Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlicesArr().length > 0) {\n              final Slice[] activeSlices = docCollection.getActiveSlicesArr();\n              Slice any = activeSlices[0];\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new SolrCmdDistributor.StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new SolrCmdDistributor.StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      zkController.getOverseer().offerStateUpdate(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: {}\", routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: {}\", routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#MIGRATE} */\n  protected List<SolrCmdDistributor.Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<SolrCmdDistributor.Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Map.Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlicesArr().length > 0) {\n              final Slice[] activeSlices = docCollection.getActiveSlicesArr();\n              Slice any = activeSlices[0];\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new SolrCmdDistributor.StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new SolrCmdDistributor.StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      zkController.getOverseer().offerStateUpdate(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"740d649f013f07efbeb73ca854f106c60166e7c0":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["740d649f013f07efbeb73ca854f106c60166e7c0"]},"commit2Childs":{"740d649f013f07efbeb73ca854f106c60166e7c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["740d649f013f07efbeb73ca854f106c60166e7c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}