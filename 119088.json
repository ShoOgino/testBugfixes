{"path":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader,boolean).mjava","commits":[{"id":"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f","date":1456936072,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader,boolean).mjava","pathOld":"/dev/null","sourceNew":"  public static IndexReader wrapReader(IndexReader r, boolean allowSlowCompositeReader) throws IOException {\n    Random random = random();\n      \n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof LeafReader;\n    for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n      switch(random.nextInt(6)) {\n      case 0:\n        if (allowSlowCompositeReader) {\n          if (VERBOSE) {\n            System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with SlowCompositeReaderWrapper.wrap\");\n          }\n          r = SlowCompositeReaderWrapper.wrap(r);\n        }\n        break;\n      case 1:\n        // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeaf/CompositeReader\");\n        }\n        r = (r instanceof LeafReader) ?\n          new ParallelLeafReader((LeafReader) r) :\n        new ParallelCompositeReader((CompositeReader) r);\n        break;\n      case 2:\n        // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with FCInvisibleMultiReader\");\n        }\n        r = new FCInvisibleMultiReader(r);\n        break;\n      case 3:\n        if (allowSlowCompositeReader) {\n          final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n          final List<String> allFields = new ArrayList<>();\n          for (FieldInfo fi : ar.getFieldInfos()) {\n            allFields.add(fi.name);\n          }\n          Collections.shuffle(allFields, random);\n          final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n          final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n          // will create no FC insanity as ParallelLeafReader has own cache key:\n          if (VERBOSE) {\n            System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeafReader(SlowCompositeReaderWapper)\");\n          }\n          r = new ParallelLeafReader(\n                                     new FieldFilterLeafReader(ar, fields, false),\n                                     new FieldFilterLeafReader(ar, fields, true)\n                                     );\n        }\n        break;\n      case 4:\n        // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with AssertingLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new AssertingLeafReader((LeafReader)r);\n        } else if (r instanceof DirectoryReader) {\n          r = new AssertingDirectoryReader((DirectoryReader)r);\n        }\n        break;\n      case 5:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with MismatchedLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new MismatchedLeafReader((LeafReader)r, random);\n        } else if (r instanceof DirectoryReader) {\n          r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n        }\n        break;\n      default:\n        fail(\"should not get here\");\n      }\n    }\n    if (wasOriginallyAtomic) {\n      if (allowSlowCompositeReader) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      }\n    } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n      // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n      r = new FCInvisibleMultiReader(r);\n    }\n    if (VERBOSE) {\n      System.out.println(\"wrapReader wrapped: \" +r);\n    }\n\n    return r;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader,boolean).mjava","pathOld":"/dev/null","sourceNew":"  public static IndexReader wrapReader(IndexReader r, boolean allowSlowCompositeReader) throws IOException {\n    Random random = random();\n      \n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof LeafReader;\n    for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n      switch(random.nextInt(6)) {\n      case 0:\n        if (allowSlowCompositeReader) {\n          if (VERBOSE) {\n            System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with SlowCompositeReaderWrapper.wrap\");\n          }\n          r = SlowCompositeReaderWrapper.wrap(r);\n        }\n        break;\n      case 1:\n        // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeaf/CompositeReader\");\n        }\n        r = (r instanceof LeafReader) ?\n          new ParallelLeafReader((LeafReader) r) :\n        new ParallelCompositeReader((CompositeReader) r);\n        break;\n      case 2:\n        // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with FCInvisibleMultiReader\");\n        }\n        r = new FCInvisibleMultiReader(r);\n        break;\n      case 3:\n        if (allowSlowCompositeReader) {\n          final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n          final List<String> allFields = new ArrayList<>();\n          for (FieldInfo fi : ar.getFieldInfos()) {\n            allFields.add(fi.name);\n          }\n          Collections.shuffle(allFields, random);\n          final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n          final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n          // will create no FC insanity as ParallelLeafReader has own cache key:\n          if (VERBOSE) {\n            System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeafReader(SlowCompositeReaderWapper)\");\n          }\n          r = new ParallelLeafReader(\n                                     new FieldFilterLeafReader(ar, fields, false),\n                                     new FieldFilterLeafReader(ar, fields, true)\n                                     );\n        }\n        break;\n      case 4:\n        // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with AssertingLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new AssertingLeafReader((LeafReader)r);\n        } else if (r instanceof DirectoryReader) {\n          r = new AssertingDirectoryReader((DirectoryReader)r);\n        }\n        break;\n      case 5:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with MismatchedLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new MismatchedLeafReader((LeafReader)r, random);\n        } else if (r instanceof DirectoryReader) {\n          r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n        }\n        break;\n      default:\n        fail(\"should not get here\");\n      }\n    }\n    if (wasOriginallyAtomic) {\n      if (allowSlowCompositeReader) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      }\n    } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n      // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n      r = new FCInvisibleMultiReader(r);\n    }\n    if (VERBOSE) {\n      System.out.println(\"wrapReader wrapped: \" +r);\n    }\n\n    return r;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","date":1457644139,"type":4,"author":"Mike McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader,boolean).mjava","sourceNew":null,"sourceOld":"  public static IndexReader wrapReader(IndexReader r, boolean allowSlowCompositeReader) throws IOException {\n    Random random = random();\n      \n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof LeafReader;\n    for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n      switch(random.nextInt(6)) {\n      case 0:\n        if (allowSlowCompositeReader) {\n          if (VERBOSE) {\n            System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with SlowCompositeReaderWrapper.wrap\");\n          }\n          r = SlowCompositeReaderWrapper.wrap(r);\n        }\n        break;\n      case 1:\n        // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeaf/CompositeReader\");\n        }\n        r = (r instanceof LeafReader) ?\n          new ParallelLeafReader((LeafReader) r) :\n        new ParallelCompositeReader((CompositeReader) r);\n        break;\n      case 2:\n        // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with FCInvisibleMultiReader\");\n        }\n        r = new FCInvisibleMultiReader(r);\n        break;\n      case 3:\n        if (allowSlowCompositeReader) {\n          final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n          final List<String> allFields = new ArrayList<>();\n          for (FieldInfo fi : ar.getFieldInfos()) {\n            allFields.add(fi.name);\n          }\n          Collections.shuffle(allFields, random);\n          final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n          final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n          // will create no FC insanity as ParallelLeafReader has own cache key:\n          if (VERBOSE) {\n            System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeafReader(SlowCompositeReaderWapper)\");\n          }\n          r = new ParallelLeafReader(\n                                     new FieldFilterLeafReader(ar, fields, false),\n                                     new FieldFilterLeafReader(ar, fields, true)\n                                     );\n        }\n        break;\n      case 4:\n        // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with AssertingLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new AssertingLeafReader((LeafReader)r);\n        } else if (r instanceof DirectoryReader) {\n          r = new AssertingDirectoryReader((DirectoryReader)r);\n        }\n        break;\n      case 5:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with MismatchedLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new MismatchedLeafReader((LeafReader)r, random);\n        } else if (r instanceof DirectoryReader) {\n          r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n        }\n        break;\n      default:\n        fail(\"should not get here\");\n      }\n    }\n    if (wasOriginallyAtomic) {\n      if (allowSlowCompositeReader) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      }\n    } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n      // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n      r = new FCInvisibleMultiReader(r);\n    }\n    if (VERBOSE) {\n      System.out.println(\"wrapReader wrapped: \" +r);\n    }\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","adc9dc8ef0ce617b940a039fd12f79e8b098cc7f"],"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"]},"commit2Childs":{"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","adc9dc8ef0ce617b940a039fd12f79e8b098cc7f"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}