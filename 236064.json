{"path":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","commits":[{"id":"0c3e228bf650e96f3002a8fb73dd0c13d55af077","date":1138253849,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      synchronized (this) {\n        log.info(\"start \"+cmd);\n        doDeletions();\n\n        if (cmd.optimize) {\n          closeSearcher();\n          openWriter();\n          writer.optimize();\n        }\n\n        closeSearcher();\n        closeWriter();\n\n        callPostCommitCallbacks();\n\n        // open a new searcher in the sync block to avoid opening it\n        // after a deleteByQuery changed the index, or in between deletes\n        // and adds of another commit being done.\n        core.getSearcher(true,false,waitSearcher);\n\n        log.info(\"end_commit_flush\");\n      }  // end synchronized block\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91b8465fcccc31866b472215d79574deeb023eb6","date":1143840320,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      synchronized (this) {\n        log.info(\"start \"+cmd);\n        doDeletions();\n\n        if (cmd.optimize) {\n          closeSearcher();\n          openWriter();\n          writer.optimize();\n        }\n\n        closeSearcher();\n        closeWriter();\n\n        callPostCommitCallbacks();\n        if (cmd.optimize) {\n          callPostOptimizeCallbacks();\n        }\n        // open a new searcher in the sync block to avoid opening it\n        // after a deleteByQuery changed the index, or in between deletes\n        // and adds of another commit being done.\n        core.getSearcher(true,false,waitSearcher);\n\n        log.info(\"end_commit_flush\");\n      }  // end synchronized block\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","sourceOld":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      synchronized (this) {\n        log.info(\"start \"+cmd);\n        doDeletions();\n\n        if (cmd.optimize) {\n          closeSearcher();\n          openWriter();\n          writer.optimize();\n        }\n\n        closeSearcher();\n        closeWriter();\n\n        callPostCommitCallbacks();\n\n        // open a new searcher in the sync block to avoid opening it\n        // after a deleteByQuery changed the index, or in between deletes\n        // and adds of another commit being done.\n        core.getSearcher(true,false,waitSearcher);\n\n        log.info(\"end_commit_flush\");\n      }  // end synchronized block\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c065faf385411ac4ff02bdc763de7dfd8aa1c9f","date":1163033034,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    iwCommit.lock();\n    try {\n      log.info(\"start \"+cmd);\n      doDeletions();\n        \n      if (cmd.optimize) {\n        closeSearcher();\n        openWriter(); \n        writer.optimize();\n      }\n\n      closeSearcher();\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      core.getSearcher(true,false,waitSearcher);\n\n      // reset commit tracking\n      tracker.didCommit();\n\n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      iwCommit.unlock();\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","sourceOld":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      synchronized (this) {\n        log.info(\"start \"+cmd);\n        doDeletions();\n\n        if (cmd.optimize) {\n          closeSearcher();\n          openWriter();\n          writer.optimize();\n        }\n\n        closeSearcher();\n        closeWriter();\n\n        callPostCommitCallbacks();\n        if (cmd.optimize) {\n          callPostOptimizeCallbacks();\n        }\n        // open a new searcher in the sync block to avoid opening it\n        // after a deleteByQuery changed the index, or in between deletes\n        // and adds of another commit being done.\n        core.getSearcher(true,false,waitSearcher);\n\n        log.info(\"end_commit_flush\");\n      }  // end synchronized block\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"978a45c0ae33fbcb8e6e9a632cacf0e030fd9aae","date":1210454197,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    iwCommit.lock();\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        closeSearcher();\n        openWriter(); \n        writer.optimize();\n      }\n\n      closeSearcher();\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      core.getSearcher(true,false,waitSearcher);\n\n      // reset commit tracking\n      tracker.didCommit();\n\n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      iwCommit.unlock();\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","sourceOld":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    iwCommit.lock();\n    try {\n      log.info(\"start \"+cmd);\n      doDeletions();\n        \n      if (cmd.optimize) {\n        closeSearcher();\n        openWriter(); \n        writer.optimize();\n      }\n\n      closeSearcher();\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      core.getSearcher(true,false,waitSearcher);\n\n      // reset commit tracking\n      tracker.didCommit();\n\n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      iwCommit.unlock();\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61af939f4c10286fd8beaa0124064437b7ac44c5","date":1214514846,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    iwCommit.lock();\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        closeSearcher();\n        openWriter();\n        writer.optimize(cmd.maxOptimizeSegments);\n      }\n\n      closeSearcher();\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      core.getSearcher(true,false,waitSearcher);\n\n      // reset commit tracking\n      tracker.didCommit();\n\n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      iwCommit.unlock();\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    iwCommit.lock();\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        closeSearcher();\n        openWriter(); \n        writer.optimize();\n      }\n\n      closeSearcher();\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      core.getSearcher(true,false,waitSearcher);\n\n      // reset commit tracking\n      tracker.didCommit();\n\n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      iwCommit.unlock();\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd0695d017a09d8819e247ede79b526a0a3bd15f","date":1222958604,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    iwCommit.lock();\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        openWriter();\n        writer.optimize(cmd.maxOptimizeSegments);\n      }\n\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      core.getSearcher(true,false,waitSearcher);\n\n      // reset commit tracking\n      tracker.didCommit();\n\n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      iwCommit.unlock();\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    iwCommit.lock();\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        closeSearcher();\n        openWriter();\n        writer.optimize(cmd.maxOptimizeSegments);\n      }\n\n      closeSearcher();\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      core.getSearcher(true,false,waitSearcher);\n\n      // reset commit tracking\n      tracker.didCommit();\n\n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      iwCommit.unlock();\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"366ee8589b0d5578d8944e35470687383abbcd94","date":1250684482,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else if (cmd.expungeDeletes) {\n      expungeDeleteCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    iwCommit.lock();\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        openWriter();\n        writer.optimize(cmd.maxOptimizeSegments);\n      }\n\n      closeWriter();\n      if (!cmd.optimize && cmd.expungeDeletes) {\n        openWriter();\n        writer.expungeDeletes();\n      }\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      core.getSearcher(true,false,waitSearcher);\n\n      // reset commit tracking\n      tracker.didCommit();\n\n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      iwCommit.unlock();\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    iwCommit.lock();\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        openWriter();\n        writer.optimize(cmd.maxOptimizeSegments);\n      }\n\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      core.getSearcher(true,false,waitSearcher);\n\n      // reset commit tracking\n      tracker.didCommit();\n\n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      iwCommit.unlock();\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b1efa08e6470e7956bb0836569628d918bd0b54","date":1250701925,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else if (cmd.expungeDeletes) {\n      expungeDeleteCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    iwCommit.lock();\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        openWriter();\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        openWriter();\n        writer.expungeDeletes();\n      }\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      core.getSearcher(true,false,waitSearcher);\n\n      // reset commit tracking\n      tracker.didCommit();\n\n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      iwCommit.unlock();\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else if (cmd.expungeDeletes) {\n      expungeDeleteCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    iwCommit.lock();\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        openWriter();\n        writer.optimize(cmd.maxOptimizeSegments);\n      }\n\n      closeWriter();\n      if (!cmd.optimize && cmd.expungeDeletes) {\n        openWriter();\n        writer.expungeDeletes();\n      }\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      core.getSearcher(true,false,waitSearcher);\n\n      // reset commit tracking\n      tracker.didCommit();\n\n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      iwCommit.unlock();\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c6a5fdcd3c20a225ad7c19c27af07f7ac7e409b","date":1250703232,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    iwCommit.lock();\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        openWriter();\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        openWriter();\n        writer.expungeDeletes();\n      }\n      \n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      core.getSearcher(true,false,waitSearcher);\n\n      // reset commit tracking\n      tracker.didCommit();\n\n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      iwCommit.unlock();\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else if (cmd.expungeDeletes) {\n      expungeDeleteCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    iwCommit.lock();\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        openWriter();\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        openWriter();\n        writer.expungeDeletes();\n      }\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      core.getSearcher(true,false,waitSearcher);\n\n      // reset commit tracking\n      tracker.didCommit();\n\n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      iwCommit.unlock();\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    iwCommit.lock();\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        openWriter();\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        openWriter();\n        writer.expungeDeletes();\n      }\n      \n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      core.getSearcher(true,false,waitSearcher);\n\n      // reset commit tracking\n      tracker.didCommit();\n\n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      iwCommit.unlock();\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    iwCommit.lock();\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        openWriter();\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        openWriter();\n        writer.expungeDeletes();\n      }\n      \n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      core.getSearcher(true,false,waitSearcher);\n\n      // reset commit tracking\n      tracker.didCommit();\n\n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      iwCommit.unlock();\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"91b8465fcccc31866b472215d79574deeb023eb6":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"4c065faf385411ac4ff02bdc763de7dfd8aa1c9f":["91b8465fcccc31866b472215d79574deeb023eb6"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"978a45c0ae33fbcb8e6e9a632cacf0e030fd9aae":["4c065faf385411ac4ff02bdc763de7dfd8aa1c9f"],"bd0695d017a09d8819e247ede79b526a0a3bd15f":["61af939f4c10286fd8beaa0124064437b7ac44c5"],"61af939f4c10286fd8beaa0124064437b7ac44c5":["978a45c0ae33fbcb8e6e9a632cacf0e030fd9aae"],"366ee8589b0d5578d8944e35470687383abbcd94":["bd0695d017a09d8819e247ede79b526a0a3bd15f"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5c6a5fdcd3c20a225ad7c19c27af07f7ac7e409b":["3b1efa08e6470e7956bb0836569628d918bd0b54"],"ad94625fb8d088209f46650c8097196fec67f00c":["5c6a5fdcd3c20a225ad7c19c27af07f7ac7e409b"],"3b1efa08e6470e7956bb0836569628d918bd0b54":["366ee8589b0d5578d8944e35470687383abbcd94"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"91b8465fcccc31866b472215d79574deeb023eb6":["4c065faf385411ac4ff02bdc763de7dfd8aa1c9f"],"4c065faf385411ac4ff02bdc763de7dfd8aa1c9f":["978a45c0ae33fbcb8e6e9a632cacf0e030fd9aae"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"978a45c0ae33fbcb8e6e9a632cacf0e030fd9aae":["61af939f4c10286fd8beaa0124064437b7ac44c5"],"bd0695d017a09d8819e247ede79b526a0a3bd15f":["366ee8589b0d5578d8944e35470687383abbcd94"],"61af939f4c10286fd8beaa0124064437b7ac44c5":["bd0695d017a09d8819e247ede79b526a0a3bd15f"],"366ee8589b0d5578d8944e35470687383abbcd94":["3b1efa08e6470e7956bb0836569628d918bd0b54"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["91b8465fcccc31866b472215d79574deeb023eb6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5c6a5fdcd3c20a225ad7c19c27af07f7ac7e409b":["ad94625fb8d088209f46650c8097196fec67f00c"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"3b1efa08e6470e7956bb0836569628d918bd0b54":["5c6a5fdcd3c20a225ad7c19c27af07f7ac7e409b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}