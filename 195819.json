{"path":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#getSplits(Collection[RangeCount],DocRouter.Range).mjava","commits":[{"id":"a05f3f5161c62339ec5560b8f6958f3df8483618","date":1563550501,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#getSplits(Collection[RangeCount],DocRouter.Range).mjava","pathOld":"/dev/null","sourceNew":"  // returns the list of recommended splits, or null if there is not enough information\n  static Collection<DocRouter.Range> getSplits(Collection<RangeCount> rawCounts, DocRouter.Range currentRange) throws Exception {\n\n    int totalCount = 0;\n    RangeCount biggest = null; // keep track of the largest in case we need to split it out into it's own shard\n    RangeCount last = null;  // keep track of what the last range is\n\n    // Remove counts that don't overlap with currentRange (can happen if someone overrode document routing)\n    List<RangeCount> counts = new ArrayList<>(rawCounts.size());\n    for (RangeCount rangeCount : rawCounts) {\n      if (!rangeCount.range.overlaps(currentRange)) {\n        continue;\n      }\n      totalCount += rangeCount.count;\n      if (biggest == null || rangeCount.count > biggest.count) {\n        biggest = rangeCount;\n      }\n      counts.add(rangeCount);\n      last = rangeCount;\n    }\n\n    if (counts.size() == 0) {\n      // we don't have any data to go off of, so do the split the normal way\n      return null;\n    }\n\n\n    List<DocRouter.Range> targetRanges = new ArrayList<>();\n\n    if (counts.size() == 1) {\n      // We have a single range, so we should split it.\n\n      // It may already be a partial range, so figure that out\n      int lower = Math.max(last.range.min, currentRange.min);\n      int upper = Math.min(last.range.max, currentRange.max);\n      int mid = lower + (upper-lower)/2;\n      if (mid == lower || mid == upper) {\n        // shard too small... this should pretty much never happen, but use default split logic if it does.\n        return null;\n      }\n\n      // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n      DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, mid);\n      DocRouter.Range upperRange = new DocRouter.Range(mid+1, currentRange.max);\n      targetRanges.add(lowerRange);\n      targetRanges.add(upperRange);\n\n      return targetRanges;\n    }\n\n    // We have at least two ranges, so we want to partition the ranges\n    // and avoid splitting any individual range.\n\n    int targetCount = totalCount / 2;\n    RangeCount middle = null;\n    RangeCount prev = null;\n    int currCount = 0;\n    for (RangeCount rangeCount : counts) {\n      currCount += rangeCount.count;\n      if (currCount >= targetCount) {  // this should at least be true on the last range\n        middle = rangeCount;\n        break;\n      }\n      prev = rangeCount;\n    }\n\n    // check if using the range before the middle one would make a better split point\n    int overError = currCount - targetCount;  // error if we include middle in first split\n    int underError = targetCount - (currCount - middle.count); // error if we include middle in second split\n    if (underError < overError) {\n      middle = prev;\n    }\n\n    // if the middle range turned out to be the last one, pick the one before it instead\n    if (middle == last) {\n      middle = prev;\n    }\n\n    // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n    DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, middle.range.max);\n    DocRouter.Range upperRange = new DocRouter.Range(middle.range.max+1, currentRange.max);\n    targetRanges.add(lowerRange);\n    targetRanges.add(upperRange);\n\n    return targetRanges;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff2097f3a1298209d513f906d65f86bc0ab8d9c0","date":1564851155,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#getSplits(Collection[RangeCount],DocRouter.Range).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#getSplits(Collection[RangeCount],DocRouter.Range).mjava","sourceNew":"  // returns the list of recommended splits, or null if there is not enough information\n  static Collection<DocRouter.Range> getSplits(Collection<RangeCount> rawCounts, DocRouter.Range currentRange) throws Exception {\n    int totalCount = 0;\n    RangeCount biggest = null; // keep track of the largest in case we need to split it out into it's own shard\n    RangeCount last = null;  // keep track of what the last range is\n\n    // Remove counts that don't overlap with currentRange (can happen if someone overrode document routing)\n    List<RangeCount> counts = new ArrayList<>(rawCounts.size());\n    for (RangeCount rangeCount : rawCounts) {\n      if (!rangeCount.range.overlaps(currentRange)) {\n        continue;\n      }\n      totalCount += rangeCount.count;\n      if (biggest == null || rangeCount.count > biggest.count) {\n        biggest = rangeCount;\n      }\n      counts.add(rangeCount);\n      last = rangeCount;\n    }\n\n    if (counts.size() == 0) {\n      // we don't have any data to go off of, so do the split the normal way\n      return null;\n    }\n\n\n    List<DocRouter.Range> targetRanges = new ArrayList<>();\n\n    if (counts.size() == 1) {\n      // We have a single range, so we should split it.\n\n      // It may already be a partial range, so figure that out\n      int lower = Math.max(last.range.min, currentRange.min);\n      int upper = Math.min(last.range.max, currentRange.max);\n      int mid = lower + (upper-lower)/2;\n      if (mid == lower || mid == upper) {\n        // shard too small... this should pretty much never happen, but use default split logic if it does.\n        return null;\n      }\n\n      // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n      DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, mid);\n      DocRouter.Range upperRange = new DocRouter.Range(mid+1, currentRange.max);\n      targetRanges.add(lowerRange);\n      targetRanges.add(upperRange);\n\n      return targetRanges;\n    }\n\n    // We have at least two ranges, so we want to partition the ranges\n    // and avoid splitting any individual range.\n\n    int targetCount = totalCount / 2;\n    RangeCount middle = null;\n    RangeCount prev = null;\n    int currCount = 0;\n    for (RangeCount rangeCount : counts) {\n      currCount += rangeCount.count;\n      if (currCount >= targetCount) {  // this should at least be true on the last range\n        middle = rangeCount;\n        break;\n      }\n      prev = rangeCount;\n    }\n\n    // check if using the range before the middle one would make a better split point\n    int overError = currCount - targetCount;  // error if we include middle in first split\n    int underError = targetCount - (currCount - middle.count); // error if we include middle in second split\n    if (underError < overError) {\n      middle = prev;\n    }\n\n    // if the middle range turned out to be the last one, pick the one before it instead\n    if (middle == last) {\n      middle = prev;\n    }\n\n    // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n    DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, middle.range.max);\n    DocRouter.Range upperRange = new DocRouter.Range(middle.range.max+1, currentRange.max);\n    targetRanges.add(lowerRange);\n    targetRanges.add(upperRange);\n\n    return targetRanges;\n  }\n\n","sourceOld":"  // returns the list of recommended splits, or null if there is not enough information\n  static Collection<DocRouter.Range> getSplits(Collection<RangeCount> rawCounts, DocRouter.Range currentRange) throws Exception {\n\n    int totalCount = 0;\n    RangeCount biggest = null; // keep track of the largest in case we need to split it out into it's own shard\n    RangeCount last = null;  // keep track of what the last range is\n\n    // Remove counts that don't overlap with currentRange (can happen if someone overrode document routing)\n    List<RangeCount> counts = new ArrayList<>(rawCounts.size());\n    for (RangeCount rangeCount : rawCounts) {\n      if (!rangeCount.range.overlaps(currentRange)) {\n        continue;\n      }\n      totalCount += rangeCount.count;\n      if (biggest == null || rangeCount.count > biggest.count) {\n        biggest = rangeCount;\n      }\n      counts.add(rangeCount);\n      last = rangeCount;\n    }\n\n    if (counts.size() == 0) {\n      // we don't have any data to go off of, so do the split the normal way\n      return null;\n    }\n\n\n    List<DocRouter.Range> targetRanges = new ArrayList<>();\n\n    if (counts.size() == 1) {\n      // We have a single range, so we should split it.\n\n      // It may already be a partial range, so figure that out\n      int lower = Math.max(last.range.min, currentRange.min);\n      int upper = Math.min(last.range.max, currentRange.max);\n      int mid = lower + (upper-lower)/2;\n      if (mid == lower || mid == upper) {\n        // shard too small... this should pretty much never happen, but use default split logic if it does.\n        return null;\n      }\n\n      // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n      DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, mid);\n      DocRouter.Range upperRange = new DocRouter.Range(mid+1, currentRange.max);\n      targetRanges.add(lowerRange);\n      targetRanges.add(upperRange);\n\n      return targetRanges;\n    }\n\n    // We have at least two ranges, so we want to partition the ranges\n    // and avoid splitting any individual range.\n\n    int targetCount = totalCount / 2;\n    RangeCount middle = null;\n    RangeCount prev = null;\n    int currCount = 0;\n    for (RangeCount rangeCount : counts) {\n      currCount += rangeCount.count;\n      if (currCount >= targetCount) {  // this should at least be true on the last range\n        middle = rangeCount;\n        break;\n      }\n      prev = rangeCount;\n    }\n\n    // check if using the range before the middle one would make a better split point\n    int overError = currCount - targetCount;  // error if we include middle in first split\n    int underError = targetCount - (currCount - middle.count); // error if we include middle in second split\n    if (underError < overError) {\n      middle = prev;\n    }\n\n    // if the middle range turned out to be the last one, pick the one before it instead\n    if (middle == last) {\n      middle = prev;\n    }\n\n    // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n    DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, middle.range.max);\n    DocRouter.Range upperRange = new DocRouter.Range(middle.range.max+1, currentRange.max);\n    targetRanges.add(lowerRange);\n    targetRanges.add(upperRange);\n\n    return targetRanges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#getSplits(Collection[RangeCount],DocRouter.Range).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#getSplits(Collection[RangeCount],DocRouter.Range).mjava","sourceNew":"  // returns the list of recommended splits, or null if there is not enough information\n  static Collection<DocRouter.Range> getSplits(Collection<RangeCount> rawCounts, DocRouter.Range currentRange) throws Exception {\n    int totalCount = 0;\n    RangeCount biggest = null; // keep track of the largest in case we need to split it out into it's own shard\n    RangeCount last = null;  // keep track of what the last range is\n\n    // Remove counts that don't overlap with currentRange (can happen if someone overrode document routing)\n    List<RangeCount> counts = new ArrayList<>(rawCounts.size());\n    for (RangeCount rangeCount : rawCounts) {\n      if (!rangeCount.range.overlaps(currentRange)) {\n        continue;\n      }\n      totalCount += rangeCount.count;\n      if (biggest == null || rangeCount.count > biggest.count) {\n        biggest = rangeCount;\n      }\n      counts.add(rangeCount);\n      last = rangeCount;\n    }\n\n    if (counts.size() == 0) {\n      // we don't have any data to go off of, so do the split the normal way\n      return null;\n    }\n\n\n    List<DocRouter.Range> targetRanges = new ArrayList<>();\n\n    if (counts.size() == 1) {\n      // We have a single range, so we should split it.\n\n      // It may already be a partial range, so figure that out\n      int lower = Math.max(last.range.min, currentRange.min);\n      int upper = Math.min(last.range.max, currentRange.max);\n      int mid = lower + (upper-lower)/2;\n      if (mid == lower || mid == upper) {\n        // shard too small... this should pretty much never happen, but use default split logic if it does.\n        return null;\n      }\n\n      // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n      DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, mid);\n      DocRouter.Range upperRange = new DocRouter.Range(mid+1, currentRange.max);\n      targetRanges.add(lowerRange);\n      targetRanges.add(upperRange);\n\n      return targetRanges;\n    }\n\n    // We have at least two ranges, so we want to partition the ranges\n    // and avoid splitting any individual range.\n\n    int targetCount = totalCount / 2;\n    RangeCount middle = null;\n    RangeCount prev = null;\n    int currCount = 0;\n    for (RangeCount rangeCount : counts) {\n      currCount += rangeCount.count;\n      if (currCount >= targetCount) {  // this should at least be true on the last range\n        middle = rangeCount;\n        break;\n      }\n      prev = rangeCount;\n    }\n\n    // check if using the range before the middle one would make a better split point\n    int overError = currCount - targetCount;  // error if we include middle in first split\n    int underError = targetCount - (currCount - middle.count); // error if we include middle in second split\n    if (underError < overError) {\n      middle = prev;\n    }\n\n    // if the middle range turned out to be the last one, pick the one before it instead\n    if (middle == last) {\n      middle = prev;\n    }\n\n    // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n    DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, middle.range.max);\n    DocRouter.Range upperRange = new DocRouter.Range(middle.range.max+1, currentRange.max);\n    targetRanges.add(lowerRange);\n    targetRanges.add(upperRange);\n\n    return targetRanges;\n  }\n\n","sourceOld":"  // returns the list of recommended splits, or null if there is not enough information\n  static Collection<DocRouter.Range> getSplits(Collection<RangeCount> rawCounts, DocRouter.Range currentRange) throws Exception {\n\n    int totalCount = 0;\n    RangeCount biggest = null; // keep track of the largest in case we need to split it out into it's own shard\n    RangeCount last = null;  // keep track of what the last range is\n\n    // Remove counts that don't overlap with currentRange (can happen if someone overrode document routing)\n    List<RangeCount> counts = new ArrayList<>(rawCounts.size());\n    for (RangeCount rangeCount : rawCounts) {\n      if (!rangeCount.range.overlaps(currentRange)) {\n        continue;\n      }\n      totalCount += rangeCount.count;\n      if (biggest == null || rangeCount.count > biggest.count) {\n        biggest = rangeCount;\n      }\n      counts.add(rangeCount);\n      last = rangeCount;\n    }\n\n    if (counts.size() == 0) {\n      // we don't have any data to go off of, so do the split the normal way\n      return null;\n    }\n\n\n    List<DocRouter.Range> targetRanges = new ArrayList<>();\n\n    if (counts.size() == 1) {\n      // We have a single range, so we should split it.\n\n      // It may already be a partial range, so figure that out\n      int lower = Math.max(last.range.min, currentRange.min);\n      int upper = Math.min(last.range.max, currentRange.max);\n      int mid = lower + (upper-lower)/2;\n      if (mid == lower || mid == upper) {\n        // shard too small... this should pretty much never happen, but use default split logic if it does.\n        return null;\n      }\n\n      // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n      DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, mid);\n      DocRouter.Range upperRange = new DocRouter.Range(mid+1, currentRange.max);\n      targetRanges.add(lowerRange);\n      targetRanges.add(upperRange);\n\n      return targetRanges;\n    }\n\n    // We have at least two ranges, so we want to partition the ranges\n    // and avoid splitting any individual range.\n\n    int targetCount = totalCount / 2;\n    RangeCount middle = null;\n    RangeCount prev = null;\n    int currCount = 0;\n    for (RangeCount rangeCount : counts) {\n      currCount += rangeCount.count;\n      if (currCount >= targetCount) {  // this should at least be true on the last range\n        middle = rangeCount;\n        break;\n      }\n      prev = rangeCount;\n    }\n\n    // check if using the range before the middle one would make a better split point\n    int overError = currCount - targetCount;  // error if we include middle in first split\n    int underError = targetCount - (currCount - middle.count); // error if we include middle in second split\n    if (underError < overError) {\n      middle = prev;\n    }\n\n    // if the middle range turned out to be the last one, pick the one before it instead\n    if (middle == last) {\n      middle = prev;\n    }\n\n    // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n    DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, middle.range.max);\n    DocRouter.Range upperRange = new DocRouter.Range(middle.range.max+1, currentRange.max);\n    targetRanges.add(lowerRange);\n    targetRanges.add(upperRange);\n\n    return targetRanges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","date":1565097295,"type":3,"author":"Jan Høydahl","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#getSplits(Collection[RangeCount],DocRouter.Range).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#getSplits(Collection[RangeCount],DocRouter.Range).mjava","sourceNew":"  // returns the list of recommended splits, or null if there is not enough information\n  static Collection<DocRouter.Range> getSplits(Collection<RangeCount> rawCounts, DocRouter.Range currentRange) throws Exception {\n    int totalCount = 0;\n    RangeCount biggest = null; // keep track of the largest in case we need to split it out into it's own shard\n    RangeCount last = null;  // keep track of what the last range is\n\n    // Remove counts that don't overlap with currentRange (can happen if someone overrode document routing)\n    List<RangeCount> counts = new ArrayList<>(rawCounts.size());\n    for (RangeCount rangeCount : rawCounts) {\n      if (!rangeCount.range.overlaps(currentRange)) {\n        continue;\n      }\n      totalCount += rangeCount.count;\n      if (biggest == null || rangeCount.count > biggest.count) {\n        biggest = rangeCount;\n      }\n      counts.add(rangeCount);\n      last = rangeCount;\n    }\n\n    if (counts.size() == 0) {\n      // we don't have any data to go off of, so do the split the normal way\n      return null;\n    }\n\n\n    List<DocRouter.Range> targetRanges = new ArrayList<>();\n\n    if (counts.size() == 1) {\n      // We have a single range, so we should split it.\n\n      // It may already be a partial range, so figure that out\n      int lower = Math.max(last.range.min, currentRange.min);\n      int upper = Math.min(last.range.max, currentRange.max);\n      int mid = lower + (upper-lower)/2;\n      if (mid == lower || mid == upper) {\n        // shard too small... this should pretty much never happen, but use default split logic if it does.\n        return null;\n      }\n\n      // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n      DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, mid);\n      DocRouter.Range upperRange = new DocRouter.Range(mid+1, currentRange.max);\n      targetRanges.add(lowerRange);\n      targetRanges.add(upperRange);\n\n      return targetRanges;\n    }\n\n    // We have at least two ranges, so we want to partition the ranges\n    // and avoid splitting any individual range.\n\n    int targetCount = totalCount / 2;\n    RangeCount middle = null;\n    RangeCount prev = null;\n    int currCount = 0;\n    for (RangeCount rangeCount : counts) {\n      currCount += rangeCount.count;\n      if (currCount >= targetCount) {  // this should at least be true on the last range\n        middle = rangeCount;\n        break;\n      }\n      prev = rangeCount;\n    }\n\n    // check if using the range before the middle one would make a better split point\n    int overError = currCount - targetCount;  // error if we include middle in first split\n    int underError = targetCount - (currCount - middle.count); // error if we include middle in second split\n    if (underError < overError) {\n      middle = prev;\n    }\n\n    // if the middle range turned out to be the last one, pick the one before it instead\n    if (middle == last) {\n      middle = prev;\n    }\n\n    // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n    DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, middle.range.max);\n    DocRouter.Range upperRange = new DocRouter.Range(middle.range.max+1, currentRange.max);\n    targetRanges.add(lowerRange);\n    targetRanges.add(upperRange);\n\n    return targetRanges;\n  }\n\n","sourceOld":"  // returns the list of recommended splits, or null if there is not enough information\n  static Collection<DocRouter.Range> getSplits(Collection<RangeCount> rawCounts, DocRouter.Range currentRange) throws Exception {\n\n    int totalCount = 0;\n    RangeCount biggest = null; // keep track of the largest in case we need to split it out into it's own shard\n    RangeCount last = null;  // keep track of what the last range is\n\n    // Remove counts that don't overlap with currentRange (can happen if someone overrode document routing)\n    List<RangeCount> counts = new ArrayList<>(rawCounts.size());\n    for (RangeCount rangeCount : rawCounts) {\n      if (!rangeCount.range.overlaps(currentRange)) {\n        continue;\n      }\n      totalCount += rangeCount.count;\n      if (biggest == null || rangeCount.count > biggest.count) {\n        biggest = rangeCount;\n      }\n      counts.add(rangeCount);\n      last = rangeCount;\n    }\n\n    if (counts.size() == 0) {\n      // we don't have any data to go off of, so do the split the normal way\n      return null;\n    }\n\n\n    List<DocRouter.Range> targetRanges = new ArrayList<>();\n\n    if (counts.size() == 1) {\n      // We have a single range, so we should split it.\n\n      // It may already be a partial range, so figure that out\n      int lower = Math.max(last.range.min, currentRange.min);\n      int upper = Math.min(last.range.max, currentRange.max);\n      int mid = lower + (upper-lower)/2;\n      if (mid == lower || mid == upper) {\n        // shard too small... this should pretty much never happen, but use default split logic if it does.\n        return null;\n      }\n\n      // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n      DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, mid);\n      DocRouter.Range upperRange = new DocRouter.Range(mid+1, currentRange.max);\n      targetRanges.add(lowerRange);\n      targetRanges.add(upperRange);\n\n      return targetRanges;\n    }\n\n    // We have at least two ranges, so we want to partition the ranges\n    // and avoid splitting any individual range.\n\n    int targetCount = totalCount / 2;\n    RangeCount middle = null;\n    RangeCount prev = null;\n    int currCount = 0;\n    for (RangeCount rangeCount : counts) {\n      currCount += rangeCount.count;\n      if (currCount >= targetCount) {  // this should at least be true on the last range\n        middle = rangeCount;\n        break;\n      }\n      prev = rangeCount;\n    }\n\n    // check if using the range before the middle one would make a better split point\n    int overError = currCount - targetCount;  // error if we include middle in first split\n    int underError = targetCount - (currCount - middle.count); // error if we include middle in second split\n    if (underError < overError) {\n      middle = prev;\n    }\n\n    // if the middle range turned out to be the last one, pick the one before it instead\n    if (middle == last) {\n      middle = prev;\n    }\n\n    // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n    DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, middle.range.max);\n    DocRouter.Range upperRange = new DocRouter.Range(middle.range.max+1, currentRange.max);\n    targetRanges.add(lowerRange);\n    targetRanges.add(upperRange);\n\n    return targetRanges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36bdabc04743acfe0e82c9cf8208b1111b2b193a","date":1565115020,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#getSplits(Collection[RangeCount],DocRouter.Range).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#getSplits(Collection[RangeCount],DocRouter.Range).mjava","sourceNew":"  /*\n   * Returns the list of recommended splits, or null if there is not enough information\n   */\n  static Collection<DocRouter.Range> getSplits(Collection<RangeCount> rawCounts, DocRouter.Range currentRange) throws Exception {\n    int totalCount = 0;\n    RangeCount biggest = null; // keep track of the largest in case we need to split it out into it's own shard\n    RangeCount last = null;  // keep track of what the last range is\n\n    // Remove counts that don't overlap with currentRange (can happen if someone overrode document routing)\n    List<RangeCount> counts = new ArrayList<>(rawCounts.size());\n    for (RangeCount rangeCount : rawCounts) {\n      if (!rangeCount.range.overlaps(currentRange)) {\n        continue;\n      }\n      totalCount += rangeCount.count;\n      if (biggest == null || rangeCount.count > biggest.count) {\n        biggest = rangeCount;\n      }\n      counts.add(rangeCount);\n      last = rangeCount;\n    }\n\n    if (counts.size() == 0) {\n      // we don't have any data to go off of, so do the split the normal way\n      return null;\n    }\n\n\n    List<DocRouter.Range> targetRanges = new ArrayList<>();\n\n    if (counts.size() == 1) {\n      // We have a single range, so we should split it.\n      // Currently, we only split a prefix/bucket when we have just one, but this could be changed/controlled\n      // in the future via a allowedSizeDifference parameter (i.e. if just separating prefix buckets results in\n      // too large of an imbalanced, allow splitting within a prefix)\n\n      // It may already be a partial range, so figure that out\n      int lower = Math.max(last.range.min, currentRange.min);\n      int upper = Math.min(last.range.max, currentRange.max);\n      int mid = lower + (upper-lower)/2;\n      if (mid == lower || mid == upper) {\n        // shard too small... this should pretty much never happen, but use default split logic if it does.\n        return null;\n      }\n\n      // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n      DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, mid);\n      DocRouter.Range upperRange = new DocRouter.Range(mid+1, currentRange.max);\n      targetRanges.add(lowerRange);\n      targetRanges.add(upperRange);\n\n      return targetRanges;\n    }\n\n    // We have at least two ranges, so we want to partition the ranges\n    // and avoid splitting any individual range.\n    // The \"middle\" bucket we are going to find will be included with the lower range and excluded from the upper range.\n\n    int targetCount = totalCount / 2;\n    RangeCount middle = null;\n    RangeCount prev = null;\n    int currCount = 0;\n    for (RangeCount rangeCount : counts) {\n      currCount += rangeCount.count;\n      if (currCount >= targetCount) {  // this should at least be true on the last range\n        middle = rangeCount;\n        break;\n      }\n      prev = rangeCount;\n    }\n\n    // check if using the range before the middle one would make a better split point\n    int overError = currCount - targetCount;  // error if we include middle in first split\n    int underError = targetCount - (currCount - middle.count); // error if we include middle in second split\n    if (underError < overError) {\n      middle = prev;\n    }\n\n    // The middle should never be the last, since that means that we won't actually do a split.\n    // Minimising the error (above) should already ensure this never happens.\n    assert middle != last;\n\n\n    // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n    DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, middle.range.max);\n    DocRouter.Range upperRange = new DocRouter.Range(middle.range.max+1, currentRange.max);\n    targetRanges.add(lowerRange);\n    targetRanges.add(upperRange);\n\n    return targetRanges;\n  }\n\n","sourceOld":"  // returns the list of recommended splits, or null if there is not enough information\n  static Collection<DocRouter.Range> getSplits(Collection<RangeCount> rawCounts, DocRouter.Range currentRange) throws Exception {\n    int totalCount = 0;\n    RangeCount biggest = null; // keep track of the largest in case we need to split it out into it's own shard\n    RangeCount last = null;  // keep track of what the last range is\n\n    // Remove counts that don't overlap with currentRange (can happen if someone overrode document routing)\n    List<RangeCount> counts = new ArrayList<>(rawCounts.size());\n    for (RangeCount rangeCount : rawCounts) {\n      if (!rangeCount.range.overlaps(currentRange)) {\n        continue;\n      }\n      totalCount += rangeCount.count;\n      if (biggest == null || rangeCount.count > biggest.count) {\n        biggest = rangeCount;\n      }\n      counts.add(rangeCount);\n      last = rangeCount;\n    }\n\n    if (counts.size() == 0) {\n      // we don't have any data to go off of, so do the split the normal way\n      return null;\n    }\n\n\n    List<DocRouter.Range> targetRanges = new ArrayList<>();\n\n    if (counts.size() == 1) {\n      // We have a single range, so we should split it.\n\n      // It may already be a partial range, so figure that out\n      int lower = Math.max(last.range.min, currentRange.min);\n      int upper = Math.min(last.range.max, currentRange.max);\n      int mid = lower + (upper-lower)/2;\n      if (mid == lower || mid == upper) {\n        // shard too small... this should pretty much never happen, but use default split logic if it does.\n        return null;\n      }\n\n      // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n      DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, mid);\n      DocRouter.Range upperRange = new DocRouter.Range(mid+1, currentRange.max);\n      targetRanges.add(lowerRange);\n      targetRanges.add(upperRange);\n\n      return targetRanges;\n    }\n\n    // We have at least two ranges, so we want to partition the ranges\n    // and avoid splitting any individual range.\n\n    int targetCount = totalCount / 2;\n    RangeCount middle = null;\n    RangeCount prev = null;\n    int currCount = 0;\n    for (RangeCount rangeCount : counts) {\n      currCount += rangeCount.count;\n      if (currCount >= targetCount) {  // this should at least be true on the last range\n        middle = rangeCount;\n        break;\n      }\n      prev = rangeCount;\n    }\n\n    // check if using the range before the middle one would make a better split point\n    int overError = currCount - targetCount;  // error if we include middle in first split\n    int underError = targetCount - (currCount - middle.count); // error if we include middle in second split\n    if (underError < overError) {\n      middle = prev;\n    }\n\n    // if the middle range turned out to be the last one, pick the one before it instead\n    if (middle == last) {\n      middle = prev;\n    }\n\n    // Make sure to include the shard's current range in the new ranges so we don't create useless empty shards.\n    DocRouter.Range lowerRange = new DocRouter.Range(currentRange.min, middle.range.max);\n    DocRouter.Range upperRange = new DocRouter.Range(middle.range.max+1, currentRange.max);\n    targetRanges.add(lowerRange);\n    targetRanges.add(upperRange);\n\n    return targetRanges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ff2097f3a1298209d513f906d65f86bc0ab8d9c0":["a05f3f5161c62339ec5560b8f6958f3df8483618"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a05f3f5161c62339ec5560b8f6958f3df8483618":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":["a05f3f5161c62339ec5560b8f6958f3df8483618","ff2097f3a1298209d513f906d65f86bc0ab8d9c0"],"36bdabc04743acfe0e82c9cf8208b1111b2b193a":["ff2097f3a1298209d513f906d65f86bc0ab8d9c0"],"f8061ddd97f3352007d927dae445884a6f3d857b":["a05f3f5161c62339ec5560b8f6958f3df8483618","ff2097f3a1298209d513f906d65f86bc0ab8d9c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["36bdabc04743acfe0e82c9cf8208b1111b2b193a"]},"commit2Childs":{"ff2097f3a1298209d513f906d65f86bc0ab8d9c0":["d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","36bdabc04743acfe0e82c9cf8208b1111b2b193a","f8061ddd97f3352007d927dae445884a6f3d857b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a05f3f5161c62339ec5560b8f6958f3df8483618"],"a05f3f5161c62339ec5560b8f6958f3df8483618":["ff2097f3a1298209d513f906d65f86bc0ab8d9c0","d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","f8061ddd97f3352007d927dae445884a6f3d857b"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":[],"36bdabc04743acfe0e82c9cf8208b1111b2b193a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}