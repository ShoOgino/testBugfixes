{"path":"lucene/suggest/src/test/org/apache/lucene/search/spell/TestWordBreakSpellChecker#testRandom().mjava","commits":[{"id":"efb805b23fcd6a1644c8bb2f14edb45b1afd97a0","date":1354906497,"type":0,"author":"James Dyer","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/spell/TestWordBreakSpellChecker#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws Exception {\n    int numDocs = _TestUtil.nextInt(random(), (10 * RANDOM_MULTIPLIER),\n        (100 * RANDOM_MULTIPLIER));\n    Directory dir = null;\n    RandomIndexWriter writer = null;\n    IndexReader ir = null;\n    try {\n      dir = newDirectory();\n      writer = new RandomIndexWriter(random(), dir, new MockAnalyzer(random(),\n          MockTokenizer.WHITESPACE, false));\n      int maxLength = _TestUtil.nextInt(random(), 5, 50);\n      List<String> originals = new ArrayList<String>(numDocs);\n      List<String[]> breaks = new ArrayList<String[]>(numDocs);\n      for (int i = 0; i < numDocs; i++) {\n        String orig = \"\";\n        if (random().nextBoolean()) {\n          while (!goodTestString(orig)) {\n            orig = _TestUtil.randomSimpleString(random(), maxLength);\n          }\n        } else {\n          while (!goodTestString(orig)) {\n            orig = _TestUtil.randomUnicodeString(random(), maxLength);\n          }\n        }\n        originals.add(orig);\n        int totalLength = orig.codePointCount(0, orig.length());\n        int breakAt = orig.offsetByCodePoints(0,\n            _TestUtil.nextInt(random(), 1, totalLength - 1));\n        String[] broken = new String[2];\n        broken[0] = orig.substring(0, breakAt);\n        broken[1] = orig.substring(breakAt);\n        breaks.add(broken);\n        Document doc = new Document();\n        doc.add(newTextField(\"random_break\", broken[0] + \" \" + broken[1],\n            Field.Store.NO));\n        doc.add(newTextField(\"random_combine\", orig, Field.Store.NO));\n        writer.addDocument(doc);\n      }\n      writer.commit();\n      writer.close();\n      \n      ir = DirectoryReader.open(dir);\n      WordBreakSpellChecker wbsp = new WordBreakSpellChecker();\n      wbsp.setMaxChanges(1);\n      wbsp.setMinBreakWordLength(1);\n      wbsp.setMinSuggestionFrequency(1);\n      wbsp.setMaxCombineWordLength(maxLength);\n      for (int i = 0; i < originals.size(); i++) {\n        String orig = originals.get(i);\n        String left = breaks.get(i)[0];\n        String right = breaks.get(i)[1];\n        {\n          Term term = new Term(\"random_break\", orig);\n          \n          SuggestWord[][] sw = wbsp.suggestWordBreaks(term, originals.size(),\n              ir, SuggestMode.SUGGEST_ALWAYS,\n              BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY);\n          boolean failed = true;\n          for (SuggestWord[] sw1 : sw) {\n            Assert.assertTrue(sw1.length == 2);\n            if (sw1[0].string.equals(left) && sw1[1].string.equals(right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting break suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n        {\n          Term[] terms = {new Term(\"random_combine\", left),\n              new Term(\"random_combine\", right)};\n          CombineSuggestion[] cs = wbsp.suggestWordCombinations(terms,\n              originals.size(), ir, SuggestMode.SUGGEST_ALWAYS);\n          boolean failed = true;\n          for (CombineSuggestion cs1 : cs) {\n            Assert.assertTrue(cs1.originalTermIndexes.length == 2);\n            if (cs1.suggestion.string.equals(left + right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting combine suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n      }\n      \n    } catch (Exception e) {\n      throw e;\n    } finally {\n      try {\n        ir.close();\n      } catch (Exception e1) {}\n      try {\n        writer.close();\n      } catch (Exception e1) {}\n      try {\n        dir.close();\n      } catch (Exception e1) {}\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/spell/TestWordBreakSpellChecker#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws Exception {\n    int numDocs = _TestUtil.nextInt(random(), (10 * RANDOM_MULTIPLIER),\n        (100 * RANDOM_MULTIPLIER));\n    Directory dir = null;\n    RandomIndexWriter writer = null;\n    IndexReader ir = null;\n    try {\n      dir = newDirectory();\n      writer = new RandomIndexWriter(random(), dir, new MockAnalyzer(random(),\n          MockTokenizer.WHITESPACE, false));\n      int maxLength = _TestUtil.nextInt(random(), 5, 50);\n      List<String> originals = new ArrayList<String>(numDocs);\n      List<String[]> breaks = new ArrayList<String[]>(numDocs);\n      for (int i = 0; i < numDocs; i++) {\n        String orig = \"\";\n        if (random().nextBoolean()) {\n          while (!goodTestString(orig)) {\n            orig = _TestUtil.randomSimpleString(random(), maxLength);\n          }\n        } else {\n          while (!goodTestString(orig)) {\n            orig = _TestUtil.randomUnicodeString(random(), maxLength);\n          }\n        }\n        originals.add(orig);\n        int totalLength = orig.codePointCount(0, orig.length());\n        int breakAt = orig.offsetByCodePoints(0,\n            _TestUtil.nextInt(random(), 1, totalLength - 1));\n        String[] broken = new String[2];\n        broken[0] = orig.substring(0, breakAt);\n        broken[1] = orig.substring(breakAt);\n        breaks.add(broken);\n        Document doc = new Document();\n        doc.add(newTextField(\"random_break\", broken[0] + \" \" + broken[1],\n            Field.Store.NO));\n        doc.add(newTextField(\"random_combine\", orig, Field.Store.NO));\n        writer.addDocument(doc);\n      }\n      writer.commit();\n      writer.close();\n      \n      ir = DirectoryReader.open(dir);\n      WordBreakSpellChecker wbsp = new WordBreakSpellChecker();\n      wbsp.setMaxChanges(1);\n      wbsp.setMinBreakWordLength(1);\n      wbsp.setMinSuggestionFrequency(1);\n      wbsp.setMaxCombineWordLength(maxLength);\n      for (int i = 0; i < originals.size(); i++) {\n        String orig = originals.get(i);\n        String left = breaks.get(i)[0];\n        String right = breaks.get(i)[1];\n        {\n          Term term = new Term(\"random_break\", orig);\n          \n          SuggestWord[][] sw = wbsp.suggestWordBreaks(term, originals.size(),\n              ir, SuggestMode.SUGGEST_ALWAYS,\n              BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY);\n          boolean failed = true;\n          for (SuggestWord[] sw1 : sw) {\n            Assert.assertTrue(sw1.length == 2);\n            if (sw1[0].string.equals(left) && sw1[1].string.equals(right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting break suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n        {\n          Term[] terms = {new Term(\"random_combine\", left),\n              new Term(\"random_combine\", right)};\n          CombineSuggestion[] cs = wbsp.suggestWordCombinations(terms,\n              originals.size(), ir, SuggestMode.SUGGEST_ALWAYS);\n          boolean failed = true;\n          for (CombineSuggestion cs1 : cs) {\n            Assert.assertTrue(cs1.originalTermIndexes.length == 2);\n            if (cs1.suggestion.string.equals(left + right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting combine suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n      }\n      \n    } catch (Exception e) {\n      throw e;\n    } finally {\n      try {\n        ir.close();\n      } catch (Exception e1) {}\n      try {\n        writer.close();\n      } catch (Exception e1) {}\n      try {\n        dir.close();\n      } catch (Exception e1) {}\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/spell/TestWordBreakSpellChecker#testRandom().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/spell/TestWordBreakSpellChecker#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numDocs = TestUtil.nextInt(random(), (10 * RANDOM_MULTIPLIER),\n        (100 * RANDOM_MULTIPLIER));\n    Directory dir = null;\n    RandomIndexWriter writer = null;\n    IndexReader ir = null;\n    try {\n      dir = newDirectory();\n      writer = new RandomIndexWriter(random(), dir, new MockAnalyzer(random(),\n          MockTokenizer.WHITESPACE, false));\n      int maxLength = TestUtil.nextInt(random(), 5, 50);\n      List<String> originals = new ArrayList<String>(numDocs);\n      List<String[]> breaks = new ArrayList<String[]>(numDocs);\n      for (int i = 0; i < numDocs; i++) {\n        String orig = \"\";\n        if (random().nextBoolean()) {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomSimpleString(random(), maxLength);\n          }\n        } else {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomUnicodeString(random(), maxLength);\n          }\n        }\n        originals.add(orig);\n        int totalLength = orig.codePointCount(0, orig.length());\n        int breakAt = orig.offsetByCodePoints(0,\n            TestUtil.nextInt(random(), 1, totalLength - 1));\n        String[] broken = new String[2];\n        broken[0] = orig.substring(0, breakAt);\n        broken[1] = orig.substring(breakAt);\n        breaks.add(broken);\n        Document doc = new Document();\n        doc.add(newTextField(\"random_break\", broken[0] + \" \" + broken[1],\n            Field.Store.NO));\n        doc.add(newTextField(\"random_combine\", orig, Field.Store.NO));\n        writer.addDocument(doc);\n      }\n      writer.commit();\n      writer.close();\n      \n      ir = DirectoryReader.open(dir);\n      WordBreakSpellChecker wbsp = new WordBreakSpellChecker();\n      wbsp.setMaxChanges(1);\n      wbsp.setMinBreakWordLength(1);\n      wbsp.setMinSuggestionFrequency(1);\n      wbsp.setMaxCombineWordLength(maxLength);\n      for (int i = 0; i < originals.size(); i++) {\n        String orig = originals.get(i);\n        String left = breaks.get(i)[0];\n        String right = breaks.get(i)[1];\n        {\n          Term term = new Term(\"random_break\", orig);\n          \n          SuggestWord[][] sw = wbsp.suggestWordBreaks(term, originals.size(),\n              ir, SuggestMode.SUGGEST_ALWAYS,\n              BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY);\n          boolean failed = true;\n          for (SuggestWord[] sw1 : sw) {\n            Assert.assertTrue(sw1.length == 2);\n            if (sw1[0].string.equals(left) && sw1[1].string.equals(right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting break suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n        {\n          Term[] terms = {new Term(\"random_combine\", left),\n              new Term(\"random_combine\", right)};\n          CombineSuggestion[] cs = wbsp.suggestWordCombinations(terms,\n              originals.size(), ir, SuggestMode.SUGGEST_ALWAYS);\n          boolean failed = true;\n          for (CombineSuggestion cs1 : cs) {\n            Assert.assertTrue(cs1.originalTermIndexes.length == 2);\n            if (cs1.suggestion.string.equals(left + right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting combine suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n      }\n      \n    } catch (Exception e) {\n      throw e;\n    } finally {\n      try {\n        ir.close();\n      } catch (Exception e1) {}\n      try {\n        writer.close();\n      } catch (Exception e1) {}\n      try {\n        dir.close();\n      } catch (Exception e1) {}\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numDocs = _TestUtil.nextInt(random(), (10 * RANDOM_MULTIPLIER),\n        (100 * RANDOM_MULTIPLIER));\n    Directory dir = null;\n    RandomIndexWriter writer = null;\n    IndexReader ir = null;\n    try {\n      dir = newDirectory();\n      writer = new RandomIndexWriter(random(), dir, new MockAnalyzer(random(),\n          MockTokenizer.WHITESPACE, false));\n      int maxLength = _TestUtil.nextInt(random(), 5, 50);\n      List<String> originals = new ArrayList<String>(numDocs);\n      List<String[]> breaks = new ArrayList<String[]>(numDocs);\n      for (int i = 0; i < numDocs; i++) {\n        String orig = \"\";\n        if (random().nextBoolean()) {\n          while (!goodTestString(orig)) {\n            orig = _TestUtil.randomSimpleString(random(), maxLength);\n          }\n        } else {\n          while (!goodTestString(orig)) {\n            orig = _TestUtil.randomUnicodeString(random(), maxLength);\n          }\n        }\n        originals.add(orig);\n        int totalLength = orig.codePointCount(0, orig.length());\n        int breakAt = orig.offsetByCodePoints(0,\n            _TestUtil.nextInt(random(), 1, totalLength - 1));\n        String[] broken = new String[2];\n        broken[0] = orig.substring(0, breakAt);\n        broken[1] = orig.substring(breakAt);\n        breaks.add(broken);\n        Document doc = new Document();\n        doc.add(newTextField(\"random_break\", broken[0] + \" \" + broken[1],\n            Field.Store.NO));\n        doc.add(newTextField(\"random_combine\", orig, Field.Store.NO));\n        writer.addDocument(doc);\n      }\n      writer.commit();\n      writer.close();\n      \n      ir = DirectoryReader.open(dir);\n      WordBreakSpellChecker wbsp = new WordBreakSpellChecker();\n      wbsp.setMaxChanges(1);\n      wbsp.setMinBreakWordLength(1);\n      wbsp.setMinSuggestionFrequency(1);\n      wbsp.setMaxCombineWordLength(maxLength);\n      for (int i = 0; i < originals.size(); i++) {\n        String orig = originals.get(i);\n        String left = breaks.get(i)[0];\n        String right = breaks.get(i)[1];\n        {\n          Term term = new Term(\"random_break\", orig);\n          \n          SuggestWord[][] sw = wbsp.suggestWordBreaks(term, originals.size(),\n              ir, SuggestMode.SUGGEST_ALWAYS,\n              BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY);\n          boolean failed = true;\n          for (SuggestWord[] sw1 : sw) {\n            Assert.assertTrue(sw1.length == 2);\n            if (sw1[0].string.equals(left) && sw1[1].string.equals(right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting break suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n        {\n          Term[] terms = {new Term(\"random_combine\", left),\n              new Term(\"random_combine\", right)};\n          CombineSuggestion[] cs = wbsp.suggestWordCombinations(terms,\n              originals.size(), ir, SuggestMode.SUGGEST_ALWAYS);\n          boolean failed = true;\n          for (CombineSuggestion cs1 : cs) {\n            Assert.assertTrue(cs1.originalTermIndexes.length == 2);\n            if (cs1.suggestion.string.equals(left + right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting combine suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n      }\n      \n    } catch (Exception e) {\n      throw e;\n    } finally {\n      try {\n        ir.close();\n      } catch (Exception e1) {}\n      try {\n        writer.close();\n      } catch (Exception e1) {}\n      try {\n        dir.close();\n      } catch (Exception e1) {}\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/spell/TestWordBreakSpellChecker#testRandom().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/spell/TestWordBreakSpellChecker#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numDocs = TestUtil.nextInt(random(), (10 * RANDOM_MULTIPLIER),\n        (100 * RANDOM_MULTIPLIER));\n    Directory dir = null;\n    RandomIndexWriter writer = null;\n    IndexReader ir = null;\n    try {\n      dir = newDirectory();\n      writer = new RandomIndexWriter(random(), dir, new MockAnalyzer(random(),\n          MockTokenizer.WHITESPACE, false));\n      int maxLength = TestUtil.nextInt(random(), 5, 50);\n      List<String> originals = new ArrayList<>(numDocs);\n      List<String[]> breaks = new ArrayList<>(numDocs);\n      for (int i = 0; i < numDocs; i++) {\n        String orig = \"\";\n        if (random().nextBoolean()) {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomSimpleString(random(), maxLength);\n          }\n        } else {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomUnicodeString(random(), maxLength);\n          }\n        }\n        originals.add(orig);\n        int totalLength = orig.codePointCount(0, orig.length());\n        int breakAt = orig.offsetByCodePoints(0,\n            TestUtil.nextInt(random(), 1, totalLength - 1));\n        String[] broken = new String[2];\n        broken[0] = orig.substring(0, breakAt);\n        broken[1] = orig.substring(breakAt);\n        breaks.add(broken);\n        Document doc = new Document();\n        doc.add(newTextField(\"random_break\", broken[0] + \" \" + broken[1],\n            Field.Store.NO));\n        doc.add(newTextField(\"random_combine\", orig, Field.Store.NO));\n        writer.addDocument(doc);\n      }\n      writer.commit();\n      writer.close();\n      \n      ir = DirectoryReader.open(dir);\n      WordBreakSpellChecker wbsp = new WordBreakSpellChecker();\n      wbsp.setMaxChanges(1);\n      wbsp.setMinBreakWordLength(1);\n      wbsp.setMinSuggestionFrequency(1);\n      wbsp.setMaxCombineWordLength(maxLength);\n      for (int i = 0; i < originals.size(); i++) {\n        String orig = originals.get(i);\n        String left = breaks.get(i)[0];\n        String right = breaks.get(i)[1];\n        {\n          Term term = new Term(\"random_break\", orig);\n          \n          SuggestWord[][] sw = wbsp.suggestWordBreaks(term, originals.size(),\n              ir, SuggestMode.SUGGEST_ALWAYS,\n              BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY);\n          boolean failed = true;\n          for (SuggestWord[] sw1 : sw) {\n            Assert.assertTrue(sw1.length == 2);\n            if (sw1[0].string.equals(left) && sw1[1].string.equals(right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting break suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n        {\n          Term[] terms = {new Term(\"random_combine\", left),\n              new Term(\"random_combine\", right)};\n          CombineSuggestion[] cs = wbsp.suggestWordCombinations(terms,\n              originals.size(), ir, SuggestMode.SUGGEST_ALWAYS);\n          boolean failed = true;\n          for (CombineSuggestion cs1 : cs) {\n            Assert.assertTrue(cs1.originalTermIndexes.length == 2);\n            if (cs1.suggestion.string.equals(left + right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting combine suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n      }\n      \n    } catch (Exception e) {\n      throw e;\n    } finally {\n      try {\n        ir.close();\n      } catch (Exception e1) {}\n      try {\n        writer.close();\n      } catch (Exception e1) {}\n      try {\n        dir.close();\n      } catch (Exception e1) {}\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numDocs = TestUtil.nextInt(random(), (10 * RANDOM_MULTIPLIER),\n        (100 * RANDOM_MULTIPLIER));\n    Directory dir = null;\n    RandomIndexWriter writer = null;\n    IndexReader ir = null;\n    try {\n      dir = newDirectory();\n      writer = new RandomIndexWriter(random(), dir, new MockAnalyzer(random(),\n          MockTokenizer.WHITESPACE, false));\n      int maxLength = TestUtil.nextInt(random(), 5, 50);\n      List<String> originals = new ArrayList<String>(numDocs);\n      List<String[]> breaks = new ArrayList<String[]>(numDocs);\n      for (int i = 0; i < numDocs; i++) {\n        String orig = \"\";\n        if (random().nextBoolean()) {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomSimpleString(random(), maxLength);\n          }\n        } else {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomUnicodeString(random(), maxLength);\n          }\n        }\n        originals.add(orig);\n        int totalLength = orig.codePointCount(0, orig.length());\n        int breakAt = orig.offsetByCodePoints(0,\n            TestUtil.nextInt(random(), 1, totalLength - 1));\n        String[] broken = new String[2];\n        broken[0] = orig.substring(0, breakAt);\n        broken[1] = orig.substring(breakAt);\n        breaks.add(broken);\n        Document doc = new Document();\n        doc.add(newTextField(\"random_break\", broken[0] + \" \" + broken[1],\n            Field.Store.NO));\n        doc.add(newTextField(\"random_combine\", orig, Field.Store.NO));\n        writer.addDocument(doc);\n      }\n      writer.commit();\n      writer.close();\n      \n      ir = DirectoryReader.open(dir);\n      WordBreakSpellChecker wbsp = new WordBreakSpellChecker();\n      wbsp.setMaxChanges(1);\n      wbsp.setMinBreakWordLength(1);\n      wbsp.setMinSuggestionFrequency(1);\n      wbsp.setMaxCombineWordLength(maxLength);\n      for (int i = 0; i < originals.size(); i++) {\n        String orig = originals.get(i);\n        String left = breaks.get(i)[0];\n        String right = breaks.get(i)[1];\n        {\n          Term term = new Term(\"random_break\", orig);\n          \n          SuggestWord[][] sw = wbsp.suggestWordBreaks(term, originals.size(),\n              ir, SuggestMode.SUGGEST_ALWAYS,\n              BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY);\n          boolean failed = true;\n          for (SuggestWord[] sw1 : sw) {\n            Assert.assertTrue(sw1.length == 2);\n            if (sw1[0].string.equals(left) && sw1[1].string.equals(right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting break suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n        {\n          Term[] terms = {new Term(\"random_combine\", left),\n              new Term(\"random_combine\", right)};\n          CombineSuggestion[] cs = wbsp.suggestWordCombinations(terms,\n              originals.size(), ir, SuggestMode.SUGGEST_ALWAYS);\n          boolean failed = true;\n          for (CombineSuggestion cs1 : cs) {\n            Assert.assertTrue(cs1.originalTermIndexes.length == 2);\n            if (cs1.suggestion.string.equals(left + right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting combine suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n      }\n      \n    } catch (Exception e) {\n      throw e;\n    } finally {\n      try {\n        ir.close();\n      } catch (Exception e1) {}\n      try {\n        writer.close();\n      } catch (Exception e1) {}\n      try {\n        dir.close();\n      } catch (Exception e1) {}\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/spell/TestWordBreakSpellChecker#testRandom().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/spell/TestWordBreakSpellChecker#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numDocs = TestUtil.nextInt(random(), (10 * RANDOM_MULTIPLIER),\n        (100 * RANDOM_MULTIPLIER));\n    Directory dir = null;\n    RandomIndexWriter writer = null;\n    IndexReader ir = null;\n    try {\n      dir = newDirectory();\n      writer = new RandomIndexWriter(random(), dir, new MockAnalyzer(random(),\n          MockTokenizer.WHITESPACE, false));\n      int maxLength = TestUtil.nextInt(random(), 5, 50);\n      List<String> originals = new ArrayList<>(numDocs);\n      List<String[]> breaks = new ArrayList<>(numDocs);\n      for (int i = 0; i < numDocs; i++) {\n        String orig = \"\";\n        if (random().nextBoolean()) {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomSimpleString(random(), maxLength);\n          }\n        } else {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomUnicodeString(random(), maxLength);\n          }\n        }\n        originals.add(orig);\n        int totalLength = orig.codePointCount(0, orig.length());\n        int breakAt = orig.offsetByCodePoints(0,\n            TestUtil.nextInt(random(), 1, totalLength - 1));\n        String[] broken = new String[2];\n        broken[0] = orig.substring(0, breakAt);\n        broken[1] = orig.substring(breakAt);\n        breaks.add(broken);\n        Document doc = new Document();\n        doc.add(newTextField(\"random_break\", broken[0] + \" \" + broken[1],\n            Field.Store.NO));\n        doc.add(newTextField(\"random_combine\", orig, Field.Store.NO));\n        writer.addDocument(doc);\n      }\n      writer.commit();\n      writer.shutdown();\n      \n      ir = DirectoryReader.open(dir);\n      WordBreakSpellChecker wbsp = new WordBreakSpellChecker();\n      wbsp.setMaxChanges(1);\n      wbsp.setMinBreakWordLength(1);\n      wbsp.setMinSuggestionFrequency(1);\n      wbsp.setMaxCombineWordLength(maxLength);\n      for (int i = 0; i < originals.size(); i++) {\n        String orig = originals.get(i);\n        String left = breaks.get(i)[0];\n        String right = breaks.get(i)[1];\n        {\n          Term term = new Term(\"random_break\", orig);\n          \n          SuggestWord[][] sw = wbsp.suggestWordBreaks(term, originals.size(),\n              ir, SuggestMode.SUGGEST_ALWAYS,\n              BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY);\n          boolean failed = true;\n          for (SuggestWord[] sw1 : sw) {\n            Assert.assertTrue(sw1.length == 2);\n            if (sw1[0].string.equals(left) && sw1[1].string.equals(right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting break suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n        {\n          Term[] terms = {new Term(\"random_combine\", left),\n              new Term(\"random_combine\", right)};\n          CombineSuggestion[] cs = wbsp.suggestWordCombinations(terms,\n              originals.size(), ir, SuggestMode.SUGGEST_ALWAYS);\n          boolean failed = true;\n          for (CombineSuggestion cs1 : cs) {\n            Assert.assertTrue(cs1.originalTermIndexes.length == 2);\n            if (cs1.suggestion.string.equals(left + right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting combine suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n      }\n      \n    } catch (Exception e) {\n      throw e;\n    } finally {\n      try {\n        ir.close();\n      } catch (Exception e1) {}\n      try {\n        writer.shutdown();\n      } catch (Exception e1) {}\n      try {\n        dir.close();\n      } catch (Exception e1) {}\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numDocs = TestUtil.nextInt(random(), (10 * RANDOM_MULTIPLIER),\n        (100 * RANDOM_MULTIPLIER));\n    Directory dir = null;\n    RandomIndexWriter writer = null;\n    IndexReader ir = null;\n    try {\n      dir = newDirectory();\n      writer = new RandomIndexWriter(random(), dir, new MockAnalyzer(random(),\n          MockTokenizer.WHITESPACE, false));\n      int maxLength = TestUtil.nextInt(random(), 5, 50);\n      List<String> originals = new ArrayList<>(numDocs);\n      List<String[]> breaks = new ArrayList<>(numDocs);\n      for (int i = 0; i < numDocs; i++) {\n        String orig = \"\";\n        if (random().nextBoolean()) {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomSimpleString(random(), maxLength);\n          }\n        } else {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomUnicodeString(random(), maxLength);\n          }\n        }\n        originals.add(orig);\n        int totalLength = orig.codePointCount(0, orig.length());\n        int breakAt = orig.offsetByCodePoints(0,\n            TestUtil.nextInt(random(), 1, totalLength - 1));\n        String[] broken = new String[2];\n        broken[0] = orig.substring(0, breakAt);\n        broken[1] = orig.substring(breakAt);\n        breaks.add(broken);\n        Document doc = new Document();\n        doc.add(newTextField(\"random_break\", broken[0] + \" \" + broken[1],\n            Field.Store.NO));\n        doc.add(newTextField(\"random_combine\", orig, Field.Store.NO));\n        writer.addDocument(doc);\n      }\n      writer.commit();\n      writer.close();\n      \n      ir = DirectoryReader.open(dir);\n      WordBreakSpellChecker wbsp = new WordBreakSpellChecker();\n      wbsp.setMaxChanges(1);\n      wbsp.setMinBreakWordLength(1);\n      wbsp.setMinSuggestionFrequency(1);\n      wbsp.setMaxCombineWordLength(maxLength);\n      for (int i = 0; i < originals.size(); i++) {\n        String orig = originals.get(i);\n        String left = breaks.get(i)[0];\n        String right = breaks.get(i)[1];\n        {\n          Term term = new Term(\"random_break\", orig);\n          \n          SuggestWord[][] sw = wbsp.suggestWordBreaks(term, originals.size(),\n              ir, SuggestMode.SUGGEST_ALWAYS,\n              BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY);\n          boolean failed = true;\n          for (SuggestWord[] sw1 : sw) {\n            Assert.assertTrue(sw1.length == 2);\n            if (sw1[0].string.equals(left) && sw1[1].string.equals(right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting break suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n        {\n          Term[] terms = {new Term(\"random_combine\", left),\n              new Term(\"random_combine\", right)};\n          CombineSuggestion[] cs = wbsp.suggestWordCombinations(terms,\n              originals.size(), ir, SuggestMode.SUGGEST_ALWAYS);\n          boolean failed = true;\n          for (CombineSuggestion cs1 : cs) {\n            Assert.assertTrue(cs1.originalTermIndexes.length == 2);\n            if (cs1.suggestion.string.equals(left + right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting combine suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n      }\n      \n    } catch (Exception e) {\n      throw e;\n    } finally {\n      try {\n        ir.close();\n      } catch (Exception e1) {}\n      try {\n        writer.close();\n      } catch (Exception e1) {}\n      try {\n        dir.close();\n      } catch (Exception e1) {}\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/spell/TestWordBreakSpellChecker#testRandom().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/spell/TestWordBreakSpellChecker#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numDocs = TestUtil.nextInt(random(), (10 * RANDOM_MULTIPLIER),\n        (100 * RANDOM_MULTIPLIER));\n    Directory dir = null;\n    RandomIndexWriter writer = null;\n    IndexReader ir = null;\n    try {\n      dir = newDirectory();\n      writer = new RandomIndexWriter(random(), dir, new MockAnalyzer(random(),\n          MockTokenizer.WHITESPACE, false));\n      int maxLength = TestUtil.nextInt(random(), 5, 50);\n      List<String> originals = new ArrayList<>(numDocs);\n      List<String[]> breaks = new ArrayList<>(numDocs);\n      for (int i = 0; i < numDocs; i++) {\n        String orig = \"\";\n        if (random().nextBoolean()) {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomSimpleString(random(), maxLength);\n          }\n        } else {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomUnicodeString(random(), maxLength);\n          }\n        }\n        originals.add(orig);\n        int totalLength = orig.codePointCount(0, orig.length());\n        int breakAt = orig.offsetByCodePoints(0,\n            TestUtil.nextInt(random(), 1, totalLength - 1));\n        String[] broken = new String[2];\n        broken[0] = orig.substring(0, breakAt);\n        broken[1] = orig.substring(breakAt);\n        breaks.add(broken);\n        Document doc = new Document();\n        doc.add(newTextField(\"random_break\", broken[0] + \" \" + broken[1],\n            Field.Store.NO));\n        doc.add(newTextField(\"random_combine\", orig, Field.Store.NO));\n        writer.addDocument(doc);\n      }\n      writer.commit();\n      writer.close();\n      \n      ir = DirectoryReader.open(dir);\n      WordBreakSpellChecker wbsp = new WordBreakSpellChecker();\n      wbsp.setMaxChanges(1);\n      wbsp.setMinBreakWordLength(1);\n      wbsp.setMinSuggestionFrequency(1);\n      wbsp.setMaxCombineWordLength(maxLength);\n      for (int i = 0; i < originals.size(); i++) {\n        String orig = originals.get(i);\n        String left = breaks.get(i)[0];\n        String right = breaks.get(i)[1];\n        {\n          Term term = new Term(\"random_break\", orig);\n          \n          SuggestWord[][] sw = wbsp.suggestWordBreaks(term, originals.size(),\n              ir, SuggestMode.SUGGEST_ALWAYS,\n              BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY);\n          boolean failed = true;\n          for (SuggestWord[] sw1 : sw) {\n            Assert.assertTrue(sw1.length == 2);\n            if (sw1[0].string.equals(left) && sw1[1].string.equals(right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting break suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n        {\n          Term[] terms = {new Term(\"random_combine\", left),\n              new Term(\"random_combine\", right)};\n          CombineSuggestion[] cs = wbsp.suggestWordCombinations(terms,\n              originals.size(), ir, SuggestMode.SUGGEST_ALWAYS);\n          boolean failed = true;\n          for (CombineSuggestion cs1 : cs) {\n            Assert.assertTrue(cs1.originalTermIndexes.length == 2);\n            if (cs1.suggestion.string.equals(left + right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting combine suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n      }\n      \n    } catch (Exception e) {\n      throw e;\n    } finally {\n      try {\n        ir.close();\n      } catch (Exception e1) {}\n      try {\n        writer.close();\n      } catch (Exception e1) {}\n      try {\n        dir.close();\n      } catch (Exception e1) {}\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numDocs = TestUtil.nextInt(random(), (10 * RANDOM_MULTIPLIER),\n        (100 * RANDOM_MULTIPLIER));\n    Directory dir = null;\n    RandomIndexWriter writer = null;\n    IndexReader ir = null;\n    try {\n      dir = newDirectory();\n      writer = new RandomIndexWriter(random(), dir, new MockAnalyzer(random(),\n          MockTokenizer.WHITESPACE, false));\n      int maxLength = TestUtil.nextInt(random(), 5, 50);\n      List<String> originals = new ArrayList<>(numDocs);\n      List<String[]> breaks = new ArrayList<>(numDocs);\n      for (int i = 0; i < numDocs; i++) {\n        String orig = \"\";\n        if (random().nextBoolean()) {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomSimpleString(random(), maxLength);\n          }\n        } else {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomUnicodeString(random(), maxLength);\n          }\n        }\n        originals.add(orig);\n        int totalLength = orig.codePointCount(0, orig.length());\n        int breakAt = orig.offsetByCodePoints(0,\n            TestUtil.nextInt(random(), 1, totalLength - 1));\n        String[] broken = new String[2];\n        broken[0] = orig.substring(0, breakAt);\n        broken[1] = orig.substring(breakAt);\n        breaks.add(broken);\n        Document doc = new Document();\n        doc.add(newTextField(\"random_break\", broken[0] + \" \" + broken[1],\n            Field.Store.NO));\n        doc.add(newTextField(\"random_combine\", orig, Field.Store.NO));\n        writer.addDocument(doc);\n      }\n      writer.commit();\n      writer.shutdown();\n      \n      ir = DirectoryReader.open(dir);\n      WordBreakSpellChecker wbsp = new WordBreakSpellChecker();\n      wbsp.setMaxChanges(1);\n      wbsp.setMinBreakWordLength(1);\n      wbsp.setMinSuggestionFrequency(1);\n      wbsp.setMaxCombineWordLength(maxLength);\n      for (int i = 0; i < originals.size(); i++) {\n        String orig = originals.get(i);\n        String left = breaks.get(i)[0];\n        String right = breaks.get(i)[1];\n        {\n          Term term = new Term(\"random_break\", orig);\n          \n          SuggestWord[][] sw = wbsp.suggestWordBreaks(term, originals.size(),\n              ir, SuggestMode.SUGGEST_ALWAYS,\n              BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY);\n          boolean failed = true;\n          for (SuggestWord[] sw1 : sw) {\n            Assert.assertTrue(sw1.length == 2);\n            if (sw1[0].string.equals(left) && sw1[1].string.equals(right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting break suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n        {\n          Term[] terms = {new Term(\"random_combine\", left),\n              new Term(\"random_combine\", right)};\n          CombineSuggestion[] cs = wbsp.suggestWordCombinations(terms,\n              originals.size(), ir, SuggestMode.SUGGEST_ALWAYS);\n          boolean failed = true;\n          for (CombineSuggestion cs1 : cs) {\n            Assert.assertTrue(cs1.originalTermIndexes.length == 2);\n            if (cs1.suggestion.string.equals(left + right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting combine suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n      }\n      \n    } catch (Exception e) {\n      throw e;\n    } finally {\n      try {\n        ir.close();\n      } catch (Exception e1) {}\n      try {\n        writer.shutdown();\n      } catch (Exception e1) {}\n      try {\n        dir.close();\n      } catch (Exception e1) {}\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a56958d7f71a28824f20031ffbb2e13502a0274e","date":1425573902,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/spell/TestWordBreakSpellChecker#testRandom().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/spell/TestWordBreakSpellChecker#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numDocs = TestUtil.nextInt(random(), (10 * RANDOM_MULTIPLIER),\n        (100 * RANDOM_MULTIPLIER));\n    IndexReader ir = null;\n    \n    Directory dir = newDirectory();\n    Analyzer analyzer = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, analyzer);\n    int maxLength = TestUtil.nextInt(random(), 5, 50);\n    List<String> originals = new ArrayList<>(numDocs);\n    List<String[]> breaks = new ArrayList<>(numDocs);\n    for (int i = 0; i < numDocs; i++) {\n      String orig = \"\";\n      if (random().nextBoolean()) {\n        while (!goodTestString(orig)) {\n          orig = TestUtil.randomSimpleString(random(), maxLength);\n        }\n      } else {\n        while (!goodTestString(orig)) {\n          orig = TestUtil.randomUnicodeString(random(), maxLength);\n        }\n      }\n      originals.add(orig);\n      int totalLength = orig.codePointCount(0, orig.length());\n      int breakAt = orig.offsetByCodePoints(0,\n          TestUtil.nextInt(random(), 1, totalLength - 1));\n      String[] broken = new String[2];\n      broken[0] = orig.substring(0, breakAt);\n      broken[1] = orig.substring(breakAt);\n      breaks.add(broken);\n      Document doc = new Document();\n      doc.add(newTextField(\"random_break\", broken[0] + \" \" + broken[1],\n          Field.Store.NO));\n      doc.add(newTextField(\"random_combine\", orig, Field.Store.NO));\n      writer.addDocument(doc);\n    }\n    writer.commit();\n    writer.close();\n    \n    ir = DirectoryReader.open(dir);\n    WordBreakSpellChecker wbsp = new WordBreakSpellChecker();\n    wbsp.setMaxChanges(1);\n    wbsp.setMinBreakWordLength(1);\n    wbsp.setMinSuggestionFrequency(1);\n    wbsp.setMaxCombineWordLength(maxLength);\n    for (int i = 0; i < originals.size(); i++) {\n      String orig = originals.get(i);\n      String left = breaks.get(i)[0];\n      String right = breaks.get(i)[1];\n      {\n        Term term = new Term(\"random_break\", orig);\n        \n        SuggestWord[][] sw = wbsp.suggestWordBreaks(term, originals.size(),\n            ir, SuggestMode.SUGGEST_ALWAYS,\n            BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY);\n        boolean failed = true;\n        for (SuggestWord[] sw1 : sw) {\n          Assert.assertTrue(sw1.length == 2);\n          if (sw1[0].string.equals(left) && sw1[1].string.equals(right)) {\n            failed = false;\n          }\n        }\n        Assert.assertFalse(\"Failed getting break suggestions\\n >Original: \"\n            + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n      }\n      {\n        Term[] terms = {new Term(\"random_combine\", left),\n            new Term(\"random_combine\", right)};\n        CombineSuggestion[] cs = wbsp.suggestWordCombinations(terms,\n            originals.size(), ir, SuggestMode.SUGGEST_ALWAYS);\n        boolean failed = true;\n        for (CombineSuggestion cs1 : cs) {\n          Assert.assertTrue(cs1.originalTermIndexes.length == 2);\n          if (cs1.suggestion.string.equals(left + right)) {\n            failed = false;\n          }\n        }\n        Assert.assertFalse(\"Failed getting combine suggestions\\n >Original: \"\n            + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n      }\n    }\n    IOUtils.close(ir, dir, analyzer);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numDocs = TestUtil.nextInt(random(), (10 * RANDOM_MULTIPLIER),\n        (100 * RANDOM_MULTIPLIER));\n    Directory dir = null;\n    RandomIndexWriter writer = null;\n    IndexReader ir = null;\n    try {\n      dir = newDirectory();\n      writer = new RandomIndexWriter(random(), dir, new MockAnalyzer(random(),\n          MockTokenizer.WHITESPACE, false));\n      int maxLength = TestUtil.nextInt(random(), 5, 50);\n      List<String> originals = new ArrayList<>(numDocs);\n      List<String[]> breaks = new ArrayList<>(numDocs);\n      for (int i = 0; i < numDocs; i++) {\n        String orig = \"\";\n        if (random().nextBoolean()) {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomSimpleString(random(), maxLength);\n          }\n        } else {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomUnicodeString(random(), maxLength);\n          }\n        }\n        originals.add(orig);\n        int totalLength = orig.codePointCount(0, orig.length());\n        int breakAt = orig.offsetByCodePoints(0,\n            TestUtil.nextInt(random(), 1, totalLength - 1));\n        String[] broken = new String[2];\n        broken[0] = orig.substring(0, breakAt);\n        broken[1] = orig.substring(breakAt);\n        breaks.add(broken);\n        Document doc = new Document();\n        doc.add(newTextField(\"random_break\", broken[0] + \" \" + broken[1],\n            Field.Store.NO));\n        doc.add(newTextField(\"random_combine\", orig, Field.Store.NO));\n        writer.addDocument(doc);\n      }\n      writer.commit();\n      writer.close();\n      \n      ir = DirectoryReader.open(dir);\n      WordBreakSpellChecker wbsp = new WordBreakSpellChecker();\n      wbsp.setMaxChanges(1);\n      wbsp.setMinBreakWordLength(1);\n      wbsp.setMinSuggestionFrequency(1);\n      wbsp.setMaxCombineWordLength(maxLength);\n      for (int i = 0; i < originals.size(); i++) {\n        String orig = originals.get(i);\n        String left = breaks.get(i)[0];\n        String right = breaks.get(i)[1];\n        {\n          Term term = new Term(\"random_break\", orig);\n          \n          SuggestWord[][] sw = wbsp.suggestWordBreaks(term, originals.size(),\n              ir, SuggestMode.SUGGEST_ALWAYS,\n              BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY);\n          boolean failed = true;\n          for (SuggestWord[] sw1 : sw) {\n            Assert.assertTrue(sw1.length == 2);\n            if (sw1[0].string.equals(left) && sw1[1].string.equals(right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting break suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n        {\n          Term[] terms = {new Term(\"random_combine\", left),\n              new Term(\"random_combine\", right)};\n          CombineSuggestion[] cs = wbsp.suggestWordCombinations(terms,\n              originals.size(), ir, SuggestMode.SUGGEST_ALWAYS);\n          boolean failed = true;\n          for (CombineSuggestion cs1 : cs) {\n            Assert.assertTrue(cs1.originalTermIndexes.length == 2);\n            if (cs1.suggestion.string.equals(left + right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting combine suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n      }\n      \n    } catch (Exception e) {\n      throw e;\n    } finally {\n      try {\n        ir.close();\n      } catch (Exception e1) {}\n      try {\n        writer.close();\n      } catch (Exception e1) {}\n      try {\n        dir.close();\n      } catch (Exception e1) {}\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/spell/TestWordBreakSpellChecker#testRandom().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/spell/TestWordBreakSpellChecker#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numDocs = TestUtil.nextInt(random(), (10 * RANDOM_MULTIPLIER),\n        (100 * RANDOM_MULTIPLIER));\n    IndexReader ir = null;\n    \n    Directory dir = newDirectory();\n    Analyzer analyzer = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, analyzer);\n    int maxLength = TestUtil.nextInt(random(), 5, 50);\n    List<String> originals = new ArrayList<>(numDocs);\n    List<String[]> breaks = new ArrayList<>(numDocs);\n    for (int i = 0; i < numDocs; i++) {\n      String orig = \"\";\n      if (random().nextBoolean()) {\n        while (!goodTestString(orig)) {\n          orig = TestUtil.randomSimpleString(random(), maxLength);\n        }\n      } else {\n        while (!goodTestString(orig)) {\n          orig = TestUtil.randomUnicodeString(random(), maxLength);\n        }\n      }\n      originals.add(orig);\n      int totalLength = orig.codePointCount(0, orig.length());\n      int breakAt = orig.offsetByCodePoints(0,\n          TestUtil.nextInt(random(), 1, totalLength - 1));\n      String[] broken = new String[2];\n      broken[0] = orig.substring(0, breakAt);\n      broken[1] = orig.substring(breakAt);\n      breaks.add(broken);\n      Document doc = new Document();\n      doc.add(newTextField(\"random_break\", broken[0] + \" \" + broken[1],\n          Field.Store.NO));\n      doc.add(newTextField(\"random_combine\", orig, Field.Store.NO));\n      writer.addDocument(doc);\n    }\n    writer.commit();\n    writer.close();\n    \n    ir = DirectoryReader.open(dir);\n    WordBreakSpellChecker wbsp = new WordBreakSpellChecker();\n    wbsp.setMaxChanges(1);\n    wbsp.setMinBreakWordLength(1);\n    wbsp.setMinSuggestionFrequency(1);\n    wbsp.setMaxCombineWordLength(maxLength);\n    for (int i = 0; i < originals.size(); i++) {\n      String orig = originals.get(i);\n      String left = breaks.get(i)[0];\n      String right = breaks.get(i)[1];\n      {\n        Term term = new Term(\"random_break\", orig);\n        \n        SuggestWord[][] sw = wbsp.suggestWordBreaks(term, originals.size(),\n            ir, SuggestMode.SUGGEST_ALWAYS,\n            BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY);\n        boolean failed = true;\n        for (SuggestWord[] sw1 : sw) {\n          Assert.assertTrue(sw1.length == 2);\n          if (sw1[0].string.equals(left) && sw1[1].string.equals(right)) {\n            failed = false;\n          }\n        }\n        Assert.assertFalse(\"Failed getting break suggestions\\n >Original: \"\n            + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n      }\n      {\n        Term[] terms = {new Term(\"random_combine\", left),\n            new Term(\"random_combine\", right)};\n        CombineSuggestion[] cs = wbsp.suggestWordCombinations(terms,\n            originals.size(), ir, SuggestMode.SUGGEST_ALWAYS);\n        boolean failed = true;\n        for (CombineSuggestion cs1 : cs) {\n          Assert.assertTrue(cs1.originalTermIndexes.length == 2);\n          if (cs1.suggestion.string.equals(left + right)) {\n            failed = false;\n          }\n        }\n        Assert.assertFalse(\"Failed getting combine suggestions\\n >Original: \"\n            + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n      }\n    }\n    IOUtils.close(ir, dir, analyzer);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numDocs = TestUtil.nextInt(random(), (10 * RANDOM_MULTIPLIER),\n        (100 * RANDOM_MULTIPLIER));\n    Directory dir = null;\n    RandomIndexWriter writer = null;\n    IndexReader ir = null;\n    try {\n      dir = newDirectory();\n      writer = new RandomIndexWriter(random(), dir, new MockAnalyzer(random(),\n          MockTokenizer.WHITESPACE, false));\n      int maxLength = TestUtil.nextInt(random(), 5, 50);\n      List<String> originals = new ArrayList<>(numDocs);\n      List<String[]> breaks = new ArrayList<>(numDocs);\n      for (int i = 0; i < numDocs; i++) {\n        String orig = \"\";\n        if (random().nextBoolean()) {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomSimpleString(random(), maxLength);\n          }\n        } else {\n          while (!goodTestString(orig)) {\n            orig = TestUtil.randomUnicodeString(random(), maxLength);\n          }\n        }\n        originals.add(orig);\n        int totalLength = orig.codePointCount(0, orig.length());\n        int breakAt = orig.offsetByCodePoints(0,\n            TestUtil.nextInt(random(), 1, totalLength - 1));\n        String[] broken = new String[2];\n        broken[0] = orig.substring(0, breakAt);\n        broken[1] = orig.substring(breakAt);\n        breaks.add(broken);\n        Document doc = new Document();\n        doc.add(newTextField(\"random_break\", broken[0] + \" \" + broken[1],\n            Field.Store.NO));\n        doc.add(newTextField(\"random_combine\", orig, Field.Store.NO));\n        writer.addDocument(doc);\n      }\n      writer.commit();\n      writer.close();\n      \n      ir = DirectoryReader.open(dir);\n      WordBreakSpellChecker wbsp = new WordBreakSpellChecker();\n      wbsp.setMaxChanges(1);\n      wbsp.setMinBreakWordLength(1);\n      wbsp.setMinSuggestionFrequency(1);\n      wbsp.setMaxCombineWordLength(maxLength);\n      for (int i = 0; i < originals.size(); i++) {\n        String orig = originals.get(i);\n        String left = breaks.get(i)[0];\n        String right = breaks.get(i)[1];\n        {\n          Term term = new Term(\"random_break\", orig);\n          \n          SuggestWord[][] sw = wbsp.suggestWordBreaks(term, originals.size(),\n              ir, SuggestMode.SUGGEST_ALWAYS,\n              BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY);\n          boolean failed = true;\n          for (SuggestWord[] sw1 : sw) {\n            Assert.assertTrue(sw1.length == 2);\n            if (sw1[0].string.equals(left) && sw1[1].string.equals(right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting break suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n        {\n          Term[] terms = {new Term(\"random_combine\", left),\n              new Term(\"random_combine\", right)};\n          CombineSuggestion[] cs = wbsp.suggestWordCombinations(terms,\n              originals.size(), ir, SuggestMode.SUGGEST_ALWAYS);\n          boolean failed = true;\n          for (CombineSuggestion cs1 : cs) {\n            Assert.assertTrue(cs1.originalTermIndexes.length == 2);\n            if (cs1.suggestion.string.equals(left + right)) {\n              failed = false;\n            }\n          }\n          Assert.assertFalse(\"Failed getting combine suggestions\\n >Original: \"\n              + orig + \"\\n >Left: \" + left + \"\\n >Right: \" + right, failed);\n        }\n      }\n      \n    } catch (Exception e) {\n      throw e;\n    } finally {\n      try {\n        ir.close();\n      } catch (Exception e1) {}\n      try {\n        writer.close();\n      } catch (Exception e1) {}\n      try {\n        dir.close();\n      } catch (Exception e1) {}\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["d0ef034a4f10871667ae75181537775ddcf8ade4","a56958d7f71a28824f20031ffbb2e13502a0274e"],"6613659748fe4411a7dcf85266e55db1f95f7315":["efb805b23fcd6a1644c8bb2f14edb45b1afd97a0"],"efb805b23fcd6a1644c8bb2f14edb45b1afd97a0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","efb805b23fcd6a1644c8bb2f14edb45b1afd97a0"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a56958d7f71a28824f20031ffbb2e13502a0274e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a56958d7f71a28824f20031ffbb2e13502a0274e"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"efb805b23fcd6a1644c8bb2f14edb45b1afd97a0":["6613659748fe4411a7dcf85266e55db1f95f7315","407687e67faf6e1f02a211ca078d8e3eed631027"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["efb805b23fcd6a1644c8bb2f14edb45b1afd97a0","407687e67faf6e1f02a211ca078d8e3eed631027"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","a56958d7f71a28824f20031ffbb2e13502a0274e"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"a56958d7f71a28824f20031ffbb2e13502a0274e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}