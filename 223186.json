{"path":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","commits":[{"id":"c9f0b4a920667fa5fce511270c486fd499f7e71a","date":1399385988,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public List<AtomicReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<AtomicReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          if (r.nextInt(4) == 0) {\n            readers.set(i, new FilterAtomicReader(readers.get(i)));\n          }\n        }\n      }\n      return readers;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","sourceNew":"    @Override\n    public List<LeafReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<LeafReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          if (r.nextInt(4) == 0) {\n            readers.set(i, new FilterLeafReader(readers.get(i)));\n          }\n        }\n      }\n      return readers;\n    }\n\n","sourceOld":"    @Override\n    public List<AtomicReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<AtomicReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          if (r.nextInt(4) == 0) {\n            readers.set(i, new FilterAtomicReader(readers.get(i)));\n          }\n        }\n      }\n      return readers;\n    }\n\n","bugFix":null,"bugIntro":["505bff044e47a553f461b6f4484d1d08faf4ac85"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef658003003b32165df5d5016addcee1da98e4a2","date":1419764948,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","sourceNew":"    @Override\n    public List<LeafReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<LeafReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          int thingToDo = r.nextInt(7);\n          if (thingToDo == 0) {\n            // simple no-op FilterReader\n            readers.set(i, new FilterLeafReader(readers.get(i)));\n          } else if (thingToDo == 1) {\n            // renumber fields\n            // NOTE: currently this only \"blocks\" bulk merges just by\n            // being a FilterReader. But it might find bugs elsewhere, \n            // and maybe the situation can be improved in the future.\n            readers.set(i, new MismatchedLeafReader(readers.get(i), r));\n          }\n          // otherwise, reader is unchanged\n        }\n      }\n      return readers;\n    }\n\n","sourceOld":"    @Override\n    public List<LeafReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<LeafReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          if (r.nextInt(4) == 0) {\n            readers.set(i, new FilterLeafReader(readers.get(i)));\n          }\n        }\n      }\n      return readers;\n    }\n\n","bugFix":null,"bugIntro":["505bff044e47a553f461b6f4484d1d08faf4ac85"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"505bff044e47a553f461b6f4484d1d08faf4ac85","date":1420728783,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","sourceNew":"    @Override\n    public List<CodecReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<CodecReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          // TODO: cut this over to FilterCodecReader api, we can explicitly\n          // enable/disable bulk merge for portions of the index we want.\n          int thingToDo = r.nextInt(7);\n          if (thingToDo == 0) {\n            // simple no-op FilterReader\n            readers.set(i, SlowCodecReaderWrapper.wrap(new FilterLeafReader(readers.get(i))));\n          } else if (thingToDo == 1) {\n            // renumber fields\n            // NOTE: currently this only \"blocks\" bulk merges just by\n            // being a FilterReader. But it might find bugs elsewhere, \n            // and maybe the situation can be improved in the future.\n            readers.set(i, SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(readers.get(i), r)));\n          }\n          // otherwise, reader is unchanged\n        }\n      }\n      return readers;\n    }\n\n","sourceOld":"    @Override\n    public List<LeafReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<LeafReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          int thingToDo = r.nextInt(7);\n          if (thingToDo == 0) {\n            // simple no-op FilterReader\n            readers.set(i, new FilterLeafReader(readers.get(i)));\n          } else if (thingToDo == 1) {\n            // renumber fields\n            // NOTE: currently this only \"blocks\" bulk merges just by\n            // being a FilterReader. But it might find bugs elsewhere, \n            // and maybe the situation can be improved in the future.\n            readers.set(i, new MismatchedLeafReader(readers.get(i), r));\n          }\n          // otherwise, reader is unchanged\n        }\n      }\n      return readers;\n    }\n\n","bugFix":["c9fb5f46e264daf5ba3860defe623a89d202dd87","ef658003003b32165df5d5016addcee1da98e4a2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8e7f3c6423c9f64e03c630917e38b85c14ea0bcc","date":1446148297,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","sourceNew":"    @Override\n    public List<CodecReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<CodecReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          // TODO: cut this over to FilterCodecReader api, we can explicitly\n          // enable/disable bulk merge for portions of the index we want.\n          int thingToDo = r.nextInt(7);\n          if (thingToDo == 0) {\n            // simple no-op FilterReader\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new FilterLeafReader(readers.get(i))));\n          } else if (thingToDo == 1) {\n            // renumber fields\n            // NOTE: currently this only \"blocks\" bulk merges just by\n            // being a FilterReader. But it might find bugs elsewhere, \n            // and maybe the situation can be improved in the future.\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(readers.get(i), r)));\n          }\n          // otherwise, reader is unchanged\n        }\n      }\n      return readers;\n    }\n\n","sourceOld":"    @Override\n    public List<CodecReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<CodecReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          // TODO: cut this over to FilterCodecReader api, we can explicitly\n          // enable/disable bulk merge for portions of the index we want.\n          int thingToDo = r.nextInt(7);\n          if (thingToDo == 0) {\n            // simple no-op FilterReader\n            readers.set(i, SlowCodecReaderWrapper.wrap(new FilterLeafReader(readers.get(i))));\n          } else if (thingToDo == 1) {\n            // renumber fields\n            // NOTE: currently this only \"blocks\" bulk merges just by\n            // being a FilterReader. But it might find bugs elsewhere, \n            // and maybe the situation can be improved in the future.\n            readers.set(i, SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(readers.get(i), r)));\n          }\n          // otherwise, reader is unchanged\n        }\n      }\n      return readers;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"153d8ff6911169b9b0d93166e3c48e9c8c7ce523","date":1457458606,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","sourceNew":"    @Override\n    public List<CodecReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<CodecReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          // TODO: cut this over to FilterCodecReader api, we can explicitly\n          // enable/disable bulk merge for portions of the index we want.\n          int thingToDo = r.nextInt(7);\n          if (thingToDo == 0) {\n            // simple no-op FilterReader\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new FilterLeafReader(readers.get(i)) {}));\n          } else if (thingToDo == 1) {\n            // renumber fields\n            // NOTE: currently this only \"blocks\" bulk merges just by\n            // being a FilterReader. But it might find bugs elsewhere, \n            // and maybe the situation can be improved in the future.\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(readers.get(i), r)));\n          }\n          // otherwise, reader is unchanged\n        }\n      }\n      return readers;\n    }\n\n","sourceOld":"    @Override\n    public List<CodecReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<CodecReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          // TODO: cut this over to FilterCodecReader api, we can explicitly\n          // enable/disable bulk merge for portions of the index we want.\n          int thingToDo = r.nextInt(7);\n          if (thingToDo == 0) {\n            // simple no-op FilterReader\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new FilterLeafReader(readers.get(i))));\n          } else if (thingToDo == 1) {\n            // renumber fields\n            // NOTE: currently this only \"blocks\" bulk merges just by\n            // being a FilterReader. But it might find bugs elsewhere, \n            // and maybe the situation can be improved in the future.\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(readers.get(i), r)));\n          }\n          // otherwise, reader is unchanged\n        }\n      }\n      return readers;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ceaef6cfc68c8ab22a684192e469a8280f9e6e70","date":1462354657,"type":4,"author":"Mike McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","sourceNew":null,"sourceOld":"    @Override\n    public List<CodecReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<CodecReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          // TODO: cut this over to FilterCodecReader api, we can explicitly\n          // enable/disable bulk merge for portions of the index we want.\n          int thingToDo = r.nextInt(7);\n          if (thingToDo == 0) {\n            // simple no-op FilterReader\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new FilterLeafReader(readers.get(i)) {}));\n          } else if (thingToDo == 1) {\n            // renumber fields\n            // NOTE: currently this only \"blocks\" bulk merges just by\n            // being a FilterReader. But it might find bugs elsewhere, \n            // and maybe the situation can be improved in the future.\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(readers.get(i), r)));\n          }\n          // otherwise, reader is unchanged\n        }\n      }\n      return readers;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":4,"author":"Mike McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","sourceNew":null,"sourceOld":"    @Override\n    public List<CodecReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<CodecReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          // TODO: cut this over to FilterCodecReader api, we can explicitly\n          // enable/disable bulk merge for portions of the index we want.\n          int thingToDo = r.nextInt(7);\n          if (thingToDo == 0) {\n            // simple no-op FilterReader\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new FilterLeafReader(readers.get(i)) {}));\n          } else if (thingToDo == 1) {\n            // renumber fields\n            // NOTE: currently this only \"blocks\" bulk merges just by\n            // being a FilterReader. But it might find bugs elsewhere, \n            // and maybe the situation can be improved in the future.\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(readers.get(i), r)));\n          }\n          // otherwise, reader is unchanged\n        }\n      }\n      return readers;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","sourceNew":null,"sourceOld":"    @Override\n    public List<CodecReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<CodecReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          // TODO: cut this over to FilterCodecReader api, we can explicitly\n          // enable/disable bulk merge for portions of the index we want.\n          int thingToDo = r.nextInt(7);\n          if (thingToDo == 0) {\n            // simple no-op FilterReader\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new FilterLeafReader(readers.get(i)) {}));\n          } else if (thingToDo == 1) {\n            // renumber fields\n            // NOTE: currently this only \"blocks\" bulk merges just by\n            // being a FilterReader. But it might find bugs elsewhere, \n            // and maybe the situation can be improved in the future.\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(readers.get(i), r)));\n          }\n          // otherwise, reader is unchanged\n        }\n      }\n      return readers;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","sourceNew":null,"sourceOld":"    @Override\n    public List<CodecReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<CodecReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          // TODO: cut this over to FilterCodecReader api, we can explicitly\n          // enable/disable bulk merge for portions of the index we want.\n          int thingToDo = r.nextInt(7);\n          if (thingToDo == 0) {\n            // simple no-op FilterReader\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new FilterLeafReader(readers.get(i)) {}));\n          } else if (thingToDo == 1) {\n            // renumber fields\n            // NOTE: currently this only \"blocks\" bulk merges just by\n            // being a FilterReader. But it might find bugs elsewhere, \n            // and maybe the situation can be improved in the future.\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(readers.get(i), r)));\n          }\n          // otherwise, reader is unchanged\n        }\n      }\n      return readers;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#getMergeReaders().mjava","sourceNew":null,"sourceOld":"    @Override\n    public List<CodecReader> getMergeReaders() throws IOException {\n      if (readers == null) {\n        readers = new ArrayList<CodecReader>(super.getMergeReaders());\n        for (int i = 0; i < readers.size(); i++) {\n          // wrap it (e.g. prevent bulk merge etc)\n          // TODO: cut this over to FilterCodecReader api, we can explicitly\n          // enable/disable bulk merge for portions of the index we want.\n          int thingToDo = r.nextInt(7);\n          if (thingToDo == 0) {\n            // simple no-op FilterReader\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new FilterLeafReader(readers.get(i)) {}));\n          } else if (thingToDo == 1) {\n            // renumber fields\n            // NOTE: currently this only \"blocks\" bulk merges just by\n            // being a FilterReader. But it might find bugs elsewhere, \n            // and maybe the situation can be improved in the future.\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + readers.get(i));\n            }\n            readers.set(i, SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(readers.get(i), r)));\n          }\n          // otherwise, reader is unchanged\n        }\n      }\n      return readers;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"153d8ff6911169b9b0d93166e3c48e9c8c7ce523":["8e7f3c6423c9f64e03c630917e38b85c14ea0bcc"],"8e7f3c6423c9f64e03c630917e38b85c14ea0bcc":["505bff044e47a553f461b6f4484d1d08faf4ac85"],"0ad30c6a479e764150a3316e57263319775f1df2":["153d8ff6911169b9b0d93166e3c48e9c8c7ce523","3d33e731a93d4b57e662ff094f64f94a745422d4"],"505bff044e47a553f461b6f4484d1d08faf4ac85":["ef658003003b32165df5d5016addcee1da98e4a2"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["c9f0b4a920667fa5fce511270c486fd499f7e71a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["153d8ff6911169b9b0d93166e3c48e9c8c7ce523","d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["153d8ff6911169b9b0d93166e3c48e9c8c7ce523","0ad30c6a479e764150a3316e57263319775f1df2"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["153d8ff6911169b9b0d93166e3c48e9c8c7ce523"],"c9f0b4a920667fa5fce511270c486fd499f7e71a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ef658003003b32165df5d5016addcee1da98e4a2":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["153d8ff6911169b9b0d93166e3c48e9c8c7ce523","ceaef6cfc68c8ab22a684192e469a8280f9e6e70"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d470c8182e92b264680e34081b75e70a9f2b3c89"]},"commit2Childs":{"153d8ff6911169b9b0d93166e3c48e9c8c7ce523":["0ad30c6a479e764150a3316e57263319775f1df2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","ceaef6cfc68c8ab22a684192e469a8280f9e6e70","3d33e731a93d4b57e662ff094f64f94a745422d4"],"8e7f3c6423c9f64e03c630917e38b85c14ea0bcc":["153d8ff6911169b9b0d93166e3c48e9c8c7ce523"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"505bff044e47a553f461b6f4484d1d08faf4ac85":["8e7f3c6423c9f64e03c630917e38b85c14ea0bcc"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["ef658003003b32165df5d5016addcee1da98e4a2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"c9f0b4a920667fa5fce511270c486fd499f7e71a":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c9f0b4a920667fa5fce511270c486fd499f7e71a"],"ef658003003b32165df5d5016addcee1da98e4a2":["505bff044e47a553f461b6f4484d1d08faf4ac85"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}