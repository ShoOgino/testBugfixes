{"path":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    MultiThreadedHttpConnectionManager mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(20);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","sourceOld":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    MultiThreadedHttpConnectionManager mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(20);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    MultiThreadedHttpConnectionManager mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(20);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","sourceOld":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    MultiThreadedHttpConnectionManager mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(20);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    MultiThreadedHttpConnectionManager mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(20);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","sourceOld":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    MultiThreadedHttpConnectionManager mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(20);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(20);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","sourceOld":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    MultiThreadedHttpConnectionManager mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(20);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(20);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","sourceOld":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    MultiThreadedHttpConnectionManager mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(20);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(20);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","sourceOld":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    MultiThreadedHttpConnectionManager mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(20);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1324b6aeda174a69f7617eacac3b04a16080ffa7","date":1329925327,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(256);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","sourceOld":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(20);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(256);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","sourceOld":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(20);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4f56c59d1a952768cd14d86f945f7488628b696","date":1331649916,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  public void init(PluginInfo info) {\r\n    NamedList args = info.initArgs;\r\n    this.soTimeout = getParameter(args, INIT_SO_TIMEOUT, 0);\r\n\r\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\r\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\r\n    this.connectionTimeout = getParameter(args, INIT_CONNECTION_TIMEOUT, 0);\r\n    this.maxConnectionsPerHost = getParameter(args, INIT_MAX_CONNECTION_PER_HOST, 20);\r\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, 0);\r\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, Integer.MAX_VALUE);\r\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, 5);\r\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, -1);\r\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, false);\r\n\r\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\r\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\r\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\r\n\r\n    this.commExecutor = new ThreadPoolExecutor(\r\n        this.corePoolSize,\r\n        this.maximumPoolSize,\r\n        this.keepAliveTime, TimeUnit.SECONDS,\r\n        blockingQueue,\r\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\r\n    );\r\n\r\n    mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(this.maxConnectionsPerHost);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(this.connectionTimeout);\r\n    mgr.getParams().setSoTimeout(this.soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\r\n    }\r\n\r\n  }\r\n\n","sourceOld":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(256);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  public void init(PluginInfo info) {\r\n    NamedList args = info.initArgs;\r\n    this.soTimeout = getParameter(args, INIT_SO_TIMEOUT, 0);\r\n\r\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\r\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\r\n    this.connectionTimeout = getParameter(args, INIT_CONNECTION_TIMEOUT, 0);\r\n    this.maxConnectionsPerHost = getParameter(args, INIT_MAX_CONNECTION_PER_HOST, 20);\r\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, 0);\r\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, Integer.MAX_VALUE);\r\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, 5);\r\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, -1);\r\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, false);\r\n\r\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\r\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\r\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\r\n\r\n    this.commExecutor = new ThreadPoolExecutor(\r\n        this.corePoolSize,\r\n        this.maximumPoolSize,\r\n        this.keepAliveTime, TimeUnit.SECONDS,\r\n        blockingQueue,\r\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\r\n    );\r\n\r\n    mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(this.maxConnectionsPerHost);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(this.connectionTimeout);\r\n    mgr.getParams().setSoTimeout(this.soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\r\n    }\r\n\r\n  }\r\n\n","sourceOld":"  public void init(PluginInfo info) {\r\n\r\n    if (info.initArgs != null) {\r\n      Object so = info.initArgs.get(INIT_SO_TIMEOUT);\r\n      if (so != null) {\r\n        soTimeout = (Integer) so;\r\n        log.info(\"Setting socketTimeout to: \" + soTimeout);\r\n      }\r\n\r\n      Object urlScheme = info.initArgs.get(INIT_URL_SCHEME);\r\n      if (urlScheme != null) {\r\n        scheme = urlScheme + \"://\";\r\n        log.info(\"Setting urlScheme to: \" + urlScheme);\r\n      }\r\n      Object co = info.initArgs.get(INIT_CONNECTION_TIMEOUT);\r\n        if (co != null) {\r\n          connectionTimeout = (Integer) co;\r\n          log.info(\"Setting shard-connection-timeout to: \" + connectionTimeout);\r\n        }\r\n    }\r\n    mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(256);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(connectionTimeout);\r\n    mgr.getParams().setSoTimeout(soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);\r\n    }\r\n\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23","date":1332766738,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, INIT_SO_TIMEOUT, 0);\n\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\n    this.connectionTimeout = getParameter(args, INIT_CONNECTION_TIMEOUT, 0);\n    this.maxConnectionsPerHost = getParameter(args, INIT_MAX_CONNECTION_PER_HOST, 20);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, 0);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, Integer.MAX_VALUE);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, 5);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, -1);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, false);\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    mgr = new MultiThreadedHttpConnectionManager();\n    mgr.getParams().setDefaultMaxConnectionsPerHost(this.maxConnectionsPerHost);\n    mgr.getParams().setMaxTotalConnections(10000);\n    mgr.getParams().setConnectionTimeout(this.connectionTimeout);\n    mgr.getParams().setSoTimeout(this.soTimeout);\n    // mgr.getParams().setStaleCheckingEnabled(false);\n\n    client = new HttpClient(mgr);\n\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\n\n    try {\n      loadbalancer = new LBHttpSolrServer(client);\n    } catch (MalformedURLException e) {\n      // should be impossible since we're not passing any URLs here\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n  }\n\n","sourceOld":"  public void init(PluginInfo info) {\r\n    NamedList args = info.initArgs;\r\n    this.soTimeout = getParameter(args, INIT_SO_TIMEOUT, 0);\r\n\r\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\r\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\r\n    this.connectionTimeout = getParameter(args, INIT_CONNECTION_TIMEOUT, 0);\r\n    this.maxConnectionsPerHost = getParameter(args, INIT_MAX_CONNECTION_PER_HOST, 20);\r\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, 0);\r\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, Integer.MAX_VALUE);\r\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, 5);\r\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, -1);\r\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, false);\r\n\r\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\r\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\r\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\r\n\r\n    this.commExecutor = new ThreadPoolExecutor(\r\n        this.corePoolSize,\r\n        this.maximumPoolSize,\r\n        this.keepAliveTime, TimeUnit.SECONDS,\r\n        blockingQueue,\r\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\r\n    );\r\n\r\n    mgr = new MultiThreadedHttpConnectionManager();\r\n    mgr.getParams().setDefaultMaxConnectionsPerHost(this.maxConnectionsPerHost);\r\n    mgr.getParams().setMaxTotalConnections(10000);\r\n    mgr.getParams().setConnectionTimeout(this.connectionTimeout);\r\n    mgr.getParams().setSoTimeout(this.soTimeout);\r\n    // mgr.getParams().setStaleCheckingEnabled(false);\r\n\r\n    client = new HttpClient(mgr);\r\n\r\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\r\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\r\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\r\n\r\n    try {\r\n      loadbalancer = new LBHttpSolrServer(client);\r\n    } catch (MalformedURLException e) {\r\n      // should be impossible since we're not passing any URLs here\r\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\r\n    }\r\n\r\n  }\r\n\n","bugFix":null,"bugIntro":["bb8ae7c34bbb61a8b59bb942d9ce2c1fddbfd149"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7321b77a7bc3edfebd637ef273e9dfaa9969eba6","date":1333023097,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, INIT_SO_TIMEOUT, 0);\n\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\n    this.connectionTimeout = getParameter(args, INIT_CONNECTION_TIMEOUT, 0);\n    this.maxConnectionsPerHost = getParameter(args, INIT_MAX_CONNECTION_PER_HOST, 20);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, 0);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, Integer.MAX_VALUE);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, 5);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, -1);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, false);\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    mgr = new ThreadSafeClientConnManager();\n    mgr.setDefaultMaxPerRoute(256);\n    mgr.setMaxTotal(10000);\n    DefaultHttpClient client = new DefaultHttpClient(mgr);\n    \n    client.getParams().setIntParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, connectionTimeout);\n    client.getParams().setIntParameter(CoreConnectionPNames.SO_TIMEOUT, soTimeout);\n    // mgr.getParams().setStaleCheckingEnabled(false);\n\n\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\n    DefaultHttpRequestRetryHandler retryhandler = new DefaultHttpRequestRetryHandler(0, false);\n    client.setHttpRequestRetryHandler(retryhandler);\n    this.client = client;\n\n    try {\n      loadbalancer = new LBHttpSolrServer(client);\n    } catch (MalformedURLException e) {\n      // should be impossible since we're not passing any URLs here\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n  }\n\n","sourceOld":"  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, INIT_SO_TIMEOUT, 0);\n\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\n    this.connectionTimeout = getParameter(args, INIT_CONNECTION_TIMEOUT, 0);\n    this.maxConnectionsPerHost = getParameter(args, INIT_MAX_CONNECTION_PER_HOST, 20);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, 0);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, Integer.MAX_VALUE);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, 5);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, -1);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, false);\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    mgr = new MultiThreadedHttpConnectionManager();\n    mgr.getParams().setDefaultMaxConnectionsPerHost(this.maxConnectionsPerHost);\n    mgr.getParams().setMaxTotalConnections(10000);\n    mgr.getParams().setConnectionTimeout(this.connectionTimeout);\n    mgr.getParams().setSoTimeout(this.soTimeout);\n    // mgr.getParams().setStaleCheckingEnabled(false);\n\n    client = new HttpClient(mgr);\n\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\n    DefaultHttpMethodRetryHandler retryhandler = new DefaultHttpMethodRetryHandler(0, false);\n    client.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, retryhandler);\n\n    try {\n      loadbalancer = new LBHttpSolrServer(client);\n    } catch (MalformedURLException e) {\n      // should be impossible since we're not passing any URLs here\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eb99886ff640d94edb43e0d36112a2b7023379ba","date":1338292884,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n\n    try {\n      loadbalancer = new LBHttpSolrServer(defaultClient);\n    } catch (MalformedURLException e) {\n      // should be impossible since we're not passing any URLs here\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n  }\n\n","sourceOld":"  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, INIT_SO_TIMEOUT, 0);\n\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\n    this.connectionTimeout = getParameter(args, INIT_CONNECTION_TIMEOUT, 0);\n    this.maxConnectionsPerHost = getParameter(args, INIT_MAX_CONNECTION_PER_HOST, 20);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, 0);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, Integer.MAX_VALUE);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, 5);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, -1);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, false);\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    mgr = new ThreadSafeClientConnManager();\n    mgr.setDefaultMaxPerRoute(256);\n    mgr.setMaxTotal(10000);\n    DefaultHttpClient client = new DefaultHttpClient(mgr);\n    \n    client.getParams().setIntParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, connectionTimeout);\n    client.getParams().setIntParameter(CoreConnectionPNames.SO_TIMEOUT, soTimeout);\n    // mgr.getParams().setStaleCheckingEnabled(false);\n\n\n    // prevent retries  (note: this didn't work when set on mgr.. needed to be set on client)\n    DefaultHttpRequestRetryHandler retryhandler = new DefaultHttpRequestRetryHandler(0, false);\n    client.setHttpRequestRetryHandler(retryhandler);\n    this.client = client;\n\n    try {\n      loadbalancer = new LBHttpSolrServer(client);\n    } catch (MalformedURLException e) {\n      // should be impossible since we're not passing any URLs here\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["1491861ccc4b32acaaafd00c1b50fb7babb02475"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n\n    try {\n      loadbalancer = new LBHttpSolrServer(defaultClient);\n    } catch (MalformedURLException e) {\n      // should be impossible since we're not passing any URLs here\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n  }\n\n","sourceOld":"  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n\n    try {\n      loadbalancer = new LBHttpSolrServer(defaultClient);\n    } catch (MalformedURLException e) {\n      // should be impossible since we're not passing any URLs here\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n\n    try {\n      loadbalancer = new LBHttpSolrServer(defaultClient);\n    } catch (MalformedURLException e) {\n      // should be impossible since we're not passing any URLs here\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n  }\n\n","sourceOld":"  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n\n    try {\n      loadbalancer = new LBHttpSolrServer(defaultClient);\n    } catch (MalformedURLException e) {\n      // should be impossible since we're not passing any URLs here\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0383cd09ec14aa4b39144430fd2bf7f866eb5ec","date":1363621241,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n\n    try {\n      loadbalancer = new LBHttpSolrServer(defaultClient);\n    } catch (MalformedURLException e) {\n      // should be impossible since we're not passing any URLs here\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n\n    try {\n      loadbalancer = new LBHttpSolrServer(defaultClient);\n    } catch (MalformedURLException e) {\n      // should be impossible since we're not passing any URLs here\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ff889f7c560e8a5cb81e263dfbcd1969af264e91","date":1368566992,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n\n    try {\n      loadbalancer = new LBHttpSolrServer(defaultClient);\n    } catch (MalformedURLException e) {\n      // should be impossible since we're not passing any URLs here\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72","date":1391985588,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, \"http://\");\n    this.scheme = (this.scheme.endsWith(\"://\")) ? this.scheme : this.scheme + \"://\";\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"df9c6da750bc12500a6d690ef55677c5271cc949","date":1412873231,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1491861ccc4b32acaaafd00c1b50fb7babb02475","date":1421260700,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n    this.useRetries = getParameter(args, USE_RETRIES, useRetries);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    if (!useRetries) {\n      clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    }\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    // must come after createClient\n    if (useRetries) {\n      // our default retry handler will never retry on IOException if the request has been sent already,\n      // but for these read only requests we can use the standard DefaultHttpRequestRetryHandler rules\n      ((DefaultHttpClient) this.defaultClient).setHttpRequestRetryHandler(new DefaultHttpRequestRetryHandler());\n    }\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":["eb99886ff640d94edb43e0d36112a2b7023379ba"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cb5af3afeddbb803fb785098176e6e177c34261b","date":1428905393,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n    this.useRetries = getParameter(args, USE_RETRIES, useRetries);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    if (!useRetries) {\n      clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    }\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    // must come after createClient\n    if (useRetries) {\n      // our default retry handler will never retry on IOException if the request has been sent already,\n      // but for these read only requests we can use the standard DefaultHttpRequestRetryHandler rules\n      ((DefaultHttpClient) this.defaultClient).setHttpRequestRetryHandler(new DefaultHttpRequestRetryHandler());\n    }\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n    this.useRetries = getParameter(args, USE_RETRIES, useRetries);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    if (!useRetries) {\n      clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    }\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    // must come after createClient\n    if (useRetries) {\n      // our default retry handler will never retry on IOException if the request has been sent already,\n      // but for these read only requests we can use the standard DefaultHttpRequestRetryHandler rules\n      ((DefaultHttpClient) this.defaultClient).setHttpRequestRetryHandler(new DefaultHttpRequestRetryHandler());\n    }\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c87b8f26e8c285df0964e77bd977f3d53cf6c0d9","date":1428989171,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.useRetries = getParameter(args, USE_RETRIES, useRetries,sb);\n    log.info(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    if (!useRetries) {\n      clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    }\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    // must come after createClient\n    if (useRetries) {\n      // our default retry handler will never retry on IOException if the request has been sent already,\n      // but for these read only requests we can use the standard DefaultHttpRequestRetryHandler rules\n      ((DefaultHttpClient) this.defaultClient).setHttpRequestRetryHandler(new DefaultHttpRequestRetryHandler());\n    }\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy);\n    this.useRetries = getParameter(args, USE_RETRIES, useRetries);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    if (!useRetries) {\n      clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    }\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    // must come after createClient\n    if (useRetries) {\n      // our default retry handler will never retry on IOException if the request has been sent already,\n      // but for these read only requests we can use the standard DefaultHttpRequestRetryHandler rules\n      ((DefaultHttpClient) this.defaultClient).setHttpRequestRetryHandler(new DefaultHttpRequestRetryHandler());\n    }\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58b7eb80017f1c5b32035176b965fa0cc0287d04","date":1432069816,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.useRetries = getParameter(args, USE_RETRIES, useRetries,sb);\n    log.info(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    // must come after createClient\n    if (useRetries) {\n      // our default retry handler will never retry on IOException if the request has been sent already,\n      // but for these read only requests we can use the standard DefaultHttpRequestRetryHandler rules\n      ((DefaultHttpClient) this.defaultClient).setHttpRequestRetryHandler(new DefaultHttpRequestRetryHandler());\n    }\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.useRetries = getParameter(args, USE_RETRIES, useRetries,sb);\n    log.info(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = new ModifiableSolrParams();\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n    clientParams.set(HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n    clientParams.set(HttpClientUtil.PROP_SO_TIMEOUT, soTimeout);\n    clientParams.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n    if (!useRetries) {\n      clientParams.set(HttpClientUtil.PROP_USE_RETRY, false);\n    }\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    // must come after createClient\n    if (useRetries) {\n      // our default retry handler will never retry on IOException if the request has been sent already,\n      // but for these read only requests we can use the standard DefaultHttpRequestRetryHandler rules\n      ((DefaultHttpClient) this.defaultClient).setHttpRequestRetryHandler(new DefaultHttpRequestRetryHandler());\n    }\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"859081acf00749f5dd462772c571d611d4a4d2db","date":1459527719,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.info(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.useRetries = getParameter(args, USE_RETRIES, useRetries,sb);\n    log.info(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    // must come after createClient\n    if (useRetries) {\n      // our default retry handler will never retry on IOException if the request has been sent already,\n      // but for these read only requests we can use the standard DefaultHttpRequestRetryHandler rules\n      ((DefaultHttpClient) this.defaultClient).setHttpRequestRetryHandler(new DefaultHttpRequestRetryHandler());\n    }\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7f0c8426396c925de8db3ed3f8ff40fd73670a5c","date":1474556641,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.info(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"126d6ad24eed13163ba0959435d5a80e5672837c","date":1474567302,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.info(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.info(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.info(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16fa358573e3c2508728b3c7c438a8c19a3f0ae4","date":1482846144,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n    httpRequestExecutor = new InstrumentedHttpRequestExecutor();\n    clientConnectionManager = new InstrumentedPoolingHttpClientConnectionManager(HttpClientUtil.getSchemaRegisteryProvider().getSchemaRegistry());\n    this.defaultClient = HttpClientUtil.createClient(clientParams, clientConnectionManager, false, httpRequestExecutor);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n    httpRequestExecutor = new InstrumentedHttpRequestExecutor();\n    clientConnectionManager = new InstrumentedPoolingHttpClientConnectionManager(HttpClientUtil.getSchemaRegisteryProvider().getSchemaRegistry());\n    this.defaultClient = HttpClientUtil.createClient(clientParams, clientConnectionManager, false, httpRequestExecutor);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n\n    this.defaultClient = HttpClientUtil.createClient(clientParams);\n    \n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc0351e5a64998aa87ebea3be11fca66075eb1b0","date":1484206200,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n    httpRequestExecutor = new InstrumentedHttpRequestExecutor(this.metricNameStrategy);\n    clientConnectionManager = new InstrumentedPoolingHttpClientConnectionManager(HttpClientUtil.getSchemaRegisteryProvider().getSchemaRegistry());\n    this.defaultClient = HttpClientUtil.createClient(clientParams, clientConnectionManager, false, httpRequestExecutor);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n    httpRequestExecutor = new InstrumentedHttpRequestExecutor();\n    clientConnectionManager = new InstrumentedPoolingHttpClientConnectionManager(HttpClientUtil.getSchemaRegisteryProvider().getSchemaRegistry());\n    this.defaultClient = HttpClientUtil.createClient(clientParams, clientConnectionManager, false, httpRequestExecutor);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n    httpRequestExecutor = new InstrumentedHttpRequestExecutor(this.metricNameStrategy);\n    clientConnectionManager = new InstrumentedPoolingHttpClientConnectionManager(HttpClientUtil.getSchemaRegisteryProvider().getSchemaRegistry());\n    this.defaultClient = HttpClientUtil.createClient(clientParams, clientConnectionManager, false, httpRequestExecutor);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n    httpRequestExecutor = new InstrumentedHttpRequestExecutor();\n    clientConnectionManager = new InstrumentedPoolingHttpClientConnectionManager(HttpClientUtil.getSchemaRegisteryProvider().getSchemaRegistry());\n    this.defaultClient = HttpClientUtil.createClient(clientParams, clientConnectionManager, false, httpRequestExecutor);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec1fd3cd1aa9782d426f1d542ff0a618ce9bbe10","date":1495727205,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n    httpRequestExecutor = new InstrumentedHttpRequestExecutor(this.metricNameStrategy);\n    clientConnectionManager = new InstrumentedPoolingHttpClientConnectionManager(HttpClientUtil.getSchemaRegisteryProvider().getSchemaRegistry());\n    this.defaultClient = HttpClientUtil.createClient(clientParams, clientConnectionManager, false, httpRequestExecutor);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n    httpRequestExecutor = new InstrumentedHttpRequestExecutor(this.metricNameStrategy);\n    clientConnectionManager = new InstrumentedPoolingHttpClientConnectionManager(HttpClientUtil.getSchemaRegisteryProvider().getSchemaRegistry());\n    this.defaultClient = HttpClientUtil.createClient(clientParams, clientConnectionManager, false, httpRequestExecutor);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1f5728f32a4a256b36cfabd7a2636452f599bb9","date":1496231774,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n    httpRequestExecutor = new InstrumentedHttpRequestExecutor(this.metricNameStrategy);\n    clientConnectionManager = new InstrumentedPoolingHttpClientConnectionManager(HttpClientUtil.getSchemaRegisteryProvider().getSchemaRegistry());\n    this.defaultClient = HttpClientUtil.createClient(clientParams, clientConnectionManager, false, httpRequestExecutor);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n    httpRequestExecutor = new InstrumentedHttpRequestExecutor(this.metricNameStrategy);\n    clientConnectionManager = new InstrumentedPoolingHttpClientConnectionManager(HttpClientUtil.getSchemaRegisteryProvider().getSchemaRegistry());\n    this.defaultClient = HttpClientUtil.createClient(clientParams, clientConnectionManager, false, httpRequestExecutor);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n    httpRequestExecutor = new InstrumentedHttpRequestExecutor(this.metricNameStrategy);\n    clientConnectionManager = new InstrumentedPoolingHttpClientConnectionManager(HttpClientUtil.getSchemaRegisteryProvider().getSchemaRegistry());\n    this.defaultClient = HttpClientUtil.createClient(clientParams, clientConnectionManager, false, httpRequestExecutor);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n    httpRequestExecutor = new InstrumentedHttpRequestExecutor(this.metricNameStrategy);\n    clientConnectionManager = new InstrumentedPoolingHttpClientConnectionManager(HttpClientUtil.getSchemaRegisteryProvider().getSchemaRegistry());\n    this.defaultClient = HttpClientUtil.createClient(clientParams, clientConnectionManager, false, httpRequestExecutor);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    this.httpListenerFactory = new InstrumentedHttpListenerFactory(this.metricNameStrategy);\n    int connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT,\n        HttpClientUtil.DEFAULT_CONNECT_TIMEOUT, sb);\n    int maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST,\n        HttpClientUtil.DEFAULT_MAXCONNECTIONSPERHOST, sb);\n    int soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT,\n        HttpClientUtil.DEFAULT_SO_TIMEOUT, sb);\n\n    this.defaultClient = new Http2SolrClient.Builder()\n        .connectionTimeout(connectionTimeout)\n        .idleTimeout(soTimeout)\n        .maxConnectionsPerHost(maxConnectionsPerHost).build();\n    this.defaultClient.addListenerFactory(this.httpListenerFactory);\n    this.loadbalancer = new LBHttp2SolrClient(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT, soTimeout,sb);\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout, sb);\n    this.maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost,sb);\n    this.maxConnections = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections,sb);\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    ModifiableSolrParams clientParams = getClientParams();\n    httpRequestExecutor = new InstrumentedHttpRequestExecutor(this.metricNameStrategy);\n    clientConnectionManager = new InstrumentedPoolingHttpClientConnectionManager(HttpClientUtil.getSchemaRegisteryProvider().getSchemaRegistry());\n    this.defaultClient = HttpClientUtil.createClient(clientParams, clientConnectionManager, false, httpRequestExecutor);\n    this.loadbalancer = createLoadbalancer(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d51e7db479b42602c7e23ba871b177387268179","date":1547581497,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.whitelistHostChecker = new WhitelistHostChecker(args == null? null: (String) args.get(INIT_SHARDS_WHITELIST), !getDisableShardsWhitelist());\n    log.info(\"Host whitelist initialized: {}\", this.whitelistHostChecker);\n    \n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    this.httpListenerFactory = new InstrumentedHttpListenerFactory(this.metricNameStrategy);\n    int connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT,\n        HttpClientUtil.DEFAULT_CONNECT_TIMEOUT, sb);\n    int maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST,\n        HttpClientUtil.DEFAULT_MAXCONNECTIONSPERHOST, sb);\n    int soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT,\n        HttpClientUtil.DEFAULT_SO_TIMEOUT, sb);\n\n    this.defaultClient = new Http2SolrClient.Builder()\n        .connectionTimeout(connectionTimeout)\n        .idleTimeout(soTimeout)\n        .maxConnectionsPerHost(maxConnectionsPerHost).build();\n    this.defaultClient.addListenerFactory(this.httpListenerFactory);\n    this.loadbalancer = new LBHttp2SolrClient(defaultClient);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    this.httpListenerFactory = new InstrumentedHttpListenerFactory(this.metricNameStrategy);\n    int connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT,\n        HttpClientUtil.DEFAULT_CONNECT_TIMEOUT, sb);\n    int maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST,\n        HttpClientUtil.DEFAULT_MAXCONNECTIONSPERHOST, sb);\n    int soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT,\n        HttpClientUtil.DEFAULT_SO_TIMEOUT, sb);\n\n    this.defaultClient = new Http2SolrClient.Builder()\n        .connectionTimeout(connectionTimeout)\n        .idleTimeout(soTimeout)\n        .maxConnectionsPerHost(maxConnectionsPerHost).build();\n    this.defaultClient.addListenerFactory(this.httpListenerFactory);\n    this.loadbalancer = new LBHttp2SolrClient(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"78d42a7a80ee59932aca8a1fe42b53cf202e75ad","date":1566412272,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.whitelistHostChecker = new WhitelistHostChecker(args == null? null: (String) args.get(INIT_SHARDS_WHITELIST), !getDisableShardsWhitelist());\n    log.info(\"Host whitelist initialized: {}\", this.whitelistHostChecker);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    this.httpListenerFactory = new InstrumentedHttpListenerFactory(this.metricNameStrategy);\n    int connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT,\n        HttpClientUtil.DEFAULT_CONNECT_TIMEOUT, sb);\n    int maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST,\n        HttpClientUtil.DEFAULT_MAXCONNECTIONSPERHOST, sb);\n    int soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT,\n        HttpClientUtil.DEFAULT_SO_TIMEOUT, sb);\n\n    this.defaultClient = new Http2SolrClient.Builder()\n        .connectionTimeout(connectionTimeout)\n        .idleTimeout(soTimeout)\n        .maxConnectionsPerHost(maxConnectionsPerHost).build();\n    this.defaultClient.addListenerFactory(this.httpListenerFactory);\n    this.loadbalancer = new LBHttp2SolrClient(defaultClient);\n\n    initReplicaListTransformers(getParameter(args, \"replicaRouting\", null, sb));\n\n    log.debug(\"created with {}\",sb);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.whitelistHostChecker = new WhitelistHostChecker(args == null? null: (String) args.get(INIT_SHARDS_WHITELIST), !getDisableShardsWhitelist());\n    log.info(\"Host whitelist initialized: {}\", this.whitelistHostChecker);\n    \n    log.debug(\"created with {}\",sb);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    this.httpListenerFactory = new InstrumentedHttpListenerFactory(this.metricNameStrategy);\n    int connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT,\n        HttpClientUtil.DEFAULT_CONNECT_TIMEOUT, sb);\n    int maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST,\n        HttpClientUtil.DEFAULT_MAXCONNECTIONSPERHOST, sb);\n    int soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT,\n        HttpClientUtil.DEFAULT_SO_TIMEOUT, sb);\n\n    this.defaultClient = new Http2SolrClient.Builder()\n        .connectionTimeout(connectionTimeout)\n        .idleTimeout(soTimeout)\n        .maxConnectionsPerHost(maxConnectionsPerHost).build();\n    this.defaultClient.addListenerFactory(this.httpListenerFactory);\n    this.loadbalancer = new LBHttp2SolrClient(defaultClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"833432c363468a5df50f87446a68015404b1fbcf","date":1572302961,"type":3,"author":"Houston Putman","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.whitelistHostChecker = new WhitelistHostChecker(args == null? null: (String) args.get(INIT_SHARDS_WHITELIST), !getDisableShardsWhitelist());\n    log.info(\"Host whitelist initialized: {}\", this.whitelistHostChecker);\n\n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    this.httpListenerFactory = new InstrumentedHttpListenerFactory(this.metricNameStrategy);\n    int connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT,\n        HttpClientUtil.DEFAULT_CONNECT_TIMEOUT, sb);\n    int maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST,\n        HttpClientUtil.DEFAULT_MAXCONNECTIONSPERHOST, sb);\n    int soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT,\n        HttpClientUtil.DEFAULT_SO_TIMEOUT, sb);\n\n    this.defaultClient = new Http2SolrClient.Builder()\n        .connectionTimeout(connectionTimeout)\n        .idleTimeout(soTimeout)\n        .maxConnectionsPerHost(maxConnectionsPerHost).build();\n    this.defaultClient.addListenerFactory(this.httpListenerFactory);\n    this.loadbalancer = new LBHttp2SolrClient(defaultClient);\n\n    initReplicaListTransformers(getParameter(args, \"replicaRouting\", null, sb));\n\n    log.debug(\"created with {}\",sb);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.whitelistHostChecker = new WhitelistHostChecker(args == null? null: (String) args.get(INIT_SHARDS_WHITELIST), !getDisableShardsWhitelist());\n    log.info(\"Host whitelist initialized: {}\", this.whitelistHostChecker);\n    \n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    this.httpListenerFactory = new InstrumentedHttpListenerFactory(this.metricNameStrategy);\n    int connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT,\n        HttpClientUtil.DEFAULT_CONNECT_TIMEOUT, sb);\n    int maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST,\n        HttpClientUtil.DEFAULT_MAXCONNECTIONSPERHOST, sb);\n    int soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT,\n        HttpClientUtil.DEFAULT_SO_TIMEOUT, sb);\n\n    this.defaultClient = new Http2SolrClient.Builder()\n        .connectionTimeout(connectionTimeout)\n        .idleTimeout(soTimeout)\n        .maxConnectionsPerHost(maxConnectionsPerHost).build();\n    this.defaultClient.addListenerFactory(this.httpListenerFactory);\n    this.loadbalancer = new LBHttp2SolrClient(defaultClient);\n\n    initReplicaListTransformers(getParameter(args, \"replicaRouting\", null, sb));\n\n    log.debug(\"created with {}\",sb);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb8ae7c34bbb61a8b59bb942d9ce2c1fddbfd149","date":1586575561,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.whitelistHostChecker = new WhitelistHostChecker(args == null? null: (String) args.get(INIT_SHARDS_WHITELIST), !getDisableShardsWhitelist());\n    log.info(\"Host whitelist initialized: {}\", this.whitelistHostChecker);\n\n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\"),\n        // the Runnable added to this executor handles all exceptions so we disable stack trace collection as an optimization\n        // see SOLR-11880 for more details\n        false\n    );\n\n    this.httpListenerFactory = new InstrumentedHttpListenerFactory(this.metricNameStrategy);\n    int connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT,\n        HttpClientUtil.DEFAULT_CONNECT_TIMEOUT, sb);\n    int maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST,\n        HttpClientUtil.DEFAULT_MAXCONNECTIONSPERHOST, sb);\n    int soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT,\n        HttpClientUtil.DEFAULT_SO_TIMEOUT, sb);\n\n    this.defaultClient = new Http2SolrClient.Builder()\n        .connectionTimeout(connectionTimeout)\n        .idleTimeout(soTimeout)\n        .maxConnectionsPerHost(maxConnectionsPerHost).build();\n    this.defaultClient.addListenerFactory(this.httpListenerFactory);\n    this.loadbalancer = new LBHttp2SolrClient(defaultClient);\n\n    initReplicaListTransformers(getParameter(args, \"replicaRouting\", null, sb));\n\n    log.debug(\"created with {}\",sb);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.whitelistHostChecker = new WhitelistHostChecker(args == null? null: (String) args.get(INIT_SHARDS_WHITELIST), !getDisableShardsWhitelist());\n    log.info(\"Host whitelist initialized: {}\", this.whitelistHostChecker);\n\n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\")\n    );\n\n    this.httpListenerFactory = new InstrumentedHttpListenerFactory(this.metricNameStrategy);\n    int connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT,\n        HttpClientUtil.DEFAULT_CONNECT_TIMEOUT, sb);\n    int maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST,\n        HttpClientUtil.DEFAULT_MAXCONNECTIONSPERHOST, sb);\n    int soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT,\n        HttpClientUtil.DEFAULT_SO_TIMEOUT, sb);\n\n    this.defaultClient = new Http2SolrClient.Builder()\n        .connectionTimeout(connectionTimeout)\n        .idleTimeout(soTimeout)\n        .maxConnectionsPerHost(maxConnectionsPerHost).build();\n    this.defaultClient.addListenerFactory(this.httpListenerFactory);\n    this.loadbalancer = new LBHttp2SolrClient(defaultClient);\n\n    initReplicaListTransformers(getParameter(args, \"replicaRouting\", null, sb));\n\n    log.debug(\"created with {}\",sb);\n  }\n\n","bugFix":["5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.whitelistHostChecker = new WhitelistHostChecker(args == null? null: (String) args.get(INIT_SHARDS_WHITELIST), !getDisableShardsWhitelist());\n    log.info(\"Host whitelist initialized: {}\", this.whitelistHostChecker);\n\n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new SolrNamedThreadFactory(\"httpShardExecutor\"),\n        // the Runnable added to this executor handles all exceptions so we disable stack trace collection as an optimization\n        // see SOLR-11880 for more details\n        false\n    );\n\n    this.httpListenerFactory = new InstrumentedHttpListenerFactory(this.metricNameStrategy);\n    int connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT,\n        HttpClientUtil.DEFAULT_CONNECT_TIMEOUT, sb);\n    int maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST,\n        HttpClientUtil.DEFAULT_MAXCONNECTIONSPERHOST, sb);\n    int soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT,\n        HttpClientUtil.DEFAULT_SO_TIMEOUT, sb);\n\n    this.defaultClient = new Http2SolrClient.Builder()\n        .connectionTimeout(connectionTimeout)\n        .idleTimeout(soTimeout)\n        .maxConnectionsPerHost(maxConnectionsPerHost).build();\n    this.defaultClient.addListenerFactory(this.httpListenerFactory);\n    this.loadbalancer = new LBHttp2SolrClient(defaultClient);\n\n    initReplicaListTransformers(getParameter(args, \"replicaRouting\", null, sb));\n\n    log.debug(\"created with {}\",sb);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.whitelistHostChecker = new WhitelistHostChecker(args == null? null: (String) args.get(INIT_SHARDS_WHITELIST), !getDisableShardsWhitelist());\n    log.info(\"Host whitelist initialized: {}\", this.whitelistHostChecker);\n\n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new DefaultSolrThreadFactory(\"httpShardExecutor\"),\n        // the Runnable added to this executor handles all exceptions so we disable stack trace collection as an optimization\n        // see SOLR-11880 for more details\n        false\n    );\n\n    this.httpListenerFactory = new InstrumentedHttpListenerFactory(this.metricNameStrategy);\n    int connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT,\n        HttpClientUtil.DEFAULT_CONNECT_TIMEOUT, sb);\n    int maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST,\n        HttpClientUtil.DEFAULT_MAXCONNECTIONSPERHOST, sb);\n    int soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT,\n        HttpClientUtil.DEFAULT_SO_TIMEOUT, sb);\n\n    this.defaultClient = new Http2SolrClient.Builder()\n        .connectionTimeout(connectionTimeout)\n        .idleTimeout(soTimeout)\n        .maxConnectionsPerHost(maxConnectionsPerHost).build();\n    this.defaultClient.addListenerFactory(this.httpListenerFactory);\n    this.loadbalancer = new LBHttp2SolrClient(defaultClient);\n\n    initReplicaListTransformers(getParameter(args, \"replicaRouting\", null, sb));\n\n    log.debug(\"created with {}\",sb);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8582f07e9350eaeb33bf6c4617b8c9895d99c839","date":1591307386,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList args = info.initArgs;\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.whitelistHostChecker = new WhitelistHostChecker(args == null? null: (String) args.get(INIT_SHARDS_WHITELIST), !getDisableShardsWhitelist());\n    log.info(\"Host whitelist initialized: {}\", this.whitelistHostChecker);\n\n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new SolrNamedThreadFactory(\"httpShardExecutor\"),\n        // the Runnable added to this executor handles all exceptions so we disable stack trace collection as an optimization\n        // see SOLR-11880 for more details\n        false\n    );\n\n    this.httpListenerFactory = new InstrumentedHttpListenerFactory(this.metricNameStrategy);\n    int connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT,\n        HttpClientUtil.DEFAULT_CONNECT_TIMEOUT, sb);\n    int maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST,\n        HttpClientUtil.DEFAULT_MAXCONNECTIONSPERHOST, sb);\n    int soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT,\n        HttpClientUtil.DEFAULT_SO_TIMEOUT, sb);\n\n    this.defaultClient = new Http2SolrClient.Builder()\n        .connectionTimeout(connectionTimeout)\n        .idleTimeout(soTimeout)\n        .maxConnectionsPerHost(maxConnectionsPerHost).build();\n    this.defaultClient.addListenerFactory(this.httpListenerFactory);\n    this.loadbalancer = new LBHttp2SolrClient(defaultClient);\n\n    initReplicaListTransformers(getParameter(args, \"replicaRouting\", null, sb));\n\n    log.debug(\"created with {}\",sb);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    NamedList args = info.initArgs;\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.whitelistHostChecker = new WhitelistHostChecker(args == null? null: (String) args.get(INIT_SHARDS_WHITELIST), !getDisableShardsWhitelist());\n    log.info(\"Host whitelist initialized: {}\", this.whitelistHostChecker);\n\n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new SolrNamedThreadFactory(\"httpShardExecutor\"),\n        // the Runnable added to this executor handles all exceptions so we disable stack trace collection as an optimization\n        // see SOLR-11880 for more details\n        false\n    );\n\n    this.httpListenerFactory = new InstrumentedHttpListenerFactory(this.metricNameStrategy);\n    int connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT,\n        HttpClientUtil.DEFAULT_CONNECT_TIMEOUT, sb);\n    int maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST,\n        HttpClientUtil.DEFAULT_MAXCONNECTIONSPERHOST, sb);\n    int soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT,\n        HttpClientUtil.DEFAULT_SO_TIMEOUT, sb);\n\n    this.defaultClient = new Http2SolrClient.Builder()\n        .connectionTimeout(connectionTimeout)\n        .idleTimeout(soTimeout)\n        .maxConnectionsPerHost(maxConnectionsPerHost).build();\n    this.defaultClient.addListenerFactory(this.httpListenerFactory);\n    this.loadbalancer = new LBHttp2SolrClient(defaultClient);\n\n    initReplicaListTransformers(getParameter(args, \"replicaRouting\", null, sb));\n\n    log.debug(\"created with {}\",sb);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1964c059f45ae1de1877f9f0fe3ca327ea4218e8","date":1594088246,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandlerFactory#init(PluginInfo).mjava","sourceNew":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList args = info.initArgs;\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.whitelistHostChecker = new WhitelistHostChecker(args == null? null: (String) args.get(INIT_SHARDS_WHITELIST), !getDisableShardsWhitelist());\n    log.info(\"Host whitelist initialized: {}\", this.whitelistHostChecker);\n\n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new SolrNamedThreadFactory(\"httpShardExecutor\"),\n        // the Runnable added to this executor handles all exceptions so we disable stack trace collection as an optimization\n        // see SOLR-11880 for more details\n        false\n    );\n\n    this.httpListenerFactory = new InstrumentedHttpListenerFactory(this.metricNameStrategy);\n    int connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT,\n        HttpClientUtil.DEFAULT_CONNECT_TIMEOUT, sb);\n    int maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST,\n        HttpClientUtil.DEFAULT_MAXCONNECTIONSPERHOST, sb);\n    int soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT,\n        HttpClientUtil.DEFAULT_SO_TIMEOUT, sb);\n\n    this.defaultClient = new Http2SolrClient.Builder()\n        .connectionTimeout(connectionTimeout)\n        .idleTimeout(soTimeout)\n        .withExecutor(commExecutor)\n        .maxConnectionsPerHost(maxConnectionsPerHost).build();\n    this.defaultClient.addListenerFactory(this.httpListenerFactory);\n    this.loadbalancer = new LBHttp2SolrClient(defaultClient);\n\n    initReplicaListTransformers(getParameter(args, \"replicaRouting\", null, sb));\n\n    log.debug(\"created with {}\",sb);\n  }\n\n","sourceOld":"  @Override\n  public void init(PluginInfo info) {\n    StringBuilder sb = new StringBuilder();\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList args = info.initArgs;\n    this.scheme = getParameter(args, INIT_URL_SCHEME, null,sb);\n    if(StringUtils.endsWith(this.scheme, \"://\")) {\n      this.scheme = StringUtils.removeEnd(this.scheme, \"://\");\n    }\n\n    String strategy = getParameter(args, \"metricNameStrategy\", UpdateShardHandlerConfig.DEFAULT_METRICNAMESTRATEGY, sb);\n    this.metricNameStrategy = KNOWN_METRIC_NAME_STRATEGIES.get(strategy);\n    if (this.metricNameStrategy == null)  {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Unknown metricNameStrategy: \" + strategy + \" found. Must be one of: \" + KNOWN_METRIC_NAME_STRATEGIES.keySet());\n    }\n\n    this.corePoolSize = getParameter(args, INIT_CORE_POOL_SIZE, corePoolSize,sb);\n    this.maximumPoolSize = getParameter(args, INIT_MAX_POOL_SIZE, maximumPoolSize,sb);\n    this.keepAliveTime = getParameter(args, MAX_THREAD_IDLE_TIME, keepAliveTime,sb);\n    this.queueSize = getParameter(args, INIT_SIZE_OF_QUEUE, queueSize,sb);\n    this.permittedLoadBalancerRequestsMinimumAbsolute = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MIN_ABSOLUTE,\n        permittedLoadBalancerRequestsMinimumAbsolute,\n        sb);\n    this.permittedLoadBalancerRequestsMaximumFraction = getParameter(\n        args,\n        LOAD_BALANCER_REQUESTS_MAX_FRACTION,\n        permittedLoadBalancerRequestsMaximumFraction,\n        sb);\n    this.accessPolicy = getParameter(args, INIT_FAIRNESS_POLICY, accessPolicy,sb);\n    this.whitelistHostChecker = new WhitelistHostChecker(args == null? null: (String) args.get(INIT_SHARDS_WHITELIST), !getDisableShardsWhitelist());\n    log.info(\"Host whitelist initialized: {}\", this.whitelistHostChecker);\n\n    // magic sysprop to make tests reproducible: set by SolrTestCaseJ4.\n    String v = System.getProperty(\"tests.shardhandler.randomSeed\");\n    if (v != null) {\n      r.setSeed(Long.parseLong(v));\n    }\n\n    BlockingQueue<Runnable> blockingQueue = (this.queueSize == -1) ?\n        new SynchronousQueue<Runnable>(this.accessPolicy) :\n        new ArrayBlockingQueue<Runnable>(this.queueSize, this.accessPolicy);\n\n    this.commExecutor = new ExecutorUtil.MDCAwareThreadPoolExecutor(\n        this.corePoolSize,\n        this.maximumPoolSize,\n        this.keepAliveTime, TimeUnit.SECONDS,\n        blockingQueue,\n        new SolrNamedThreadFactory(\"httpShardExecutor\"),\n        // the Runnable added to this executor handles all exceptions so we disable stack trace collection as an optimization\n        // see SOLR-11880 for more details\n        false\n    );\n\n    this.httpListenerFactory = new InstrumentedHttpListenerFactory(this.metricNameStrategy);\n    int connectionTimeout = getParameter(args, HttpClientUtil.PROP_CONNECTION_TIMEOUT,\n        HttpClientUtil.DEFAULT_CONNECT_TIMEOUT, sb);\n    int maxConnectionsPerHost = getParameter(args, HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST,\n        HttpClientUtil.DEFAULT_MAXCONNECTIONSPERHOST, sb);\n    int soTimeout = getParameter(args, HttpClientUtil.PROP_SO_TIMEOUT,\n        HttpClientUtil.DEFAULT_SO_TIMEOUT, sb);\n\n    this.defaultClient = new Http2SolrClient.Builder()\n        .connectionTimeout(connectionTimeout)\n        .idleTimeout(soTimeout)\n        .maxConnectionsPerHost(maxConnectionsPerHost).build();\n    this.defaultClient.addListenerFactory(this.httpListenerFactory);\n    this.loadbalancer = new LBHttp2SolrClient(defaultClient);\n\n    initReplicaListTransformers(getParameter(args, \"replicaRouting\", null, sb));\n\n    log.debug(\"created with {}\",sb);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["eb99886ff640d94edb43e0d36112a2b7023379ba","7530de27b87b961b51f01bd1299b7004d46e8823"],"1964c059f45ae1de1877f9f0fe3ca327ea4218e8":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"58b7eb80017f1c5b32035176b965fa0cc0287d04":["c87b8f26e8c285df0964e77bd977f3d53cf6c0d9"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","1324b6aeda174a69f7617eacac3b04a16080ffa7"],"c87b8f26e8c285df0964e77bd977f3d53cf6c0d9":["cb5af3afeddbb803fb785098176e6e177c34261b"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"d4f56c59d1a952768cd14d86f945f7488628b696":["1324b6aeda174a69f7617eacac3b04a16080ffa7"],"1491861ccc4b32acaaafd00c1b50fb7babb02475":["df9c6da750bc12500a6d690ef55677c5271cc949"],"fc0351e5a64998aa87ebea3be11fca66075eb1b0":["16fa358573e3c2508728b3c7c438a8c19a3f0ae4"],"7f0c8426396c925de8db3ed3f8ff40fd73670a5c":["859081acf00749f5dd462772c571d611d4a4d2db"],"833432c363468a5df50f87446a68015404b1fbcf":["78d42a7a80ee59932aca8a1fe42b53cf202e75ad"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["fc0351e5a64998aa87ebea3be11fca66075eb1b0","ec1fd3cd1aa9782d426f1d542ff0a618ce9bbe10"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"78d42a7a80ee59932aca8a1fe42b53cf202e75ad":["4d51e7db479b42602c7e23ba871b177387268179"],"1324b6aeda174a69f7617eacac3b04a16080ffa7":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["859081acf00749f5dd462772c571d611d4a4d2db","126d6ad24eed13163ba0959435d5a80e5672837c"],"bb8ae7c34bbb61a8b59bb942d9ce2c1fddbfd149":["833432c363468a5df50f87446a68015404b1fbcf"],"df9c6da750bc12500a6d690ef55677c5271cc949":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72"],"d1f5728f32a4a256b36cfabd7a2636452f599bb9":["fc0351e5a64998aa87ebea3be11fca66075eb1b0","ec1fd3cd1aa9782d426f1d542ff0a618ce9bbe10"],"38e3b736c7ca086d61b7dbb841c905ee115490da":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d4f56c59d1a952768cd14d86f945f7488628b696"],"55980207f1977bd1463465de1659b821347e2fa8":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72","df9c6da750bc12500a6d690ef55677c5271cc949"],"5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23":["d4f56c59d1a952768cd14d86f945f7488628b696"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["f03e4bed5023ec3ef93a771b8888cae991cf448d","fc0351e5a64998aa87ebea3be11fca66075eb1b0"],"d0383cd09ec14aa4b39144430fd2bf7f866eb5ec":["7530de27b87b961b51f01bd1299b7004d46e8823"],"eb99886ff640d94edb43e0d36112a2b7023379ba":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["859081acf00749f5dd462772c571d611d4a4d2db","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","16fa358573e3c2508728b3c7c438a8c19a3f0ae4"],"4d51e7db479b42602c7e23ba871b177387268179":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"859081acf00749f5dd462772c571d611d4a4d2db":["58b7eb80017f1c5b32035176b965fa0cc0287d04"],"126d6ad24eed13163ba0959435d5a80e5672837c":["859081acf00749f5dd462772c571d611d4a4d2db","7f0c8426396c925de8db3ed3f8ff40fd73670a5c"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["ff889f7c560e8a5cb81e263dfbcd1969af264e91"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ff889f7c560e8a5cb81e263dfbcd1969af264e91":["d0383cd09ec14aa4b39144430fd2bf7f866eb5ec"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["bb8ae7c34bbb61a8b59bb942d9ce2c1fddbfd149"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["c26f00b574427b55127e869b935845554afde1fa"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7530de27b87b961b51f01bd1299b7004d46e8823":["eb99886ff640d94edb43e0d36112a2b7023379ba"],"cb5af3afeddbb803fb785098176e6e177c34261b":["1491861ccc4b32acaaafd00c1b50fb7babb02475"],"ec1fd3cd1aa9782d426f1d542ff0a618ce9bbe10":["fc0351e5a64998aa87ebea3be11fca66075eb1b0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1964c059f45ae1de1877f9f0fe3ca327ea4218e8"],"16fa358573e3c2508728b3c7c438a8c19a3f0ae4":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"1964c059f45ae1de1877f9f0fe3ca327ea4218e8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"58b7eb80017f1c5b32035176b965fa0cc0287d04":["859081acf00749f5dd462772c571d611d4a4d2db"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["38e3b736c7ca086d61b7dbb841c905ee115490da"],"c87b8f26e8c285df0964e77bd977f3d53cf6c0d9":["58b7eb80017f1c5b32035176b965fa0cc0287d04"],"c26f00b574427b55127e869b935845554afde1fa":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"d4f56c59d1a952768cd14d86f945f7488628b696":["38e3b736c7ca086d61b7dbb841c905ee115490da","5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23"],"1491861ccc4b32acaaafd00c1b50fb7babb02475":["cb5af3afeddbb803fb785098176e6e177c34261b"],"fc0351e5a64998aa87ebea3be11fca66075eb1b0":["e9017cf144952056066919f1ebc7897ff9bd71b1","d1f5728f32a4a256b36cfabd7a2636452f599bb9","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","ec1fd3cd1aa9782d426f1d542ff0a618ce9bbe10"],"7f0c8426396c925de8db3ed3f8ff40fd73670a5c":["126d6ad24eed13163ba0959435d5a80e5672837c"],"833432c363468a5df50f87446a68015404b1fbcf":["bb8ae7c34bbb61a8b59bb942d9ce2c1fddbfd149"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["4d51e7db479b42602c7e23ba871b177387268179"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"78d42a7a80ee59932aca8a1fe42b53cf202e75ad":["833432c363468a5df50f87446a68015404b1fbcf"],"1324b6aeda174a69f7617eacac3b04a16080ffa7":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d4f56c59d1a952768cd14d86f945f7488628b696"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","16fa358573e3c2508728b3c7c438a8c19a3f0ae4"],"bb8ae7c34bbb61a8b59bb942d9ce2c1fddbfd149":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"df9c6da750bc12500a6d690ef55677c5271cc949":["1491861ccc4b32acaaafd00c1b50fb7babb02475","55980207f1977bd1463465de1659b821347e2fa8"],"d1f5728f32a4a256b36cfabd7a2636452f599bb9":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"55980207f1977bd1463465de1659b821347e2fa8":[],"5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["eb99886ff640d94edb43e0d36112a2b7023379ba"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"eb99886ff640d94edb43e0d36112a2b7023379ba":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"d0383cd09ec14aa4b39144430fd2bf7f866eb5ec":["ff889f7c560e8a5cb81e263dfbcd1969af264e91"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f03e4bed5023ec3ef93a771b8888cae991cf448d"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["1964c059f45ae1de1877f9f0fe3ca327ea4218e8"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"4d51e7db479b42602c7e23ba871b177387268179":["78d42a7a80ee59932aca8a1fe42b53cf202e75ad"],"859081acf00749f5dd462772c571d611d4a4d2db":["7f0c8426396c925de8db3ed3f8ff40fd73670a5c","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","126d6ad24eed13163ba0959435d5a80e5672837c"],"126d6ad24eed13163ba0959435d5a80e5672837c":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["df9c6da750bc12500a6d690ef55677c5271cc949","55980207f1977bd1463465de1659b821347e2fa8"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"ff889f7c560e8a5cb81e263dfbcd1969af264e91":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0d22ac6a4146774c1bc8400160fc0b6150294e92","1324b6aeda174a69f7617eacac3b04a16080ffa7","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d0383cd09ec14aa4b39144430fd2bf7f866eb5ec"],"cb5af3afeddbb803fb785098176e6e177c34261b":["c87b8f26e8c285df0964e77bd977f3d53cf6c0d9"],"ec1fd3cd1aa9782d426f1d542ff0a618ce9bbe10":["e9017cf144952056066919f1ebc7897ff9bd71b1","d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"16fa358573e3c2508728b3c7c438a8c19a3f0ae4":["fc0351e5a64998aa87ebea3be11fca66075eb1b0","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","e9017cf144952056066919f1ebc7897ff9bd71b1","0d22ac6a4146774c1bc8400160fc0b6150294e92","38e3b736c7ca086d61b7dbb841c905ee115490da","55980207f1977bd1463465de1659b821347e2fa8","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}