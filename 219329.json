{"path":"lucene/sandbox/src/java/org/apache/lucene/search/MultiRangeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","commits":[{"id":"bc29621aa343e88cbc47d168a1d556972a8d3851","date":1564149243,"type":0,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/MultiRangeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this, boost) {\n\n      private PointValues.IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new PointValues.IntersectVisitor() {\n\n          DocIdSetBuilder.BulkAdder adder;\n\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n\n          @Override\n          public void visit(int docID) {\n            adder.add(docID);\n          }\n\n          @Override\n          public void visit(int docID, byte[] packedValue) {\n            // If a single OR clause has the value in range, the entire query accepts the value\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n                if ((Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                  (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  // Doc is in-bounds. Add and short circuit\n                  adder.add(docID);\n                  return;\n                }\n                // Iterate till we have any OR clauses remaining\n              }\n            }\n          }\n\n          @Override\n          public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n            boolean crosses = false;\n\n            /**\n             * CROSSES and INSIDE take priority over OUTSIDE. How we calculate the position is:\n             * 1) If any range sees the point as inside, return INSIDE.\n             * 2) If no range sees the point as inside and atleast one range sees the point as CROSSES, return CROSSES\n             * 3) If none of the above, return OUTSIDE\n             */\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n\n                if ((Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                    (Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  return PointValues.Relation.CELL_INSIDE_QUERY;\n                }\n\n                crosses |= Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) > 0;\n              }\n            }\n\n            if (crosses) {\n              return PointValues.Relation.CELL_CROSSES_QUERY;\n            } else {\n              return PointValues.Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment/field indexed any points\n          return null;\n        }\n\n        if (values.getNumIndexDimensions() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numIndexDimensions=\" + values.getNumIndexDimensions() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != values.getBytesPerDimension()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + values.getBytesPerDimension() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount() == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue();\n          final byte[] fieldPackedUpper = values.getMaxPackedValue();\n          allDocsMatch = true;\n          for (RangeClause rangeClause : rangeClauses) {\n            for (int i = 0; i < numDims; ++i) {\n              int offset = i * bytesPerDim;\n              if (Arrays.compareUnsigned(rangeClause.lowerValue, offset, offset + bytesPerDim, fieldPackedLower, offset, offset + bytesPerDim) > 0\n                  || Arrays.compareUnsigned(rangeClause.upperValue, offset, offset + bytesPerDim, fieldPackedUpper, offset, offset + bytesPerDim) < 0) {\n                allDocsMatch = false;\n                break;\n              }\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final PointValues.IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), scoreMode, iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor) * rangeClauses.size();\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2626561c84f2122279879cd914fdee76f2876bfc","date":1564149243,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/MultiRangeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/MultiRangeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  /*\n   * TODO: Organize ranges similar to how EdgeTree does, to avoid linear scan of ranges\n   */\n  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this, boost) {\n\n      private PointValues.IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new PointValues.IntersectVisitor() {\n\n          DocIdSetBuilder.BulkAdder adder;\n\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n\n          @Override\n          public void visit(int docID) {\n            adder.add(docID);\n          }\n\n          @Override\n          public void visit(int docID, byte[] packedValue) {\n            // If a single OR clause has the value in range, the entire query accepts the value\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n                if ((Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                  (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  // Doc is in-bounds. Add and short circuit\n                  adder.add(docID);\n                  return;\n                }\n                // Iterate till we have any OR clauses remaining\n              }\n            }\n          }\n\n          @Override\n          public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n            boolean crosses = false;\n\n            /**\n             * CROSSES and INSIDE take priority over OUTSIDE. How we calculate the position is:\n             * 1) If any range sees the point as inside, return INSIDE.\n             * 2) If no range sees the point as inside and atleast one range sees the point as CROSSES, return CROSSES\n             * 3) If none of the above, return OUTSIDE\n             */\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n\n                if ((Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                    (Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  return PointValues.Relation.CELL_INSIDE_QUERY;\n                }\n\n                crosses |= Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) > 0;\n              }\n            }\n\n            if (crosses) {\n              return PointValues.Relation.CELL_CROSSES_QUERY;\n            } else {\n              return PointValues.Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment/field indexed any points\n          return null;\n        }\n\n        if (values.getNumIndexDimensions() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numIndexDimensions=\" + values.getNumIndexDimensions() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != values.getBytesPerDimension()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + values.getBytesPerDimension() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount() == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue();\n          final byte[] fieldPackedUpper = values.getMaxPackedValue();\n          allDocsMatch = true;\n          for (RangeClause rangeClause : rangeClauses) {\n            for (int i = 0; i < numDims; ++i) {\n              int offset = i * bytesPerDim;\n              if (Arrays.compareUnsigned(rangeClause.lowerValue, offset, offset + bytesPerDim, fieldPackedLower, offset, offset + bytesPerDim) > 0\n                  || Arrays.compareUnsigned(rangeClause.upperValue, offset, offset + bytesPerDim, fieldPackedUpper, offset, offset + bytesPerDim) < 0) {\n                allDocsMatch = false;\n                break;\n              }\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final PointValues.IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), scoreMode, iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor) * rangeClauses.size();\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this, boost) {\n\n      private PointValues.IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new PointValues.IntersectVisitor() {\n\n          DocIdSetBuilder.BulkAdder adder;\n\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n\n          @Override\n          public void visit(int docID) {\n            adder.add(docID);\n          }\n\n          @Override\n          public void visit(int docID, byte[] packedValue) {\n            // If a single OR clause has the value in range, the entire query accepts the value\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n                if ((Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                  (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  // Doc is in-bounds. Add and short circuit\n                  adder.add(docID);\n                  return;\n                }\n                // Iterate till we have any OR clauses remaining\n              }\n            }\n          }\n\n          @Override\n          public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n            boolean crosses = false;\n\n            /**\n             * CROSSES and INSIDE take priority over OUTSIDE. How we calculate the position is:\n             * 1) If any range sees the point as inside, return INSIDE.\n             * 2) If no range sees the point as inside and atleast one range sees the point as CROSSES, return CROSSES\n             * 3) If none of the above, return OUTSIDE\n             */\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n\n                if ((Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                    (Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  return PointValues.Relation.CELL_INSIDE_QUERY;\n                }\n\n                crosses |= Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) > 0;\n              }\n            }\n\n            if (crosses) {\n              return PointValues.Relation.CELL_CROSSES_QUERY;\n            } else {\n              return PointValues.Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment/field indexed any points\n          return null;\n        }\n\n        if (values.getNumIndexDimensions() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numIndexDimensions=\" + values.getNumIndexDimensions() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != values.getBytesPerDimension()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + values.getBytesPerDimension() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount() == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue();\n          final byte[] fieldPackedUpper = values.getMaxPackedValue();\n          allDocsMatch = true;\n          for (RangeClause rangeClause : rangeClauses) {\n            for (int i = 0; i < numDims; ++i) {\n              int offset = i * bytesPerDim;\n              if (Arrays.compareUnsigned(rangeClause.lowerValue, offset, offset + bytesPerDim, fieldPackedLower, offset, offset + bytesPerDim) > 0\n                  || Arrays.compareUnsigned(rangeClause.upperValue, offset, offset + bytesPerDim, fieldPackedUpper, offset, offset + bytesPerDim) < 0) {\n                allDocsMatch = false;\n                break;\n              }\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final PointValues.IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), scoreMode, iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor) * rangeClauses.size();\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf9da1d4a2d2f04a562030d1d46862163f506f62","date":1566205061,"type":0,"author":"Jim Ferenczi","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/MultiRangeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * TODO: Organize ranges similar to how EdgeTree does, to avoid linear scan of ranges\n   */\n  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this, boost) {\n\n      private PointValues.IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new PointValues.IntersectVisitor() {\n\n          DocIdSetBuilder.BulkAdder adder;\n\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n\n          @Override\n          public void visit(int docID) {\n            adder.add(docID);\n          }\n\n          @Override\n          public void visit(int docID, byte[] packedValue) {\n            // If a single OR clause has the value in range, the entire query accepts the value\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n                if ((Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                  (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  // Doc is in-bounds. Add and short circuit\n                  adder.add(docID);\n                  return;\n                }\n                // Iterate till we have any OR clauses remaining\n              }\n            }\n          }\n\n          @Override\n          public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n            boolean crosses = false;\n\n            /**\n             * CROSSES and INSIDE take priority over OUTSIDE. How we calculate the position is:\n             * 1) If any range sees the point as inside, return INSIDE.\n             * 2) If no range sees the point as inside and atleast one range sees the point as CROSSES, return CROSSES\n             * 3) If none of the above, return OUTSIDE\n             */\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n\n                if ((Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                    (Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  return PointValues.Relation.CELL_INSIDE_QUERY;\n                }\n\n                crosses |= Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) > 0;\n              }\n            }\n\n            if (crosses) {\n              return PointValues.Relation.CELL_CROSSES_QUERY;\n            } else {\n              return PointValues.Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment/field indexed any points\n          return null;\n        }\n\n        if (values.getNumIndexDimensions() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numIndexDimensions=\" + values.getNumIndexDimensions() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != values.getBytesPerDimension()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + values.getBytesPerDimension() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount() == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue();\n          final byte[] fieldPackedUpper = values.getMaxPackedValue();\n          allDocsMatch = true;\n          for (RangeClause rangeClause : rangeClauses) {\n            for (int i = 0; i < numDims; ++i) {\n              int offset = i * bytesPerDim;\n              if (Arrays.compareUnsigned(rangeClause.lowerValue, offset, offset + bytesPerDim, fieldPackedLower, offset, offset + bytesPerDim) > 0\n                  || Arrays.compareUnsigned(rangeClause.upperValue, offset, offset + bytesPerDim, fieldPackedUpper, offset, offset + bytesPerDim) < 0) {\n                allDocsMatch = false;\n                break;\n              }\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final PointValues.IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), scoreMode, iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor) * rangeClauses.size();\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3c09c5c6cd995294d83f12c1bdf8d47d8e749f49","date":1570176835,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/MultiRangeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/MultiRangeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  /*\n   * TODO: Organize ranges similar to how EdgeTree does, to avoid linear scan of ranges\n   */\n  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this, boost) {\n\n      private PointValues.IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new PointValues.IntersectVisitor() {\n\n          DocIdSetBuilder.BulkAdder adder;\n\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n\n          @Override\n          public void visit(int docID) {\n            adder.add(docID);\n          }\n\n          @Override\n          public void visit(int docID, byte[] packedValue) {\n            // If a single OR clause has the value in range, the entire query accepts the value\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n                if ((Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                  (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  // Doc is in-bounds. Add and short circuit\n                  adder.add(docID);\n                  return;\n                }\n                // Iterate till we have any OR clauses remaining\n              }\n            }\n          }\n\n          @Override\n          public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n            boolean crosses = false;\n\n            /**\n             * CROSSES and INSIDE take priority over OUTSIDE. How we calculate the position is:\n             * 1) If any range sees the point as inside, return INSIDE.\n             * 2) If no range sees the point as inside and atleast one range sees the point as CROSSES, return CROSSES\n             * 3) If none of the above, return OUTSIDE\n             */\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n\n                if ((Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                    (Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  return PointValues.Relation.CELL_INSIDE_QUERY;\n                }\n\n                crosses |= Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) > 0;\n              }\n            }\n\n            if (crosses) {\n              return PointValues.Relation.CELL_CROSSES_QUERY;\n            } else {\n              return PointValues.Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment/field indexed any points\n          return null;\n        }\n\n        if (values.getNumIndexDimensions() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numIndexDimensions=\" + values.getNumIndexDimensions() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != values.getBytesPerDimension()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + values.getBytesPerDimension() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount() == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue();\n          final byte[] fieldPackedUpper = values.getMaxPackedValue();\n          allDocsMatch = true;\n          for (RangeClause rangeClause : rangeClauses) {\n            for (int i = 0; i < numDims; ++i) {\n              int offset = i * bytesPerDim;\n              if (Arrays.compareUnsigned(rangeClause.lowerValue, offset, offset + bytesPerDim, fieldPackedLower, offset, offset + bytesPerDim) > 0\n                  || Arrays.compareUnsigned(rangeClause.upperValue, offset, offset + bytesPerDim, fieldPackedUpper, offset, offset + bytesPerDim) < 0) {\n                allDocsMatch = false;\n                break;\n              }\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final PointValues.IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), scoreMode, iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimateDocCount(visitor) * rangeClauses.size();\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n\n    };\n  }\n\n","sourceOld":"  /*\n   * TODO: Organize ranges similar to how EdgeTree does, to avoid linear scan of ranges\n   */\n  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this, boost) {\n\n      private PointValues.IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new PointValues.IntersectVisitor() {\n\n          DocIdSetBuilder.BulkAdder adder;\n\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n\n          @Override\n          public void visit(int docID) {\n            adder.add(docID);\n          }\n\n          @Override\n          public void visit(int docID, byte[] packedValue) {\n            // If a single OR clause has the value in range, the entire query accepts the value\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n                if ((Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                  (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  // Doc is in-bounds. Add and short circuit\n                  adder.add(docID);\n                  return;\n                }\n                // Iterate till we have any OR clauses remaining\n              }\n            }\n          }\n\n          @Override\n          public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n            boolean crosses = false;\n\n            /**\n             * CROSSES and INSIDE take priority over OUTSIDE. How we calculate the position is:\n             * 1) If any range sees the point as inside, return INSIDE.\n             * 2) If no range sees the point as inside and atleast one range sees the point as CROSSES, return CROSSES\n             * 3) If none of the above, return OUTSIDE\n             */\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n\n                if ((Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                    (Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  return PointValues.Relation.CELL_INSIDE_QUERY;\n                }\n\n                crosses |= Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) > 0;\n              }\n            }\n\n            if (crosses) {\n              return PointValues.Relation.CELL_CROSSES_QUERY;\n            } else {\n              return PointValues.Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment/field indexed any points\n          return null;\n        }\n\n        if (values.getNumIndexDimensions() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numIndexDimensions=\" + values.getNumIndexDimensions() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != values.getBytesPerDimension()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + values.getBytesPerDimension() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount() == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue();\n          final byte[] fieldPackedUpper = values.getMaxPackedValue();\n          allDocsMatch = true;\n          for (RangeClause rangeClause : rangeClauses) {\n            for (int i = 0; i < numDims; ++i) {\n              int offset = i * bytesPerDim;\n              if (Arrays.compareUnsigned(rangeClause.lowerValue, offset, offset + bytesPerDim, fieldPackedLower, offset, offset + bytesPerDim) > 0\n                  || Arrays.compareUnsigned(rangeClause.upperValue, offset, offset + bytesPerDim, fieldPackedUpper, offset, offset + bytesPerDim) < 0) {\n                allDocsMatch = false;\n                break;\n              }\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final PointValues.IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), scoreMode, iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor) * rangeClauses.size();\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n\n    };\n  }\n\n","bugFix":["bc29621aa343e88cbc47d168a1d556972a8d3851"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/MultiRangeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/MultiRangeQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  /*\n   * TODO: Organize ranges similar to how EdgeTree does, to avoid linear scan of ranges\n   */\n  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this, boost) {\n\n      private PointValues.IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new PointValues.IntersectVisitor() {\n\n          DocIdSetBuilder.BulkAdder adder;\n\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n\n          @Override\n          public void visit(int docID) {\n            adder.add(docID);\n          }\n\n          @Override\n          public void visit(int docID, byte[] packedValue) {\n            // If a single OR clause has the value in range, the entire query accepts the value\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n                if ((Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                  (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  // Doc is in-bounds. Add and short circuit\n                  adder.add(docID);\n                  return;\n                }\n                // Iterate till we have any OR clauses remaining\n              }\n            }\n          }\n\n          @Override\n          public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n            boolean crosses = false;\n\n            /**\n             * CROSSES and INSIDE take priority over OUTSIDE. How we calculate the position is:\n             * 1) If any range sees the point as inside, return INSIDE.\n             * 2) If no range sees the point as inside and atleast one range sees the point as CROSSES, return CROSSES\n             * 3) If none of the above, return OUTSIDE\n             */\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n\n                if ((Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                    (Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  return PointValues.Relation.CELL_INSIDE_QUERY;\n                }\n\n                crosses |= Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) > 0;\n              }\n            }\n\n            if (crosses) {\n              return PointValues.Relation.CELL_CROSSES_QUERY;\n            } else {\n              return PointValues.Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment/field indexed any points\n          return null;\n        }\n\n        if (values.getNumIndexDimensions() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numIndexDimensions=\" + values.getNumIndexDimensions() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != values.getBytesPerDimension()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + values.getBytesPerDimension() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount() == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue();\n          final byte[] fieldPackedUpper = values.getMaxPackedValue();\n          allDocsMatch = true;\n          for (RangeClause rangeClause : rangeClauses) {\n            for (int i = 0; i < numDims; ++i) {\n              int offset = i * bytesPerDim;\n              if (Arrays.compareUnsigned(rangeClause.lowerValue, offset, offset + bytesPerDim, fieldPackedLower, offset, offset + bytesPerDim) > 0\n                  || Arrays.compareUnsigned(rangeClause.upperValue, offset, offset + bytesPerDim, fieldPackedUpper, offset, offset + bytesPerDim) < 0) {\n                allDocsMatch = false;\n                break;\n              }\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final PointValues.IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), scoreMode, iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimateDocCount(visitor) * rangeClauses.size();\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n\n    };\n  }\n\n","sourceOld":"  /*\n   * TODO: Organize ranges similar to how EdgeTree does, to avoid linear scan of ranges\n   */\n  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this, boost) {\n\n      private PointValues.IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new PointValues.IntersectVisitor() {\n\n          DocIdSetBuilder.BulkAdder adder;\n\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n\n          @Override\n          public void visit(int docID) {\n            adder.add(docID);\n          }\n\n          @Override\n          public void visit(int docID, byte[] packedValue) {\n            // If a single OR clause has the value in range, the entire query accepts the value\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n                if ((Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                  (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  // Doc is in-bounds. Add and short circuit\n                  adder.add(docID);\n                  return;\n                }\n                // Iterate till we have any OR clauses remaining\n              }\n            }\n          }\n\n          @Override\n          public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n            boolean crosses = false;\n\n            /**\n             * CROSSES and INSIDE take priority over OUTSIDE. How we calculate the position is:\n             * 1) If any range sees the point as inside, return INSIDE.\n             * 2) If no range sees the point as inside and atleast one range sees the point as CROSSES, return CROSSES\n             * 3) If none of the above, return OUTSIDE\n             */\n            for (RangeClause rangeClause : rangeClauses) {\n              for (int dim = 0; dim < numDims; dim++) {\n                int offset = dim * bytesPerDim;\n\n                if ((Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) >= 0) &&\n                    (Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) <= 0)) {\n                  return PointValues.Relation.CELL_INSIDE_QUERY;\n                }\n\n                crosses |= Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) > 0;\n              }\n            }\n\n            if (crosses) {\n              return PointValues.Relation.CELL_CROSSES_QUERY;\n            } else {\n              return PointValues.Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // No docs in this segment/field indexed any points\n          return null;\n        }\n\n        if (values.getNumIndexDimensions() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numIndexDimensions=\" + values.getNumIndexDimensions() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != values.getBytesPerDimension()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + values.getBytesPerDimension() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount() == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue();\n          final byte[] fieldPackedUpper = values.getMaxPackedValue();\n          allDocsMatch = true;\n          for (RangeClause rangeClause : rangeClauses) {\n            for (int i = 0; i < numDims; ++i) {\n              int offset = i * bytesPerDim;\n              if (Arrays.compareUnsigned(rangeClause.lowerValue, offset, offset + bytesPerDim, fieldPackedLower, offset, offset + bytesPerDim) > 0\n                  || Arrays.compareUnsigned(rangeClause.upperValue, offset, offset + bytesPerDim, fieldPackedUpper, offset, offset + bytesPerDim) < 0) {\n                allDocsMatch = false;\n                break;\n              }\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final PointValues.IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), scoreMode, iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor) * rangeClauses.size();\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2626561c84f2122279879cd914fdee76f2876bfc":["bc29621aa343e88cbc47d168a1d556972a8d3851"],"bc29621aa343e88cbc47d168a1d556972a8d3851":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cf9da1d4a2d2f04a562030d1d46862163f506f62":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2626561c84f2122279879cd914fdee76f2876bfc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"],"3c09c5c6cd995294d83f12c1bdf8d47d8e749f49":["cf9da1d4a2d2f04a562030d1d46862163f506f62"],"b0b597c65628ca9e73913a07e81691f8229bae35":["cf9da1d4a2d2f04a562030d1d46862163f506f62","3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"]},"commit2Childs":{"2626561c84f2122279879cd914fdee76f2876bfc":["cf9da1d4a2d2f04a562030d1d46862163f506f62"],"bc29621aa343e88cbc47d168a1d556972a8d3851":["2626561c84f2122279879cd914fdee76f2876bfc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bc29621aa343e88cbc47d168a1d556972a8d3851","cf9da1d4a2d2f04a562030d1d46862163f506f62"],"cf9da1d4a2d2f04a562030d1d46862163f506f62":["3c09c5c6cd995294d83f12c1bdf8d47d8e749f49","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"3c09c5c6cd995294d83f12c1bdf8d47d8e749f49":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}