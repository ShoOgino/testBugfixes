{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#doStem(char[],int,boolean).mjava","commits":[{"id":"422da43e6414338103dfc37b7c8c68dcbe309d87","date":1405540909,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#doStem(char[],int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private List<CharsRef> doStem(char word[], int length, boolean caseVariant) {\n    List<CharsRef> stems = new ArrayList<>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i += formStep) {\n        boolean checkKeepCase = caseVariant && dictionary.keepcase != -1;\n        boolean checkNeedAffix = dictionary.needaffix != -1;\n        boolean checkOnlyInCompound = dictionary.onlyincompound != -1;\n        if (checkKeepCase || checkNeedAffix || checkOnlyInCompound) {\n          dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n          char wordFlags[] = Dictionary.decodeFlags(scratch);\n          // we are looking for a case variant, but this word does not allow it\n          if (checkKeepCase && Dictionary.hasFlag(wordFlags, (char)dictionary.keepcase)) {\n            continue;\n          }\n          // we can't add this form, its a pseudostem requiring an affix\n          if (checkNeedAffix && Dictionary.hasFlag(wordFlags, (char)dictionary.needaffix)) {\n            continue;\n          }\n          // we can't add this form, it only belongs inside a compound word\n          if (checkOnlyInCompound && Dictionary.hasFlag(wordFlags, (char)dictionary.onlyincompound)) {\n            continue;\n          }\n        }\n        stems.add(newStem(word, length, forms, i));\n      }\n    }\n    try {\n      boolean v = stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false, false, caseVariant));\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n    return stems;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#doStem(char[],int,boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#doStem(char[],int,boolean).mjava","sourceNew":"  private List<CharsRef> doStem(char word[], int length, boolean caseVariant) {\n    List<CharsRef> stems = new ArrayList<>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i += formStep) {\n        boolean checkKeepCase = caseVariant && dictionary.keepcase != -1;\n        boolean checkNeedAffix = dictionary.needaffix != -1;\n        boolean checkOnlyInCompound = dictionary.onlyincompound != -1;\n        if (checkKeepCase || checkNeedAffix || checkOnlyInCompound) {\n          dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n          char wordFlags[] = Dictionary.decodeFlags(scratch);\n          // we are looking for a case variant, but this word does not allow it\n          if (checkKeepCase && Dictionary.hasFlag(wordFlags, (char)dictionary.keepcase)) {\n            continue;\n          }\n          // we can't add this form, it's a pseudostem requiring an affix\n          if (checkNeedAffix && Dictionary.hasFlag(wordFlags, (char)dictionary.needaffix)) {\n            continue;\n          }\n          // we can't add this form, it only belongs inside a compound word\n          if (checkOnlyInCompound && Dictionary.hasFlag(wordFlags, (char)dictionary.onlyincompound)) {\n            continue;\n          }\n        }\n        stems.add(newStem(word, length, forms, i));\n      }\n    }\n    try {\n      boolean v = stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false, false, caseVariant));\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n    return stems;\n  }\n\n","sourceOld":"  private List<CharsRef> doStem(char word[], int length, boolean caseVariant) {\n    List<CharsRef> stems = new ArrayList<>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i += formStep) {\n        boolean checkKeepCase = caseVariant && dictionary.keepcase != -1;\n        boolean checkNeedAffix = dictionary.needaffix != -1;\n        boolean checkOnlyInCompound = dictionary.onlyincompound != -1;\n        if (checkKeepCase || checkNeedAffix || checkOnlyInCompound) {\n          dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n          char wordFlags[] = Dictionary.decodeFlags(scratch);\n          // we are looking for a case variant, but this word does not allow it\n          if (checkKeepCase && Dictionary.hasFlag(wordFlags, (char)dictionary.keepcase)) {\n            continue;\n          }\n          // we can't add this form, its a pseudostem requiring an affix\n          if (checkNeedAffix && Dictionary.hasFlag(wordFlags, (char)dictionary.needaffix)) {\n            continue;\n          }\n          // we can't add this form, it only belongs inside a compound word\n          if (checkOnlyInCompound && Dictionary.hasFlag(wordFlags, (char)dictionary.onlyincompound)) {\n            continue;\n          }\n        }\n        stems.add(newStem(word, length, forms, i));\n      }\n    }\n    try {\n      boolean v = stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false, false, caseVariant));\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["422da43e6414338103dfc37b7c8c68dcbe309d87"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"422da43e6414338103dfc37b7c8c68dcbe309d87":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"]},"commit2Childs":{"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["422da43e6414338103dfc37b7c8c68dcbe309d87"],"422da43e6414338103dfc37b7c8c68dcbe309d87":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}