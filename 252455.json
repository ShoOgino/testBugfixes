{"path":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","commits":[{"id":"112d77ac8d3e10a362516ad834c9a11d35c94234","date":1456784319,"type":1,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","sourceNew":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey();\n      final int count = entry.getValue();\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        //left half of dateline:\n        if (rect.getMaxX() >= heatMinX) {\n          final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth) + 1;\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinY() <= heatMaxX) {\n          final int rightColumns = (int) Math.round(heatMaxX / cellWidth) + 1;\n          intersectInterval(0, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n\n    }\n\n    return heatmap;\n  }\n\n","sourceOld":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey();\n      final int count = entry.getValue();\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        //left half of dateline:\n        if (rect.getMaxX() >= heatMinX) {\n          final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth) + 1;\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinY() <= heatMaxX) {\n          final int rightColumns = (int) Math.round(heatMaxX / cellWidth) + 1;\n          intersectInterval(0, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n\n    }\n\n    return heatmap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","sourceNew":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey();\n      final int count = entry.getValue();\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        //left half of dateline:\n        if (rect.getMaxX() >= heatMinX) {\n          final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth) + 1;\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinY() <= heatMaxX) {\n          final int rightColumns = (int) Math.round(heatMaxX / cellWidth) + 1;\n          intersectInterval(0, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n\n    }\n\n    return heatmap;\n  }\n\n","sourceOld":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey();\n      final int count = entry.getValue();\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        //left half of dateline:\n        if (rect.getMaxX() >= heatMinX) {\n          final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth) + 1;\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinY() <= heatMaxX) {\n          final int rightColumns = (int) Math.round(heatMaxX / cellWidth) + 1;\n          intersectInterval(0, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n\n    }\n\n    return heatmap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ceee459b5d9af86f3490334133c7cf34a5b69beb","date":1465580167,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","sourceNew":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey(); // from a cell (thus doesn't cross DL)\n      final int count = entry.getValue();\n\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        // note: the cell rect might intersect 2 disjoint parts of the heatmap, so we do the left & right separately\n        final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth);\n        final int rightColumns = heatmap.columns - leftColumns;\n        //left half of dateline:\n        if (rect.getMaxX() > heatMinX) {\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinX() < heatMaxX) {\n          intersectInterval(-180, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0] + leftColumns;\n          final int endCol = pair[1] + leftColumns;\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n    }\n\n    return heatmap;\n  }\n\n","sourceOld":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey();\n      final int count = entry.getValue();\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        //left half of dateline:\n        if (rect.getMaxX() >= heatMinX) {\n          final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth) + 1;\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinY() <= heatMaxX) {\n          final int rightColumns = (int) Math.round(heatMaxX / cellWidth) + 1;\n          intersectInterval(0, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n\n    }\n\n    return heatmap;\n  }\n\n","bugFix":["d19946da5b8a6505034a72adcb5bae87dd043ddd"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","sourceNew":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey(); // from a cell (thus doesn't cross DL)\n      final int count = entry.getValue();\n\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        // note: the cell rect might intersect 2 disjoint parts of the heatmap, so we do the left & right separately\n        final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth);\n        final int rightColumns = heatmap.columns - leftColumns;\n        //left half of dateline:\n        if (rect.getMaxX() > heatMinX) {\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinX() < heatMaxX) {\n          intersectInterval(-180, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0] + leftColumns;\n          final int endCol = pair[1] + leftColumns;\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n    }\n\n    return heatmap;\n  }\n\n","sourceOld":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey();\n      final int count = entry.getValue();\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        //left half of dateline:\n        if (rect.getMaxX() >= heatMinX) {\n          final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth) + 1;\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinY() <= heatMaxX) {\n          final int rightColumns = (int) Math.round(heatMaxX / cellWidth) + 1;\n          intersectInterval(0, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n\n    }\n\n    return heatmap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6af378d4176d939f1271b3e0d7504884436925b","date":1492533132,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","sourceNew":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n    if (topAcceptDocs instanceof Bits.MatchNoBits) {\n      return heatmap; // short-circuit\n    }\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey(); // from a cell (thus doesn't cross DL)\n      final int count = entry.getValue();\n\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        // note: the cell rect might intersect 2 disjoint parts of the heatmap, so we do the left & right separately\n        final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth);\n        final int rightColumns = heatmap.columns - leftColumns;\n        //left half of dateline:\n        if (rect.getMaxX() > heatMinX) {\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinX() < heatMaxX) {\n          intersectInterval(-180, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0] + leftColumns;\n          final int endCol = pair[1] + leftColumns;\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n    }\n\n    return heatmap;\n  }\n\n","sourceOld":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey(); // from a cell (thus doesn't cross DL)\n      final int count = entry.getValue();\n\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        // note: the cell rect might intersect 2 disjoint parts of the heatmap, so we do the left & right separately\n        final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth);\n        final int rightColumns = heatmap.columns - leftColumns;\n        //left half of dateline:\n        if (rect.getMaxX() > heatMinX) {\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinX() < heatMaxX) {\n          intersectInterval(-180, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0] + leftColumns;\n          final int endCol = pair[1] + leftColumns;\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n    }\n\n    return heatmap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","sourceNew":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n    if (topAcceptDocs instanceof Bits.MatchNoBits) {\n      return heatmap; // short-circuit\n    }\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey(); // from a cell (thus doesn't cross DL)\n      final int count = entry.getValue();\n\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        // note: the cell rect might intersect 2 disjoint parts of the heatmap, so we do the left & right separately\n        final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth);\n        final int rightColumns = heatmap.columns - leftColumns;\n        //left half of dateline:\n        if (rect.getMaxX() > heatMinX) {\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinX() < heatMaxX) {\n          intersectInterval(-180, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0] + leftColumns;\n          final int endCol = pair[1] + leftColumns;\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n    }\n\n    return heatmap;\n  }\n\n","sourceOld":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey(); // from a cell (thus doesn't cross DL)\n      final int count = entry.getValue();\n\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        // note: the cell rect might intersect 2 disjoint parts of the heatmap, so we do the left & right separately\n        final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth);\n        final int rightColumns = heatmap.columns - leftColumns;\n        //left half of dateline:\n        if (rect.getMaxX() > heatMinX) {\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinX() < heatMaxX) {\n          intersectInterval(-180, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0] + leftColumns;\n          final int endCol = pair[1] + leftColumns;\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n    }\n\n    return heatmap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9","date":1574619880,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","sourceNew":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  @SuppressWarnings(\"deprecation\")\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n    if (topAcceptDocs instanceof Bits.MatchNoBits) {\n      return heatmap; // short-circuit\n    }\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey(); // from a cell (thus doesn't cross DL)\n      final int count = entry.getValue();\n\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        // note: the cell rect might intersect 2 disjoint parts of the heatmap, so we do the left & right separately\n        final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth);\n        final int rightColumns = heatmap.columns - leftColumns;\n        //left half of dateline:\n        if (rect.getMaxX() > heatMinX) {\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinX() < heatMaxX) {\n          intersectInterval(-180, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0] + leftColumns;\n          final int endCol = pair[1] + leftColumns;\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n    }\n\n    return heatmap;\n  }\n\n","sourceOld":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n    if (topAcceptDocs instanceof Bits.MatchNoBits) {\n      return heatmap; // short-circuit\n    }\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey(); // from a cell (thus doesn't cross DL)\n      final int count = entry.getValue();\n\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        // note: the cell rect might intersect 2 disjoint parts of the heatmap, so we do the left & right separately\n        final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth);\n        final int rightColumns = heatmap.columns - leftColumns;\n        //left half of dateline:\n        if (rect.getMaxX() > heatMinX) {\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinX() < heatMaxX) {\n          intersectInterval(-180, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0] + leftColumns;\n          final int endCol = pair[1] + leftColumns;\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n    }\n\n    return heatmap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9c3baacabd473e8ecd6c4948aabacead49b88e","date":1574700980,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","sourceNew":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n    if (topAcceptDocs instanceof Bits.MatchNoBits) {\n      return heatmap; // short-circuit\n    }\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey(); // from a cell (thus doesn't cross DL)\n      final int count = entry.getValue();\n\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        // note: the cell rect might intersect 2 disjoint parts of the heatmap, so we do the left & right separately\n        final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth);\n        final int rightColumns = heatmap.columns - leftColumns;\n        //left half of dateline:\n        if (rect.getMaxX() > heatMinX) {\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinX() < heatMaxX) {\n          intersectInterval(-180, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0] + leftColumns;\n          final int endCol = pair[1] + leftColumns;\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n    }\n\n    return heatmap;\n  }\n\n","sourceOld":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  @SuppressWarnings(\"deprecation\")\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n    if (topAcceptDocs instanceof Bits.MatchNoBits) {\n      return heatmap; // short-circuit\n    }\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey(); // from a cell (thus doesn't cross DL)\n      final int count = entry.getValue();\n\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        // note: the cell rect might intersect 2 disjoint parts of the heatmap, so we do the left & right separately\n        final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth);\n        final int rightColumns = heatmap.columns - leftColumns;\n        //left half of dateline:\n        if (rect.getMaxX() > heatMinX) {\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinX() < heatMaxX) {\n          intersectInterval(-180, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0] + leftColumns;\n          final int endCol = pair[1] + leftColumns;\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n    }\n\n    return heatmap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","date":1591961131,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","sourceNew":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.getShapeFactory().pointXY(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.getShapeFactory().rect(heatMinX, heatMaxX, heatMinY, heatMaxY));\n    if (topAcceptDocs instanceof Bits.MatchNoBits) {\n      return heatmap; // short-circuit\n    }\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey(); // from a cell (thus doesn't cross DL)\n      final int count = entry.getValue();\n\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        // note: the cell rect might intersect 2 disjoint parts of the heatmap, so we do the left & right separately\n        final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth);\n        final int rightColumns = heatmap.columns - leftColumns;\n        //left half of dateline:\n        if (rect.getMaxX() > heatMinX) {\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinX() < heatMaxX) {\n          intersectInterval(-180, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0] + leftColumns;\n          final int endCol = pair[1] + leftColumns;\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n    }\n\n    return heatmap;\n  }\n\n","sourceOld":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n    if (topAcceptDocs instanceof Bits.MatchNoBits) {\n      return heatmap; // short-circuit\n    }\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey(); // from a cell (thus doesn't cross DL)\n      final int count = entry.getValue();\n\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        // note: the cell rect might intersect 2 disjoint parts of the heatmap, so we do the left & right separately\n        final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth);\n        final int rightColumns = heatmap.columns - leftColumns;\n        //left half of dateline:\n        if (rect.getMaxX() > heatMinX) {\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinX() < heatMaxX) {\n          intersectInterval(-180, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0] + leftColumns;\n          final int endCol = pair[1] + leftColumns;\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n    }\n\n    return heatmap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d6af378d4176d939f1271b3e0d7504884436925b":["ceee459b5d9af86f3490334133c7cf34a5b69beb"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["ceee459b5d9af86f3490334133c7cf34a5b69beb"],"af2638813028b254a88b418ebeafb541afb49653":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","112d77ac8d3e10a362516ad834c9a11d35c94234"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["d6af378d4176d939f1271b3e0d7504884436925b"],"ceee459b5d9af86f3490334133c7cf34a5b69beb":["af2638813028b254a88b418ebeafb541afb49653"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["af2638813028b254a88b418ebeafb541afb49653","ceee459b5d9af86f3490334133c7cf34a5b69beb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"]},"commit2Childs":{"d6af378d4176d939f1271b3e0d7504884436925b":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"af2638813028b254a88b418ebeafb541afb49653":["ceee459b5d9af86f3490334133c7cf34a5b69beb","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"ceee459b5d9af86f3490334133c7cf34a5b69beb":["d6af378d4176d939f1271b3e0d7504884436925b","54ca69905c5d9d1529286f06ab1d12c68f6c13cb","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["af2638813028b254a88b418ebeafb541afb49653","112d77ac8d3e10a362516ad834c9a11d35c94234"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["af2638813028b254a88b418ebeafb541afb49653"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}