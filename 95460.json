{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private void copySegmentAsIs(SegmentInfo info, String segName,\n      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    if (info.getDocStoreOffset() != -1) {\n      // only violate the codec this way if its preflex\n      codec.storedFieldsFormat().files(info, codecDocStoreFiles);\n      codec.termVectorsFormat().files(info, codecDocStoreFiles);\n    }\n    \n    // Copy the segment files\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      \n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    info.setDocStore(info.getDocStoreOffset(), newDsName, info.getDocStoreIsCompoundFile());\n    info.dir = directory;\n    info.name = segName;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private void copySegmentAsIs(SegmentInfo info, String segName,\n      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    if (info.getDocStoreOffset() != -1) {\n      // only violate the codec this way if its preflex\n      codec.storedFieldsFormat().files(info, codecDocStoreFiles);\n      codec.termVectorsFormat().files(info, codecDocStoreFiles);\n    }\n    \n    // Copy the segment files\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      \n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    info.setDocStore(info.getDocStoreOffset(), newDsName, info.getDocStoreIsCompoundFile());\n    info.dir = directory;\n    info.name = segName;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ee5c613bc76903f5e2dee48b9d63c3a9ed3aeb0","date":1337448276,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private void copySegmentAsIs(SegmentInfo info, String segName,\n                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    if (info.getDocStoreOffset() != -1) {\n      // only violate the codec this way if its preflex\n      info.getCodec().storedFieldsFormat().files(info, codecDocStoreFiles);\n      info.getCodec().termVectorsFormat().files(info, codecDocStoreFiles);\n    }\n\n    // Copy the segment files\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      \n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    info.setDocStore(info.getDocStoreOffset(), newDsName, info.getDocStoreIsCompoundFile());\n    info.dir = directory;\n    info.name = segName;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private void copySegmentAsIs(SegmentInfo info, String segName,\n      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    if (info.getDocStoreOffset() != -1) {\n      // only violate the codec this way if its preflex\n      codec.storedFieldsFormat().files(info, codecDocStoreFiles);\n      codec.termVectorsFormat().files(info, codecDocStoreFiles);\n    }\n    \n    // Copy the segment files\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      \n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    info.setDocStore(info.getDocStoreOffset(), newDsName, info.getDocStoreIsCompoundFile());\n    info.dir = directory;\n    info.name = segName;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4356000e349e38c9fb48034695b7c309abd54557","date":1337460341,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfo copySegmentAsIs(SegmentInfo info, String segName,\n                                      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                      Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    if (info.getDocStoreOffset() != -1) {\n      // only violate the codec this way if its preflex\n      info.getCodec().storedFieldsFormat().files(info, codecDocStoreFiles);\n      info.getCodec().termVectorsFormat().files(info, codecDocStoreFiles);\n    }\n\n    //System.out.println(\"copy seg=\" + info.name + \" version=\" + info.getVersion());\n    \n    // Copy the segment files\n    for (String file: info.files()) {\n\n      // nocommit messy: insteda we should pull .files()\n      // from the codec's SIFormat and check if it's in\n      // there...\n      if (file.endsWith(\".si\")) {\n        continue;\n      }\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      //System.out.println(\"COPY \" + file + \" -> \" + newFileName);\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    // Same SI as before but we change directory and name:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.getVersion(), segName, info.docCount, info.getDocStoreOffset(),\n                                          newDsName, info.getDocStoreIsCompoundFile(), info.getNormGen(), info.getUseCompoundFile(),\n                                          info.getDelCount(), info.getCodec(), info.getDiagnostics());\n    newInfo.setDelGen(info.getDelGen());\n\n    // nocommit need to pass real FIS...\n    // nocommit maybe we don't pass FIS......?\n    // nocommit messy....\n    //if (!newInfo.getCodec().getName().equals(\"Lucene3x\")) {\n    if (!newInfo.getVersion().startsWith(\"3.\")) {\n      //System.out.println(\"  now write si for seg=\" + newInfo.name + \" codec=\" + newInfo.getCodec());\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(newInfo, null);\n    }\n    \n    return newInfo;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private void copySegmentAsIs(SegmentInfo info, String segName,\n      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    if (info.getDocStoreOffset() != -1) {\n      // only violate the codec this way if its preflex\n      codec.storedFieldsFormat().files(info, codecDocStoreFiles);\n      codec.termVectorsFormat().files(info, codecDocStoreFiles);\n    }\n    \n    // Copy the segment files\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      \n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    info.setDocStore(info.getDocStoreOffset(), newDsName, info.getDocStoreIsCompoundFile());\n    info.dir = directory;\n    info.name = segName;\n  }\n\n","bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072","5f6bd27530a2846413fe2d00030493c0e2d3a072"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"4356000e349e38c9fb48034695b7c309abd54557":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"2ee5c613bc76903f5e2dee48b9d63c3a9ed3aeb0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2ee5c613bc76903f5e2dee48b9d63c3a9ed3aeb0"]},"commit2Childs":{"4356000e349e38c9fb48034695b7c309abd54557":[],"2ee5c613bc76903f5e2dee48b9d63c3a9ed3aeb0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["4356000e349e38c9fb48034695b7c309abd54557","2ee5c613bc76903f5e2dee48b9d63c3a9ed3aeb0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4356000e349e38c9fb48034695b7c309abd54557","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}