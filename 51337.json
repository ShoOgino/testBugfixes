{"path":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext#runLeaderProcess(boolean,int).mjava","commits":[{"id":"ba33781da68babcaa5828121b443d3eb5c9d8480","date":1590595589,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /*\n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        // shutdown or removed\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n\n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n\n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n\n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later,\n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will\n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n\n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          return;\n        }\n\n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            // only log an error if this replica win the election\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n\n        log.info(\"I may be the new leader - try and sync\");\n\n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n\n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n\n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n\n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false)) {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              if (log.isDebugEnabled()) {\n                log.debug(\"{} synched {}\", core.getCoreContainer().getZkController().getNodeName()\n                    , searcher.count(new MatchAllDocsQuery()));\n              }\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n\n      }\n\n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) {}\"\n                , \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"I am the new leader: {} {}\", ZkCoreNodeProps.getCoreUrl(leaderProps), shardId);\n          }\n\n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (SessionExpiredException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n\n          try (SolrCore core = cc.getCore(coreName)) {\n\n            if (core == null) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"SolrCore not found: {} in {}\", coreName, cc.getLoadedCoreNames());\n              }\n              return;\n            }\n\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n\n            // we could not publish ourselves as leader - try and rejoin election\n            try {\n              rejoinLeaderElection(core);\n            } catch (SessionExpiredException exc) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n            }\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        // shutdown or removed\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          return;\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            // only log an error if this replica win the election\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              if (log.isDebugEnabled()) {\n                log.debug(\"{} synched {}\", core.getCoreContainer().getZkController().getNodeName()\n                    , searcher.count(new MatchAllDocsQuery()));\n              }\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) {}\"\n                , \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"I am the new leader: {} {}\", ZkCoreNodeProps.getCoreUrl(leaderProps), shardId);\n          }\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (SessionExpiredException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"SolrCore not found: {} in {}\", coreName, cc.getLoadedCoreNames());\n              }\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            try {\n              rejoinLeaderElection(core);\n            } catch (SessionExpiredException exc) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n            }\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ba33781da68babcaa5828121b443d3eb5c9d8480":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ba33781da68babcaa5828121b443d3eb5c9d8480"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ba33781da68babcaa5828121b443d3eb5c9d8480"],"ba33781da68babcaa5828121b443d3eb5c9d8480":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}