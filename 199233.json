{"path":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","commits":[{"id":"2e11e54ce6015434b2aaadb49ca5071dbe7be50c","date":1489404389,"type":1,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsWithInPlaceUpdatesShouldNotThrowReplicaInLIRTest().mjava","sourceNew":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n    \n    log.info(\"Non leader 0: \"+((HttpSolrClient)NONLEADERS.get(0)).getBaseURL());\n    log.info(\"Non leader 1: \"+((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: \"+doc0);\n    log.info(\"Doc in both replica 1: \"+doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsWithInPlaceUpdatesShouldNotThrowReplicaInLIRTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n    \n    log.info(\"Non leader 0: \"+((HttpSolrClient)NONLEADERS.get(0)).getBaseURL());\n    log.info(\"Non leader 1: \"+((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: \"+doc0);\n    log.info(\"Doc in both replica 1: \"+doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsWithInPlaceUpdatesShouldNotThrowReplicaInLIRTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","sourceNew":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in append replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n    \n    log.info(\"Non leader 0: \"+((HttpSolrClient)NONLEADERS.get(0)).getBaseURL());\n    log.info(\"Non leader 1: \"+((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: \"+doc0);\n    log.info(\"Doc in both replica 1: \"+doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n    \n    log.info(\"Non leader 0: \"+((HttpSolrClient)NONLEADERS.get(0)).getBaseURL());\n    log.info(\"Non leader 1: \"+((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: \"+doc0);\n    log.info(\"Doc in both replica 1: \"+doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","sourceNew":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in append replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n    \n    log.info(\"Non leader 0: \"+((HttpSolrClient)NONLEADERS.get(0)).getBaseURL());\n    log.info(\"Non leader 1: \"+((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: \"+doc0);\n    log.info(\"Doc in both replica 1: \"+doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n    \n    log.info(\"Non leader 0: \"+((HttpSolrClient)NONLEADERS.get(0)).getBaseURL());\n    log.info(\"Non leader 1: \"+((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: \"+doc0);\n    log.info(\"Doc in both replica 1: \"+doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","sourceNew":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in append replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n    \n    log.info(\"Non leader 0: \"+((HttpSolrClient)NONLEADERS.get(0)).getBaseURL());\n    log.info(\"Non leader 1: \"+((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: \"+doc0);\n    log.info(\"Doc in both replica 1: \"+doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n    \n    log.info(\"Non leader 0: \"+((HttpSolrClient)NONLEADERS.get(0)).getBaseURL());\n    log.info(\"Non leader 1: \"+((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: \"+doc0);\n    log.info(\"Doc in both replica 1: \"+doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","sourceNew":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n    \n    log.info(\"Non leader 0: \"+((HttpSolrClient)NONLEADERS.get(0)).getBaseURL());\n    log.info(\"Non leader 1: \"+((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: \"+doc0);\n    log.info(\"Doc in both replica 1: \"+doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in append replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n    \n    log.info(\"Non leader 0: \"+((HttpSolrClient)NONLEADERS.get(0)).getBaseURL());\n    log.info(\"Non leader 1: \"+((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: \"+doc0);\n    log.info(\"Doc in both replica 1: \"+doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","sourceNew":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n    \n    log.info(\"Non leader 0: \"+((HttpSolrClient)NONLEADERS.get(0)).getBaseURL());\n    log.info(\"Non leader 1: \"+((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: \"+doc0);\n    log.info(\"Doc in both replica 1: \"+doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in append replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n    \n    log.info(\"Non leader 0: \"+((HttpSolrClient)NONLEADERS.get(0)).getBaseURL());\n    log.info(\"Non leader 1: \"+((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: \"+doc0);\n    log.info(\"Doc in both replica 1: \"+doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","sourceNew":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new SolrNamedThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n    \n    log.info(\"Non leader 0: \"+((HttpSolrClient)NONLEADERS.get(0)).getBaseURL());\n    log.info(\"Non leader 1: \"+((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: \"+doc0);\n    log.info(\"Doc in both replica 1: \"+doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n    \n    log.info(\"Non leader 0: \"+((HttpSolrClient)NONLEADERS.get(0)).getBaseURL());\n    log.info(\"Non leader 1: \"+((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: \"+doc0);\n    log.info(\"Doc in both replica 1: \"+doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","sourceNew":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Issuing well ordered update: {}\", update.getDocuments());\n      }\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new SolrNamedThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Non leader 0: {}\", ((HttpSolrClient) NONLEADERS.get(0)).getBaseURL());\n      log.info(\"Non leader 1: {}\", ((HttpSolrClient) NONLEADERS.get(1)).getBaseURL()); // logOk\n    }\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: {}\", doc0);\n    log.info(\"Doc in both replica 1: {}\", doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new SolrNamedThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n    \n    log.info(\"Non leader 0: \"+((HttpSolrClient)NONLEADERS.get(0)).getBaseURL());\n    log.info(\"Non leader 1: \"+((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: \"+doc0);\n    log.info(\"Doc in both replica 1: \"+doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2d19164145b2a65acf62a657c75f4a249b649c0","date":1601732857,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsResurrectionTest().mjava","sourceNew":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Issuing well ordered update: {}\", update.getDocuments());\n      }\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new SolrNamedThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Non leader 0: {}\", ((HttpSolrClient) NONLEADERS.get(0)).getBaseURL());\n      log.info(\"Non leader 1: {}\", ((HttpSolrClient) NONLEADERS.get(1)).getBaseURL()); // nowarn\n    }\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: {}\", doc0);\n    log.info(\"Doc in both replica 1: {}\", doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  /* Test for a situation when a document requiring in-place update cannot be \"resurrected\"\n   * when the original full indexed document has been deleted by an out of order DBQ.\n   * Expected behaviour in this case should be to throw the replica into LIR (since this will\n   * be rare). Here's an example of the situation:\n        ADD(id=x, val=5, ver=1)\n        UPD(id=x, val=10, ver = 2)\n        DBQ(q=val:10, v=4)\n        DV(id=x, val=5, ver=3)\n   */\n  private void reorderedDBQsResurrectionTest() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    //assertEquals(value, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    String field = \"inplace_updatable_int\";\n    \n    // put replica out of sync\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", field, 5, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, field, 10, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedUpdateRequest(version0 + 2, \"id\", 0, field, 5, \"_version_\", version0 + 3)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(field+\":10\", version0 + 4)); // supposed to not delete anything\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Issuing well ordered update: {}\", update.getDocuments());\n      }\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new SolrNamedThreadFactory(getTestName()));\n    // re-order the last two updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.swap(reorderedUpdates, 2, 3);\n\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      // pretend as this update is coming from the other non-leader, so that\n      // the resurrection can happen from there (instead of the leader)\n      update.setParam(DistributedUpdateProcessor.DISTRIB_FROM, ((HttpSolrClient)NONLEADERS.get(1)).getBaseURL());\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0),\n                                                                         random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    int successful = 0;\n    for (Future<UpdateResponse> resp: updateResponses) {\n      try {\n        UpdateResponse r = resp.get();\n        if (r.getStatus() == 0) {\n          successful++;\n        }\n      } catch (Exception ex) {\n        // reordered DBQ should trigger an error, thus throwing the replica into LIR.\n        // the cause of the error is that the full document was deleted by mistake due to the\n        // out of order DBQ, and the in-place update that arrives after the DBQ (but was supposed to \n        // arrive before) cannot be applied, since the full document can't now be \"resurrected\".\n\n        if (!ex.getMessage().contains(\"Tried to fetch missing update\"\n            + \" from the leader, but missing wasn't present at leader.\")) {\n          throw ex;\n        }\n      }\n    }\n    // All should succeed, i.e. no LIR\n    assertEquals(updateResponses.size(), successful);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Non leader 0: {}\", ((HttpSolrClient) NONLEADERS.get(0)).getBaseURL());\n      log.info(\"Non leader 1: {}\", ((HttpSolrClient) NONLEADERS.get(1)).getBaseURL()); // logOk\n    }\n    \n    SolrDocument doc0 = NONLEADERS.get(0).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n    SolrDocument doc1 = NONLEADERS.get(1).getById(String.valueOf(0), params(\"distrib\", \"false\"));\n\n    log.info(\"Doc in both replica 0: {}\", doc0);\n    log.info(\"Doc in both replica 1: {}\", doc1);\n    // assert both replicas have same effect\n    for (int i=0; i<NONLEADERS.size(); i++) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrClient client = NONLEADERS.get(i);\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNotNull(\"Client: \"+((HttpSolrClient)client).getBaseURL(), doc);\n      assertEquals(\"Client: \"+((HttpSolrClient)client).getBaseURL(), 5, doc.getFieldValue(field));\n    }\n\n    log.info(\"reorderedDBQsResurrectionTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["ab68488225b6a6c357dda72ed11dedca9914a192","61c45e99cf6676da48f19d7511c73712ad39402b"],"61c45e99cf6676da48f19d7511c73712ad39402b":["be320990bdc77e643388fa801e75017f19289c42"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c"],"2e11e54ce6015434b2aaadb49ca5071dbe7be50c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["61c45e99cf6676da48f19d7511c73712ad39402b"],"b2d19164145b2a65acf62a657c75f4a249b649c0":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"be320990bdc77e643388fa801e75017f19289c42":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c"],"ab68488225b6a6c357dda72ed11dedca9914a192":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b2d19164145b2a65acf62a657c75f4a249b649c0"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"2e11e54ce6015434b2aaadb49ca5071dbe7be50c":["f996f8177b9204bdc92f7164460c6cefad9ac99a","be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"b2d19164145b2a65acf62a657c75f4a249b649c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"be320990bdc77e643388fa801e75017f19289c42":["61c45e99cf6676da48f19d7511c73712ad39402b"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["b2d19164145b2a65acf62a657c75f4a249b649c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}