{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#DirectIntersectTermsEnum(CompiledAutomaton,BytesRef).mjava","commits":[{"id":"3e45d45bc3730ddd1341f4eb6025f33b8482e6e2","date":1346834651,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#DirectIntersectTermsEnum(CompiledAutomaton,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#DirectIntersectTermsEnum(CompiledAutomaton,BytesRef).mjava","sourceNew":"      public DirectIntersectTermsEnum(CompiledAutomaton compiled, BytesRef startTerm) {\n        runAutomaton = compiled.runAutomaton;\n        compiledAutomaton = compiled;\n        termOrd = -1;\n        states = new State[1];\n        states[0] = new State();\n        states[0].changeOrd = terms.length;\n        states[0].state = runAutomaton.getInitialState();\n        states[0].transitions = compiledAutomaton.sortedTransitions[states[0].state];\n        states[0].transitionUpto = -1;\n        states[0].transitionMax = -1;\n\n        //System.out.println(\"IE.init startTerm=\" + startTerm);\n\n        if (startTerm != null) {\n          int skipUpto = 0;\n          if (startTerm.length == 0) {\n            if (terms.length > 0 && termOffsets[1] == 0) {\n              termOrd = 0;\n            }\n          } else {\n            termOrd++;\n\n            nextLabel:\n            for(int i=0;i<startTerm.length;i++) {\n              final int label = startTerm.bytes[startTerm.offset+i] & 0xFF;\n\n              while (label > states[i].transitionMax) {\n                states[i].transitionUpto++;\n                assert states[i].transitionUpto < states[i].transitions.length;\n                states[i].transitionMin = states[i].transitions[states[i].transitionUpto].getMin();\n                states[i].transitionMax = states[i].transitions[states[i].transitionUpto].getMax();\n                assert states[i].transitionMin >= 0;\n                assert states[i].transitionMin <= 255;\n                assert states[i].transitionMax >= 0;\n                assert states[i].transitionMax <= 255;\n              }\n\n              // Skip forwards until we find a term matching\n              // the label at this position:\n              while (termOrd < terms.length) {\n                final int skipOffset = skipOffsets[termOrd];\n                final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n                final int termOffset = termOffsets[termOrd];\n                final int termLength = termOffsets[1+termOrd] - termOffset;\n\n                // if (DEBUG) {\n                //   System.out.println(\"  check termOrd=\" + termOrd + \" term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips) + \" i=\" + i);\n                // }\n\n                if (termOrd == states[stateUpto].changeOrd) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"  end push return\");\n                  // }\n                  stateUpto--;\n                  termOrd--;\n                  return;\n                }\n\n                if (termLength == i) {\n                  termOrd++;\n                  skipUpto = 0;\n                  // if (DEBUG) {\n                  //   System.out.println(\"    term too short; next term\");\n                  // }\n                } else if (label < (termBytes[termOffset+i] & 0xFF)) {\n                  termOrd--;\n                  // if (DEBUG) {\n                  //   System.out.println(\"  no match; already beyond; return termOrd=\" + termOrd);\n                  // }\n                  stateUpto -= skipUpto;\n                  assert stateUpto >= 0;\n                  return;\n                } else if (label == (termBytes[termOffset+i] & 0xFF)) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"    label[\" + i + \"] matches\");\n                  // }\n                  if (skipUpto < numSkips) {\n                    grow();\n\n                    final int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n                    // Automaton is required to accept startTerm:\n                    assert nextState != -1;\n\n                    stateUpto++;\n                    states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n                    states[stateUpto].state = nextState;\n                    states[stateUpto].transitions = compiledAutomaton.sortedTransitions[nextState];\n                    states[stateUpto].transitionUpto = -1;\n                    states[stateUpto].transitionMax = -1;\n                    //System.out.println(\"  push \" + states[stateUpto].transitions.length + \" trans\");\n\n                    // if (DEBUG) {\n                    //   System.out.println(\"    push skip; changeOrd=\" + states[stateUpto].changeOrd);\n                    // }\n\n                    // Match next label at this same term:\n                    continue nextLabel;\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"    linear scan\");\n                    // }\n                    // Index exhausted: just scan now (the\n                    // number of scans required will be less\n                    // than the minSkipCount):\n                    final int startTermOrd = termOrd;\n                    while (termOrd < terms.length && compare(termOrd, startTerm) <= 0) {\n                      assert termOrd == startTermOrd || skipOffsets[termOrd] == skipOffsets[termOrd+1];\n                      termOrd++;\n                    }\n                    assert termOrd - startTermOrd < minSkipCount;\n                    termOrd--;\n                    stateUpto -= skipUpto;\n                    // if (DEBUG) {\n                    //   System.out.println(\"  end termOrd=\" + termOrd);\n                    // }\n                    return;\n                  }\n                } else {\n                  if (skipUpto < numSkips) {\n                    termOrd = skips[skipOffset + skipUpto];\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; skip to termOrd=\" + termOrd);\n                    // }\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; next term\");\n                    // }\n                    termOrd++;\n                  }\n                  skipUpto = 0;\n                }\n              }\n\n              // startTerm is >= last term so enum will not\n              // return any terms:\n              termOrd--;\n              // if (DEBUG) {\n              //   System.out.println(\"  beyond end; no terms will match\");\n              // }\n              return;\n            }\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLen = termOffsets[1+termOrd] - termOffset;\n\n          if (termOrd >= 0 && !startTerm.equals(new BytesRef(termBytes, termOffset, termLen))) {\n            stateUpto -= skipUpto;\n            termOrd--;\n          }\n          // if (DEBUG) {\n          //   System.out.println(\"  loop end; return termOrd=\" + termOrd + \" stateUpto=\" + stateUpto);\n          // }\n        }\n      }\n\n","sourceOld":"      public DirectIntersectTermsEnum(CompiledAutomaton compiled, BytesRef startTerm) {\n        runAutomaton = compiled.runAutomaton;\n        compiledAutomaton = compiled;\n        termOrd = -1;\n        states = new State[1];\n        states[0] = new State();\n        states[0].changeOrd = terms.length;\n        states[0].state = runAutomaton.getInitialState();\n        states[0].transitions = compiledAutomaton.sortedTransitions[states[0].state];\n        states[0].transitionUpto = -1;\n        states[0].transitionMax = -1;\n\n        //System.out.println(\"IE.init startTerm=\" + startTerm);\n\n        if (startTerm != null) {\n          int skipUpto = 0;\n          if (startTerm.length == 0) {\n            if (terms.length > 0 && termOffsets[1] == 0) {\n              termOrd = 0;\n            }\n          } else {\n            termOrd++;\n\n            nextLabel:\n            for(int i=0;i<startTerm.length;i++) {\n              final int label = startTerm.bytes[startTerm.offset+i] & 0xFF;\n\n              while (label > states[i].transitionMax) {\n                states[i].transitionUpto++;\n                assert states[i].transitionUpto < states[i].transitions.length;\n                states[i].transitionMin = states[i].transitions[states[i].transitionUpto].getMin();\n                states[i].transitionMax = states[i].transitions[states[i].transitionUpto].getMax();\n                assert states[i].transitionMin >= 0;\n                assert states[i].transitionMin <= 255;\n                assert states[i].transitionMax >= 0;\n                assert states[i].transitionMax <= 255;\n              }\n\n              // Skip forwards until we find a term matching\n              // the label at this position:\n              while (termOrd < terms.length) {\n                final int skipOffset = skipOffsets[termOrd];\n                final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n                final int termOffset = termOffsets[termOrd];\n                final int termLength = termOffsets[1+termOrd] - termOffset;\n\n                // if (DEBUG) {\n                //   System.out.println(\"  check termOrd=\" + termOrd + \" term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips) + \" i=\" + i);\n                // }\n\n                if (termOrd == states[stateUpto].changeOrd) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"  end push return\");\n                  // }\n                  stateUpto--;\n                  termOrd--;\n                  return;\n                }\n\n                if (termLength == i) {\n                  termOrd++;\n                  skipUpto = 0;\n                  // if (DEBUG) {\n                  //   System.out.println(\"    term too short; next term\");\n                  // }\n                } else if (label < (termBytes[termOffset+i] & 0xFF)) {\n                  termOrd--;\n                  // if (DEBUG) {\n                  //   System.out.println(\"  no match; already beyond; return termOrd=\" + termOrd);\n                  // }\n                  stateUpto -= skipUpto;\n                  assert stateUpto >= 0;\n                  return;\n                } else if (label == (termBytes[termOffset+i] & 0xFF)) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"    label[\" + i + \"] matches\");\n                  // }\n                  if (skipUpto < numSkips) {\n                    grow();\n\n                    final int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n                    // Automaton is required to accept startTerm:\n                    assert nextState != -1;\n\n                    stateUpto++;\n                    states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n                    states[stateUpto].state = nextState;\n                    states[stateUpto].transitions = compiledAutomaton.sortedTransitions[nextState];\n                    states[stateUpto].transitionUpto = -1;\n                    states[stateUpto].transitionMax = -1;\n                    //System.out.println(\"  push \" + states[stateUpto].transitions.length + \" trans\");\n\n                    // if (DEBUG) {\n                    //   System.out.println(\"    push skip; changeOrd=\" + states[stateUpto].changeOrd);\n                    // }\n\n                    // Match next label at this same term:\n                    continue nextLabel;\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"    linear scan\");\n                    // }\n                    // Index exhausted: just scan now (the\n                    // number of scans required will be less\n                    // than the minSkipCount):\n                    final int startTermOrd = termOrd;\n                    while (termOrd < terms.length && compare(termOrd, startTerm) <= 0) {\n                      assert termOrd == startTermOrd || skipOffsets[termOrd] == skipOffsets[termOrd+1];\n                      termOrd++;\n                    }\n                    assert termOrd - startTermOrd < minSkipCount;\n                    termOrd--;\n                    stateUpto -= skipUpto;\n                    // if (DEBUG) {\n                    //   System.out.println(\"  end termOrd=\" + termOrd);\n                    // }\n                    return;\n                  }\n                } else {\n                  if (skipUpto < numSkips) {\n                    termOrd = skips[skipOffset + skipUpto];\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; skip to termOrd=\" + termOrd);\n                    // }\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; next term\");\n                    // }\n                    termOrd++;\n                  }\n                  skipUpto = 0;\n                }\n              }\n\n              // startTerm is >= last term so enum will not\n              // return any terms:\n              termOrd--;\n              // if (DEBUG) {\n              //   System.out.println(\"  beyond end; no terms will match\");\n              // }\n              return;\n            }\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLen = termOffsets[1+termOrd] - termOffset;\n\n          if (termOrd >= 0 && !startTerm.equals(new BytesRef(termBytes, termOffset, termLen))) {\n            stateUpto -= skipUpto;\n            termOrd--;\n          }\n          // if (DEBUG) {\n          //   System.out.println(\"  loop end; return termOrd=\" + termOrd + \" stateUpto=\" + stateUpto);\n          // }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac34f0c5bb9274821fb0cb18075234e02002e9bf","date":1402508126,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#DirectIntersectTermsEnum(CompiledAutomaton,BytesRef).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#DirectIntersectTermsEnum(CompiledAutomaton,BytesRef).mjava","sourceNew":"      public DirectIntersectTermsEnum(CompiledAutomaton compiled, BytesRef startTerm) {\n        runAutomaton = compiled.runAutomaton;\n        compiledAutomaton = compiled;\n        termOrd = -1;\n        states = new State[1];\n        states[0] = new State();\n        states[0].changeOrd = terms.length;\n        states[0].state = runAutomaton.getInitialState();\n        states[0].transitionCount = compiledAutomaton.lightAutomaton.getNumTransitions(states[0].state);\n        compiledAutomaton.lightAutomaton.initTransition(states[0].state, states[0].transition);\n        states[0].transitionUpto = -1;\n        states[0].transitionMax = -1;\n\n        //System.out.println(\"IE.init startTerm=\" + startTerm);\n\n        if (startTerm != null) {\n          int skipUpto = 0;\n          if (startTerm.length == 0) {\n            if (terms.length > 0 && termOffsets[1] == 0) {\n              termOrd = 0;\n            }\n          } else {\n            termOrd++;\n\n            nextLabel:\n            for(int i=0;i<startTerm.length;i++) {\n              final int label = startTerm.bytes[startTerm.offset+i] & 0xFF;\n\n              while (label > states[i].transitionMax) {\n                states[i].transitionUpto++;\n                assert states[i].transitionUpto < states[i].transitionCount;\n                compiledAutomaton.lightAutomaton.getNextTransition(states[i].transition);\n                states[i].transitionMin = states[i].transition.min;\n                states[i].transitionMax = states[i].transition.max;\n                assert states[i].transitionMin >= 0;\n                assert states[i].transitionMin <= 255;\n                assert states[i].transitionMax >= 0;\n                assert states[i].transitionMax <= 255;\n              }\n\n              // Skip forwards until we find a term matching\n              // the label at this position:\n              while (termOrd < terms.length) {\n                final int skipOffset = skipOffsets[termOrd];\n                final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n                final int termOffset = termOffsets[termOrd];\n                final int termLength = termOffsets[1+termOrd] - termOffset;\n\n                // if (DEBUG) {\n                //   System.out.println(\"  check termOrd=\" + termOrd + \" term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips) + \" i=\" + i);\n                // }\n\n                if (termOrd == states[stateUpto].changeOrd) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"  end push return\");\n                  // }\n                  stateUpto--;\n                  termOrd--;\n                  return;\n                }\n\n                if (termLength == i) {\n                  termOrd++;\n                  skipUpto = 0;\n                  // if (DEBUG) {\n                  //   System.out.println(\"    term too short; next term\");\n                  // }\n                } else if (label < (termBytes[termOffset+i] & 0xFF)) {\n                  termOrd--;\n                  // if (DEBUG) {\n                  //   System.out.println(\"  no match; already beyond; return termOrd=\" + termOrd);\n                  // }\n                  stateUpto -= skipUpto;\n                  assert stateUpto >= 0;\n                  return;\n                } else if (label == (termBytes[termOffset+i] & 0xFF)) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"    label[\" + i + \"] matches\");\n                  // }\n                  if (skipUpto < numSkips) {\n                    grow();\n\n                    final int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n                    // Automaton is required to accept startTerm:\n                    assert nextState != -1;\n\n                    stateUpto++;\n                    states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n                    states[stateUpto].state = nextState;\n                    states[stateUpto].transitionCount = compiledAutomaton.lightAutomaton.getNumTransitions(nextState);\n                    compiledAutomaton.lightAutomaton.initTransition(states[stateUpto].state, states[stateUpto].transition);\n                    states[stateUpto].transitionUpto = -1;\n                    states[stateUpto].transitionMax = -1;\n                    //System.out.println(\"  push \" + states[stateUpto].transitions.length + \" trans\");\n\n                    // if (DEBUG) {\n                    //   System.out.println(\"    push skip; changeOrd=\" + states[stateUpto].changeOrd);\n                    // }\n\n                    // Match next label at this same term:\n                    continue nextLabel;\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"    linear scan\");\n                    // }\n                    // Index exhausted: just scan now (the\n                    // number of scans required will be less\n                    // than the minSkipCount):\n                    final int startTermOrd = termOrd;\n                    while (termOrd < terms.length && compare(termOrd, startTerm) <= 0) {\n                      assert termOrd == startTermOrd || skipOffsets[termOrd] == skipOffsets[termOrd+1];\n                      termOrd++;\n                    }\n                    assert termOrd - startTermOrd < minSkipCount;\n                    termOrd--;\n                    stateUpto -= skipUpto;\n                    // if (DEBUG) {\n                    //   System.out.println(\"  end termOrd=\" + termOrd);\n                    // }\n                    return;\n                  }\n                } else {\n                  if (skipUpto < numSkips) {\n                    termOrd = skips[skipOffset + skipUpto];\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; skip to termOrd=\" + termOrd);\n                    // }\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; next term\");\n                    // }\n                    termOrd++;\n                  }\n                  skipUpto = 0;\n                }\n              }\n\n              // startTerm is >= last term so enum will not\n              // return any terms:\n              termOrd--;\n              // if (DEBUG) {\n              //   System.out.println(\"  beyond end; no terms will match\");\n              // }\n              return;\n            }\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLen = termOffsets[1+termOrd] - termOffset;\n\n          if (termOrd >= 0 && !startTerm.equals(new BytesRef(termBytes, termOffset, termLen))) {\n            stateUpto -= skipUpto;\n            termOrd--;\n          }\n          // if (DEBUG) {\n          //   System.out.println(\"  loop end; return termOrd=\" + termOrd + \" stateUpto=\" + stateUpto);\n          // }\n        }\n      }\n\n","sourceOld":"      public DirectIntersectTermsEnum(CompiledAutomaton compiled, BytesRef startTerm) {\n        runAutomaton = compiled.runAutomaton;\n        compiledAutomaton = compiled;\n        termOrd = -1;\n        states = new State[1];\n        states[0] = new State();\n        states[0].changeOrd = terms.length;\n        states[0].state = runAutomaton.getInitialState();\n        states[0].transitions = compiledAutomaton.sortedTransitions[states[0].state];\n        states[0].transitionUpto = -1;\n        states[0].transitionMax = -1;\n\n        //System.out.println(\"IE.init startTerm=\" + startTerm);\n\n        if (startTerm != null) {\n          int skipUpto = 0;\n          if (startTerm.length == 0) {\n            if (terms.length > 0 && termOffsets[1] == 0) {\n              termOrd = 0;\n            }\n          } else {\n            termOrd++;\n\n            nextLabel:\n            for(int i=0;i<startTerm.length;i++) {\n              final int label = startTerm.bytes[startTerm.offset+i] & 0xFF;\n\n              while (label > states[i].transitionMax) {\n                states[i].transitionUpto++;\n                assert states[i].transitionUpto < states[i].transitions.length;\n                states[i].transitionMin = states[i].transitions[states[i].transitionUpto].getMin();\n                states[i].transitionMax = states[i].transitions[states[i].transitionUpto].getMax();\n                assert states[i].transitionMin >= 0;\n                assert states[i].transitionMin <= 255;\n                assert states[i].transitionMax >= 0;\n                assert states[i].transitionMax <= 255;\n              }\n\n              // Skip forwards until we find a term matching\n              // the label at this position:\n              while (termOrd < terms.length) {\n                final int skipOffset = skipOffsets[termOrd];\n                final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n                final int termOffset = termOffsets[termOrd];\n                final int termLength = termOffsets[1+termOrd] - termOffset;\n\n                // if (DEBUG) {\n                //   System.out.println(\"  check termOrd=\" + termOrd + \" term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips) + \" i=\" + i);\n                // }\n\n                if (termOrd == states[stateUpto].changeOrd) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"  end push return\");\n                  // }\n                  stateUpto--;\n                  termOrd--;\n                  return;\n                }\n\n                if (termLength == i) {\n                  termOrd++;\n                  skipUpto = 0;\n                  // if (DEBUG) {\n                  //   System.out.println(\"    term too short; next term\");\n                  // }\n                } else if (label < (termBytes[termOffset+i] & 0xFF)) {\n                  termOrd--;\n                  // if (DEBUG) {\n                  //   System.out.println(\"  no match; already beyond; return termOrd=\" + termOrd);\n                  // }\n                  stateUpto -= skipUpto;\n                  assert stateUpto >= 0;\n                  return;\n                } else if (label == (termBytes[termOffset+i] & 0xFF)) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"    label[\" + i + \"] matches\");\n                  // }\n                  if (skipUpto < numSkips) {\n                    grow();\n\n                    final int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n                    // Automaton is required to accept startTerm:\n                    assert nextState != -1;\n\n                    stateUpto++;\n                    states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n                    states[stateUpto].state = nextState;\n                    states[stateUpto].transitions = compiledAutomaton.sortedTransitions[nextState];\n                    states[stateUpto].transitionUpto = -1;\n                    states[stateUpto].transitionMax = -1;\n                    //System.out.println(\"  push \" + states[stateUpto].transitions.length + \" trans\");\n\n                    // if (DEBUG) {\n                    //   System.out.println(\"    push skip; changeOrd=\" + states[stateUpto].changeOrd);\n                    // }\n\n                    // Match next label at this same term:\n                    continue nextLabel;\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"    linear scan\");\n                    // }\n                    // Index exhausted: just scan now (the\n                    // number of scans required will be less\n                    // than the minSkipCount):\n                    final int startTermOrd = termOrd;\n                    while (termOrd < terms.length && compare(termOrd, startTerm) <= 0) {\n                      assert termOrd == startTermOrd || skipOffsets[termOrd] == skipOffsets[termOrd+1];\n                      termOrd++;\n                    }\n                    assert termOrd - startTermOrd < minSkipCount;\n                    termOrd--;\n                    stateUpto -= skipUpto;\n                    // if (DEBUG) {\n                    //   System.out.println(\"  end termOrd=\" + termOrd);\n                    // }\n                    return;\n                  }\n                } else {\n                  if (skipUpto < numSkips) {\n                    termOrd = skips[skipOffset + skipUpto];\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; skip to termOrd=\" + termOrd);\n                    // }\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; next term\");\n                    // }\n                    termOrd++;\n                  }\n                  skipUpto = 0;\n                }\n              }\n\n              // startTerm is >= last term so enum will not\n              // return any terms:\n              termOrd--;\n              // if (DEBUG) {\n              //   System.out.println(\"  beyond end; no terms will match\");\n              // }\n              return;\n            }\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLen = termOffsets[1+termOrd] - termOffset;\n\n          if (termOrd >= 0 && !startTerm.equals(new BytesRef(termBytes, termOffset, termLen))) {\n            stateUpto -= skipUpto;\n            termOrd--;\n          }\n          // if (DEBUG) {\n          //   System.out.println(\"  loop end; return termOrd=\" + termOrd + \" stateUpto=\" + stateUpto);\n          // }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#DirectIntersectTermsEnum(CompiledAutomaton,BytesRef).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#DirectIntersectTermsEnum(CompiledAutomaton,BytesRef).mjava","sourceNew":"      public DirectIntersectTermsEnum(CompiledAutomaton compiled, BytesRef startTerm) {\n        runAutomaton = compiled.runAutomaton;\n        compiledAutomaton = compiled;\n        termOrd = -1;\n        states = new State[1];\n        states[0] = new State();\n        states[0].changeOrd = terms.length;\n        states[0].state = runAutomaton.getInitialState();\n        states[0].transitionCount = compiledAutomaton.automaton.getNumTransitions(states[0].state);\n        compiledAutomaton.automaton.initTransition(states[0].state, states[0].transition);\n        states[0].transitionUpto = -1;\n        states[0].transitionMax = -1;\n\n        //System.out.println(\"IE.init startTerm=\" + startTerm);\n\n        if (startTerm != null) {\n          int skipUpto = 0;\n          if (startTerm.length == 0) {\n            if (terms.length > 0 && termOffsets[1] == 0) {\n              termOrd = 0;\n            }\n          } else {\n            termOrd++;\n\n            nextLabel:\n            for(int i=0;i<startTerm.length;i++) {\n              final int label = startTerm.bytes[startTerm.offset+i] & 0xFF;\n\n              while (label > states[i].transitionMax) {\n                states[i].transitionUpto++;\n                assert states[i].transitionUpto < states[i].transitionCount;\n                compiledAutomaton.automaton.getNextTransition(states[i].transition);\n                states[i].transitionMin = states[i].transition.min;\n                states[i].transitionMax = states[i].transition.max;\n                assert states[i].transitionMin >= 0;\n                assert states[i].transitionMin <= 255;\n                assert states[i].transitionMax >= 0;\n                assert states[i].transitionMax <= 255;\n              }\n\n              // Skip forwards until we find a term matching\n              // the label at this position:\n              while (termOrd < terms.length) {\n                final int skipOffset = skipOffsets[termOrd];\n                final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n                final int termOffset = termOffsets[termOrd];\n                final int termLength = termOffsets[1+termOrd] - termOffset;\n\n                // if (DEBUG) {\n                //   System.out.println(\"  check termOrd=\" + termOrd + \" term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips) + \" i=\" + i);\n                // }\n\n                if (termOrd == states[stateUpto].changeOrd) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"  end push return\");\n                  // }\n                  stateUpto--;\n                  termOrd--;\n                  return;\n                }\n\n                if (termLength == i) {\n                  termOrd++;\n                  skipUpto = 0;\n                  // if (DEBUG) {\n                  //   System.out.println(\"    term too short; next term\");\n                  // }\n                } else if (label < (termBytes[termOffset+i] & 0xFF)) {\n                  termOrd--;\n                  // if (DEBUG) {\n                  //   System.out.println(\"  no match; already beyond; return termOrd=\" + termOrd);\n                  // }\n                  stateUpto -= skipUpto;\n                  assert stateUpto >= 0;\n                  return;\n                } else if (label == (termBytes[termOffset+i] & 0xFF)) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"    label[\" + i + \"] matches\");\n                  // }\n                  if (skipUpto < numSkips) {\n                    grow();\n\n                    final int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n                    // Automaton is required to accept startTerm:\n                    assert nextState != -1;\n\n                    stateUpto++;\n                    states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n                    states[stateUpto].state = nextState;\n                    states[stateUpto].transitionCount = compiledAutomaton.automaton.getNumTransitions(nextState);\n                    compiledAutomaton.automaton.initTransition(states[stateUpto].state, states[stateUpto].transition);\n                    states[stateUpto].transitionUpto = -1;\n                    states[stateUpto].transitionMax = -1;\n                    //System.out.println(\"  push \" + states[stateUpto].transitions.length + \" trans\");\n\n                    // if (DEBUG) {\n                    //   System.out.println(\"    push skip; changeOrd=\" + states[stateUpto].changeOrd);\n                    // }\n\n                    // Match next label at this same term:\n                    continue nextLabel;\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"    linear scan\");\n                    // }\n                    // Index exhausted: just scan now (the\n                    // number of scans required will be less\n                    // than the minSkipCount):\n                    final int startTermOrd = termOrd;\n                    while (termOrd < terms.length && compare(termOrd, startTerm) <= 0) {\n                      assert termOrd == startTermOrd || skipOffsets[termOrd] == skipOffsets[termOrd+1];\n                      termOrd++;\n                    }\n                    assert termOrd - startTermOrd < minSkipCount;\n                    termOrd--;\n                    stateUpto -= skipUpto;\n                    // if (DEBUG) {\n                    //   System.out.println(\"  end termOrd=\" + termOrd);\n                    // }\n                    return;\n                  }\n                } else {\n                  if (skipUpto < numSkips) {\n                    termOrd = skips[skipOffset + skipUpto];\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; skip to termOrd=\" + termOrd);\n                    // }\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; next term\");\n                    // }\n                    termOrd++;\n                  }\n                  skipUpto = 0;\n                }\n              }\n\n              // startTerm is >= last term so enum will not\n              // return any terms:\n              termOrd--;\n              // if (DEBUG) {\n              //   System.out.println(\"  beyond end; no terms will match\");\n              // }\n              return;\n            }\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLen = termOffsets[1+termOrd] - termOffset;\n\n          if (termOrd >= 0 && !startTerm.equals(new BytesRef(termBytes, termOffset, termLen))) {\n            stateUpto -= skipUpto;\n            termOrd--;\n          }\n          // if (DEBUG) {\n          //   System.out.println(\"  loop end; return termOrd=\" + termOrd + \" stateUpto=\" + stateUpto);\n          // }\n        }\n      }\n\n","sourceOld":"      public DirectIntersectTermsEnum(CompiledAutomaton compiled, BytesRef startTerm) {\n        runAutomaton = compiled.runAutomaton;\n        compiledAutomaton = compiled;\n        termOrd = -1;\n        states = new State[1];\n        states[0] = new State();\n        states[0].changeOrd = terms.length;\n        states[0].state = runAutomaton.getInitialState();\n        states[0].transitionCount = compiledAutomaton.lightAutomaton.getNumTransitions(states[0].state);\n        compiledAutomaton.lightAutomaton.initTransition(states[0].state, states[0].transition);\n        states[0].transitionUpto = -1;\n        states[0].transitionMax = -1;\n\n        //System.out.println(\"IE.init startTerm=\" + startTerm);\n\n        if (startTerm != null) {\n          int skipUpto = 0;\n          if (startTerm.length == 0) {\n            if (terms.length > 0 && termOffsets[1] == 0) {\n              termOrd = 0;\n            }\n          } else {\n            termOrd++;\n\n            nextLabel:\n            for(int i=0;i<startTerm.length;i++) {\n              final int label = startTerm.bytes[startTerm.offset+i] & 0xFF;\n\n              while (label > states[i].transitionMax) {\n                states[i].transitionUpto++;\n                assert states[i].transitionUpto < states[i].transitionCount;\n                compiledAutomaton.lightAutomaton.getNextTransition(states[i].transition);\n                states[i].transitionMin = states[i].transition.min;\n                states[i].transitionMax = states[i].transition.max;\n                assert states[i].transitionMin >= 0;\n                assert states[i].transitionMin <= 255;\n                assert states[i].transitionMax >= 0;\n                assert states[i].transitionMax <= 255;\n              }\n\n              // Skip forwards until we find a term matching\n              // the label at this position:\n              while (termOrd < terms.length) {\n                final int skipOffset = skipOffsets[termOrd];\n                final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n                final int termOffset = termOffsets[termOrd];\n                final int termLength = termOffsets[1+termOrd] - termOffset;\n\n                // if (DEBUG) {\n                //   System.out.println(\"  check termOrd=\" + termOrd + \" term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips) + \" i=\" + i);\n                // }\n\n                if (termOrd == states[stateUpto].changeOrd) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"  end push return\");\n                  // }\n                  stateUpto--;\n                  termOrd--;\n                  return;\n                }\n\n                if (termLength == i) {\n                  termOrd++;\n                  skipUpto = 0;\n                  // if (DEBUG) {\n                  //   System.out.println(\"    term too short; next term\");\n                  // }\n                } else if (label < (termBytes[termOffset+i] & 0xFF)) {\n                  termOrd--;\n                  // if (DEBUG) {\n                  //   System.out.println(\"  no match; already beyond; return termOrd=\" + termOrd);\n                  // }\n                  stateUpto -= skipUpto;\n                  assert stateUpto >= 0;\n                  return;\n                } else if (label == (termBytes[termOffset+i] & 0xFF)) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"    label[\" + i + \"] matches\");\n                  // }\n                  if (skipUpto < numSkips) {\n                    grow();\n\n                    final int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n                    // Automaton is required to accept startTerm:\n                    assert nextState != -1;\n\n                    stateUpto++;\n                    states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n                    states[stateUpto].state = nextState;\n                    states[stateUpto].transitionCount = compiledAutomaton.lightAutomaton.getNumTransitions(nextState);\n                    compiledAutomaton.lightAutomaton.initTransition(states[stateUpto].state, states[stateUpto].transition);\n                    states[stateUpto].transitionUpto = -1;\n                    states[stateUpto].transitionMax = -1;\n                    //System.out.println(\"  push \" + states[stateUpto].transitions.length + \" trans\");\n\n                    // if (DEBUG) {\n                    //   System.out.println(\"    push skip; changeOrd=\" + states[stateUpto].changeOrd);\n                    // }\n\n                    // Match next label at this same term:\n                    continue nextLabel;\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"    linear scan\");\n                    // }\n                    // Index exhausted: just scan now (the\n                    // number of scans required will be less\n                    // than the minSkipCount):\n                    final int startTermOrd = termOrd;\n                    while (termOrd < terms.length && compare(termOrd, startTerm) <= 0) {\n                      assert termOrd == startTermOrd || skipOffsets[termOrd] == skipOffsets[termOrd+1];\n                      termOrd++;\n                    }\n                    assert termOrd - startTermOrd < minSkipCount;\n                    termOrd--;\n                    stateUpto -= skipUpto;\n                    // if (DEBUG) {\n                    //   System.out.println(\"  end termOrd=\" + termOrd);\n                    // }\n                    return;\n                  }\n                } else {\n                  if (skipUpto < numSkips) {\n                    termOrd = skips[skipOffset + skipUpto];\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; skip to termOrd=\" + termOrd);\n                    // }\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; next term\");\n                    // }\n                    termOrd++;\n                  }\n                  skipUpto = 0;\n                }\n              }\n\n              // startTerm is >= last term so enum will not\n              // return any terms:\n              termOrd--;\n              // if (DEBUG) {\n              //   System.out.println(\"  beyond end; no terms will match\");\n              // }\n              return;\n            }\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLen = termOffsets[1+termOrd] - termOffset;\n\n          if (termOrd >= 0 && !startTerm.equals(new BytesRef(termBytes, termOffset, termLen))) {\n            stateUpto -= skipUpto;\n            termOrd--;\n          }\n          // if (DEBUG) {\n          //   System.out.println(\"  loop end; return termOrd=\" + termOrd + \" stateUpto=\" + stateUpto);\n          // }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#DirectIntersectTermsEnum(CompiledAutomaton,BytesRef).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#DirectIntersectTermsEnum(CompiledAutomaton,BytesRef).mjava","sourceNew":"      public DirectIntersectTermsEnum(CompiledAutomaton compiled, BytesRef startTerm) {\n        runAutomaton = compiled.runAutomaton;\n        compiledAutomaton = compiled;\n        termOrd = -1;\n        states = new State[1];\n        states[0] = new State();\n        states[0].changeOrd = terms.length;\n        states[0].state = runAutomaton.getInitialState();\n        states[0].transitionCount = compiledAutomaton.automaton.getNumTransitions(states[0].state);\n        compiledAutomaton.automaton.initTransition(states[0].state, states[0].transition);\n        states[0].transitionUpto = -1;\n        states[0].transitionMax = -1;\n\n        //System.out.println(\"IE.init startTerm=\" + startTerm);\n\n        if (startTerm != null) {\n          int skipUpto = 0;\n          if (startTerm.length == 0) {\n            if (terms.length > 0 && termOffsets[1] == 0) {\n              termOrd = 0;\n            }\n          } else {\n            termOrd++;\n\n            nextLabel:\n            for(int i=0;i<startTerm.length;i++) {\n              final int label = startTerm.bytes[startTerm.offset+i] & 0xFF;\n\n              while (label > states[i].transitionMax) {\n                states[i].transitionUpto++;\n                assert states[i].transitionUpto < states[i].transitionCount;\n                compiledAutomaton.automaton.getNextTransition(states[i].transition);\n                states[i].transitionMin = states[i].transition.min;\n                states[i].transitionMax = states[i].transition.max;\n                assert states[i].transitionMin >= 0;\n                assert states[i].transitionMin <= 255;\n                assert states[i].transitionMax >= 0;\n                assert states[i].transitionMax <= 255;\n              }\n\n              // Skip forwards until we find a term matching\n              // the label at this position:\n              while (termOrd < terms.length) {\n                final int skipOffset = skipOffsets[termOrd];\n                final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n                final int termOffset = termOffsets[termOrd];\n                final int termLength = termOffsets[1+termOrd] - termOffset;\n\n                // if (DEBUG) {\n                //   System.out.println(\"  check termOrd=\" + termOrd + \" term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips) + \" i=\" + i);\n                // }\n\n                if (termOrd == states[stateUpto].changeOrd) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"  end push return\");\n                  // }\n                  stateUpto--;\n                  termOrd--;\n                  return;\n                }\n\n                if (termLength == i) {\n                  termOrd++;\n                  skipUpto = 0;\n                  // if (DEBUG) {\n                  //   System.out.println(\"    term too short; next term\");\n                  // }\n                } else if (label < (termBytes[termOffset+i] & 0xFF)) {\n                  termOrd--;\n                  // if (DEBUG) {\n                  //   System.out.println(\"  no match; already beyond; return termOrd=\" + termOrd);\n                  // }\n                  stateUpto -= skipUpto;\n                  assert stateUpto >= 0;\n                  return;\n                } else if (label == (termBytes[termOffset+i] & 0xFF)) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"    label[\" + i + \"] matches\");\n                  // }\n                  if (skipUpto < numSkips) {\n                    grow();\n\n                    final int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n                    // Automaton is required to accept startTerm:\n                    assert nextState != -1;\n\n                    stateUpto++;\n                    states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n                    states[stateUpto].state = nextState;\n                    states[stateUpto].transitionCount = compiledAutomaton.automaton.getNumTransitions(nextState);\n                    compiledAutomaton.automaton.initTransition(states[stateUpto].state, states[stateUpto].transition);\n                    states[stateUpto].transitionUpto = -1;\n                    states[stateUpto].transitionMax = -1;\n                    //System.out.println(\"  push \" + states[stateUpto].transitions.length + \" trans\");\n\n                    // if (DEBUG) {\n                    //   System.out.println(\"    push skip; changeOrd=\" + states[stateUpto].changeOrd);\n                    // }\n\n                    // Match next label at this same term:\n                    continue nextLabel;\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"    linear scan\");\n                    // }\n                    // Index exhausted: just scan now (the\n                    // number of scans required will be less\n                    // than the minSkipCount):\n                    final int startTermOrd = termOrd;\n                    while (termOrd < terms.length && compare(termOrd, startTerm) <= 0) {\n                      assert termOrd == startTermOrd || skipOffsets[termOrd] == skipOffsets[termOrd+1];\n                      termOrd++;\n                    }\n                    assert termOrd - startTermOrd < minSkipCount;\n                    termOrd--;\n                    stateUpto -= skipUpto;\n                    // if (DEBUG) {\n                    //   System.out.println(\"  end termOrd=\" + termOrd);\n                    // }\n                    return;\n                  }\n                } else {\n                  if (skipUpto < numSkips) {\n                    termOrd = skips[skipOffset + skipUpto];\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; skip to termOrd=\" + termOrd);\n                    // }\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; next term\");\n                    // }\n                    termOrd++;\n                  }\n                  skipUpto = 0;\n                }\n              }\n\n              // startTerm is >= last term so enum will not\n              // return any terms:\n              termOrd--;\n              // if (DEBUG) {\n              //   System.out.println(\"  beyond end; no terms will match\");\n              // }\n              return;\n            }\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLen = termOffsets[1+termOrd] - termOffset;\n\n          if (termOrd >= 0 && !startTerm.equals(new BytesRef(termBytes, termOffset, termLen))) {\n            stateUpto -= skipUpto;\n            termOrd--;\n          }\n          // if (DEBUG) {\n          //   System.out.println(\"  loop end; return termOrd=\" + termOrd + \" stateUpto=\" + stateUpto);\n          // }\n        }\n      }\n\n","sourceOld":"      public DirectIntersectTermsEnum(CompiledAutomaton compiled, BytesRef startTerm) {\n        runAutomaton = compiled.runAutomaton;\n        compiledAutomaton = compiled;\n        termOrd = -1;\n        states = new State[1];\n        states[0] = new State();\n        states[0].changeOrd = terms.length;\n        states[0].state = runAutomaton.getInitialState();\n        states[0].transitions = compiledAutomaton.sortedTransitions[states[0].state];\n        states[0].transitionUpto = -1;\n        states[0].transitionMax = -1;\n\n        //System.out.println(\"IE.init startTerm=\" + startTerm);\n\n        if (startTerm != null) {\n          int skipUpto = 0;\n          if (startTerm.length == 0) {\n            if (terms.length > 0 && termOffsets[1] == 0) {\n              termOrd = 0;\n            }\n          } else {\n            termOrd++;\n\n            nextLabel:\n            for(int i=0;i<startTerm.length;i++) {\n              final int label = startTerm.bytes[startTerm.offset+i] & 0xFF;\n\n              while (label > states[i].transitionMax) {\n                states[i].transitionUpto++;\n                assert states[i].transitionUpto < states[i].transitions.length;\n                states[i].transitionMin = states[i].transitions[states[i].transitionUpto].getMin();\n                states[i].transitionMax = states[i].transitions[states[i].transitionUpto].getMax();\n                assert states[i].transitionMin >= 0;\n                assert states[i].transitionMin <= 255;\n                assert states[i].transitionMax >= 0;\n                assert states[i].transitionMax <= 255;\n              }\n\n              // Skip forwards until we find a term matching\n              // the label at this position:\n              while (termOrd < terms.length) {\n                final int skipOffset = skipOffsets[termOrd];\n                final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n                final int termOffset = termOffsets[termOrd];\n                final int termLength = termOffsets[1+termOrd] - termOffset;\n\n                // if (DEBUG) {\n                //   System.out.println(\"  check termOrd=\" + termOrd + \" term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips) + \" i=\" + i);\n                // }\n\n                if (termOrd == states[stateUpto].changeOrd) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"  end push return\");\n                  // }\n                  stateUpto--;\n                  termOrd--;\n                  return;\n                }\n\n                if (termLength == i) {\n                  termOrd++;\n                  skipUpto = 0;\n                  // if (DEBUG) {\n                  //   System.out.println(\"    term too short; next term\");\n                  // }\n                } else if (label < (termBytes[termOffset+i] & 0xFF)) {\n                  termOrd--;\n                  // if (DEBUG) {\n                  //   System.out.println(\"  no match; already beyond; return termOrd=\" + termOrd);\n                  // }\n                  stateUpto -= skipUpto;\n                  assert stateUpto >= 0;\n                  return;\n                } else if (label == (termBytes[termOffset+i] & 0xFF)) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"    label[\" + i + \"] matches\");\n                  // }\n                  if (skipUpto < numSkips) {\n                    grow();\n\n                    final int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n                    // Automaton is required to accept startTerm:\n                    assert nextState != -1;\n\n                    stateUpto++;\n                    states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n                    states[stateUpto].state = nextState;\n                    states[stateUpto].transitions = compiledAutomaton.sortedTransitions[nextState];\n                    states[stateUpto].transitionUpto = -1;\n                    states[stateUpto].transitionMax = -1;\n                    //System.out.println(\"  push \" + states[stateUpto].transitions.length + \" trans\");\n\n                    // if (DEBUG) {\n                    //   System.out.println(\"    push skip; changeOrd=\" + states[stateUpto].changeOrd);\n                    // }\n\n                    // Match next label at this same term:\n                    continue nextLabel;\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"    linear scan\");\n                    // }\n                    // Index exhausted: just scan now (the\n                    // number of scans required will be less\n                    // than the minSkipCount):\n                    final int startTermOrd = termOrd;\n                    while (termOrd < terms.length && compare(termOrd, startTerm) <= 0) {\n                      assert termOrd == startTermOrd || skipOffsets[termOrd] == skipOffsets[termOrd+1];\n                      termOrd++;\n                    }\n                    assert termOrd - startTermOrd < minSkipCount;\n                    termOrd--;\n                    stateUpto -= skipUpto;\n                    // if (DEBUG) {\n                    //   System.out.println(\"  end termOrd=\" + termOrd);\n                    // }\n                    return;\n                  }\n                } else {\n                  if (skipUpto < numSkips) {\n                    termOrd = skips[skipOffset + skipUpto];\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; skip to termOrd=\" + termOrd);\n                    // }\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; next term\");\n                    // }\n                    termOrd++;\n                  }\n                  skipUpto = 0;\n                }\n              }\n\n              // startTerm is >= last term so enum will not\n              // return any terms:\n              termOrd--;\n              // if (DEBUG) {\n              //   System.out.println(\"  beyond end; no terms will match\");\n              // }\n              return;\n            }\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLen = termOffsets[1+termOrd] - termOffset;\n\n          if (termOrd >= 0 && !startTerm.equals(new BytesRef(termBytes, termOffset, termLen))) {\n            stateUpto -= skipUpto;\n            termOrd--;\n          }\n          // if (DEBUG) {\n          //   System.out.println(\"  loop end; return termOrd=\" + termOrd + \" stateUpto=\" + stateUpto);\n          // }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7543e96e2d4820e09334d36a699b998ed963f4f","date":1476121426,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#DirectIntersectTermsEnum(CompiledAutomaton,BytesRef).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#DirectIntersectTermsEnum(CompiledAutomaton,BytesRef).mjava","sourceNew":"      public DirectIntersectTermsEnum(CompiledAutomaton compiled, BytesRef startTerm) {\n        runAutomaton = compiled.runAutomaton;\n        compiledAutomaton = compiled;\n        termOrd = -1;\n        states = new State[1];\n        states[0] = new State();\n        states[0].changeOrd = terms.length;\n        states[0].state = 0;\n        states[0].transitionCount = compiledAutomaton.automaton.getNumTransitions(states[0].state);\n        compiledAutomaton.automaton.initTransition(states[0].state, states[0].transition);\n        states[0].transitionUpto = -1;\n        states[0].transitionMax = -1;\n\n        //System.out.println(\"IE.init startTerm=\" + startTerm);\n\n        if (startTerm != null) {\n          int skipUpto = 0;\n          if (startTerm.length == 0) {\n            if (terms.length > 0 && termOffsets[1] == 0) {\n              termOrd = 0;\n            }\n          } else {\n            termOrd++;\n\n            nextLabel:\n            for(int i=0;i<startTerm.length;i++) {\n              final int label = startTerm.bytes[startTerm.offset+i] & 0xFF;\n\n              while (label > states[i].transitionMax) {\n                states[i].transitionUpto++;\n                assert states[i].transitionUpto < states[i].transitionCount;\n                compiledAutomaton.automaton.getNextTransition(states[i].transition);\n                states[i].transitionMin = states[i].transition.min;\n                states[i].transitionMax = states[i].transition.max;\n                assert states[i].transitionMin >= 0;\n                assert states[i].transitionMin <= 255;\n                assert states[i].transitionMax >= 0;\n                assert states[i].transitionMax <= 255;\n              }\n\n              // Skip forwards until we find a term matching\n              // the label at this position:\n              while (termOrd < terms.length) {\n                final int skipOffset = skipOffsets[termOrd];\n                final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n                final int termOffset = termOffsets[termOrd];\n                final int termLength = termOffsets[1+termOrd] - termOffset;\n\n                // if (DEBUG) {\n                //   System.out.println(\"  check termOrd=\" + termOrd + \" term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips) + \" i=\" + i);\n                // }\n\n                if (termOrd == states[stateUpto].changeOrd) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"  end push return\");\n                  // }\n                  stateUpto--;\n                  termOrd--;\n                  return;\n                }\n\n                if (termLength == i) {\n                  termOrd++;\n                  skipUpto = 0;\n                  // if (DEBUG) {\n                  //   System.out.println(\"    term too short; next term\");\n                  // }\n                } else if (label < (termBytes[termOffset+i] & 0xFF)) {\n                  termOrd--;\n                  // if (DEBUG) {\n                  //   System.out.println(\"  no match; already beyond; return termOrd=\" + termOrd);\n                  // }\n                  stateUpto -= skipUpto;\n                  assert stateUpto >= 0;\n                  return;\n                } else if (label == (termBytes[termOffset+i] & 0xFF)) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"    label[\" + i + \"] matches\");\n                  // }\n                  if (skipUpto < numSkips) {\n                    grow();\n\n                    final int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n                    // Automaton is required to accept startTerm:\n                    assert nextState != -1;\n\n                    stateUpto++;\n                    states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n                    states[stateUpto].state = nextState;\n                    states[stateUpto].transitionCount = compiledAutomaton.automaton.getNumTransitions(nextState);\n                    compiledAutomaton.automaton.initTransition(states[stateUpto].state, states[stateUpto].transition);\n                    states[stateUpto].transitionUpto = -1;\n                    states[stateUpto].transitionMax = -1;\n                    //System.out.println(\"  push \" + states[stateUpto].transitions.length + \" trans\");\n\n                    // if (DEBUG) {\n                    //   System.out.println(\"    push skip; changeOrd=\" + states[stateUpto].changeOrd);\n                    // }\n\n                    // Match next label at this same term:\n                    continue nextLabel;\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"    linear scan\");\n                    // }\n                    // Index exhausted: just scan now (the\n                    // number of scans required will be less\n                    // than the minSkipCount):\n                    final int startTermOrd = termOrd;\n                    while (termOrd < terms.length && compare(termOrd, startTerm) <= 0) {\n                      assert termOrd == startTermOrd || skipOffsets[termOrd] == skipOffsets[termOrd+1];\n                      termOrd++;\n                    }\n                    assert termOrd - startTermOrd < minSkipCount;\n                    termOrd--;\n                    stateUpto -= skipUpto;\n                    // if (DEBUG) {\n                    //   System.out.println(\"  end termOrd=\" + termOrd);\n                    // }\n                    return;\n                  }\n                } else {\n                  if (skipUpto < numSkips) {\n                    termOrd = skips[skipOffset + skipUpto];\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; skip to termOrd=\" + termOrd);\n                    // }\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; next term\");\n                    // }\n                    termOrd++;\n                  }\n                  skipUpto = 0;\n                }\n              }\n\n              // startTerm is >= last term so enum will not\n              // return any terms:\n              termOrd--;\n              // if (DEBUG) {\n              //   System.out.println(\"  beyond end; no terms will match\");\n              // }\n              return;\n            }\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLen = termOffsets[1+termOrd] - termOffset;\n\n          if (termOrd >= 0 && !startTerm.equals(new BytesRef(termBytes, termOffset, termLen))) {\n            stateUpto -= skipUpto;\n            termOrd--;\n          }\n          // if (DEBUG) {\n          //   System.out.println(\"  loop end; return termOrd=\" + termOrd + \" stateUpto=\" + stateUpto);\n          // }\n        }\n      }\n\n","sourceOld":"      public DirectIntersectTermsEnum(CompiledAutomaton compiled, BytesRef startTerm) {\n        runAutomaton = compiled.runAutomaton;\n        compiledAutomaton = compiled;\n        termOrd = -1;\n        states = new State[1];\n        states[0] = new State();\n        states[0].changeOrd = terms.length;\n        states[0].state = runAutomaton.getInitialState();\n        states[0].transitionCount = compiledAutomaton.automaton.getNumTransitions(states[0].state);\n        compiledAutomaton.automaton.initTransition(states[0].state, states[0].transition);\n        states[0].transitionUpto = -1;\n        states[0].transitionMax = -1;\n\n        //System.out.println(\"IE.init startTerm=\" + startTerm);\n\n        if (startTerm != null) {\n          int skipUpto = 0;\n          if (startTerm.length == 0) {\n            if (terms.length > 0 && termOffsets[1] == 0) {\n              termOrd = 0;\n            }\n          } else {\n            termOrd++;\n\n            nextLabel:\n            for(int i=0;i<startTerm.length;i++) {\n              final int label = startTerm.bytes[startTerm.offset+i] & 0xFF;\n\n              while (label > states[i].transitionMax) {\n                states[i].transitionUpto++;\n                assert states[i].transitionUpto < states[i].transitionCount;\n                compiledAutomaton.automaton.getNextTransition(states[i].transition);\n                states[i].transitionMin = states[i].transition.min;\n                states[i].transitionMax = states[i].transition.max;\n                assert states[i].transitionMin >= 0;\n                assert states[i].transitionMin <= 255;\n                assert states[i].transitionMax >= 0;\n                assert states[i].transitionMax <= 255;\n              }\n\n              // Skip forwards until we find a term matching\n              // the label at this position:\n              while (termOrd < terms.length) {\n                final int skipOffset = skipOffsets[termOrd];\n                final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n                final int termOffset = termOffsets[termOrd];\n                final int termLength = termOffsets[1+termOrd] - termOffset;\n\n                // if (DEBUG) {\n                //   System.out.println(\"  check termOrd=\" + termOrd + \" term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips) + \" i=\" + i);\n                // }\n\n                if (termOrd == states[stateUpto].changeOrd) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"  end push return\");\n                  // }\n                  stateUpto--;\n                  termOrd--;\n                  return;\n                }\n\n                if (termLength == i) {\n                  termOrd++;\n                  skipUpto = 0;\n                  // if (DEBUG) {\n                  //   System.out.println(\"    term too short; next term\");\n                  // }\n                } else if (label < (termBytes[termOffset+i] & 0xFF)) {\n                  termOrd--;\n                  // if (DEBUG) {\n                  //   System.out.println(\"  no match; already beyond; return termOrd=\" + termOrd);\n                  // }\n                  stateUpto -= skipUpto;\n                  assert stateUpto >= 0;\n                  return;\n                } else if (label == (termBytes[termOffset+i] & 0xFF)) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"    label[\" + i + \"] matches\");\n                  // }\n                  if (skipUpto < numSkips) {\n                    grow();\n\n                    final int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n                    // Automaton is required to accept startTerm:\n                    assert nextState != -1;\n\n                    stateUpto++;\n                    states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n                    states[stateUpto].state = nextState;\n                    states[stateUpto].transitionCount = compiledAutomaton.automaton.getNumTransitions(nextState);\n                    compiledAutomaton.automaton.initTransition(states[stateUpto].state, states[stateUpto].transition);\n                    states[stateUpto].transitionUpto = -1;\n                    states[stateUpto].transitionMax = -1;\n                    //System.out.println(\"  push \" + states[stateUpto].transitions.length + \" trans\");\n\n                    // if (DEBUG) {\n                    //   System.out.println(\"    push skip; changeOrd=\" + states[stateUpto].changeOrd);\n                    // }\n\n                    // Match next label at this same term:\n                    continue nextLabel;\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"    linear scan\");\n                    // }\n                    // Index exhausted: just scan now (the\n                    // number of scans required will be less\n                    // than the minSkipCount):\n                    final int startTermOrd = termOrd;\n                    while (termOrd < terms.length && compare(termOrd, startTerm) <= 0) {\n                      assert termOrd == startTermOrd || skipOffsets[termOrd] == skipOffsets[termOrd+1];\n                      termOrd++;\n                    }\n                    assert termOrd - startTermOrd < minSkipCount;\n                    termOrd--;\n                    stateUpto -= skipUpto;\n                    // if (DEBUG) {\n                    //   System.out.println(\"  end termOrd=\" + termOrd);\n                    // }\n                    return;\n                  }\n                } else {\n                  if (skipUpto < numSkips) {\n                    termOrd = skips[skipOffset + skipUpto];\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; skip to termOrd=\" + termOrd);\n                    // }\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; next term\");\n                    // }\n                    termOrd++;\n                  }\n                  skipUpto = 0;\n                }\n              }\n\n              // startTerm is >= last term so enum will not\n              // return any terms:\n              termOrd--;\n              // if (DEBUG) {\n              //   System.out.println(\"  beyond end; no terms will match\");\n              // }\n              return;\n            }\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLen = termOffsets[1+termOrd] - termOffset;\n\n          if (termOrd >= 0 && !startTerm.equals(new BytesRef(termBytes, termOffset, termLen))) {\n            stateUpto -= skipUpto;\n            termOrd--;\n          }\n          // if (DEBUG) {\n          //   System.out.println(\"  loop end; return termOrd=\" + termOrd + \" stateUpto=\" + stateUpto);\n          // }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#DirectIntersectTermsEnum(CompiledAutomaton,BytesRef).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#DirectIntersectTermsEnum(CompiledAutomaton,BytesRef).mjava","sourceNew":"      public DirectIntersectTermsEnum(CompiledAutomaton compiled, BytesRef startTerm) {\n        runAutomaton = compiled.runAutomaton;\n        compiledAutomaton = compiled;\n        termOrd = -1;\n        states = new State[1];\n        states[0] = new State();\n        states[0].changeOrd = terms.length;\n        states[0].state = 0;\n        states[0].transitionCount = compiledAutomaton.automaton.getNumTransitions(states[0].state);\n        compiledAutomaton.automaton.initTransition(states[0].state, states[0].transition);\n        states[0].transitionUpto = -1;\n        states[0].transitionMax = -1;\n\n        //System.out.println(\"IE.init startTerm=\" + startTerm);\n\n        if (startTerm != null) {\n          int skipUpto = 0;\n          if (startTerm.length == 0) {\n            if (terms.length > 0 && termOffsets[1] == 0) {\n              termOrd = 0;\n            }\n          } else {\n            termOrd++;\n\n            nextLabel:\n            for(int i=0;i<startTerm.length;i++) {\n              final int label = startTerm.bytes[startTerm.offset+i] & 0xFF;\n\n              while (label > states[i].transitionMax) {\n                states[i].transitionUpto++;\n                assert states[i].transitionUpto < states[i].transitionCount;\n                compiledAutomaton.automaton.getNextTransition(states[i].transition);\n                states[i].transitionMin = states[i].transition.min;\n                states[i].transitionMax = states[i].transition.max;\n                assert states[i].transitionMin >= 0;\n                assert states[i].transitionMin <= 255;\n                assert states[i].transitionMax >= 0;\n                assert states[i].transitionMax <= 255;\n              }\n\n              // Skip forwards until we find a term matching\n              // the label at this position:\n              while (termOrd < terms.length) {\n                final int skipOffset = skipOffsets[termOrd];\n                final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n                final int termOffset = termOffsets[termOrd];\n                final int termLength = termOffsets[1+termOrd] - termOffset;\n\n                // if (DEBUG) {\n                //   System.out.println(\"  check termOrd=\" + termOrd + \" term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips) + \" i=\" + i);\n                // }\n\n                if (termOrd == states[stateUpto].changeOrd) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"  end push return\");\n                  // }\n                  stateUpto--;\n                  termOrd--;\n                  return;\n                }\n\n                if (termLength == i) {\n                  termOrd++;\n                  skipUpto = 0;\n                  // if (DEBUG) {\n                  //   System.out.println(\"    term too short; next term\");\n                  // }\n                } else if (label < (termBytes[termOffset+i] & 0xFF)) {\n                  termOrd--;\n                  // if (DEBUG) {\n                  //   System.out.println(\"  no match; already beyond; return termOrd=\" + termOrd);\n                  // }\n                  stateUpto -= skipUpto;\n                  assert stateUpto >= 0;\n                  return;\n                } else if (label == (termBytes[termOffset+i] & 0xFF)) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"    label[\" + i + \"] matches\");\n                  // }\n                  if (skipUpto < numSkips) {\n                    grow();\n\n                    final int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n                    // Automaton is required to accept startTerm:\n                    assert nextState != -1;\n\n                    stateUpto++;\n                    states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n                    states[stateUpto].state = nextState;\n                    states[stateUpto].transitionCount = compiledAutomaton.automaton.getNumTransitions(nextState);\n                    compiledAutomaton.automaton.initTransition(states[stateUpto].state, states[stateUpto].transition);\n                    states[stateUpto].transitionUpto = -1;\n                    states[stateUpto].transitionMax = -1;\n                    //System.out.println(\"  push \" + states[stateUpto].transitions.length + \" trans\");\n\n                    // if (DEBUG) {\n                    //   System.out.println(\"    push skip; changeOrd=\" + states[stateUpto].changeOrd);\n                    // }\n\n                    // Match next label at this same term:\n                    continue nextLabel;\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"    linear scan\");\n                    // }\n                    // Index exhausted: just scan now (the\n                    // number of scans required will be less\n                    // than the minSkipCount):\n                    final int startTermOrd = termOrd;\n                    while (termOrd < terms.length && compare(termOrd, startTerm) <= 0) {\n                      assert termOrd == startTermOrd || skipOffsets[termOrd] == skipOffsets[termOrd+1];\n                      termOrd++;\n                    }\n                    assert termOrd - startTermOrd < minSkipCount;\n                    termOrd--;\n                    stateUpto -= skipUpto;\n                    // if (DEBUG) {\n                    //   System.out.println(\"  end termOrd=\" + termOrd);\n                    // }\n                    return;\n                  }\n                } else {\n                  if (skipUpto < numSkips) {\n                    termOrd = skips[skipOffset + skipUpto];\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; skip to termOrd=\" + termOrd);\n                    // }\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; next term\");\n                    // }\n                    termOrd++;\n                  }\n                  skipUpto = 0;\n                }\n              }\n\n              // startTerm is >= last term so enum will not\n              // return any terms:\n              termOrd--;\n              // if (DEBUG) {\n              //   System.out.println(\"  beyond end; no terms will match\");\n              // }\n              return;\n            }\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLen = termOffsets[1+termOrd] - termOffset;\n\n          if (termOrd >= 0 && !startTerm.equals(new BytesRef(termBytes, termOffset, termLen))) {\n            stateUpto -= skipUpto;\n            termOrd--;\n          }\n          // if (DEBUG) {\n          //   System.out.println(\"  loop end; return termOrd=\" + termOrd + \" stateUpto=\" + stateUpto);\n          // }\n        }\n      }\n\n","sourceOld":"      public DirectIntersectTermsEnum(CompiledAutomaton compiled, BytesRef startTerm) {\n        runAutomaton = compiled.runAutomaton;\n        compiledAutomaton = compiled;\n        termOrd = -1;\n        states = new State[1];\n        states[0] = new State();\n        states[0].changeOrd = terms.length;\n        states[0].state = runAutomaton.getInitialState();\n        states[0].transitionCount = compiledAutomaton.automaton.getNumTransitions(states[0].state);\n        compiledAutomaton.automaton.initTransition(states[0].state, states[0].transition);\n        states[0].transitionUpto = -1;\n        states[0].transitionMax = -1;\n\n        //System.out.println(\"IE.init startTerm=\" + startTerm);\n\n        if (startTerm != null) {\n          int skipUpto = 0;\n          if (startTerm.length == 0) {\n            if (terms.length > 0 && termOffsets[1] == 0) {\n              termOrd = 0;\n            }\n          } else {\n            termOrd++;\n\n            nextLabel:\n            for(int i=0;i<startTerm.length;i++) {\n              final int label = startTerm.bytes[startTerm.offset+i] & 0xFF;\n\n              while (label > states[i].transitionMax) {\n                states[i].transitionUpto++;\n                assert states[i].transitionUpto < states[i].transitionCount;\n                compiledAutomaton.automaton.getNextTransition(states[i].transition);\n                states[i].transitionMin = states[i].transition.min;\n                states[i].transitionMax = states[i].transition.max;\n                assert states[i].transitionMin >= 0;\n                assert states[i].transitionMin <= 255;\n                assert states[i].transitionMax >= 0;\n                assert states[i].transitionMax <= 255;\n              }\n\n              // Skip forwards until we find a term matching\n              // the label at this position:\n              while (termOrd < terms.length) {\n                final int skipOffset = skipOffsets[termOrd];\n                final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n                final int termOffset = termOffsets[termOrd];\n                final int termLength = termOffsets[1+termOrd] - termOffset;\n\n                // if (DEBUG) {\n                //   System.out.println(\"  check termOrd=\" + termOrd + \" term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips) + \" i=\" + i);\n                // }\n\n                if (termOrd == states[stateUpto].changeOrd) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"  end push return\");\n                  // }\n                  stateUpto--;\n                  termOrd--;\n                  return;\n                }\n\n                if (termLength == i) {\n                  termOrd++;\n                  skipUpto = 0;\n                  // if (DEBUG) {\n                  //   System.out.println(\"    term too short; next term\");\n                  // }\n                } else if (label < (termBytes[termOffset+i] & 0xFF)) {\n                  termOrd--;\n                  // if (DEBUG) {\n                  //   System.out.println(\"  no match; already beyond; return termOrd=\" + termOrd);\n                  // }\n                  stateUpto -= skipUpto;\n                  assert stateUpto >= 0;\n                  return;\n                } else if (label == (termBytes[termOffset+i] & 0xFF)) {\n                  // if (DEBUG) {\n                  //   System.out.println(\"    label[\" + i + \"] matches\");\n                  // }\n                  if (skipUpto < numSkips) {\n                    grow();\n\n                    final int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n                    // Automaton is required to accept startTerm:\n                    assert nextState != -1;\n\n                    stateUpto++;\n                    states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n                    states[stateUpto].state = nextState;\n                    states[stateUpto].transitionCount = compiledAutomaton.automaton.getNumTransitions(nextState);\n                    compiledAutomaton.automaton.initTransition(states[stateUpto].state, states[stateUpto].transition);\n                    states[stateUpto].transitionUpto = -1;\n                    states[stateUpto].transitionMax = -1;\n                    //System.out.println(\"  push \" + states[stateUpto].transitions.length + \" trans\");\n\n                    // if (DEBUG) {\n                    //   System.out.println(\"    push skip; changeOrd=\" + states[stateUpto].changeOrd);\n                    // }\n\n                    // Match next label at this same term:\n                    continue nextLabel;\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"    linear scan\");\n                    // }\n                    // Index exhausted: just scan now (the\n                    // number of scans required will be less\n                    // than the minSkipCount):\n                    final int startTermOrd = termOrd;\n                    while (termOrd < terms.length && compare(termOrd, startTerm) <= 0) {\n                      assert termOrd == startTermOrd || skipOffsets[termOrd] == skipOffsets[termOrd+1];\n                      termOrd++;\n                    }\n                    assert termOrd - startTermOrd < minSkipCount;\n                    termOrd--;\n                    stateUpto -= skipUpto;\n                    // if (DEBUG) {\n                    //   System.out.println(\"  end termOrd=\" + termOrd);\n                    // }\n                    return;\n                  }\n                } else {\n                  if (skipUpto < numSkips) {\n                    termOrd = skips[skipOffset + skipUpto];\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; skip to termOrd=\" + termOrd);\n                    // }\n                  } else {\n                    // if (DEBUG) {\n                    //   System.out.println(\"  no match; next term\");\n                    // }\n                    termOrd++;\n                  }\n                  skipUpto = 0;\n                }\n              }\n\n              // startTerm is >= last term so enum will not\n              // return any terms:\n              termOrd--;\n              // if (DEBUG) {\n              //   System.out.println(\"  beyond end; no terms will match\");\n              // }\n              return;\n            }\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLen = termOffsets[1+termOrd] - termOffset;\n\n          if (termOrd >= 0 && !startTerm.equals(new BytesRef(termBytes, termOffset, termLen))) {\n            stateUpto -= skipUpto;\n            termOrd--;\n          }\n          // if (DEBUG) {\n          //   System.out.println(\"  loop end; return termOrd=\" + termOrd + \" stateUpto=\" + stateUpto);\n          // }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b7543e96e2d4820e09334d36a699b998ed963f4f":["5c84485629d80d203608e8975a1139de9933cc38"],"3e45d45bc3730ddd1341f4eb6025f33b8482e6e2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"5c84485629d80d203608e8975a1139de9933cc38":["3e45d45bc3730ddd1341f4eb6025f33b8482e6e2","4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["3e45d45bc3730ddd1341f4eb6025f33b8482e6e2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5c84485629d80d203608e8975a1139de9933cc38","b7543e96e2d4820e09334d36a699b998ed963f4f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b7543e96e2d4820e09334d36a699b998ed963f4f"]},"commit2Childs":{"b7543e96e2d4820e09334d36a699b998ed963f4f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3e45d45bc3730ddd1341f4eb6025f33b8482e6e2":["5c84485629d80d203608e8975a1139de9933cc38","ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3e45d45bc3730ddd1341f4eb6025f33b8482e6e2"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["5c84485629d80d203608e8975a1139de9933cc38"],"5c84485629d80d203608e8975a1139de9933cc38":["b7543e96e2d4820e09334d36a699b998ed963f4f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}