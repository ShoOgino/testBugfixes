{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  ZkNodeProps addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    message = assignReplicaDetails(ocmh.cloudManager, clusterState, message, sessionWrapper);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    DocCollection coll = clusterState.getCollection(collection);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collection,\n            ZkStateReader.SHARD_ID_PROP, shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(node),\n            ZkStateReader.NODE_NAME_PROP, node,\n            ZkStateReader.REPLICA_TYPE, replicaType.name());\n        if (coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        try {\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collection, Collections.singletonList(coreName)).get(coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collection);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collection);\n    params.set(CoreAdminParams.REPLICA_TYPE, replicaType.name());\n    if (shard != null) {\n      params.set(CoreAdminParams.SHARD, shard);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    // For tracking async calls.\n    Map<String,String> requestMap = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    ocmh.sendShardRequest(node, params, shardHandler, asyncId, requestMap);\n\n    final String fnode = node;\n    final String fcoreName = coreName;\n\n    Runnable runnable = () -> {\n      ocmh.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\", asyncId, requestMap);\n      ocmh.waitForCoreNodeName(collection, fnode, fcoreName);\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(1, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collection, null, Collections.singletonList(coreName), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collection, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collection, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n\n    return new ZkNodeProps(\n        ZkStateReader.COLLECTION_PROP, collection,\n        ZkStateReader.SHARD_ID_PROP, shard,\n        ZkStateReader.CORE_NAME_PROP, coreName,\n        ZkStateReader.NODE_NAME_PROP, node\n    );\n  }\n\n","sourceOld":"  ZkNodeProps addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    message = assignReplicaDetails(ocmh.cloudManager, clusterState, message, sessionWrapper);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    DocCollection coll = clusterState.getCollection(collection);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collection,\n            ZkStateReader.SHARD_ID_PROP, shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(node),\n            ZkStateReader.NODE_NAME_PROP, node,\n            ZkStateReader.REPLICA_TYPE, replicaType.name());\n        if (coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        try {\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collection, Collections.singletonList(coreName)).get(coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collection);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collection);\n    params.set(CoreAdminParams.REPLICA_TYPE, replicaType.name());\n    if (shard != null) {\n      params.set(CoreAdminParams.SHARD, shard);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    // For tracking async calls.\n    Map<String,String> requestMap = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    ocmh.sendShardRequest(node, params, shardHandler, asyncId, requestMap);\n\n    final String fnode = node;\n    final String fcoreName = coreName;\n\n    Runnable runnable = () -> {\n      ocmh.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\", asyncId, requestMap);\n      ocmh.waitForCoreNodeName(collection, fnode, fcoreName);\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(1, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collection, null, Collections.singletonList(coreName), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collection, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collection, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n\n    return new ZkNodeProps(\n        ZkStateReader.COLLECTION_PROP, collection,\n        ZkStateReader.SHARD_ID_PROP, shard,\n        ZkStateReader.CORE_NAME_PROP, coreName,\n        ZkStateReader.NODE_NAME_PROP, node\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  ZkNodeProps addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    message = assignReplicaDetails(ocmh.cloudManager, clusterState, message, sessionWrapper);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    DocCollection coll = clusterState.getCollection(collection);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collection,\n            ZkStateReader.SHARD_ID_PROP, shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(node),\n            ZkStateReader.NODE_NAME_PROP, node,\n            ZkStateReader.REPLICA_TYPE, replicaType.name());\n        if (coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        try {\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collection, Collections.singletonList(coreName)).get(coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collection);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collection);\n    params.set(CoreAdminParams.REPLICA_TYPE, replicaType.name());\n    if (shard != null) {\n      params.set(CoreAdminParams.SHARD, shard);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    // For tracking async calls.\n    Map<String,String> requestMap = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    ocmh.sendShardRequest(node, params, shardHandler, asyncId, requestMap);\n\n    final String fnode = node;\n    final String fcoreName = coreName;\n\n    Runnable runnable = () -> {\n      ocmh.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\", asyncId, requestMap);\n      ocmh.waitForCoreNodeName(collection, fnode, fcoreName);\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(1, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collection, null, Collections.singletonList(coreName), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collection, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collection, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n\n    return new ZkNodeProps(\n        ZkStateReader.COLLECTION_PROP, collection,\n        ZkStateReader.SHARD_ID_PROP, shard,\n        ZkStateReader.CORE_NAME_PROP, coreName,\n        ZkStateReader.NODE_NAME_PROP, node\n    );\n  }\n\n","sourceOld":"  ZkNodeProps addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    message = assignReplicaDetails(ocmh.cloudManager, clusterState, message, sessionWrapper);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    DocCollection coll = clusterState.getCollection(collection);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collection,\n            ZkStateReader.SHARD_ID_PROP, shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(node),\n            ZkStateReader.NODE_NAME_PROP, node,\n            ZkStateReader.REPLICA_TYPE, replicaType.name());\n        if (coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        try {\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collection, Collections.singletonList(coreName)).get(coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collection);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collection);\n    params.set(CoreAdminParams.REPLICA_TYPE, replicaType.name());\n    if (shard != null) {\n      params.set(CoreAdminParams.SHARD, shard);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    // For tracking async calls.\n    Map<String,String> requestMap = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    ocmh.sendShardRequest(node, params, shardHandler, asyncId, requestMap);\n\n    final String fnode = node;\n    final String fcoreName = coreName;\n\n    Runnable runnable = () -> {\n      ocmh.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\", asyncId, requestMap);\n      ocmh.waitForCoreNodeName(collection, fnode, fcoreName);\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(1, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collection, null, Collections.singletonList(coreName), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collection, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collection, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n\n    return new ZkNodeProps(\n        ZkStateReader.COLLECTION_PROP, collection,\n        ZkStateReader.SHARD_ID_PROP, shard,\n        ZkStateReader.CORE_NAME_PROP, coreName,\n        ZkStateReader.NODE_NAME_PROP, node\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27639bb5e041490ce599065875dd2f6d8beef62a","date":1532829373,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  ZkNodeProps addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String collectionName = message.getStr(COLLECTION_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    message = assignReplicaDetails(ocmh.cloudManager, clusterState, message, sessionWrapper);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", node,\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(node),\n            ZkStateReader.NODE_NAME_PROP, node,\n            ZkStateReader.REPLICA_TYPE, replicaType.name());\n        if (coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        try {\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(coreName)).get(coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, replicaType.name());\n    if (shard != null) {\n      params.set(CoreAdminParams.SHARD, shard);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    // For tracking async calls.\n    Map<String,String> requestMap = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    ocmh.sendShardRequest(node, params, shardHandler, asyncId, requestMap);\n\n    final String fnode = node;\n    final String fcoreName = coreName;\n\n    Runnable runnable = () -> {\n      ocmh.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\", asyncId, requestMap);\n      ocmh.waitForCoreNodeName(collectionName, fnode, fcoreName);\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(1, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null, Collections.singletonList(coreName), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n\n    return new ZkNodeProps(\n        ZkStateReader.COLLECTION_PROP, collectionName,\n        ZkStateReader.SHARD_ID_PROP, shard,\n        ZkStateReader.CORE_NAME_PROP, coreName,\n        ZkStateReader.NODE_NAME_PROP, node\n    );\n  }\n\n","sourceOld":"  ZkNodeProps addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    message = assignReplicaDetails(ocmh.cloudManager, clusterState, message, sessionWrapper);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    DocCollection coll = clusterState.getCollection(collection);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collection,\n            ZkStateReader.SHARD_ID_PROP, shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(node),\n            ZkStateReader.NODE_NAME_PROP, node,\n            ZkStateReader.REPLICA_TYPE, replicaType.name());\n        if (coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        try {\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collection, Collections.singletonList(coreName)).get(coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collection);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collection);\n    params.set(CoreAdminParams.REPLICA_TYPE, replicaType.name());\n    if (shard != null) {\n      params.set(CoreAdminParams.SHARD, shard);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    // For tracking async calls.\n    Map<String,String> requestMap = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    ocmh.sendShardRequest(node, params, shardHandler, asyncId, requestMap);\n\n    final String fnode = node;\n    final String fcoreName = coreName;\n\n    Runnable runnable = () -> {\n      ocmh.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\", asyncId, requestMap);\n      ocmh.waitForCoreNodeName(collection, fnode, fcoreName);\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(1, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collection, null, Collections.singletonList(coreName), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collection, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collection, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n\n    return new ZkNodeProps(\n        ZkStateReader.COLLECTION_PROP, collection,\n        ZkStateReader.SHARD_ID_PROP, shard,\n        ZkStateReader.CORE_NAME_PROP, coreName,\n        ZkStateReader.NODE_NAME_PROP, node\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"deea3439de4f487ae553317e50d5d641ca386374","date":1537522941,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n        .stream()\n        .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n        .collect(Collectors.toList());\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    // For tracking async calls.\n    Map<String,String> requestMap = new HashMap<>();\n\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      ocmh.sendShardRequest(createReplica.node, params, shardHandler, asyncId, requestMap);\n    }\n\n    Runnable runnable = () -> {\n      ocmh.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\", asyncId, requestMap);\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","sourceOld":"  ZkNodeProps addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String collectionName = message.getStr(COLLECTION_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    message = assignReplicaDetails(ocmh.cloudManager, clusterState, message, sessionWrapper);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", node,\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(node),\n            ZkStateReader.NODE_NAME_PROP, node,\n            ZkStateReader.REPLICA_TYPE, replicaType.name());\n        if (coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        try {\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(coreName)).get(coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, replicaType.name());\n    if (shard != null) {\n      params.set(CoreAdminParams.SHARD, shard);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    // For tracking async calls.\n    Map<String,String> requestMap = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    ocmh.sendShardRequest(node, params, shardHandler, asyncId, requestMap);\n\n    final String fnode = node;\n    final String fcoreName = coreName;\n\n    Runnable runnable = () -> {\n      ocmh.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\", asyncId, requestMap);\n      ocmh.waitForCoreNodeName(collectionName, fnode, fcoreName);\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(1, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null, Collections.singletonList(coreName), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n\n    return new ZkNodeProps(\n        ZkStateReader.COLLECTION_PROP, collectionName,\n        ZkStateReader.SHARD_ID_PROP, shard,\n        ZkStateReader.CORE_NAME_PROP, coreName,\n        ZkStateReader.NODE_NAME_PROP, node\n    );\n  }\n\n","bugFix":null,"bugIntro":["69e6520a21709190413a63084ed135271aab1a7c","69e6520a21709190413a63084ed135271aab1a7c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f1fec8b37cbb6884a64d39565e9dd7b4522a0598","date":1537699559,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n        .stream()\n        .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n        .collect(Collectors.toList());\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    // For tracking async calls.\n    Map<String,String> requestMap = new HashMap<>();\n\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      ocmh.sendShardRequest(createReplica.node, params, shardHandler, asyncId, requestMap);\n    }\n\n    Runnable runnable = () -> {\n      ocmh.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\", asyncId, requestMap);\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","sourceOld":"  ZkNodeProps addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String collectionName = message.getStr(COLLECTION_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    message = assignReplicaDetails(ocmh.cloudManager, clusterState, message, sessionWrapper);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", node,\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(node),\n            ZkStateReader.NODE_NAME_PROP, node,\n            ZkStateReader.REPLICA_TYPE, replicaType.name());\n        if (coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        try {\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(coreName)).get(coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, replicaType.name());\n    if (shard != null) {\n      params.set(CoreAdminParams.SHARD, shard);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    // For tracking async calls.\n    Map<String,String> requestMap = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    ocmh.sendShardRequest(node, params, shardHandler, asyncId, requestMap);\n\n    final String fnode = node;\n    final String fcoreName = coreName;\n\n    Runnable runnable = () -> {\n      ocmh.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\", asyncId, requestMap);\n      ocmh.waitForCoreNodeName(collectionName, fnode, fcoreName);\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(1, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null, Collections.singletonList(coreName), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n\n    return new ZkNodeProps(\n        ZkStateReader.COLLECTION_PROP, collectionName,\n        ZkStateReader.SHARD_ID_PROP, shard,\n        ZkStateReader.CORE_NAME_PROP, coreName,\n        ZkStateReader.NODE_NAME_PROP, node\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6cb9ef8e77bce265c4b0d4272f2321c220c98edf","date":1539171770,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    // For tracking async calls.\n    Map<String,String> requestMap = new HashMap<>();\n\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      ocmh.sendShardRequest(createReplica.node, params, shardHandler, asyncId, requestMap);\n    }\n\n    Runnable runnable = () -> {\n      ocmh.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\", asyncId, requestMap);\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","sourceOld":"  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n        .stream()\n        .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n        .collect(Collectors.toList());\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    // For tracking async calls.\n    Map<String,String> requestMap = new HashMap<>();\n\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      ocmh.sendShardRequest(createReplica.node, params, shardHandler, asyncId, requestMap);\n    }\n\n    Runnable runnable = () -> {\n      ocmh.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\", asyncId, requestMap);\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"59bad1cc1e7f90125a140496e79b06afcedb68ec","date":1554915399,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    // For tracking async calls.\n    Map<String,String> requestMap = new HashMap<>();\n\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      ocmh.sendShardRequest(createReplica.node, params, shardHandler, asyncId, requestMap);\n    }\n\n    Runnable runnable = () -> {\n      ocmh.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\", asyncId, requestMap);\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","sourceOld":"  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    // For tracking async calls.\n    Map<String,String> requestMap = new HashMap<>();\n\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      ocmh.sendShardRequest(createReplica.node, params, shardHandler, asyncId, requestMap);\n    }\n\n    Runnable runnable = () -> {\n      ocmh.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\", asyncId, requestMap);\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"69e6520a21709190413a63084ed135271aab1a7c","date":1556607462,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","sourceOld":"  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    // For tracking async calls.\n    Map<String,String> requestMap = new HashMap<>();\n\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      ocmh.sendShardRequest(createReplica.node, params, shardHandler, asyncId, requestMap);\n    }\n\n    Runnable runnable = () -> {\n      ocmh.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\", asyncId, requestMap);\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","bugFix":["deea3439de4f487ae553317e50d5d641ca386374","66e0b82bd39567aa2bf534e5282d05fb4a4a2c76"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4949836c6e83246ddba8997472e3333f40986c8c","date":1560293762,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException, KeeperException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","sourceOld":"  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c","date":1562161956,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException, KeeperException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName;\n    if (followAliases) {\n      collectionName =  ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","sourceOld":"  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException, KeeperException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4abf821a41a2fdca2a1dea148999931d22e20529","date":1587749643,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException, KeeperException {\n    if (log.isDebugEnabled()) {\n      log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    }\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName;\n    if (followAliases) {\n      collectionName =  ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","sourceOld":"  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException, KeeperException {\n    log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName;\n    if (followAliases) {\n      collectionName =  ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86968c6cf51846df861b8f29bd85b6d9a7c9f19c","date":1591481497,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException, KeeperException {\n    if (log.isDebugEnabled()) {\n      log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    }\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName;\n    if (followAliases) {\n      collectionName =  ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","sourceOld":"  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException, KeeperException {\n    if (log.isDebugEnabled()) {\n      log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    }\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName;\n    if (followAliases) {\n      collectionName =  ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f3b1b5ef1e767058494533a3bdbeb782abaee09","date":1591546827,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException, KeeperException {\n    if (log.isDebugEnabled()) {\n      log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    }\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName;\n    if (followAliases) {\n      collectionName =  ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (node != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException, KeeperException {\n    if (log.isDebugEnabled()) {\n      log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    }\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName;\n    if (followAliases) {\n      collectionName =  ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (message.getStr(CoreAdminParams.NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException, KeeperException {\n    if (log.isDebugEnabled()) {\n      log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    }\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName;\n    if (followAliases) {\n      collectionName =  ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (node != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    List<CreateReplica> createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException, KeeperException {\n    if (log.isDebugEnabled()) {\n      log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    }\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName;\n    if (followAliases) {\n      collectionName =  ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (node != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<CreateReplica> createReplicas;\n    try {\n      createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount, sessionWrapper)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n    } finally {\n      if (sessionWrapper.get() != null) {\n        sessionWrapper.get().release();\n      }\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,CloudConfig,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  List<ZkNodeProps> addReplica(ClusterState clusterState, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException, KeeperException {\n    if (log.isDebugEnabled()) {\n      log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    }\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName;\n    if (followAliases) {\n      collectionName =  ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (node != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    List<CreateReplica> createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, cloudConfig, collectionName, message, replicaTypesVsCount)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, cloudConfig, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException, KeeperException {\n    if (log.isDebugEnabled()) {\n      log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    }\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName;\n    if (followAliases) {\n      collectionName =  ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (node != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    List<CreateReplica> createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#addReplica(ClusterState,CloudConfig,ZkNodeProps,NamedList,Runnable).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  List<ZkNodeProps> addReplica(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException, KeeperException {\n    if (log.isDebugEnabled()) {\n      log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    }\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName;\n    if (followAliases) {\n      collectionName =  ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (node != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    List<CreateReplica> createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, replicaTypesVsCount)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  List<ZkNodeProps> addReplica(ClusterState clusterState, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, Runnable onComplete)\n      throws IOException, InterruptedException, KeeperException {\n    if (log.isDebugEnabled()) {\n      log.debug(\"addReplica() : {}\", Utils.toJSONString(message));\n    }\n\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String shard = message.getStr(SHARD_ID_PROP);\n\n    final String collectionName;\n    if (followAliases) {\n      collectionName =  ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collectionName + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collectionName + \" shard: \" + shard + \" does not exist\");\n    }\n\n    boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n    final String asyncId = message.getStr(ASYNC);\n\n    String node = message.getStr(CoreAdminParams.NODE);\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    if (node != null && createNodeSetStr != null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Both 'node' and 'createNodeSet' parameters cannot be specified together.\");\n    }\n\n    int timeout = message.getInt(TIMEOUT, 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    EnumMap<Replica.Type, Integer> replicaTypesVsCount = new EnumMap<>(Replica.Type.class);\n    replicaTypesVsCount.put(Replica.Type.NRT, message.getInt(NRT_REPLICAS, replicaType == Replica.Type.NRT ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.TLOG, message.getInt(TLOG_REPLICAS, replicaType == Replica.Type.TLOG ? 1 : 0));\n    replicaTypesVsCount.put(Replica.Type.PULL, message.getInt(PULL_REPLICAS, replicaType == Replica.Type.PULL ? 1 : 0));\n\n    int totalReplicas = 0;\n    for (Map.Entry<Replica.Type, Integer> entry : replicaTypesVsCount.entrySet()) {\n      totalReplicas += entry.getValue();\n    }\n    if (totalReplicas > 1)  {\n      if (node != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'name' parameter is specified\");\n      }\n      if (message.getStr(CoreAdminParams.CORE_NODE_NAME) != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cannot create \" + totalReplicas + \" replicas if 'coreNodeName' parameter is specified\");\n      }\n    }\n\n    List<CreateReplica> createReplicas = buildReplicaPositions(ocmh.cloudManager, clusterState, cloudConfig, collectionName, message, replicaTypesVsCount)\n          .stream()\n          .map(replicaPosition -> assignReplicaDetails(ocmh.cloudManager, clusterState, message, replicaPosition))\n          .collect(Collectors.toList());\n\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (CreateReplica createReplica : createReplicas) {\n      assert createReplica.coreName != null;\n      ModifiableSolrParams params = getReplicaParams(clusterState, cloudConfig, message, results, collectionName, coll, skipCreateReplicaInClusterState, asyncId, shardHandler, createReplica);\n      shardRequestTracker.sendShardRequest(createReplica.node, params, shardHandler);\n    }\n\n    Runnable runnable = () -> {\n      shardRequestTracker.processResponses(results, shardHandler, true, \"ADDREPLICA failed to create replica\");\n      for (CreateReplica replica : createReplicas) {\n        ocmh.waitForCoreNodeName(collectionName, replica.node, replica.coreName);\n      }\n      if (onComplete != null) onComplete.run();\n    };\n\n    if (!parallel || waitForFinalState) {\n      if (waitForFinalState) {\n        SolrCloseableLatch latch = new SolrCloseableLatch(totalReplicas, ocmh);\n        ActiveReplicaWatcher watcher = new ActiveReplicaWatcher(collectionName, null,\n            createReplicas.stream().map(createReplica -> createReplica.coreName).collect(Collectors.toList()), latch);\n        try {\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          runnable.run();\n          if (!latch.await(timeout, TimeUnit.SECONDS)) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Timeout waiting \" + timeout + \" seconds for replica to become active.\");\n          }\n        } finally {\n          zkStateReader.removeCollectionStateWatcher(collectionName, watcher);\n        }\n      } else {\n        runnable.run();\n      }\n    } else {\n      ocmh.tpe.submit(runnable);\n    }\n\n    return createReplicas.stream()\n        .map(createReplica -> new ZkNodeProps(\n            ZkStateReader.COLLECTION_PROP, createReplica.collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.NODE_NAME_PROP, createReplica.node\n        ))\n        .collect(Collectors.toList());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"c526352db87264a72a7a9ad68c1b769b81e54305":["3f504512a03d978990cbff30db0522b354e846db"],"3f504512a03d978990cbff30db0522b354e846db":["0f3b1b5ef1e767058494533a3bdbeb782abaee09"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["6cb9ef8e77bce265c4b0d4272f2321c220c98edf"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6cb9ef8e77bce265c4b0d4272f2321c220c98edf":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598"],"0f3b1b5ef1e767058494533a3bdbeb782abaee09":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c":["4949836c6e83246ddba8997472e3333f40986c8c"],"4abf821a41a2fdca2a1dea148999931d22e20529":["d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["4abf821a41a2fdca2a1dea148999931d22e20529"],"69e6520a21709190413a63084ed135271aab1a7c":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"f1fec8b37cbb6884a64d39565e9dd7b4522a0598":["27639bb5e041490ce599065875dd2f6d8beef62a","deea3439de4f487ae553317e50d5d641ca386374"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"deea3439de4f487ae553317e50d5d641ca386374":["27639bb5e041490ce599065875dd2f6d8beef62a"],"4949836c6e83246ddba8997472e3333f40986c8c":["69e6520a21709190413a63084ed135271aab1a7c"],"27639bb5e041490ce599065875dd2f6d8beef62a":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b94236357aaa22b76c10629851fe4e376e0cea82":["27639bb5e041490ce599065875dd2f6d8beef62a"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"3f504512a03d978990cbff30db0522b354e846db":["c526352db87264a72a7a9ad68c1b769b81e54305"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["69e6520a21709190413a63084ed135271aab1a7c"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"6cb9ef8e77bce265c4b0d4272f2321c220c98edf":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"0f3b1b5ef1e767058494533a3bdbeb782abaee09":["3f504512a03d978990cbff30db0522b354e846db"],"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c":["4abf821a41a2fdca2a1dea148999931d22e20529"],"4abf821a41a2fdca2a1dea148999931d22e20529":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["0f3b1b5ef1e767058494533a3bdbeb782abaee09"],"69e6520a21709190413a63084ed135271aab1a7c":["4949836c6e83246ddba8997472e3333f40986c8c"],"f1fec8b37cbb6884a64d39565e9dd7b4522a0598":["6cb9ef8e77bce265c4b0d4272f2321c220c98edf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"deea3439de4f487ae553317e50d5d641ca386374":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598"],"4949836c6e83246ddba8997472e3333f40986c8c":["d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c"],"27639bb5e041490ce599065875dd2f6d8beef62a":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598","deea3439de4f487ae553317e50d5d641ca386374"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}