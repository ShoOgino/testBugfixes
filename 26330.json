{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","commits":[{"id":"e2fe60a17a7a0cfd101b1169acf089221bc6c166","date":1412767493,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoWriter#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    boolean success = false;\n    IndexOutput output = dir.createOutput(segFileName, ioContext);\n\n    try {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.getDocCount()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(output);\n        IOUtils.deleteFilesIgnoringExceptions(dir, segFileName);\n      } else {\n        output.close();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    boolean success = false;\n    IndexOutput output = dir.createOutput(segFileName, ioContext);\n\n    try {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.getDocCount()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(output);\n        IOUtils.deleteFilesIgnoringExceptions(dir, segFileName);\n      } else {\n        output.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoWriter#write(Directory,SegmentInfo,FieldInfos,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    boolean success = false;\n    IndexOutput output = dir.createOutput(segFileName, ioContext);\n\n    try {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.getDocCount()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(output);\n        IOUtils.deleteFilesIgnoringExceptions(dir, segFileName);\n      } else {\n        output.close();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, FieldInfos fis, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    boolean success = false;\n    IndexOutput output = dir.createOutput(segFileName, ioContext);\n\n    try {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.getDocCount()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(output);\n        IOUtils.deleteFilesIgnoringExceptions(dir, segFileName);\n      } else {\n        output.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"474b77fc1ee62c3fc1c73ceb19cc975cb03667ac","date":1417363109,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    boolean success = false;\n    IndexOutput output = dir.createOutput(segFileName, ioContext);\n\n    try {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.getDocCount()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(output);\n      } else {\n        output.close();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    boolean success = false;\n    IndexOutput output = dir.createOutput(segFileName, ioContext);\n\n    try {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.getDocCount()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(output);\n        IOUtils.deleteFilesIgnoringExceptions(dir, segFileName);\n      } else {\n        output.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9d13460921f3c71f3cb803ee4568f4e0d6b6984","date":1417363521,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.getDocCount()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    boolean success = false;\n    IndexOutput output = dir.createOutput(segFileName, ioContext);\n\n    try {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.getDocCount()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(output);\n      } else {\n        output.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8521d944f9dfb45692ec28235dbf116d47ef69ba","date":1417535150,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.getDocCount()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.getDocCount()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.getDocCount()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.getDocCount()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.getDocCount()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7711f4cf675506a5b4a2c45d6f1de359cf5278c1","date":1436885419,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n    si.addFile(segFileName);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ceaef6cfc68c8ab22a684192e469a8280f9e6e70","date":1462354657,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortType;\n        switch (sortField.getType()) {\n          case STRING:\n            sortType = \"string\";\n            break;\n          case LONG:\n            sortType = \"long\";\n            break;\n          case INT:\n            sortType = \"int\";\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortType, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else if (missingValue instanceof Long) {\n          missing = Long.toString((Long) missingValue);\n        } else {\n          throw new IllegalStateException(\"Unexpected missing sort value: \" + missingValue);\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8","date":1462567286,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortType;\n        switch (sortField.getType()) {\n          case STRING:\n            sortType = \"string\";\n            break;\n          case LONG:\n            sortType = \"long\";\n            break;\n          case INT:\n            sortType = \"int\";\n            break;\n          // nocommit the rest:\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortType, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else if (missingValue instanceof Long) {\n          missing = Long.toString((Long) missingValue);\n        } else {\n          throw new IllegalStateException(\"Unexpected missing sort value: \" + missingValue);\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortType;\n        switch (sortField.getType()) {\n          case STRING:\n            sortType = \"string\";\n            break;\n          case LONG:\n            sortType = \"long\";\n            break;\n          case INT:\n            sortType = \"int\";\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortType, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else if (missingValue instanceof Long) {\n          missing = Long.toString((Long) missingValue);\n        } else {\n          throw new IllegalStateException(\"Unexpected missing sort value: \" + missingValue);\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45bfb4d30b7e62ec7d645a5e0113362636ac4981","date":1462660573,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortType;\n        switch (sortField.getType()) {\n          case STRING:\n            sortType = \"string\";\n            break;\n          case LONG:\n            sortType = \"long\";\n            break;\n          case INT:\n            sortType = \"int\";\n            break;\n          case DOUBLE:\n            sortType = \"double\";\n            break;\n          case FLOAT:\n            sortType = \"float\";\n            break;\n          // nocommit the rest:\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortType, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortType;\n        switch (sortField.getType()) {\n          case STRING:\n            sortType = \"string\";\n            break;\n          case LONG:\n            sortType = \"long\";\n            break;\n          case INT:\n            sortType = \"int\";\n            break;\n          // nocommit the rest:\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortType, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else if (missingValue instanceof Long) {\n          missing = Long.toString((Long) missingValue);\n        } else {\n          throw new IllegalStateException(\"Unexpected missing sort value: \" + missingValue);\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e03940e6e9044943de4b7ac08f8581da37a9534","date":1462870173,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortType;\n        switch (sortField.getType()) {\n          case STRING:\n            sortType = \"string\";\n            break;\n          case LONG:\n            sortType = \"long\";\n            break;\n          case INT:\n            sortType = \"int\";\n            break;\n          case DOUBLE:\n            sortType = \"double\";\n            break;\n          case FLOAT:\n            sortType = \"float\";\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortType, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortType;\n        switch (sortField.getType()) {\n          case STRING:\n            sortType = \"string\";\n            break;\n          case LONG:\n            sortType = \"long\";\n            break;\n          case INT:\n            sortType = \"int\";\n            break;\n          case DOUBLE:\n            sortType = \"double\";\n            break;\n          case FLOAT:\n            sortType = \"float\";\n            break;\n          // nocommit the rest:\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortType, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortType;\n        switch (sortField.getType()) {\n          case STRING:\n            sortType = \"string\";\n            break;\n          case LONG:\n            sortType = \"long\";\n            break;\n          case INT:\n            sortType = \"int\";\n            break;\n          case DOUBLE:\n            sortType = \"double\";\n            break;\n          case FLOAT:\n            sortType = \"float\";\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortType, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortType;\n        switch (sortField.getType()) {\n          case STRING:\n            sortType = \"string\";\n            break;\n          case LONG:\n            sortType = \"long\";\n            break;\n          case INT:\n            sortType = \"int\";\n            break;\n          case DOUBLE:\n            sortType = \"double\";\n            break;\n          case FLOAT:\n            sortType = \"float\";\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortType, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortType;\n        switch (sortField.getType()) {\n          case STRING:\n            sortType = \"string\";\n            break;\n          case LONG:\n            sortType = \"long\";\n            break;\n          case INT:\n            sortType = \"int\";\n            break;\n          case DOUBLE:\n            sortType = \"double\";\n            break;\n          case FLOAT:\n            sortType = \"float\";\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortType, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortType;\n        switch (sortField.getType()) {\n          case STRING:\n            sortType = \"string\";\n            break;\n          case LONG:\n            sortType = \"long\";\n            break;\n          case INT:\n            sortType = \"int\";\n            break;\n          case DOUBLE:\n            sortType = \"double\";\n            break;\n          case FLOAT:\n            sortType = \"float\";\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortType, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e065cebbdee472a02bde38052717a8cd7ee8ab3b","date":1479244971,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortTypeString;\n        final SortField.Type sortType;\n        final boolean multiValued;\n        if (sortField instanceof SortedSetSortField) {\n          sortType = SortField.Type.STRING;\n          multiValued = true;\n        } else if (sortField instanceof SortedNumericSortField) {\n          sortType = ((SortedNumericSortField) sortField).getNumericType();\n          multiValued = true;\n        } else {\n          sortType = sortField.getType();\n          multiValued = false;\n        }\n        switch (sortType) {\n          case STRING:\n              if (multiValued) {\n                sortTypeString = \"multi_valued_string\";\n              } else {\n                sortTypeString = \"string\";\n              }\n            break;\n          case LONG:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_long\";\n            } else {\n              sortTypeString = \"long\";\n            }\n            break;\n          case INT:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_int\";\n            } else {\n              sortTypeString = \"int\";\n            }\n            break;\n          case DOUBLE:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_double\";\n            } else {\n              sortTypeString = \"double\";\n            }\n            break;\n          case FLOAT:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_float\";\n            } else {\n              sortTypeString = \"float\";\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortTypeString, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        if (sortField instanceof SortedSetSortField) {\n          SortedSetSelector.Type selector = ((SortedSetSortField) sortField).getSelector();\n          final String selectorString;\n          if (selector == SortedSetSelector.Type.MIN) {\n            selectorString = \"min\";\n          } else if (selector == SortedSetSelector.Type.MIDDLE_MIN) {\n            selectorString = \"middle_min\";\n          } else if (selector == SortedSetSelector.Type.MIDDLE_MAX) {\n            selectorString = \"middle_max\";\n          } else if (selector == SortedSetSelector.Type.MAX) {\n            selectorString = \"max\";\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type selector: \" + selector);\n          }\n          SimpleTextUtil.write(output, SI_SELECTOR_TYPE);\n          SimpleTextUtil.write(output, selectorString, scratch);\n          SimpleTextUtil.writeNewline(output);\n        } else if (sortField instanceof SortedNumericSortField) {\n          SortedNumericSelector.Type selector = ((SortedNumericSortField) sortField).getSelector();\n          final String selectorString;\n          if (selector == SortedNumericSelector.Type.MIN) {\n            selectorString = \"min\";\n          } else if (selector == SortedNumericSelector.Type.MAX) {\n            selectorString = \"max\";\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type selector: \" + selector);\n          }\n          SimpleTextUtil.write(output, SI_SELECTOR_TYPE);\n          SimpleTextUtil.write(output, selectorString, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortType;\n        switch (sortField.getType()) {\n          case STRING:\n            sortType = \"string\";\n            break;\n          case LONG:\n            sortType = \"long\";\n            break;\n          case INT:\n            sortType = \"int\";\n            break;\n          case DOUBLE:\n            sortType = \"double\";\n            break;\n          case FLOAT:\n            sortType = \"float\";\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortType, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1ef55e1fff7ff44354432770ad8bc19be1fcc75","date":1479266056,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortTypeString;\n        final SortField.Type sortType;\n        final boolean multiValued;\n        if (sortField instanceof SortedSetSortField) {\n          sortType = SortField.Type.STRING;\n          multiValued = true;\n        } else if (sortField instanceof SortedNumericSortField) {\n          sortType = ((SortedNumericSortField) sortField).getNumericType();\n          multiValued = true;\n        } else {\n          sortType = sortField.getType();\n          multiValued = false;\n        }\n        switch (sortType) {\n          case STRING:\n              if (multiValued) {\n                sortTypeString = \"multi_valued_string\";\n              } else {\n                sortTypeString = \"string\";\n              }\n            break;\n          case LONG:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_long\";\n            } else {\n              sortTypeString = \"long\";\n            }\n            break;\n          case INT:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_int\";\n            } else {\n              sortTypeString = \"int\";\n            }\n            break;\n          case DOUBLE:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_double\";\n            } else {\n              sortTypeString = \"double\";\n            }\n            break;\n          case FLOAT:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_float\";\n            } else {\n              sortTypeString = \"float\";\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortTypeString, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        if (sortField instanceof SortedSetSortField) {\n          SortedSetSelector.Type selector = ((SortedSetSortField) sortField).getSelector();\n          final String selectorString;\n          if (selector == SortedSetSelector.Type.MIN) {\n            selectorString = \"min\";\n          } else if (selector == SortedSetSelector.Type.MIDDLE_MIN) {\n            selectorString = \"middle_min\";\n          } else if (selector == SortedSetSelector.Type.MIDDLE_MAX) {\n            selectorString = \"middle_max\";\n          } else if (selector == SortedSetSelector.Type.MAX) {\n            selectorString = \"max\";\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type selector: \" + selector);\n          }\n          SimpleTextUtil.write(output, SI_SELECTOR_TYPE);\n          SimpleTextUtil.write(output, selectorString, scratch);\n          SimpleTextUtil.writeNewline(output);\n        } else if (sortField instanceof SortedNumericSortField) {\n          SortedNumericSelector.Type selector = ((SortedNumericSortField) sortField).getSelector();\n          final String selectorString;\n          if (selector == SortedNumericSelector.Type.MIN) {\n            selectorString = \"min\";\n          } else if (selector == SortedNumericSelector.Type.MAX) {\n            selectorString = \"max\";\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type selector: \" + selector);\n          }\n          SimpleTextUtil.write(output, SI_SELECTOR_TYPE);\n          SimpleTextUtil.write(output, selectorString, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortType;\n        switch (sortField.getType()) {\n          case STRING:\n            sortType = \"string\";\n            break;\n          case LONG:\n            sortType = \"long\";\n            break;\n          case INT:\n            sortType = \"int\";\n            break;\n          case DOUBLE:\n            sortType = \"double\";\n            break;\n          case FLOAT:\n            sortType = \"float\";\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortType, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31741cf1390044e38a2ec3127cf302ba841bfd75","date":1491292636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      SimpleTextUtil.write(output, SI_MIN_VERSION);\n      if (si.getMinVersion() == null) {\n        SimpleTextUtil.write(output, \"null\", scratch);\n      } else {\n        SimpleTextUtil.write(output, si.getMinVersion().toString(), scratch);\n      }\n      SimpleTextUtil.writeNewline(output);\n\n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortTypeString;\n        final SortField.Type sortType;\n        final boolean multiValued;\n        if (sortField instanceof SortedSetSortField) {\n          sortType = SortField.Type.STRING;\n          multiValued = true;\n        } else if (sortField instanceof SortedNumericSortField) {\n          sortType = ((SortedNumericSortField) sortField).getNumericType();\n          multiValued = true;\n        } else {\n          sortType = sortField.getType();\n          multiValued = false;\n        }\n        switch (sortType) {\n          case STRING:\n              if (multiValued) {\n                sortTypeString = \"multi_valued_string\";\n              } else {\n                sortTypeString = \"string\";\n              }\n            break;\n          case LONG:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_long\";\n            } else {\n              sortTypeString = \"long\";\n            }\n            break;\n          case INT:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_int\";\n            } else {\n              sortTypeString = \"int\";\n            }\n            break;\n          case DOUBLE:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_double\";\n            } else {\n              sortTypeString = \"double\";\n            }\n            break;\n          case FLOAT:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_float\";\n            } else {\n              sortTypeString = \"float\";\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortTypeString, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        if (sortField instanceof SortedSetSortField) {\n          SortedSetSelector.Type selector = ((SortedSetSortField) sortField).getSelector();\n          final String selectorString;\n          if (selector == SortedSetSelector.Type.MIN) {\n            selectorString = \"min\";\n          } else if (selector == SortedSetSelector.Type.MIDDLE_MIN) {\n            selectorString = \"middle_min\";\n          } else if (selector == SortedSetSelector.Type.MIDDLE_MAX) {\n            selectorString = \"middle_max\";\n          } else if (selector == SortedSetSelector.Type.MAX) {\n            selectorString = \"max\";\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type selector: \" + selector);\n          }\n          SimpleTextUtil.write(output, SI_SELECTOR_TYPE);\n          SimpleTextUtil.write(output, selectorString, scratch);\n          SimpleTextUtil.writeNewline(output);\n        } else if (sortField instanceof SortedNumericSortField) {\n          SortedNumericSelector.Type selector = ((SortedNumericSortField) sortField).getSelector();\n          final String selectorString;\n          if (selector == SortedNumericSelector.Type.MIN) {\n            selectorString = \"min\";\n          } else if (selector == SortedNumericSelector.Type.MAX) {\n            selectorString = \"max\";\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type selector: \" + selector);\n          }\n          SimpleTextUtil.write(output, SI_SELECTOR_TYPE);\n          SimpleTextUtil.write(output, selectorString, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortTypeString;\n        final SortField.Type sortType;\n        final boolean multiValued;\n        if (sortField instanceof SortedSetSortField) {\n          sortType = SortField.Type.STRING;\n          multiValued = true;\n        } else if (sortField instanceof SortedNumericSortField) {\n          sortType = ((SortedNumericSortField) sortField).getNumericType();\n          multiValued = true;\n        } else {\n          sortType = sortField.getType();\n          multiValued = false;\n        }\n        switch (sortType) {\n          case STRING:\n              if (multiValued) {\n                sortTypeString = \"multi_valued_string\";\n              } else {\n                sortTypeString = \"string\";\n              }\n            break;\n          case LONG:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_long\";\n            } else {\n              sortTypeString = \"long\";\n            }\n            break;\n          case INT:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_int\";\n            } else {\n              sortTypeString = \"int\";\n            }\n            break;\n          case DOUBLE:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_double\";\n            } else {\n              sortTypeString = \"double\";\n            }\n            break;\n          case FLOAT:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_float\";\n            } else {\n              sortTypeString = \"float\";\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortTypeString, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        if (sortField instanceof SortedSetSortField) {\n          SortedSetSelector.Type selector = ((SortedSetSortField) sortField).getSelector();\n          final String selectorString;\n          if (selector == SortedSetSelector.Type.MIN) {\n            selectorString = \"min\";\n          } else if (selector == SortedSetSelector.Type.MIDDLE_MIN) {\n            selectorString = \"middle_min\";\n          } else if (selector == SortedSetSelector.Type.MIDDLE_MAX) {\n            selectorString = \"middle_max\";\n          } else if (selector == SortedSetSelector.Type.MAX) {\n            selectorString = \"max\";\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type selector: \" + selector);\n          }\n          SimpleTextUtil.write(output, SI_SELECTOR_TYPE);\n          SimpleTextUtil.write(output, selectorString, scratch);\n          SimpleTextUtil.writeNewline(output);\n        } else if (sortField instanceof SortedNumericSortField) {\n          SortedNumericSelector.Type selector = ((SortedNumericSortField) sortField).getSelector();\n          final String selectorString;\n          if (selector == SortedNumericSelector.Type.MIN) {\n            selectorString = \"min\";\n          } else if (selector == SortedNumericSelector.Type.MAX) {\n            selectorString = \"max\";\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type selector: \" + selector);\n          }\n          SimpleTextUtil.write(output, SI_SELECTOR_TYPE);\n          SimpleTextUtil.write(output, selectorString, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92212fd254551a0b1156aafc3a1a6ed1a43932ad","date":1491296431,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      SimpleTextUtil.write(output, SI_MIN_VERSION);\n      if (si.getMinVersion() == null) {\n        SimpleTextUtil.write(output, \"null\", scratch);\n      } else {\n        SimpleTextUtil.write(output, si.getMinVersion().toString(), scratch);\n      }\n      SimpleTextUtil.writeNewline(output);\n\n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortTypeString;\n        final SortField.Type sortType;\n        final boolean multiValued;\n        if (sortField instanceof SortedSetSortField) {\n          sortType = SortField.Type.STRING;\n          multiValued = true;\n        } else if (sortField instanceof SortedNumericSortField) {\n          sortType = ((SortedNumericSortField) sortField).getNumericType();\n          multiValued = true;\n        } else {\n          sortType = sortField.getType();\n          multiValued = false;\n        }\n        switch (sortType) {\n          case STRING:\n              if (multiValued) {\n                sortTypeString = \"multi_valued_string\";\n              } else {\n                sortTypeString = \"string\";\n              }\n            break;\n          case LONG:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_long\";\n            } else {\n              sortTypeString = \"long\";\n            }\n            break;\n          case INT:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_int\";\n            } else {\n              sortTypeString = \"int\";\n            }\n            break;\n          case DOUBLE:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_double\";\n            } else {\n              sortTypeString = \"double\";\n            }\n            break;\n          case FLOAT:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_float\";\n            } else {\n              sortTypeString = \"float\";\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortTypeString, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        if (sortField instanceof SortedSetSortField) {\n          SortedSetSelector.Type selector = ((SortedSetSortField) sortField).getSelector();\n          final String selectorString;\n          if (selector == SortedSetSelector.Type.MIN) {\n            selectorString = \"min\";\n          } else if (selector == SortedSetSelector.Type.MIDDLE_MIN) {\n            selectorString = \"middle_min\";\n          } else if (selector == SortedSetSelector.Type.MIDDLE_MAX) {\n            selectorString = \"middle_max\";\n          } else if (selector == SortedSetSelector.Type.MAX) {\n            selectorString = \"max\";\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type selector: \" + selector);\n          }\n          SimpleTextUtil.write(output, SI_SELECTOR_TYPE);\n          SimpleTextUtil.write(output, selectorString, scratch);\n          SimpleTextUtil.writeNewline(output);\n        } else if (sortField instanceof SortedNumericSortField) {\n          SortedNumericSelector.Type selector = ((SortedNumericSortField) sortField).getSelector();\n          final String selectorString;\n          if (selector == SortedNumericSelector.Type.MIN) {\n            selectorString = \"min\";\n          } else if (selector == SortedNumericSelector.Type.MAX) {\n            selectorString = \"max\";\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type selector: \" + selector);\n          }\n          SimpleTextUtil.write(output, SI_SELECTOR_TYPE);\n          SimpleTextUtil.write(output, selectorString, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortTypeString;\n        final SortField.Type sortType;\n        final boolean multiValued;\n        if (sortField instanceof SortedSetSortField) {\n          sortType = SortField.Type.STRING;\n          multiValued = true;\n        } else if (sortField instanceof SortedNumericSortField) {\n          sortType = ((SortedNumericSortField) sortField).getNumericType();\n          multiValued = true;\n        } else {\n          sortType = sortField.getType();\n          multiValued = false;\n        }\n        switch (sortType) {\n          case STRING:\n              if (multiValued) {\n                sortTypeString = \"multi_valued_string\";\n              } else {\n                sortTypeString = \"string\";\n              }\n            break;\n          case LONG:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_long\";\n            } else {\n              sortTypeString = \"long\";\n            }\n            break;\n          case INT:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_int\";\n            } else {\n              sortTypeString = \"int\";\n            }\n            break;\n          case DOUBLE:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_double\";\n            } else {\n              sortTypeString = \"double\";\n            }\n            break;\n          case FLOAT:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_float\";\n            } else {\n              sortTypeString = \"float\";\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortTypeString, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        if (sortField instanceof SortedSetSortField) {\n          SortedSetSelector.Type selector = ((SortedSetSortField) sortField).getSelector();\n          final String selectorString;\n          if (selector == SortedSetSelector.Type.MIN) {\n            selectorString = \"min\";\n          } else if (selector == SortedSetSelector.Type.MIDDLE_MIN) {\n            selectorString = \"middle_min\";\n          } else if (selector == SortedSetSelector.Type.MIDDLE_MAX) {\n            selectorString = \"middle_max\";\n          } else if (selector == SortedSetSelector.Type.MAX) {\n            selectorString = \"max\";\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type selector: \" + selector);\n          }\n          SimpleTextUtil.write(output, SI_SELECTOR_TYPE);\n          SimpleTextUtil.write(output, selectorString, scratch);\n          SimpleTextUtil.writeNewline(output);\n        } else if (sortField instanceof SortedNumericSortField) {\n          SortedNumericSelector.Type selector = ((SortedNumericSortField) sortField).getSelector();\n          final String selectorString;\n          if (selector == SortedNumericSelector.Type.MIN) {\n            selectorString = \"min\";\n          } else if (selector == SortedNumericSelector.Type.MAX) {\n            selectorString = \"max\";\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type selector: \" + selector);\n          }\n          SimpleTextUtil.write(output, SI_SELECTOR_TYPE);\n          SimpleTextUtil.write(output, selectorString, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"773bf150032d3ef6c95997a154fb914b82875cb8","date":1590150786,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      SimpleTextUtil.write(output, SI_MIN_VERSION);\n      if (si.getMinVersion() == null) {\n        SimpleTextUtil.write(output, \"null\", scratch);\n      } else {\n        SimpleTextUtil.write(output, si.getMinVersion().toString(), scratch);\n      }\n      SimpleTextUtil.writeNewline(output);\n\n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n        IndexSorter sorter = sortField.getIndexSorter();\n        if (sorter == null) {\n          throw new IllegalStateException(\"Cannot serialize sort \" + sortField);\n        }\n\n        SimpleTextUtil.write(output, SI_SORT_NAME);\n        SimpleTextUtil.write(output, sorter.getProviderName(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        SimpleTextUtil.write(output, sortField.toString(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_BYTES);\n        BytesRefOutput b = new BytesRefOutput();\n        SortFieldProvider.write(sortField, b);\n        SimpleTextUtil.write(output, b.bytes.get().toString(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n\n    String segFileName = IndexFileNames.segmentFileName(si.name, \"\", SimpleTextSegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(segFileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(segFileName);\n      BytesRefBuilder scratch = new BytesRefBuilder();\n    \n      SimpleTextUtil.write(output, SI_VERSION);\n      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      SimpleTextUtil.write(output, SI_MIN_VERSION);\n      if (si.getMinVersion() == null) {\n        SimpleTextUtil.write(output, \"null\", scratch);\n      } else {\n        SimpleTextUtil.write(output, si.getMinVersion().toString(), scratch);\n      }\n      SimpleTextUtil.writeNewline(output);\n\n      SimpleTextUtil.write(output, SI_DOCCOUNT);\n      SimpleTextUtil.write(output, Integer.toString(si.maxDoc()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      SimpleTextUtil.write(output, SI_USECOMPOUND);\n      SimpleTextUtil.write(output, Boolean.toString(si.getUseCompoundFile()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      Map<String,String> diagnostics = si.getDiagnostics();\n      int numDiagnostics = diagnostics == null ? 0 : diagnostics.size();\n      SimpleTextUtil.write(output, SI_NUM_DIAG);\n      SimpleTextUtil.write(output, Integer.toString(numDiagnostics), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      if (numDiagnostics > 0) {\n        for (Map.Entry<String,String> diagEntry : diagnostics.entrySet()) {\n          SimpleTextUtil.write(output, SI_DIAG_KEY);\n          SimpleTextUtil.write(output, diagEntry.getKey(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        \n          SimpleTextUtil.write(output, SI_DIAG_VALUE);\n          SimpleTextUtil.write(output, diagEntry.getValue(), scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n      \n      Map<String,String> attributes = si.getAttributes();\n      SimpleTextUtil.write(output, SI_NUM_ATT);\n      SimpleTextUtil.write(output, Integer.toString(attributes.size()), scratch);\n      SimpleTextUtil.writeNewline(output);\n    \n      for (Map.Entry<String,String> attEntry : attributes.entrySet()) {\n        SimpleTextUtil.write(output, SI_ATT_KEY);\n        SimpleTextUtil.write(output, attEntry.getKey(), scratch);\n        SimpleTextUtil.writeNewline(output);\n        \n        SimpleTextUtil.write(output, SI_ATT_VALUE);\n        SimpleTextUtil.write(output, attEntry.getValue(), scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      Set<String> files = si.files();\n      int numFiles = files == null ? 0 : files.size();\n      SimpleTextUtil.write(output, SI_NUM_FILES);\n      SimpleTextUtil.write(output, Integer.toString(numFiles), scratch);\n      SimpleTextUtil.writeNewline(output);\n\n      if (numFiles > 0) {\n        for(String fileName : files) {\n          SimpleTextUtil.write(output, SI_FILE);\n          SimpleTextUtil.write(output, fileName, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n      }\n\n      SimpleTextUtil.write(output, SI_ID);\n      SimpleTextUtil.write(output, new BytesRef(si.getId()));\n      SimpleTextUtil.writeNewline(output);\n      \n      Sort indexSort = si.getIndexSort();\n      SimpleTextUtil.write(output, SI_SORT);\n      final int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      SimpleTextUtil.write(output, Integer.toString(numSortFields), scratch);\n      SimpleTextUtil.writeNewline(output);\n      for (int i = 0; i < numSortFields; ++i) {\n        final SortField sortField = indexSort.getSort()[i];\n\n        SimpleTextUtil.write(output, SI_SORT_FIELD);\n        SimpleTextUtil.write(output, sortField.getField(), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_TYPE);\n        final String sortTypeString;\n        final SortField.Type sortType;\n        final boolean multiValued;\n        if (sortField instanceof SortedSetSortField) {\n          sortType = SortField.Type.STRING;\n          multiValued = true;\n        } else if (sortField instanceof SortedNumericSortField) {\n          sortType = ((SortedNumericSortField) sortField).getNumericType();\n          multiValued = true;\n        } else {\n          sortType = sortField.getType();\n          multiValued = false;\n        }\n        switch (sortType) {\n          case STRING:\n              if (multiValued) {\n                sortTypeString = \"multi_valued_string\";\n              } else {\n                sortTypeString = \"string\";\n              }\n            break;\n          case LONG:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_long\";\n            } else {\n              sortTypeString = \"long\";\n            }\n            break;\n          case INT:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_int\";\n            } else {\n              sortTypeString = \"int\";\n            }\n            break;\n          case DOUBLE:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_double\";\n            } else {\n              sortTypeString = \"double\";\n            }\n            break;\n          case FLOAT:\n            if (multiValued) {\n              sortTypeString = \"multi_valued_float\";\n            } else {\n              sortTypeString = \"float\";\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        SimpleTextUtil.write(output, sortTypeString, scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        if (sortField instanceof SortedSetSortField) {\n          SortedSetSelector.Type selector = ((SortedSetSortField) sortField).getSelector();\n          final String selectorString;\n          if (selector == SortedSetSelector.Type.MIN) {\n            selectorString = \"min\";\n          } else if (selector == SortedSetSelector.Type.MIDDLE_MIN) {\n            selectorString = \"middle_min\";\n          } else if (selector == SortedSetSelector.Type.MIDDLE_MAX) {\n            selectorString = \"middle_max\";\n          } else if (selector == SortedSetSelector.Type.MAX) {\n            selectorString = \"max\";\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type selector: \" + selector);\n          }\n          SimpleTextUtil.write(output, SI_SELECTOR_TYPE);\n          SimpleTextUtil.write(output, selectorString, scratch);\n          SimpleTextUtil.writeNewline(output);\n        } else if (sortField instanceof SortedNumericSortField) {\n          SortedNumericSelector.Type selector = ((SortedNumericSortField) sortField).getSelector();\n          final String selectorString;\n          if (selector == SortedNumericSelector.Type.MIN) {\n            selectorString = \"min\";\n          } else if (selector == SortedNumericSelector.Type.MAX) {\n            selectorString = \"max\";\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type selector: \" + selector);\n          }\n          SimpleTextUtil.write(output, SI_SELECTOR_TYPE);\n          SimpleTextUtil.write(output, selectorString, scratch);\n          SimpleTextUtil.writeNewline(output);\n        }\n\n        SimpleTextUtil.write(output, SI_SORT_REVERSE);\n        SimpleTextUtil.write(output, Boolean.toString(sortField.getReverse()), scratch);\n        SimpleTextUtil.writeNewline(output);\n\n        SimpleTextUtil.write(output, SI_SORT_MISSING);\n        final Object missingValue = sortField.getMissingValue();\n        final String missing;\n        if (missingValue == null) {\n          missing = \"null\";\n        } else if (missingValue == SortField.STRING_FIRST) {\n          missing = \"first\";\n        } else if (missingValue == SortField.STRING_LAST) {\n          missing = \"last\";\n        } else {\n          missing = missingValue.toString();\n        }\n        SimpleTextUtil.write(output, missing, scratch);\n        SimpleTextUtil.writeNewline(output);\n      }\n      \n      SimpleTextUtil.writeChecksum(output, scratch);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e2fe60a17a7a0cfd101b1169acf089221bc6c166":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"45bfb4d30b7e62ec7d645a5e0113362636ac4981":["fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8"],"55980207f1977bd1463465de1659b821347e2fa8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e2fe60a17a7a0cfd101b1169acf089221bc6c166"],"b0267c69e2456a3477a1ad785723f2135da3117e":["8521d944f9dfb45692ec28235dbf116d47ef69ba"],"e065cebbdee472a02bde38052717a8cd7ee8ab3b":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"0ad30c6a479e764150a3316e57263319775f1df2":["7711f4cf675506a5b4a2c45d6f1de359cf5278c1","3d33e731a93d4b57e662ff094f64f94a745422d4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7711f4cf675506a5b4a2c45d6f1de359cf5278c1","d470c8182e92b264680e34081b75e70a9f2b3c89"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["e065cebbdee472a02bde38052717a8cd7ee8ab3b"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["7711f4cf675506a5b4a2c45d6f1de359cf5278c1","0ad30c6a479e764150a3316e57263319775f1df2"],"7711f4cf675506a5b4a2c45d6f1de359cf5278c1":["b0267c69e2456a3477a1ad785723f2135da3117e"],"8521d944f9dfb45692ec28235dbf116d47ef69ba":["e9d13460921f3c71f3cb803ee4568f4e0d6b6984"],"474b77fc1ee62c3fc1c73ceb19cc975cb03667ac":["e2fe60a17a7a0cfd101b1169acf089221bc6c166"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["8521d944f9dfb45692ec28235dbf116d47ef69ba","b0267c69e2456a3477a1ad785723f2135da3117e"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["7711f4cf675506a5b4a2c45d6f1de359cf5278c1"],"b06445ae1731e049327712db0454e5643ca9b7fe":["8521d944f9dfb45692ec28235dbf116d47ef69ba","b0267c69e2456a3477a1ad785723f2135da3117e"],"773bf150032d3ef6c95997a154fb914b82875cb8":["31741cf1390044e38a2ec3127cf302ba841bfd75"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a1ef55e1fff7ff44354432770ad8bc19be1fcc75":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e065cebbdee472a02bde38052717a8cd7ee8ab3b"],"5e03940e6e9044943de4b7ac08f8581da37a9534":["45bfb4d30b7e62ec7d645a5e0113362636ac4981"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["e065cebbdee472a02bde38052717a8cd7ee8ab3b"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["7711f4cf675506a5b4a2c45d6f1de359cf5278c1","5e03940e6e9044943de4b7ac08f8581da37a9534"],"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8":["ceaef6cfc68c8ab22a684192e469a8280f9e6e70"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["773bf150032d3ef6c95997a154fb914b82875cb8"],"e9d13460921f3c71f3cb803ee4568f4e0d6b6984":["474b77fc1ee62c3fc1c73ceb19cc975cb03667ac"]},"commit2Childs":{"e2fe60a17a7a0cfd101b1169acf089221bc6c166":["55980207f1977bd1463465de1659b821347e2fa8","474b77fc1ee62c3fc1c73ceb19cc975cb03667ac"],"45bfb4d30b7e62ec7d645a5e0113362636ac4981":["5e03940e6e9044943de4b7ac08f8581da37a9534"],"55980207f1977bd1463465de1659b821347e2fa8":[],"b0267c69e2456a3477a1ad785723f2135da3117e":["7711f4cf675506a5b4a2c45d6f1de359cf5278c1","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe"],"e065cebbdee472a02bde38052717a8cd7ee8ab3b":["31741cf1390044e38a2ec3127cf302ba841bfd75","a1ef55e1fff7ff44354432770ad8bc19be1fcc75","92212fd254551a0b1156aafc3a1a6ed1a43932ad"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a1ef55e1fff7ff44354432770ad8bc19be1fcc75"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["e065cebbdee472a02bde38052717a8cd7ee8ab3b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["773bf150032d3ef6c95997a154fb914b82875cb8"],"8521d944f9dfb45692ec28235dbf116d47ef69ba":["b0267c69e2456a3477a1ad785723f2135da3117e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe"],"7711f4cf675506a5b4a2c45d6f1de359cf5278c1":["0ad30c6a479e764150a3316e57263319775f1df2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","ceaef6cfc68c8ab22a684192e469a8280f9e6e70","3d33e731a93d4b57e662ff094f64f94a745422d4"],"474b77fc1ee62c3fc1c73ceb19cc975cb03667ac":["e9d13460921f3c71f3cb803ee4568f4e0d6b6984"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8"],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e2fe60a17a7a0cfd101b1169acf089221bc6c166","55980207f1977bd1463465de1659b821347e2fa8"],"773bf150032d3ef6c95997a154fb914b82875cb8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a1ef55e1fff7ff44354432770ad8bc19be1fcc75":[],"5e03940e6e9044943de4b7ac08f8581da37a9534":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":[],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8":["45bfb4d30b7e62ec7d645a5e0113362636ac4981"],"e9d13460921f3c71f3cb803ee4568f4e0d6b6984":["8521d944f9dfb45692ec28235dbf116d47ef69ba"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","a1ef55e1fff7ff44354432770ad8bc19be1fcc75","92212fd254551a0b1156aafc3a1a6ed1a43932ad","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}