{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#validateRouteValue(AddUpdateCommand).mjava","commits":[{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":0,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#validateRouteValue(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void validateRouteValue(AddUpdateCommand cmd) throws SolrException {\n    final Instant docTimestamp =\n        parseRouteKey(cmd.getSolrInputDocument().getFieldValue(getRouteField()));\n\n    // FUTURE: maybe in some cases the user would want to ignore/warn instead?\n    if (docTimestamp.isAfter(Instant.now().plusMillis(getMaxFutureMs()))) {\n      throw new SolrException(BAD_REQUEST,\n          \"The document's time routed key of \" + docTimestamp + \" is too far in the future given \" +\n              ROUTER_MAX_FUTURE + \"=\" + getMaxFutureMs());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eebf1b080530bdd7572c4927fb2bb52334b7a86","date":1563199033,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#validateRouteValue(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#validateRouteValue(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void validateRouteValue(AddUpdateCommand cmd) throws SolrException {\n\n    final Instant docTimestamp =\n        parseRouteKey(cmd.getSolrInputDocument().getFieldValue(getRouteField()));\n\n    // FUTURE: maybe in some cases the user would want to ignore/warn instead?\n    if (docTimestamp.isAfter(Instant.now().plusMillis(getMaxFutureMs()))) {\n      throw new SolrException(BAD_REQUEST,\n          \"The document's time routed key of \" + docTimestamp + \" is too far in the future given \" +\n              ROUTER_MAX_FUTURE + \"=\" + getMaxFutureMs());\n    }\n\n    // Although this is also checked later, we need to check it here too to handle the case in Dimensional Routed\n    // aliases where one can legally have zero collections for a newly encountered category and thus the loop later\n    // can't catch this.\n    Instant startTime = parseRouteKey(start);\n    if (docTimestamp.isBefore(startTime)) {\n      throw new SolrException(BAD_REQUEST, \"The document couldn't be routed because \" + docTimestamp +\n          \" is before the start time for this alias \" +start+\")\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void validateRouteValue(AddUpdateCommand cmd) throws SolrException {\n    final Instant docTimestamp =\n        parseRouteKey(cmd.getSolrInputDocument().getFieldValue(getRouteField()));\n\n    // FUTURE: maybe in some cases the user would want to ignore/warn instead?\n    if (docTimestamp.isAfter(Instant.now().plusMillis(getMaxFutureMs()))) {\n      throw new SolrException(BAD_REQUEST,\n          \"The document's time routed key of \" + docTimestamp + \" is too far in the future given \" +\n              ROUTER_MAX_FUTURE + \"=\" + getMaxFutureMs());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56aa6ff4cdf3147154a86d7c22a8a2615869e772","date":1570745842,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#validateRouteValue(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#validateRouteValue(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void validateRouteValue(AddUpdateCommand cmd) throws SolrException {\n\n    final Instant docTimestamp =\n        parseRouteKey(cmd.getSolrInputDocument().getFieldValue(getRouteField()));\n\n    // FUTURE: maybe in some cases the user would want to ignore/warn instead?\n    if (docTimestamp.isAfter(Instant.now().plusMillis(getMaxFutureMs()))) {\n      throw new SolrException(BAD_REQUEST,\n          \"The document's time routed key of \" + docTimestamp + \" is too far in the future given \" +\n              ROUTER_MAX_FUTURE + \"=\" + getMaxFutureMs());\n    }\n\n    // Although this is also checked later, we need to check it here too to handle the case in Dimensional Routed\n    // aliases where one can legally have zero collections for a newly encountered category and thus the loop later\n    // can't catch this.\n\n    // SOLR-13760 - we need to fix the date math to a specific instant when the first document arrives.\n    // If we don't do this DRA's with a time dimension have variable start times across the other dimensions\n    // and logic gets much to complicated, and depends too much on queries to zookeeper. This keeps life simpler.\n    // I have to admit I'm not terribly fond of the mutation during a validate method however.\n    Instant startTime;\n    try {\n      startTime = Instant.parse(start);\n    } catch (DateTimeParseException e) {\n      startTime = DateMathParser.parseMath(new Date(), start).toInstant();\n      SolrCore core = cmd.getReq().getCore();\n      ZkStateReader zkStateReader = core.getCoreContainer().getZkController().zkStateReader;\n      Aliases aliases = zkStateReader.getAliases();\n      Map<String, String> props = new HashMap<>(aliases.getCollectionAliasProperties(aliasName));\n      start = DateTimeFormatter.ISO_INSTANT.format(startTime);\n      props.put(ROUTER_START, start);\n\n      // This could race, but it only occurs when the alias is first used and the values produced\n      // should all be identical and who wins won't matter (baring cases of Date Math involving seconds,\n      // which is pretty far fetched). Putting this in a separate thread to ensure that any failed\n      // races don't cause documents to get rejected.\n      core.runAsync(() -> zkStateReader.aliasesManager.applyModificationAndExportToZk(\n          (a) -> aliases.cloneWithCollectionAliasProperties(aliasName, props)));\n\n    }\n    if (docTimestamp.isBefore(startTime)) {\n      throw new SolrException(BAD_REQUEST, \"The document couldn't be routed because \" + docTimestamp +\n          \" is before the start time for this alias \" +start+\")\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void validateRouteValue(AddUpdateCommand cmd) throws SolrException {\n\n    final Instant docTimestamp =\n        parseRouteKey(cmd.getSolrInputDocument().getFieldValue(getRouteField()));\n\n    // FUTURE: maybe in some cases the user would want to ignore/warn instead?\n    if (docTimestamp.isAfter(Instant.now().plusMillis(getMaxFutureMs()))) {\n      throw new SolrException(BAD_REQUEST,\n          \"The document's time routed key of \" + docTimestamp + \" is too far in the future given \" +\n              ROUTER_MAX_FUTURE + \"=\" + getMaxFutureMs());\n    }\n\n    // Although this is also checked later, we need to check it here too to handle the case in Dimensional Routed\n    // aliases where one can legally have zero collections for a newly encountered category and thus the loop later\n    // can't catch this.\n    Instant startTime = parseRouteKey(start);\n    if (docTimestamp.isBefore(startTime)) {\n      throw new SolrException(BAD_REQUEST, \"The document couldn't be routed because \" + docTimestamp +\n          \" is before the start time for this alias \" +start+\")\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#validateRouteValue(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#validateRouteValue(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void validateRouteValue(AddUpdateCommand cmd) throws SolrException {\n\n    final Instant docTimestamp =\n        parseRouteKey(cmd.getSolrInputDocument().getFieldValue(getRouteField()));\n\n    // FUTURE: maybe in some cases the user would want to ignore/warn instead?\n    if (docTimestamp.isAfter(Instant.now().plusMillis(getMaxFutureMs()))) {\n      throw new SolrException(BAD_REQUEST,\n          \"The document's time routed key of \" + docTimestamp + \" is too far in the future given \" +\n              ROUTER_MAX_FUTURE + \"=\" + getMaxFutureMs());\n    }\n\n    // Although this is also checked later, we need to check it here too to handle the case in Dimensional Routed\n    // aliases where one can legally have zero collections for a newly encountered category and thus the loop later\n    // can't catch this.\n\n    // SOLR-13760 - we need to fix the date math to a specific instant when the first document arrives.\n    // If we don't do this DRA's with a time dimension have variable start times across the other dimensions\n    // and logic gets much to complicated, and depends too much on queries to zookeeper. This keeps life simpler.\n    // I have to admit I'm not terribly fond of the mutation during a validate method however.\n    Instant startTime;\n    try {\n      startTime = Instant.parse(start);\n    } catch (DateTimeParseException e) {\n      startTime = DateMathParser.parseMath(new Date(), start).toInstant();\n      SolrCore core = cmd.getReq().getCore();\n      ZkStateReader zkStateReader = core.getCoreContainer().getZkController().zkStateReader;\n      Aliases aliases = zkStateReader.getAliases();\n      Map<String, String> props = new HashMap<>(aliases.getCollectionAliasProperties(aliasName));\n      start = DateTimeFormatter.ISO_INSTANT.format(startTime);\n      props.put(ROUTER_START, start);\n\n      // This could race, but it only occurs when the alias is first used and the values produced\n      // should all be identical and who wins won't matter (baring cases of Date Math involving seconds,\n      // which is pretty far fetched). Putting this in a separate thread to ensure that any failed\n      // races don't cause documents to get rejected.\n      core.runAsync(() -> zkStateReader.aliasesManager.applyModificationAndExportToZk(\n          (a) -> aliases.cloneWithCollectionAliasProperties(aliasName, props)));\n\n    }\n    if (docTimestamp.isBefore(startTime)) {\n      throw new SolrException(BAD_REQUEST, \"The document couldn't be routed because \" + docTimestamp +\n          \" is before the start time for this alias \" +start+\")\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void validateRouteValue(AddUpdateCommand cmd) throws SolrException {\n\n    final Instant docTimestamp =\n        parseRouteKey(cmd.getSolrInputDocument().getFieldValue(getRouteField()));\n\n    // FUTURE: maybe in some cases the user would want to ignore/warn instead?\n    if (docTimestamp.isAfter(Instant.now().plusMillis(getMaxFutureMs()))) {\n      throw new SolrException(BAD_REQUEST,\n          \"The document's time routed key of \" + docTimestamp + \" is too far in the future given \" +\n              ROUTER_MAX_FUTURE + \"=\" + getMaxFutureMs());\n    }\n\n    // Although this is also checked later, we need to check it here too to handle the case in Dimensional Routed\n    // aliases where one can legally have zero collections for a newly encountered category and thus the loop later\n    // can't catch this.\n    Instant startTime = parseRouteKey(start);\n    if (docTimestamp.isBefore(startTime)) {\n      throw new SolrException(BAD_REQUEST, \"The document couldn't be routed because \" + docTimestamp +\n          \" is before the start time for this alias \" +start+\")\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b627755385655c7cd3fb296f17593658805cf4d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["b627755385655c7cd3fb296f17593658805cf4d5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["56aa6ff4cdf3147154a86d7c22a8a2615869e772"],"56aa6ff4cdf3147154a86d7c22a8a2615869e772":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"b0b597c65628ca9e73913a07e81691f8229bae35":["1eebf1b080530bdd7572c4927fb2bb52334b7a86","56aa6ff4cdf3147154a86d7c22a8a2615869e772"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b627755385655c7cd3fb296f17593658805cf4d5"],"b627755385655c7cd3fb296f17593658805cf4d5":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["56aa6ff4cdf3147154a86d7c22a8a2615869e772","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"56aa6ff4cdf3147154a86d7c22a8a2615869e772":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}