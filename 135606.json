{"path":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPResponse#readResponseData(InputStream,int).mjava","commits":[{"id":"bc6055f4a2e8e9f9caaec2297010c9502480ed69","date":1050060580,"type":0,"author":"cmarschner","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPResponse#readResponseData(InputStream,int).mjava","pathOld":"/dev/null","sourceNew":"        /**\n     * Reads the response data received. Does not return until either\n     * Content-Length bytes have been read or EOF is reached.\n     *\n     * @param inp              Description of the Parameter\n     * @exception IOException  if any read on the input stream fails\n     * @inp                    the input stream from which to read the data\n     */\n    private void readResponseData(InputStream inp, int max)\n        throws IOException, ModuleException\n    {\n        boolean readUnlimited = (max == -1);\n\n        if (ContentLength == 0)\n        {\n            return;\n        }\n\n        if (Data == null)\n        {\n            Data = new byte[0];\n        }\n\n        // read response data\n\n        int off = Data.length;\n\n        try\n        {\n            // check Content-length header in case CE-Module removed it\n            if (getHeader(\"Content-Length\") != null)\n            {\n                int rcvd = 0;\n                int total = max > 1 ? Math.min(ContentLength, max) : ContentLength;\n                //System.out.println(\"Reading with max file size: \" + total);\n                Data = new byte[total];\n                do\n                {\n                    off += rcvd;\n                    rcvd = inp.read(Data, off, total - off);\n                } while (rcvd != -1 && off + rcvd < total);\n                // if max < ContentLength (&& max > -1): lose the rest\n                /*if(total < ContentLength)\n                {\n                    inp.skip(ContentLength - total);\n                }*/\n                /*\n                 *  Don't do this!\n                 *  If we do, then getData() won't work after a getInputStream()\n                 *  because we'll never get all the expected data. Instead, let\n                 *  the underlying RespInputStream throw the EOF.\n                 *  if (rcvd == -1)\t// premature EOF\n                 *  {\n                 *  throw new EOFException(\"Encountered premature EOF while \" +\n                 *  \"reading headers: received \" + off +\n                 *  \" bytes instead of the expected \" +\n                 *  ContentLength + \" bytes\");\n                 *  }\n                 */\n            }\n            else\n            {\n                //System.out.println(\"Reading with unknown file size\");\n                java.util.LinkedList blocks = new java.util.LinkedList();\n                //System.out.println(\"new LinkedList()\");\n                int total = 0;\n                int secondBlockSize = 10*2000;\n                byte[] secondBlock = new byte[secondBlockSize];\n                //System.out.println(\"new byte[\" + secondBlockSize + \"]\");\n                int offInSecondBlock = 0;\n                int rcvd = 0;\n                do\n                {\n                    int bytesToRead = secondBlockSize - offInSecondBlock;\n                    if(bytesToRead < 1)\n                    {\n                        // System.out.println(\"adding block to list...\");\n                        blocks.addLast(secondBlock);\n                        secondBlock = new byte[secondBlockSize];\n                        //System.out.println(\"new byte[\" + secondBlockSize + \"]\");\n                        offInSecondBlock = 0;\n                        bytesToRead = secondBlockSize;\n                    }\n                    rcvd = inp.read(secondBlock, offInSecondBlock, bytesToRead);\n                    //System.out.println(\"read \" + rcvd);\n                    // rcvd is usually << secondBlockSize\n                    if(rcvd != -1)\n                    {\n                        offInSecondBlock += rcvd;\n                        total += rcvd;\n                        max -= rcvd;\n                    }\n                } while(rcvd != -1 && (readUnlimited || max > 0));\n\n                // now we have: 1 x the last block as \"secondBlock\" + 0...n x blocks in the list\n                Data = new byte[total];  // I can't see how to do it without this second buffer\n                //System.out.println(\"new byte[\" + total + \"]\");\n\n                int offset = 0;\n                while(blocks.size() > 0)\n                {\n                    byte[] block = (byte[]) blocks.removeFirst();\n                    System.arraycopy(block, 0, Data, offset, block.length);\n                    //System.out.println(\"System.arraycopy(\" + block.length + \")\");\n                    offset += block.length;\n                }\n                if(offInSecondBlock > 0)\n                {\n                    //System.out.println(\"System.arraycopy(\" + offInSecondBlock + \")\");\n                    System.arraycopy(secondBlock, 0, Data, offset, offInSecondBlock);\n                }\n\n\n            }\n        }\n        catch (IOException ioe)\n        {\n            Data = Util.resizeArray(Data, off);\n            throw ioe;\n        }\n        finally\n        {\n            try\n            {\n                inp.close();\n            }\n            catch (IOException ioe)\n            {\n            }\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"afc16d717d9ed1a8e45371668ca6de674164d624","date":1103345442,"type":4,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"/dev/null","pathOld":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPResponse#readResponseData(InputStream,int).mjava","sourceNew":null,"sourceOld":"        /**\n     * Reads the response data received. Does not return until either\n     * Content-Length bytes have been read or EOF is reached.\n     *\n     * @param inp              Description of the Parameter\n     * @exception IOException  if any read on the input stream fails\n     * @inp                    the input stream from which to read the data\n     */\n    private void readResponseData(InputStream inp, int max)\n        throws IOException, ModuleException\n    {\n        boolean readUnlimited = (max == -1);\n\n        if (ContentLength == 0)\n        {\n            return;\n        }\n\n        if (Data == null)\n        {\n            Data = new byte[0];\n        }\n\n        // read response data\n\n        int off = Data.length;\n\n        try\n        {\n            // check Content-length header in case CE-Module removed it\n            if (getHeader(\"Content-Length\") != null)\n            {\n                int rcvd = 0;\n                int total = max > 1 ? Math.min(ContentLength, max) : ContentLength;\n                //System.out.println(\"Reading with max file size: \" + total);\n                Data = new byte[total];\n                do\n                {\n                    off += rcvd;\n                    rcvd = inp.read(Data, off, total - off);\n                } while (rcvd != -1 && off + rcvd < total);\n                // if max < ContentLength (&& max > -1): lose the rest\n                /*if(total < ContentLength)\n                {\n                    inp.skip(ContentLength - total);\n                }*/\n                /*\n                 *  Don't do this!\n                 *  If we do, then getData() won't work after a getInputStream()\n                 *  because we'll never get all the expected data. Instead, let\n                 *  the underlying RespInputStream throw the EOF.\n                 *  if (rcvd == -1)\t// premature EOF\n                 *  {\n                 *  throw new EOFException(\"Encountered premature EOF while \" +\n                 *  \"reading headers: received \" + off +\n                 *  \" bytes instead of the expected \" +\n                 *  ContentLength + \" bytes\");\n                 *  }\n                 */\n            }\n            else\n            {\n                //System.out.println(\"Reading with unknown file size\");\n                java.util.LinkedList blocks = new java.util.LinkedList();\n                //System.out.println(\"new LinkedList()\");\n                int total = 0;\n                int secondBlockSize = 10*2000;\n                byte[] secondBlock = new byte[secondBlockSize];\n                //System.out.println(\"new byte[\" + secondBlockSize + \"]\");\n                int offInSecondBlock = 0;\n                int rcvd = 0;\n                do\n                {\n                    int bytesToRead = secondBlockSize - offInSecondBlock;\n                    if(bytesToRead < 1)\n                    {\n                        // System.out.println(\"adding block to list...\");\n                        blocks.addLast(secondBlock);\n                        secondBlock = new byte[secondBlockSize];\n                        //System.out.println(\"new byte[\" + secondBlockSize + \"]\");\n                        offInSecondBlock = 0;\n                        bytesToRead = secondBlockSize;\n                    }\n                    rcvd = inp.read(secondBlock, offInSecondBlock, bytesToRead);\n                    //System.out.println(\"read \" + rcvd);\n                    // rcvd is usually << secondBlockSize\n                    if(rcvd != -1)\n                    {\n                        offInSecondBlock += rcvd;\n                        total += rcvd;\n                        max -= rcvd;\n                    }\n                } while(rcvd != -1 && (readUnlimited || max > 0));\n\n                // now we have: 1 x the last block as \"secondBlock\" + 0...n x blocks in the list\n                Data = new byte[total];  // I can't see how to do it without this second buffer\n                //System.out.println(\"new byte[\" + total + \"]\");\n\n                int offset = 0;\n                while(blocks.size() > 0)\n                {\n                    byte[] block = (byte[]) blocks.removeFirst();\n                    System.arraycopy(block, 0, Data, offset, block.length);\n                    //System.out.println(\"System.arraycopy(\" + block.length + \")\");\n                    offset += block.length;\n                }\n                if(offInSecondBlock > 0)\n                {\n                    //System.out.println(\"System.arraycopy(\" + offInSecondBlock + \")\");\n                    System.arraycopy(secondBlock, 0, Data, offset, offInSecondBlock);\n                }\n\n\n            }\n        }\n        catch (IOException ioe)\n        {\n            Data = Util.resizeArray(Data, off);\n            throw ioe;\n        }\n        finally\n        {\n            try\n            {\n                inp.close();\n            }\n            catch (IOException ioe)\n            {\n            }\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bc6055f4a2e8e9f9caaec2297010c9502480ed69":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"afc16d717d9ed1a8e45371668ca6de674164d624":["bc6055f4a2e8e9f9caaec2297010c9502480ed69"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["afc16d717d9ed1a8e45371668ca6de674164d624"]},"commit2Childs":{"bc6055f4a2e8e9f9caaec2297010c9502480ed69":["afc16d717d9ed1a8e45371668ca6de674164d624"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bc6055f4a2e8e9f9caaec2297010c9502480ed69"],"afc16d717d9ed1a8e45371668ca6de674164d624":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}