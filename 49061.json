{"path":"lucene/src/java/org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl#append(CharSequence,int,int).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl#append(CharSequence,int,int).mjava","pathOld":"/dev/null","sourceNew":"  public CharTermAttribute append(CharSequence csq, int start, int end) {\n    resizeBuffer(termLength + end - start);\n    if (csq instanceof String) {\n      ((String) csq).getChars(start, end, termBuffer, termLength);\n    } else if (csq instanceof StringBuilder) {\n      ((StringBuilder) csq).getChars(start, end, termBuffer, termLength);\n    } else if (csq instanceof StringBuffer) {\n      ((StringBuffer) csq).getChars(start, end, termBuffer, termLength);\n    } else if (csq instanceof CharBuffer && ((CharBuffer) csq).hasArray()) {\n      final CharBuffer cb = (CharBuffer) csq;\n      System.arraycopy(cb.array(), cb.arrayOffset() + cb.position() + start, termBuffer, termLength, end - start);\n    } else {\n      while (start < end)\n        termBuffer[termLength++] = csq.charAt(start++);\n      // no fall-through here, as termLength is updated!\n      return this;\n    }\n    termLength += end - start;\n    return this;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b298ec7eee064feb32314fd646a95e38f1152835","date":1271673925,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl#append(CharSequence,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl#append(CharSequence,int,int).mjava","sourceNew":"  public final CharTermAttribute append(CharSequence csq, int start, int end) {\n    if (csq == null) // needed for Appendable compliance\n      csq = \"null\";\n    final int len = end - start, csqlen = csq.length();\n    if (len < 0 || start > csqlen || end > csqlen)\n      throw new IndexOutOfBoundsException();\n    if (len == 0)\n      return this;\n    resizeBuffer(termLength + len);\n    if (len > 4) { // only use instanceof check series for longer CSQs, else simply iterate\n      if (csq instanceof String) {\n        ((String) csq).getChars(start, end, termBuffer, termLength);\n      } else if (csq instanceof StringBuilder) {\n        ((StringBuilder) csq).getChars(start, end, termBuffer, termLength);\n      } else if (csq instanceof CharTermAttribute) {\n        System.arraycopy(((CharTermAttribute) csq).buffer(), start, termBuffer, termLength, len);\n      } else if (csq instanceof CharBuffer && ((CharBuffer) csq).hasArray()) {\n        final CharBuffer cb = (CharBuffer) csq;\n        System.arraycopy(cb.array(), cb.arrayOffset() + cb.position() + start, termBuffer, termLength, len);\n      } else if (csq instanceof StringBuffer) {\n        ((StringBuffer) csq).getChars(start, end, termBuffer, termLength);\n      } else {\n        while (start < end)\n          termBuffer[termLength++] = csq.charAt(start++);\n        // no fall-through here, as termLength is updated!\n        return this;\n      }\n      termLength += len;\n      return this;\n    } else {\n      while (start < end)\n        termBuffer[termLength++] = csq.charAt(start++);\n      return this;\n    }\n  }\n\n","sourceOld":"  public CharTermAttribute append(CharSequence csq, int start, int end) {\n    resizeBuffer(termLength + end - start);\n    if (csq instanceof String) {\n      ((String) csq).getChars(start, end, termBuffer, termLength);\n    } else if (csq instanceof StringBuilder) {\n      ((StringBuilder) csq).getChars(start, end, termBuffer, termLength);\n    } else if (csq instanceof StringBuffer) {\n      ((StringBuffer) csq).getChars(start, end, termBuffer, termLength);\n    } else if (csq instanceof CharBuffer && ((CharBuffer) csq).hasArray()) {\n      final CharBuffer cb = (CharBuffer) csq;\n      System.arraycopy(cb.array(), cb.arrayOffset() + cb.position() + start, termBuffer, termLength, end - start);\n    } else {\n      while (start < end)\n        termBuffer[termLength++] = csq.charAt(start++);\n      // no fall-through here, as termLength is updated!\n      return this;\n    }\n    termLength += end - start;\n    return this;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl#append(CharSequence,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl#append(CharSequence,int,int).mjava","sourceNew":"  public final CharTermAttribute append(CharSequence csq, int start, int end) {\n    if (csq == null) // needed for Appendable compliance\n      csq = \"null\";\n    final int len = end - start, csqlen = csq.length();\n    if (len < 0 || start > csqlen || end > csqlen)\n      throw new IndexOutOfBoundsException();\n    if (len == 0)\n      return this;\n    resizeBuffer(termLength + len);\n    if (len > 4) { // only use instanceof check series for longer CSQs, else simply iterate\n      if (csq instanceof String) {\n        ((String) csq).getChars(start, end, termBuffer, termLength);\n      } else if (csq instanceof StringBuilder) {\n        ((StringBuilder) csq).getChars(start, end, termBuffer, termLength);\n      } else if (csq instanceof CharTermAttribute) {\n        System.arraycopy(((CharTermAttribute) csq).buffer(), start, termBuffer, termLength, len);\n      } else if (csq instanceof CharBuffer && ((CharBuffer) csq).hasArray()) {\n        final CharBuffer cb = (CharBuffer) csq;\n        System.arraycopy(cb.array(), cb.arrayOffset() + cb.position() + start, termBuffer, termLength, len);\n      } else if (csq instanceof StringBuffer) {\n        ((StringBuffer) csq).getChars(start, end, termBuffer, termLength);\n      } else {\n        while (start < end)\n          termBuffer[termLength++] = csq.charAt(start++);\n        // no fall-through here, as termLength is updated!\n        return this;\n      }\n      termLength += len;\n      return this;\n    } else {\n      while (start < end)\n        termBuffer[termLength++] = csq.charAt(start++);\n      return this;\n    }\n  }\n\n","sourceOld":"  public final CharTermAttribute append(CharSequence csq, int start, int end) {\n    if (csq == null) // needed for Appendable compliance\n      csq = \"null\";\n    final int len = end - start, csqlen = csq.length();\n    if (len < 0 || start > csqlen || end > csqlen)\n      throw new IndexOutOfBoundsException();\n    if (len == 0)\n      return this;\n    resizeBuffer(termLength + len);\n    if (len > 4) { // only use instanceof check series for longer CSQs, else simply iterate\n      if (csq instanceof String) {\n        ((String) csq).getChars(start, end, termBuffer, termLength);\n      } else if (csq instanceof StringBuilder) {\n        ((StringBuilder) csq).getChars(start, end, termBuffer, termLength);\n      } else if (csq instanceof CharTermAttribute) {\n        System.arraycopy(((CharTermAttribute) csq).buffer(), start, termBuffer, termLength, len);\n      } else if (csq instanceof CharBuffer && ((CharBuffer) csq).hasArray()) {\n        final CharBuffer cb = (CharBuffer) csq;\n        System.arraycopy(cb.array(), cb.arrayOffset() + cb.position() + start, termBuffer, termLength, len);\n      } else if (csq instanceof StringBuffer) {\n        ((StringBuffer) csq).getChars(start, end, termBuffer, termLength);\n      } else {\n        while (start < end)\n          termBuffer[termLength++] = csq.charAt(start++);\n        // no fall-through here, as termLength is updated!\n        return this;\n      }\n      termLength += len;\n      return this;\n    } else {\n      while (start < end)\n        termBuffer[termLength++] = csq.charAt(start++);\n      return this;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["b298ec7eee064feb32314fd646a95e38f1152835"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b298ec7eee064feb32314fd646a95e38f1152835":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"b298ec7eee064feb32314fd646a95e38f1152835":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["b298ec7eee064feb32314fd646a95e38f1152835"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}