{"path":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b68df8b95f3ea758a8dc21cb20a50a01db973e8e","date":1321650433,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      rb.req.getContext().put(\"BOOSTED\", booster.ids);\n      \n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fae06511695f4be0bce5337deb3b3f813d0c3e7c","date":1323890147,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      rb.req.getContext().put(\"BOOSTED\", booster.ids);\n      \n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( \n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      rb.req.getContext().put(\"BOOSTED\", booster.ids);\n      \n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d0561cea94adff1867218e77bb763c7583be279","date":1324334341,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(\"BOOSTED\", booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          for (BooleanClause bq : booster.exclude) {\n            newq.add(bq);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSort(new Sort(new SortField[]{\n            new SortField(idField, comparator, false),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      } else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>(current.length + 1);\n        // Perhaps force it to always sort by score\n        if (force && current[0].getType() != SortField.Type.SCORE) {\n          sorts.add(new SortField(idField, comparator, false));\n          modify = true;\n        }\n        for (SortField sf : current) {\n          if (sf.getType() == SortField.Type.SCORE) {\n            sorts.add(new SortField(idField, comparator, sf.getReverse()));\n            modify = true;\n          }\n          sorts.add(sf);\n        }\n        if (modify) {\n          sortSpec.setSort(new Sort(sorts.toArray(new SortField[sorts.size()])));\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      rb.req.getContext().put(\"BOOSTED\", booster.ids);\n      \n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( \n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["1445434793334e26d7938862ae6f101e137de632"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3fb0c241e2a5e80dcaf41e354c7003520fcb777d","date":1324562351,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.SHOULD));\n            }\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSort(new Sort(new SortField[]{\n            new SortField(idField, comparator, false),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      } else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>(current.length + 1);\n        // Perhaps force it to always sort by score\n        if (force && current[0].getType() != SortField.Type.SCORE) {\n          sorts.add(new SortField(idField, comparator, false));\n          modify = true;\n        }\n        for (SortField sf : current) {\n          if (sf.getType() == SortField.Type.SCORE) {\n            sorts.add(new SortField(idField, comparator, sf.getReverse()));\n            modify = true;\n          }\n          sorts.add(sf);\n        }\n        if (modify) {\n          sortSpec.setSort(new Sort(sorts.toArray(new SortField[sorts.size()])));\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(\"BOOSTED\", booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          for (BooleanClause bq : booster.exclude) {\n            newq.add(bq);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSort(new Sort(new SortField[]{\n            new SortField(idField, comparator, false),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      } else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>(current.length + 1);\n        // Perhaps force it to always sort by score\n        if (force && current[0].getType() != SortField.Type.SCORE) {\n          sorts.add(new SortField(idField, comparator, false));\n          modify = true;\n        }\n        for (SortField sf : current) {\n          if (sf.getType() == SortField.Type.SCORE) {\n            sorts.add(new SortField(idField, comparator, sf.getReverse()));\n            modify = true;\n          }\n          sorts.add(sf);\n        }\n        if (modify) {\n          sortSpec.setSort(new Sort(sorts.toArray(new SortField[sorts.size()])));\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["44c12811987af7a5dc1a8fa7d3ddf54399fdeb2a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e1a45617f98e5cd25b73e9ae4ea69e0a0edacebe","date":1332176888,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.SHOULD));\n            }\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSort(new Sort(new SortField[]{\n            new SortField(\"_elevate_\", comparator, true),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      } else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>(current.length + 1);\n        // Perhaps force it to always sort by score\n        if (force && current[0].getType() != SortField.Type.SCORE) {\n          sorts.add(new SortField(\"_elevate_\", comparator, true));\n          modify = true;\n        }\n        for (SortField sf : current) {\n          if (sf.getType() == SortField.Type.SCORE) {\n            sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n            modify = true;\n          }\n          sorts.add(sf);\n        }\n        if (modify) {\n          sortSpec.setSort(new Sort(sorts.toArray(new SortField[sorts.size()])));\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.SHOULD));\n            }\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSort(new Sort(new SortField[]{\n            new SortField(idField, comparator, false),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      } else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>(current.length + 1);\n        // Perhaps force it to always sort by score\n        if (force && current[0].getType() != SortField.Type.SCORE) {\n          sorts.add(new SortField(idField, comparator, false));\n          modify = true;\n        }\n        for (SortField sf : current) {\n          if (sf.getType() == SortField.Type.SCORE) {\n            sorts.add(new SortField(idField, comparator, sf.getReverse()));\n            modify = true;\n          }\n          sorts.add(sf);\n        }\n        if (modify) {\n          sortSpec.setSort(new Sort(sorts.toArray(new SortField[sorts.size()])));\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["1445434793334e26d7938862ae6f101e137de632"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"44c12811987af7a5dc1a8fa7d3ddf54399fdeb2a","date":1347574644,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSort(new Sort(new SortField[]{\n            new SortField(\"_elevate_\", comparator, true),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      } else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>(current.length + 1);\n        // Perhaps force it to always sort by score\n        if (force && current[0].getType() != SortField.Type.SCORE) {\n          sorts.add(new SortField(\"_elevate_\", comparator, true));\n          modify = true;\n        }\n        for (SortField sf : current) {\n          if (sf.getType() == SortField.Type.SCORE) {\n            sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n            modify = true;\n          }\n          sorts.add(sf);\n        }\n        if (modify) {\n          sortSpec.setSort(new Sort(sorts.toArray(new SortField[sorts.size()])));\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.SHOULD));\n            }\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSort(new Sort(new SortField[]{\n            new SortField(\"_elevate_\", comparator, true),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      } else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>(current.length + 1);\n        // Perhaps force it to always sort by score\n        if (force && current[0].getType() != SortField.Type.SCORE) {\n          sorts.add(new SortField(\"_elevate_\", comparator, true));\n          modify = true;\n        }\n        for (SortField sf : current) {\n          if (sf.getType() == SortField.Type.SCORE) {\n            sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n            modify = true;\n          }\n          sorts.add(sf);\n        }\n        if (modify) {\n          sortSpec.setSort(new Sort(sorts.toArray(new SortField[sorts.size()])));\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":["3fb0c241e2a5e80dcaf41e354c7003520fcb777d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1445434793334e26d7938862ae6f101e137de632","date":1376673242,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSort(new Sort(new SortField[]{\n            new SortField(\"_elevate_\", comparator, true),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      } else {\n        // Check if the sort is based on score\n        SortField[] current = sortSpec.getSort().getSort();\n        Sort modified = this.modifySort(current, force, comparator);\n        if(modified != null) {\n          sortSpec.setSort(modified);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSort(new Sort(new SortField[]{\n            new SortField(\"_elevate_\", comparator, true),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      } else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>(current.length + 1);\n        // Perhaps force it to always sort by score\n        if (force && current[0].getType() != SortField.Type.SCORE) {\n          sorts.add(new SortField(\"_elevate_\", comparator, true));\n          modify = true;\n        }\n        for (SortField sf : current) {\n          if (sf.getType() == SortField.Type.SCORE) {\n            sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n            modify = true;\n          }\n          sorts.add(sf);\n        }\n        if (modify) {\n          sortSpec.setSort(new Sort(sorts.toArray(new SortField[sorts.size()])));\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":["5391288921372c32bf6096df320497ad2d05757f","1d0561cea94adff1867218e77bb763c7583be279","e1a45617f98e5cd25b73e9ae4ea69e0a0edacebe"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSort(new Sort(new SortField[]{\n            new SortField(\"_elevate_\", comparator, true),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      } else {\n        // Check if the sort is based on score\n        SortField[] current = sortSpec.getSort().getSort();\n        Sort modified = this.modifySort(current, force, comparator);\n        if(modified != null) {\n          sortSpec.setSort(modified);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSort(new Sort(new SortField[]{\n            new SortField(\"_elevate_\", comparator, true),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      } else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>(current.length + 1);\n        // Perhaps force it to always sort by score\n        if (force && current[0].getType() != SortField.Type.SCORE) {\n          sorts.add(new SortField(\"_elevate_\", comparator, true));\n          modify = true;\n        }\n        for (SortField sf : current) {\n          if (sf.getType() == SortField.Type.SCORE) {\n            sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n            modify = true;\n          }\n          sorts.add(sf);\n        }\n        if (modify) {\n          sortSpec.setSort(new Sort(sorts.toArray(new SortField[sorts.size()])));\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSort(new Sort(new SortField[]{\n            new SortField(\"_elevate_\", comparator, true),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      } else {\n        // Check if the sort is based on score\n        SortField[] current = sortSpec.getSort().getSort();\n        Sort modified = this.modifySort(current, force, comparator);\n        if(modified != null) {\n          sortSpec.setSort(modified);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSort(new Sort(new SortField[]{\n            new SortField(\"_elevate_\", comparator, true),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      } else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>(current.length + 1);\n        // Perhaps force it to always sort by score\n        if (force && current[0].getType() != SortField.Type.SCORE) {\n          sorts.add(new SortField(\"_elevate_\", comparator, true));\n          modify = true;\n        }\n        for (SortField sf : current) {\n          if (sf.getType() == SortField.Type.SCORE) {\n            sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n            modify = true;\n          }\n          sorts.add(sf);\n        }\n        if (modify) {\n          sortSpec.setSort(new Sort(sorts.toArray(new SortField[sorts.size()])));\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02453e8d9fe1bde22dc7676145ad809cb1dbfcad","date":1386084179,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSort(new Sort(new SortField[]{\n            new SortField(\"_elevate_\", comparator, true),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      } else {\n        // Check if the sort is based on score\n        SortField[] current = sortSpec.getSort().getSort();\n        Sort modified = this.modifySort(current, force, comparator);\n        if(modified != null) {\n          sortSpec.setSort(modified);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSort(new Sort(new SortField[]{\n            new SortField(\"_elevate_\", comparator, true),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      } else {\n        // Check if the sort is based on score\n        SortField[] current = sortSpec.getSort().getSort();\n        Sort modified = this.modifySort(current, force, comparator);\n        if(modified != null) {\n          sortSpec.setSort(modified);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70944c2a43908e32d54fb0ba4e51a9dad195b4e6","date":1389291298,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        String[] boosts = (boostStr != null) ? boostStr.split(\",\") : new String[0];\n        String[] excludes = (exStr != null) ? exStr.split(\",\") : new String[0];\n        booster = getElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap(reader, req.getCore()).get(qstr);\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d3aa69f7f5260249bbd9e947da205416eaf6f64","date":1391741283,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        String[] boosts = (boostStr != null) ? boostStr.split(\",\") : new String[0];\n        String[] excludes = (exStr != null) ? exStr.split(\",\") : new String[0];\n        booster = getElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7","date":1401992910,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"610ea64c35555f78954a3969b2df27aa3fd8343d","date":1413838070,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    String qstr = QueryElevationComponent.stripLocalParams(rb.getQueryString());\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["fe1ca67cfc99f55eaa3e9e1e00ed8be9a61c9959"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe1ca67cfc99f55eaa3e9e1e00ed8be9a61c9959","date":1413904387,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    String qstr = QueryElevationComponent.stripLocalParams(rb.getQueryString());\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":["610ea64c35555f78954a3969b2df27aa3fd8343d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.setDisableCoord(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq);\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dfdf766e55e943d942055d7de53c7ad6bc45283","date":1441632886,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.setDisableCoord(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.setDisableCoord(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(booster.include, BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8a0e442f7b61f811680273b25da95994a724466","date":1467878549,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.setDisableCoord(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.setDisableCoord(true);\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f20d97ebbd280405cebcc21d53c781bf4456453","date":1480454130,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortSpec groupSortSpec = groupingSpec.getGroupSortSpec();\n        SortSpec modGroupSortSpec = this.modifySortSpec(groupSortSpec, force, comparator);\n        if (modGroupSortSpec != null) {\n          groupingSpec.setGroupSortSpec(modGroupSortSpec);\n        }\n        SortSpec withinGroupSortSpec = groupingSpec.getSortSpecWithinGroup();\n        SortSpec modWithinGroupSortSpec = this.modifySortSpec(withinGroupSortSpec, force, comparator);\n        if (modWithinGroupSortSpec != null) {\n          groupingSpec.setSortSpecWithinGroup(modWithinGroupSortSpec);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b101c3c0e7f5871415e80d970cb3289309f3522e","date":1480511898,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortSpec groupSortSpec = groupingSpec.getGroupSortSpec();\n        SortSpec modGroupSortSpec = this.modifySortSpec(groupSortSpec, force, comparator);\n        if (modGroupSortSpec != null) {\n          groupingSpec.setGroupSortSpec(modGroupSortSpec);\n        }\n        SortSpec withinGroupSortSpec = groupingSpec.getSortSpecWithinGroup();\n        SortSpec modWithinGroupSortSpec = this.modifySortSpec(withinGroupSortSpec, force, comparator);\n        if (modWithinGroupSortSpec != null) {\n          groupingSpec.setSortSpecWithinGroup(modWithinGroupSortSpec);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortSpec groupSortSpec = groupingSpec.getGroupSortSpec();\n        SortSpec modGroupSortSpec = this.modifySortSpec(groupSortSpec, force, comparator);\n        if (modGroupSortSpec != null) {\n          groupingSpec.setGroupSortSpec(modGroupSortSpec);\n        }\n        SortSpec withinGroupSortSpec = groupingSpec.getSortSpecWithinGroup();\n        SortSpec modWithinGroupSortSpec = this.modifySortSpec(withinGroupSortSpec, force, comparator);\n        if (modWithinGroupSortSpec != null) {\n          groupingSpec.setSortSpecWithinGroup(modWithinGroupSortSpec);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortField[] groupSort = groupingSpec.getGroupSort().getSort();\n        Sort modGroupSort = this.modifySort(groupSort, force, comparator);\n        if(modGroupSort != null) {\n          groupingSpec.setGroupSort(modGroupSort);\n        }\n        SortField[] withinGroupSort = groupingSpec.getSortWithinGroup().getSort();\n        Sort modWithinGroupSort = this.modifySort(withinGroupSort, force, comparator);\n        if(modWithinGroupSort != null) {\n          groupingSpec.setSortWithinGroup(modWithinGroupSort);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe5f7e6793410fbed586cbf4066125df4b7b31d4","date":1482508865,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortSpec groupSortSpec = groupingSpec.getGroupSortSpec();\n        SortSpec modGroupSortSpec = this.modifySortSpec(groupSortSpec, force, comparator);\n        if (modGroupSortSpec != null) {\n          groupingSpec.setGroupSortSpec(modGroupSortSpec);\n        }\n        SortSpec withinGroupSortSpec = groupingSpec.getWithinGroupSortSpec();\n        SortSpec modWithinGroupSortSpec = this.modifySortSpec(withinGroupSortSpec, force, comparator);\n        if (modWithinGroupSortSpec != null) {\n          groupingSpec.setWithinGroupSortSpec(modWithinGroupSortSpec);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortSpec groupSortSpec = groupingSpec.getGroupSortSpec();\n        SortSpec modGroupSortSpec = this.modifySortSpec(groupSortSpec, force, comparator);\n        if (modGroupSortSpec != null) {\n          groupingSpec.setGroupSortSpec(modGroupSortSpec);\n        }\n        SortSpec withinGroupSortSpec = groupingSpec.getSortSpecWithinGroup();\n        SortSpec modWithinGroupSortSpec = this.modifySortSpec(withinGroupSortSpec, force, comparator);\n        if (modWithinGroupSortSpec != null) {\n          groupingSpec.setSortSpecWithinGroup(modWithinGroupSortSpec);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortSpec groupSortSpec = groupingSpec.getGroupSortSpec();\n        SortSpec modGroupSortSpec = this.modifySortSpec(groupSortSpec, force, comparator);\n        if (modGroupSortSpec != null) {\n          groupingSpec.setGroupSortSpec(modGroupSortSpec);\n        }\n        SortSpec withinGroupSortSpec = groupingSpec.getWithinGroupSortSpec();\n        SortSpec modWithinGroupSortSpec = this.modifySortSpec(withinGroupSortSpec, force, comparator);\n        if (modWithinGroupSortSpec != null) {\n          groupingSpec.setWithinGroupSortSpec(modWithinGroupSortSpec);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortSpec groupSortSpec = groupingSpec.getGroupSortSpec();\n        SortSpec modGroupSortSpec = this.modifySortSpec(groupSortSpec, force, comparator);\n        if (modGroupSortSpec != null) {\n          groupingSpec.setGroupSortSpec(modGroupSortSpec);\n        }\n        SortSpec withinGroupSortSpec = groupingSpec.getSortSpecWithinGroup();\n        SortSpec modWithinGroupSortSpec = this.modifySortSpec(withinGroupSortSpec, force, comparator);\n        if (modWithinGroupSortSpec != null) {\n          groupingSpec.setSortSpecWithinGroup(modWithinGroupSortSpec);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ad458affd82a1d762eb506003907d9363a333cb","date":1528558344,"type":3,"author":"broustant","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    if (!initialized || !rb.req.getParams().getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    Elevation elevation = getElevation(rb);\n    if (elevation != null) {\n      setQuery(rb, elevation);\n      setSort(rb, elevation);\n    }\n\n    if (rb.isDebug() && rb.isDebugQuery()) {\n      addDebugInfo(rb, elevation);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortSpec groupSortSpec = groupingSpec.getGroupSortSpec();\n        SortSpec modGroupSortSpec = this.modifySortSpec(groupSortSpec, force, comparator);\n        if (modGroupSortSpec != null) {\n          groupingSpec.setGroupSortSpec(modGroupSortSpec);\n        }\n        SortSpec withinGroupSortSpec = groupingSpec.getWithinGroupSortSpec();\n        SortSpec modWithinGroupSortSpec = this.modifySortSpec(withinGroupSortSpec, force, comparator);\n        if (modWithinGroupSortSpec != null) {\n          groupingSpec.setWithinGroupSortSpec(modWithinGroupSortSpec);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    if (!initialized || !rb.req.getParams().getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    Elevation elevation = getElevation(rb);\n    if (elevation != null) {\n      setQuery(rb, elevation);\n      setSort(rb, elevation);\n    }\n\n    if (rb.isDebug() && rb.isDebugQuery()) {\n      addDebugInfo(rb, elevation);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortSpec groupSortSpec = groupingSpec.getGroupSortSpec();\n        SortSpec modGroupSortSpec = this.modifySortSpec(groupSortSpec, force, comparator);\n        if (modGroupSortSpec != null) {\n          groupingSpec.setGroupSortSpec(modGroupSortSpec);\n        }\n        SortSpec withinGroupSortSpec = groupingSpec.getWithinGroupSortSpec();\n        SortSpec modWithinGroupSortSpec = this.modifySortSpec(withinGroupSortSpec, force, comparator);\n        if (modWithinGroupSortSpec != null) {\n          groupingSpec.setWithinGroupSortSpec(modWithinGroupSortSpec);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    if (!initialized || !rb.req.getParams().getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    Elevation elevation = getElevation(rb);\n    if (elevation != null) {\n      setQuery(rb, elevation);\n      setSort(rb, elevation);\n    }\n\n    if (rb.isDebug() && rb.isDebugQuery()) {\n      addDebugInfo(rb, elevation);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if (!params.getBool(QueryElevationParams.ENABLE, true)) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool(QueryElevationParams.FORCE_ELEVATION, forceElevation);\n    boolean markExcludes = params.getBool(QueryElevationParams.MARK_EXCLUDES, false);\n    String boostStr = params.get(QueryElevationParams.IDS);\n    String exStr = params.get(QueryElevationParams.EXCLUDE);\n\n    Query query = rb.getQuery();\n    SolrParams localParams = rb.getQparser().getLocalParams();\n    String qstr = localParams == null ? rb.getQueryString() : localParams.get(QueryParsing.V);\n    if (query == null || qstr == null) {\n      return;\n    }\n\n    ElevationObj booster = null;\n    try {\n      if(boostStr != null || exStr != null) {\n        List<String> boosts = (boostStr != null) ? StrUtils.splitSmart(boostStr,\",\", true) : new ArrayList<String>(0);\n        List<String> excludes = (exStr != null) ? StrUtils.splitSmart(exStr, \",\", true) : new ArrayList<String>(0);\n        booster = new ElevationObj(qstr, boosts, excludes);\n      } else {\n        IndexReader reader = req.getSearcher().getIndexReader();\n        qstr = getAnalyzedQuery(qstr);\n        booster = getElevationMap(reader, req.getCore()).get(qstr);\n      }\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex);\n    }\n\n    if (booster != null) {\n      rb.req.getContext().put(BOOSTED, booster.ids);\n      rb.req.getContext().put(BOOSTED_PRIORITY, booster.priority);\n\n      // Change the query to insert forced documents\n      if (exclusive == true) {\n        //we only want these results\n        rb.setQuery(new BoostQuery(booster.include, 0f));\n      } else {\n        BooleanQuery.Builder newq = new BooleanQuery.Builder();\n        newq.add(query, BooleanClause.Occur.SHOULD);\n        newq.add(new BoostQuery(booster.include, 0f), BooleanClause.Occur.SHOULD);\n        if (booster.exclude != null) {\n          if (markExcludes == false) {\n            for (TermQuery tq : booster.exclude) {\n              newq.add(new BooleanClause(tq, BooleanClause.Occur.MUST_NOT));\n            }\n          } else {\n            //we are only going to mark items as excluded, not actually exclude them.  This works\n            //with the EditorialMarkerFactory\n            rb.req.getContext().put(EXCLUDED, booster.excludeIds);\n          }\n        }\n        rb.setQuery(newq.build());\n      }\n\n      ElevationComparatorSource comparator = new ElevationComparatorSource(booster);\n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if (sortSpec.getSort() == null) {\n        sortSpec.setSortAndFields(new Sort(new SortField[]{\n              new SortField(\"_elevate_\", comparator, true),\n              new SortField(null, SortField.Type.SCORE, false)\n            }),\n          Arrays.asList(new SchemaField[2]));\n      } else {\n        // Check if the sort is based on score\n        SortSpec modSortSpec = this.modifySortSpec(sortSpec, force, comparator);\n        if (null != modSortSpec) {\n          rb.setSortSpec(modSortSpec);\n        }\n      }\n\n      // alter the sorting in the grouping specification if there is one\n      GroupingSpecification groupingSpec = rb.getGroupingSpec();\n      if(groupingSpec != null) {\n        SortSpec groupSortSpec = groupingSpec.getGroupSortSpec();\n        SortSpec modGroupSortSpec = this.modifySortSpec(groupSortSpec, force, comparator);\n        if (modGroupSortSpec != null) {\n          groupingSpec.setGroupSortSpec(modGroupSortSpec);\n        }\n        SortSpec withinGroupSortSpec = groupingSpec.getWithinGroupSortSpec();\n        SortSpec modWithinGroupSortSpec = this.modifySortSpec(withinGroupSortSpec, force, comparator);\n        if (modWithinGroupSortSpec != null) {\n          groupingSpec.setWithinGroupSortSpec(modWithinGroupSortSpec);\n        }\n      }\n    }\n\n    // Add debugging information\n    if (rb.isDebug()) {\n      List<String> match = null;\n      if (booster != null) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<>(booster.priority.size());\n        for (Object o : booster.include.clauses()) {\n          TermQuery tq = (TermQuery) ((BooleanClause) o).getQuery();\n          match.add(tq.getTerm().text());\n        }\n      }\n\n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<>();\n      dbg.add(\"q\", qstr);\n      dbg.add(\"match\", match);\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"1d0561cea94adff1867218e77bb763c7583be279":["fae06511695f4be0bce5337deb3b3f813d0c3e7c"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["fe1ca67cfc99f55eaa3e9e1e00ed8be9a61c9959"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["fe5f7e6793410fbed586cbf4066125df4b7b31d4","2ad458affd82a1d762eb506003907d9363a333cb"],"3fb0c241e2a5e80dcaf41e354c7003520fcb777d":["1d0561cea94adff1867218e77bb763c7583be279"],"02453e8d9fe1bde22dc7676145ad809cb1dbfcad":["1445434793334e26d7938862ae6f101e137de632"],"b101c3c0e7f5871415e80d970cb3289309f3522e":["c8a0e442f7b61f811680273b25da95994a724466","3f20d97ebbd280405cebcc21d53c781bf4456453"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2ad458affd82a1d762eb506003907d9363a333cb":["fe5f7e6793410fbed586cbf4066125df4b7b31d4"],"9856095f7afb5a607bf5e65077615ed91273508c":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","b101c3c0e7f5871415e80d970cb3289309f3522e"],"fae06511695f4be0bce5337deb3b3f813d0c3e7c":["b68df8b95f3ea758a8dc21cb20a50a01db973e8e"],"fe1ca67cfc99f55eaa3e9e1e00ed8be9a61c9959":["610ea64c35555f78954a3969b2df27aa3fd8343d"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["fe5f7e6793410fbed586cbf4066125df4b7b31d4","2ad458affd82a1d762eb506003907d9363a333cb"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["9d3aa69f7f5260249bbd9e947da205416eaf6f64"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["44c12811987af7a5dc1a8fa7d3ddf54399fdeb2a","1445434793334e26d7938862ae6f101e137de632"],"31d4861802ca404d78ca1d15f4550eec415b9199":["44c12811987af7a5dc1a8fa7d3ddf54399fdeb2a","1445434793334e26d7938862ae6f101e137de632"],"3f20d97ebbd280405cebcc21d53c781bf4456453":["c8a0e442f7b61f811680273b25da95994a724466"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"e1a45617f98e5cd25b73e9ae4ea69e0a0edacebe":["3fb0c241e2a5e80dcaf41e354c7003520fcb777d"],"fe5f7e6793410fbed586cbf4066125df4b7b31d4":["b101c3c0e7f5871415e80d970cb3289309f3522e"],"a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["2dfdf766e55e943d942055d7de53c7ad6bc45283","c8a0e442f7b61f811680273b25da95994a724466"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["9856095f7afb5a607bf5e65077615ed91273508c","fe5f7e6793410fbed586cbf4066125df4b7b31d4"],"610ea64c35555f78954a3969b2df27aa3fd8343d":["a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7"],"44c12811987af7a5dc1a8fa7d3ddf54399fdeb2a":["e1a45617f98e5cd25b73e9ae4ea69e0a0edacebe"],"b68df8b95f3ea758a8dc21cb20a50a01db973e8e":["c26f00b574427b55127e869b935845554afde1fa"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7","fe1ca67cfc99f55eaa3e9e1e00ed8be9a61c9959"],"1445434793334e26d7938862ae6f101e137de632":["44c12811987af7a5dc1a8fa7d3ddf54399fdeb2a"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9d3aa69f7f5260249bbd9e947da205416eaf6f64":["70944c2a43908e32d54fb0ba4e51a9dad195b4e6"],"70944c2a43908e32d54fb0ba4e51a9dad195b4e6":["02453e8d9fe1bde22dc7676145ad809cb1dbfcad"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["1445434793334e26d7938862ae6f101e137de632","02453e8d9fe1bde22dc7676145ad809cb1dbfcad"],"c8a0e442f7b61f811680273b25da95994a724466":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2ad458affd82a1d762eb506003907d9363a333cb"]},"commit2Childs":{"c26f00b574427b55127e869b935845554afde1fa":["b68df8b95f3ea758a8dc21cb20a50a01db973e8e"],"1d0561cea94adff1867218e77bb763c7583be279":["3fb0c241e2a5e80dcaf41e354c7003520fcb777d"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"3fb0c241e2a5e80dcaf41e354c7003520fcb777d":["e1a45617f98e5cd25b73e9ae4ea69e0a0edacebe"],"02453e8d9fe1bde22dc7676145ad809cb1dbfcad":["70944c2a43908e32d54fb0ba4e51a9dad195b4e6","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"b101c3c0e7f5871415e80d970cb3289309f3522e":["9856095f7afb5a607bf5e65077615ed91273508c","fe5f7e6793410fbed586cbf4066125df4b7b31d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"2ad458affd82a1d762eb506003907d9363a333cb":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9856095f7afb5a607bf5e65077615ed91273508c":["f03e4bed5023ec3ef93a771b8888cae991cf448d"],"fae06511695f4be0bce5337deb3b3f813d0c3e7c":["1d0561cea94adff1867218e77bb763c7583be279"],"fe1ca67cfc99f55eaa3e9e1e00ed8be9a61c9959":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"3f20d97ebbd280405cebcc21d53c781bf4456453":["b101c3c0e7f5871415e80d970cb3289309f3522e"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c8a0e442f7b61f811680273b25da95994a724466"],"e1a45617f98e5cd25b73e9ae4ea69e0a0edacebe":["44c12811987af7a5dc1a8fa7d3ddf54399fdeb2a"],"fe5f7e6793410fbed586cbf4066125df4b7b31d4":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","2ad458affd82a1d762eb506003907d9363a333cb","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7":["610ea64c35555f78954a3969b2df27aa3fd8343d","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9856095f7afb5a607bf5e65077615ed91273508c"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[],"b68df8b95f3ea758a8dc21cb20a50a01db973e8e":["fae06511695f4be0bce5337deb3b3f813d0c3e7c"],"610ea64c35555f78954a3969b2df27aa3fd8343d":["fe1ca67cfc99f55eaa3e9e1e00ed8be9a61c9959"],"44c12811987af7a5dc1a8fa7d3ddf54399fdeb2a":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","1445434793334e26d7938862ae6f101e137de632"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"1445434793334e26d7938862ae6f101e137de632":["02453e8d9fe1bde22dc7676145ad809cb1dbfcad","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"9d3aa69f7f5260249bbd9e947da205416eaf6f64":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"70944c2a43908e32d54fb0ba4e51a9dad195b4e6":["9d3aa69f7f5260249bbd9e947da205416eaf6f64"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"c8a0e442f7b61f811680273b25da95994a724466":["b101c3c0e7f5871415e80d970cb3289309f3522e","3f20d97ebbd280405cebcc21d53c781bf4456453","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","f03e4bed5023ec3ef93a771b8888cae991cf448d","0a22eafe3f72a4c2945eaad9547e6c78816978f4","74f45af4339b0daf7a95c820ab88c1aea74fbce0","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}