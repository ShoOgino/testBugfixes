{"path":"lucene/src/test-framework/java/org/apache/lucene/index/MultiNorms#norms(IndexReader,String).mjava","commits":[{"id":"f6e3376a314fcc2b31bc46d399c2ff23552b78d6","date":1325780477,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/index/MultiNorms#norms(IndexReader,String).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiNorms#norms(IndexReader,String).mjava","sourceNew":"  /**\n   * Warning: this is heavy! Do not use in a loop, or implement norms()\n   * in your own reader with this (you should likely cache the result).\n   */\n  public static byte[] norms(IndexReader r, String field) throws IOException {\n    final IndexReader[] subs = r.getSequentialSubReaders();\n    if (subs == null) {\n      // already an atomic reader\n      return r.norms(field);\n    } else if (subs.length == 0 || !r.hasNorms(field)) {\n      // no norms\n      return null;\n    } else if (subs.length == 1) {\n      return norms(subs[0], field);\n    } else {\n      // TODO: optimize more maybe\n      byte norms[] = new byte[r.maxDoc()];\n      final List<IndexReader> leaves = new ArrayList<IndexReader>();\n      ReaderUtil.gatherSubReaders(leaves, r);\n      int end = 0;\n      for (IndexReader leaf : leaves) {\n        Fields fields = leaf.fields();\n        boolean hasField = (fields != null && fields.terms(field) != null);\n        \n        int start = end;\n        byte leafNorms[] = leaf.norms(field);\n        if (leafNorms == null) {\n          if (hasField) { // omitted norms\n            return null;\n          }\n          // doesn't have field, fill bytes\n          leafNorms = new byte[leaf.maxDoc()];\n          Arrays.fill(leafNorms, (byte) 0);\n        }\n        \n        System.arraycopy(leafNorms, 0, norms, start, leafNorms.length);\n        end += leaf.maxDoc();\n      }\n      return norms;\n    }\n  }\n\n","sourceOld":"  /**\n   * Warning: this is heavy! Do not use in a loop, or implement norms()\n   * in your own reader with this (you should likely cache the result).\n   */\n  public static byte[] norms(IndexReader r, String field) throws IOException {\n    final IndexReader[] subs = r.getSequentialSubReaders();\n    if (subs == null) {\n      // already an atomic reader\n      return r.norms(field);\n    } else if (subs.length == 0 || !r.hasNorms(field)) {\n      // no norms\n      return null;\n    } else if (subs.length == 1) {\n      return norms(subs[0], field);\n    } else {\n      // TODO: optimize more maybe\n      byte norms[] = new byte[r.maxDoc()];\n      final List<IndexReader> leaves = new ArrayList<IndexReader>();\n      ReaderUtil.gatherSubReaders(leaves, r);\n      int end = 0;\n      for (IndexReader leaf : leaves) {\n        Fields fields = leaf.fields();\n        boolean hasField = (fields != null && fields.terms(field) != null);\n        \n        int start = end;\n        byte leafNorms[] = leaf.norms(field);\n        if (leafNorms == null) {\n          if (hasField) { // omitted norms\n            return null;\n          }\n          // doesn't have field, fill bytes\n          leafNorms = new byte[leaf.maxDoc()];\n          Arrays.fill(leafNorms, (byte) 0);\n        }\n        \n        System.arraycopy(leafNorms, 0, norms, start, leafNorms.length);\n        end += leaf.maxDoc();\n      }\n      return norms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4b223b56d0c7927ae8baced5e1b1dd4c693b1d","date":1325789720,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/MultiNorms#norms(IndexReader,String).mjava","sourceNew":null,"sourceOld":"  /**\n   * Warning: this is heavy! Do not use in a loop, or implement norms()\n   * in your own reader with this (you should likely cache the result).\n   */\n  public static byte[] norms(IndexReader r, String field) throws IOException {\n    final IndexReader[] subs = r.getSequentialSubReaders();\n    if (subs == null) {\n      // already an atomic reader\n      return r.norms(field);\n    } else if (subs.length == 0 || !r.hasNorms(field)) {\n      // no norms\n      return null;\n    } else if (subs.length == 1) {\n      return norms(subs[0], field);\n    } else {\n      // TODO: optimize more maybe\n      byte norms[] = new byte[r.maxDoc()];\n      final List<IndexReader> leaves = new ArrayList<IndexReader>();\n      ReaderUtil.gatherSubReaders(leaves, r);\n      int end = 0;\n      for (IndexReader leaf : leaves) {\n        Fields fields = leaf.fields();\n        boolean hasField = (fields != null && fields.terms(field) != null);\n        \n        int start = end;\n        byte leafNorms[] = leaf.norms(field);\n        if (leafNorms == null) {\n          if (hasField) { // omitted norms\n            return null;\n          }\n          // doesn't have field, fill bytes\n          leafNorms = new byte[leaf.maxDoc()];\n          Arrays.fill(leafNorms, (byte) 0);\n        }\n        \n        System.arraycopy(leafNorms, 0, norms, start, leafNorms.length);\n        end += leaf.maxDoc();\n      }\n      return norms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4b223b56d0c7927ae8baced5e1b1dd4c693b1d":["f6e3376a314fcc2b31bc46d399c2ff23552b78d6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f6e3376a314fcc2b31bc46d399c2ff23552b78d6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4b223b56d0c7927ae8baced5e1b1dd4c693b1d"]},"commit2Childs":{"0f4b223b56d0c7927ae8baced5e1b1dd4c693b1d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f6e3376a314fcc2b31bc46d399c2ff23552b78d6"],"f6e3376a314fcc2b31bc46d399c2ff23552b78d6":["0f4b223b56d0c7927ae8baced5e1b1dd4c693b1d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}