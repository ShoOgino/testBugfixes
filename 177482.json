{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean).mjava","commits":[{"id":"12df104910eced8075ef09fb442e2db6273d6741","date":1475520560,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,boolean,boolean).mjava","sourceNew":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.\n   * @param lbHttpSolrClientBuilder\n   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts,\n                          String chroot,\n                          HttpClient httpClient,\n                          LBHttpSolrClient lbSolrClient,\n                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,\n                          boolean updatesToLeaders,\n                          boolean directUpdatesToLeadersOnly) {\n    this.clientIsInternal = httpClient == null;\n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();\n    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = lbSolrClient;\n    this.zkHost = buildZkHostString(zkHosts, chroot);\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n  }\n\n","sourceOld":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrServer instance for requests.  If null, a default HttpClient will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts, String chroot, HttpClient httpClient, LBHttpSolrClient lbSolrClient,\n      boolean updatesToLeaders, boolean directUpdatesToLeadersOnly) {\n    this.zkHost = buildZkHostString(zkHosts, chroot);\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n    \n    this.clientIsInternal = httpClient == null;\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    \n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    this.lbClient = lbSolrClient == null ? createLBHttpSolrClient(myClient) : lbSolrClient;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bdbaebf25de77aae0fdc3b8b9873280b373032dc","date":1475524772,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean).mjava","sourceNew":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.\n   * @param lbHttpSolrClientBuilder\n   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts,\n                          String chroot,\n                          HttpClient httpClient,\n                          LBHttpSolrClient lbSolrClient,\n                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,\n                          boolean updatesToLeaders,\n                          boolean directUpdatesToLeadersOnly) {\n    this.zkHost = buildZkHostString(zkHosts, chroot);\n    this.clientIsInternal = httpClient == null;\n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();\n    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = lbSolrClient;\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n  }\n\n","sourceOld":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.\n   * @param lbHttpSolrClientBuilder\n   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts,\n                          String chroot,\n                          HttpClient httpClient,\n                          LBHttpSolrClient lbSolrClient,\n                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,\n                          boolean updatesToLeaders,\n                          boolean directUpdatesToLeadersOnly) {\n    this.clientIsInternal = httpClient == null;\n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();\n    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = lbSolrClient;\n    this.zkHost = buildZkHostString(zkHosts, chroot);\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.\n   * @param lbHttpSolrClientBuilder\n   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts,\n                          String chroot,\n                          HttpClient httpClient,\n                          LBHttpSolrClient lbSolrClient,\n                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,\n                          boolean updatesToLeaders,\n                          boolean directUpdatesToLeadersOnly) {\n    this.zkHost = buildZkHostString(zkHosts, chroot);\n    this.clientIsInternal = httpClient == null;\n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();\n    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = lbSolrClient;\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3eaeb36333664e8cb92108ef03f68a7b90beb759","date":1480015298,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean,ClusterStateProvider).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean).mjava","sourceNew":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.\n   * @param lbHttpSolrClientBuilder\n   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts,\n                          String chroot,\n                          HttpClient httpClient,\n                          LBHttpSolrClient lbSolrClient,\n                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,\n                          boolean updatesToLeaders,\n                          boolean directUpdatesToLeadersOnly,\n                          ClusterStateProvider stateProvider\n\n  ) {\n    if (stateProvider == null) {\n      this.stateProvider = new ZkClientClusterStateProvider(zkHosts, chroot);\n    } else {\n      this.stateProvider = stateProvider;\n    }\n    this.clientIsInternal = httpClient == null;\n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();\n    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = lbSolrClient;\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n  }\n\n","sourceOld":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.\n   * @param lbHttpSolrClientBuilder\n   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts,\n                          String chroot,\n                          HttpClient httpClient,\n                          LBHttpSolrClient lbSolrClient,\n                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,\n                          boolean updatesToLeaders,\n                          boolean directUpdatesToLeadersOnly) {\n    this.zkHost = buildZkHostString(zkHosts, chroot);\n    this.clientIsInternal = httpClient == null;\n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();\n    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = lbSolrClient;\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean,ClusterStateProvider).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean).mjava","sourceNew":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.\n   * @param lbHttpSolrClientBuilder\n   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts,\n                          String chroot,\n                          HttpClient httpClient,\n                          LBHttpSolrClient lbSolrClient,\n                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,\n                          boolean updatesToLeaders,\n                          boolean directUpdatesToLeadersOnly,\n                          ClusterStateProvider stateProvider\n\n  ) {\n    if (stateProvider == null) {\n      this.stateProvider = new ZkClientClusterStateProvider(zkHosts, chroot);\n    } else {\n      this.stateProvider = stateProvider;\n    }\n    this.clientIsInternal = httpClient == null;\n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();\n    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = lbSolrClient;\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n  }\n\n","sourceOld":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.\n   * @param lbHttpSolrClientBuilder\n   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts,\n                          String chroot,\n                          HttpClient httpClient,\n                          LBHttpSolrClient lbSolrClient,\n                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,\n                          boolean updatesToLeaders,\n                          boolean directUpdatesToLeadersOnly) {\n    this.zkHost = buildZkHostString(zkHosts, chroot);\n    this.clientIsInternal = httpClient == null;\n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();\n    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = lbSolrClient;\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bdbaebf25de77aae0fdc3b8b9873280b373032dc":["12df104910eced8075ef09fb442e2db6273d6741"],"727bb765ff2542275f6d31f67be18d7104bae148":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3eaeb36333664e8cb92108ef03f68a7b90beb759"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3eaeb36333664e8cb92108ef03f68a7b90beb759":["bdbaebf25de77aae0fdc3b8b9873280b373032dc"],"12df104910eced8075ef09fb442e2db6273d6741":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bdbaebf25de77aae0fdc3b8b9873280b373032dc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3eaeb36333664e8cb92108ef03f68a7b90beb759"]},"commit2Childs":{"bdbaebf25de77aae0fdc3b8b9873280b373032dc":["3eaeb36333664e8cb92108ef03f68a7b90beb759","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"727bb765ff2542275f6d31f67be18d7104bae148":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["12df104910eced8075ef09fb442e2db6273d6741","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"3eaeb36333664e8cb92108ef03f68a7b90beb759":["727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"12df104910eced8075ef09fb442e2db6273d6741":["bdbaebf25de77aae0fdc3b8b9873280b373032dc"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["727bb765ff2542275f6d31f67be18d7104bae148"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}