{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","commits":[{"id":"4be6b65a4bd628f9b1c1a8832622df34d6eba980","date":1394300189,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","pathOld":"/dev/null","sourceNew":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["3022960bd0a67a6f828074db6d078b29b254d1f5","e1ae7b855157931b62ac3e8d17966c323980f75d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","date":1394564625,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","pathOld":"/dev/null","sourceNew":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","sourceNew":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","sourceOld":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","bugFix":null,"bugIntro":["3022960bd0a67a6f828074db6d078b29b254d1f5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d3d365762604952e436b51980101dfc84cc1b3e","date":1396298116,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","sourceNew":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, StandardCharsets.UTF_8));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","sourceOld":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","bugFix":null,"bugIntro":["3022960bd0a67a6f828074db6d078b29b254d1f5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","sourceNew":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, StandardCharsets.UTF_8));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","sourceOld":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1ae7b855157931b62ac3e8d17966c323980f75d","date":1407744420,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","sourceNew":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, StandardCharsets.UTF_8));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","sourceOld":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, StandardCharsets.UTF_8));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","bugFix":["4be6b65a4bd628f9b1c1a8832622df34d6eba980"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf5f0a722ca79f92ea9e7ab1a7d803909655f0f8","date":1411625045,"type":3,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","sourceNew":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() || SolrRequest.METHOD.PUT == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = ((this.useMultiPartPost && SolrRequest.METHOD.POST == request.getMethod())\n              || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postOrPutParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              String fullQueryUrl = url + ClientUtils.toQueryString( queryParams, false );\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(fullQueryUrl) : new HttpPut(fullQueryUrl);\n              if (!isMultipart) {\n                postOrPut.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postOrPutParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                postOrPut.setEntity(entity);\n              } else {\n                //not using multipart\n                postOrPut.setEntity(new UrlEncodedFormEntity(postOrPutParams, StandardCharsets.UTF_8));\n              }\n\n              method = postOrPut;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(url + pstr) : new HttpPut(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = postOrPut;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","sourceOld":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, StandardCharsets.UTF_8));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","bugFix":null,"bugIntro":["3022960bd0a67a6f828074db6d078b29b254d1f5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6122889c0d9dbc6211cd4ab44633264fb906e74d","date":1411769054,"type":3,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","sourceNew":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() || SolrRequest.METHOD.PUT == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = ((this.useMultiPartPost && SolrRequest.METHOD.POST == request.getMethod())\n              || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            // send server list and request list as query string params\n            ModifiableSolrParams queryParams = calculateQueryParams(this.queryParams, wparams);\n            queryParams.add(calculateQueryParams(request.getQueryParams(), wparams));\n\n            LinkedList<NameValuePair> postOrPutParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              String fullQueryUrl = url + ClientUtils.toQueryString( queryParams, false );\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(fullQueryUrl) : new HttpPut(fullQueryUrl);\n              if (!isMultipart) {\n                postOrPut.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postOrPutParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                postOrPut.setEntity(entity);\n              } else {\n                //not using multipart\n                postOrPut.setEntity(new UrlEncodedFormEntity(postOrPutParams, StandardCharsets.UTF_8));\n              }\n\n              method = postOrPut;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(url + pstr) : new HttpPut(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = postOrPut;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","sourceOld":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() || SolrRequest.METHOD.PUT == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = ((this.useMultiPartPost && SolrRequest.METHOD.POST == request.getMethod())\n              || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postOrPutParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              String fullQueryUrl = url + ClientUtils.toQueryString( queryParams, false );\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(fullQueryUrl) : new HttpPut(fullQueryUrl);\n              if (!isMultipart) {\n                postOrPut.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postOrPutParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                postOrPut.setEntity(entity);\n              } else {\n                //not using multipart\n                postOrPut.setEntity(new UrlEncodedFormEntity(postOrPutParams, StandardCharsets.UTF_8));\n              }\n\n              method = postOrPut;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(url + pstr) : new HttpPut(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = postOrPut;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","bugFix":null,"bugIntro":["c2cb68c00dbca95047d023c1885c85ffc344a53d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a4f5b5d0516cf5176e9577e3adaeda6803f3b76e","date":1411813593,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","sourceNew":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() || SolrRequest.METHOD.PUT == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = ((this.useMultiPartPost && SolrRequest.METHOD.POST == request.getMethod())\n              || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            // send server list and request list as query string params\n            ModifiableSolrParams queryParams = calculateQueryParams(this.queryParams, wparams);\n            queryParams.add(calculateQueryParams(request.getQueryParams(), wparams));\n\n            LinkedList<NameValuePair> postOrPutParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              String fullQueryUrl = url + ClientUtils.toQueryString( queryParams, false );\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(fullQueryUrl) : new HttpPut(fullQueryUrl);\n              if (!isMultipart) {\n                postOrPut.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postOrPutParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                postOrPut.setEntity(entity);\n              } else {\n                //not using multipart\n                postOrPut.setEntity(new UrlEncodedFormEntity(postOrPutParams, StandardCharsets.UTF_8));\n              }\n\n              method = postOrPut;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(url + pstr) : new HttpPut(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = postOrPut;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","sourceOld":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() || SolrRequest.METHOD.PUT == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = ((this.useMultiPartPost && SolrRequest.METHOD.POST == request.getMethod())\n              || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postOrPutParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              String fullQueryUrl = url + ClientUtils.toQueryString( queryParams, false );\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(fullQueryUrl) : new HttpPut(fullQueryUrl);\n              if (!isMultipart) {\n                postOrPut.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postOrPutParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                postOrPut.setEntity(entity);\n              } else {\n                //not using multipart\n                postOrPut.setEntity(new UrlEncodedFormEntity(postOrPutParams, StandardCharsets.UTF_8));\n              }\n\n              method = postOrPut;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(url + pstr) : new HttpPut(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = postOrPut;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c2cb68c00dbca95047d023c1885c85ffc344a53d","date":1412884832,"type":3,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","sourceNew":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() || SolrRequest.METHOD.PUT == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = ((this.useMultiPartPost && SolrRequest.METHOD.POST == request.getMethod())\n              || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            LinkedList<NameValuePair> postOrPutParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              // send server list and request list as query string params\n              ModifiableSolrParams queryParams = calculateQueryParams(this.queryParams, wparams);\n              queryParams.add(calculateQueryParams(request.getQueryParams(), wparams));\n              String fullQueryUrl = url + ClientUtils.toQueryString( queryParams, false );\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(fullQueryUrl) : new HttpPut(fullQueryUrl);\n              if (!isMultipart) {\n                postOrPut.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postOrPutParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                postOrPut.setEntity(entity);\n              } else {\n                //not using multipart\n                postOrPut.setEntity(new UrlEncodedFormEntity(postOrPutParams, StandardCharsets.UTF_8));\n              }\n\n              method = postOrPut;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(url + pstr) : new HttpPut(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = postOrPut;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","sourceOld":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() || SolrRequest.METHOD.PUT == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = ((this.useMultiPartPost && SolrRequest.METHOD.POST == request.getMethod())\n              || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            // send server list and request list as query string params\n            ModifiableSolrParams queryParams = calculateQueryParams(this.queryParams, wparams);\n            queryParams.add(calculateQueryParams(request.getQueryParams(), wparams));\n\n            LinkedList<NameValuePair> postOrPutParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              String fullQueryUrl = url + ClientUtils.toQueryString( queryParams, false );\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(fullQueryUrl) : new HttpPut(fullQueryUrl);\n              if (!isMultipart) {\n                postOrPut.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postOrPutParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                postOrPut.setEntity(entity);\n              } else {\n                //not using multipart\n                postOrPut.setEntity(new UrlEncodedFormEntity(postOrPutParams, StandardCharsets.UTF_8));\n              }\n\n              method = postOrPut;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(url + pstr) : new HttpPut(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = postOrPut;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","bugFix":["6122889c0d9dbc6211cd4ab44633264fb906e74d"],"bugIntro":["3022960bd0a67a6f828074db6d078b29b254d1f5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","sourceNew":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() || SolrRequest.METHOD.PUT == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = ((this.useMultiPartPost && SolrRequest.METHOD.POST == request.getMethod())\n              || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            LinkedList<NameValuePair> postOrPutParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              // send server list and request list as query string params\n              ModifiableSolrParams queryParams = calculateQueryParams(this.queryParams, wparams);\n              queryParams.add(calculateQueryParams(request.getQueryParams(), wparams));\n              String fullQueryUrl = url + ClientUtils.toQueryString( queryParams, false );\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(fullQueryUrl) : new HttpPut(fullQueryUrl);\n              if (!isMultipart) {\n                postOrPut.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postOrPutParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                postOrPut.setEntity(entity);\n              } else {\n                //not using multipart\n                postOrPut.setEntity(new UrlEncodedFormEntity(postOrPutParams, StandardCharsets.UTF_8));\n              }\n\n              method = postOrPut;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(url + pstr) : new HttpPut(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = postOrPut;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","sourceOld":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() || SolrRequest.METHOD.PUT == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = ((this.useMultiPartPost && SolrRequest.METHOD.POST == request.getMethod())\n              || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            // send server list and request list as query string params\n            ModifiableSolrParams queryParams = calculateQueryParams(this.queryParams, wparams);\n            queryParams.add(calculateQueryParams(request.getQueryParams(), wparams));\n\n            LinkedList<NameValuePair> postOrPutParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              String fullQueryUrl = url + ClientUtils.toQueryString( queryParams, false );\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(fullQueryUrl) : new HttpPut(fullQueryUrl);\n              if (!isMultipart) {\n                postOrPut.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postOrPutParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                postOrPut.setEntity(entity);\n              } else {\n                //not using multipart\n                postOrPut.setEntity(new UrlEncodedFormEntity(postOrPutParams, StandardCharsets.UTF_8));\n              }\n\n              method = postOrPut;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(url + pstr) : new HttpPut(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = postOrPut;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient#createMethod(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#createMethod(SolrRequest).mjava","sourceNew":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() || SolrRequest.METHOD.PUT == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = ((this.useMultiPartPost && SolrRequest.METHOD.POST == request.getMethod())\n              || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            LinkedList<NameValuePair> postOrPutParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              // send server list and request list as query string params\n              ModifiableSolrParams queryParams = calculateQueryParams(this.queryParams, wparams);\n              queryParams.add(calculateQueryParams(request.getQueryParams(), wparams));\n              String fullQueryUrl = url + ClientUtils.toQueryString( queryParams, false );\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(fullQueryUrl) : new HttpPut(fullQueryUrl);\n              if (!isMultipart) {\n                postOrPut.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postOrPutParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                postOrPut.setEntity(entity);\n              } else {\n                //not using multipart\n                postOrPut.setEntity(new UrlEncodedFormEntity(postOrPutParams, StandardCharsets.UTF_8));\n              }\n\n              method = postOrPut;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(url + pstr) : new HttpPut(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = postOrPut;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","sourceOld":"  protected HttpRequestBase createMethod(final SolrRequest request) throws IOException, SolrServerException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() || SolrRequest.METHOD.PUT == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = ((this.useMultiPartPost && SolrRequest.METHOD.POST == request.getMethod())\n              || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            LinkedList<NameValuePair> postOrPutParams = new LinkedList<>();\n            if (streams == null || isMultipart) {\n              // send server list and request list as query string params\n              ModifiableSolrParams queryParams = calculateQueryParams(this.queryParams, wparams);\n              queryParams.add(calculateQueryParams(request.getQueryParams(), wparams));\n              String fullQueryUrl = url + ClientUtils.toQueryString( queryParams, false );\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(fullQueryUrl) : new HttpPut(fullQueryUrl);\n              if (!isMultipart) {\n                postOrPut.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, StandardCharsets.UTF_8)));\n                    } else {\n                      postOrPutParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                postOrPut.setEntity(entity);\n              } else {\n                //not using multipart\n                postOrPut.setEntity(new UrlEncodedFormEntity(postOrPutParams, StandardCharsets.UTF_8));\n              }\n\n              method = postOrPut;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpEntityEnclosingRequestBase postOrPut = SolrRequest.METHOD.POST == request.getMethod() ?\n                new HttpPost(url + pstr) : new HttpPut(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                postOrPut.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = postOrPut;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    return method;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","9d3d365762604952e436b51980101dfc84cc1b3e"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["4be6b65a4bd628f9b1c1a8832622df34d6eba980"],"55980207f1977bd1463465de1659b821347e2fa8":["a4f5b5d0516cf5176e9577e3adaeda6803f3b76e","c2cb68c00dbca95047d023c1885c85ffc344a53d"],"a58bbbe1c866963764d3f15d3a26a6a85f6c6af4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4be6b65a4bd628f9b1c1a8832622df34d6eba980"],"cf5f0a722ca79f92ea9e7ab1a7d803909655f0f8":["e1ae7b855157931b62ac3e8d17966c323980f75d"],"bafca15d8e408346a67f4282ad1143b88023893b":["c2cb68c00dbca95047d023c1885c85ffc344a53d"],"c2cb68c00dbca95047d023c1885c85ffc344a53d":["6122889c0d9dbc6211cd4ab44633264fb906e74d"],"6122889c0d9dbc6211cd4ab44633264fb906e74d":["cf5f0a722ca79f92ea9e7ab1a7d803909655f0f8"],"4be6b65a4bd628f9b1c1a8832622df34d6eba980":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a4f5b5d0516cf5176e9577e3adaeda6803f3b76e":["cf5f0a722ca79f92ea9e7ab1a7d803909655f0f8","6122889c0d9dbc6211cd4ab44633264fb906e74d"],"e1ae7b855157931b62ac3e8d17966c323980f75d":["9d3d365762604952e436b51980101dfc84cc1b3e"],"9d3d365762604952e436b51980101dfc84cc1b3e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bafca15d8e408346a67f4282ad1143b88023893b"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5eb2511ababf862ea11e10761c70ee560cd84510","9d3d365762604952e436b51980101dfc84cc1b3e"],"55980207f1977bd1463465de1659b821347e2fa8":[],"a58bbbe1c866963764d3f15d3a26a6a85f6c6af4":[],"cf5f0a722ca79f92ea9e7ab1a7d803909655f0f8":["6122889c0d9dbc6211cd4ab44633264fb906e74d","a4f5b5d0516cf5176e9577e3adaeda6803f3b76e"],"4be6b65a4bd628f9b1c1a8832622df34d6eba980":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","a58bbbe1c866963764d3f15d3a26a6a85f6c6af4"],"c2cb68c00dbca95047d023c1885c85ffc344a53d":["55980207f1977bd1463465de1659b821347e2fa8","bafca15d8e408346a67f4282ad1143b88023893b"],"bafca15d8e408346a67f4282ad1143b88023893b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6122889c0d9dbc6211cd4ab44633264fb906e74d":["c2cb68c00dbca95047d023c1885c85ffc344a53d","a4f5b5d0516cf5176e9577e3adaeda6803f3b76e"],"a4f5b5d0516cf5176e9577e3adaeda6803f3b76e":["55980207f1977bd1463465de1659b821347e2fa8"],"e1ae7b855157931b62ac3e8d17966c323980f75d":["cf5f0a722ca79f92ea9e7ab1a7d803909655f0f8"],"9d3d365762604952e436b51980101dfc84cc1b3e":["5eb2511ababf862ea11e10761c70ee560cd84510","e1ae7b855157931b62ac3e8d17966c323980f75d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","4be6b65a4bd628f9b1c1a8832622df34d6eba980"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","55980207f1977bd1463465de1659b821347e2fa8","a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}