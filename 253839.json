{"path":"modules/facet/src/java/org/apache/lucene/facet/search/TopKFacetResultsHandler#heapDescendants(int,Heap[FacetResultNode],MutableFacetResultNode,FacetArrays,int).mjava","commits":[{"id":"89f15687f60bd49cd3d9de427e85c17fd9397d61","date":1309381327,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/search/TopKFacetResultsHandler#heapDescendants(int,Heap[FacetResultNode],MutableFacetResultNode,FacetArrays,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Finds the top K descendants of ordinal, which are at most facetRequest.getDepth()\n   * deeper than facetRequest.getCategoryPath (whose ordinal is input parameter ordinal). \n   * Candidates are restricted to current \"counting list\" and current \"partition\",\n   * they join the overall priority queue pq of size K.  \n   * @return total number of descendants considered here by pq, excluding ordinal itself.\n   */\n  private int heapDescendants(int ordinal, Heap<FacetResultNode> pq,\n      MutableFacetResultNode parentResultNode, FacetArrays facetArrays, int offset) {\n    int partitionSize = facetArrays.getArraysLength();\n    int endOffset = offset + partitionSize;\n    ChildrenArrays childrenArray = taxonomyReader.getChildrenArrays();\n    int[] youngestChild = childrenArray.getYoungestChildArray();\n    int[] olderSibling = childrenArray.getOlderSiblingArray();\n    FacetResultNode reusable = null;\n    int localDepth = 0;\n    int depth = facetRequest.getDepth();\n    int[] ordinalStack = new int[2+Math.min(Short.MAX_VALUE, depth)];\n    int childrenCounter = 0;\n    \n    int tosOrdinal; // top of stack element\n    \n    int yc = youngestChild[ordinal];\n    while (yc >= endOffset) {\n      yc = olderSibling[yc];\n    }\n    // make use of the fact that TaxonomyReader.INVALID_ORDINAL == -1, < endOffset\n    // and it, too, can stop the loop.\n    ordinalStack[++localDepth] = yc;\n    \n    /*\n     * stack holds input parameter ordinal in position 0.\n     * Other elements are < endoffset.\n     * Only top of stack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if\n     * the element below it exhausted all its children: has them all processed.\n     * \n     * stack elements are processed (counted and accumulated) only if they \n     * belong to current partition (between offset and endoffset) and first time\n     * they are on top of stack \n     * \n     * loop as long as stack is not empty of elements other than input ordinal, or for a little while -- it sibling\n     */\n    while (localDepth > 0) {\n      tosOrdinal = ordinalStack[localDepth];\n      if (tosOrdinal == TaxonomyReader.INVALID_ORDINAL) {\n        // element below tos has all its children, and itself, all processed\n        // need to proceed to its sibling\n        localDepth--;\n        // change element now on top of stack to its sibling.\n        ordinalStack[localDepth] = olderSibling[ordinalStack[localDepth]];\n        continue;\n      }\n      // top of stack is not invalid, this is the first time we see it on top of stack.\n      // collect it, if belongs to current partition, and then push its kids on itself, if applicable\n      if (tosOrdinal >= offset) { // tosOrdinal resides in current partition\n        int relativeOrdinal = tosOrdinal % partitionSize;\n        double value = facetRequest.getValueOf(facetArrays, relativeOrdinal);\n        if (value != 0 && !Double.isNaN(value)) {\n          // Count current ordinal -- the TOS\n          if (reusable == null) {\n            reusable = new MutableFacetResultNode(tosOrdinal, value);\n          } else {\n            // it is safe to cast since reusable was created here.\n            ((MutableFacetResultNode)reusable).reset(tosOrdinal, value);\n          }\n          ++childrenCounter;\n          reusable = pq.insertWithOverflow(reusable);\n          if (reusable != null) {\n            // TODO (Facet): is other logic (not add) needed, per aggregator?\n            parentResultNode.increaseResidue(reusable.getValue());\n          }\n        }\n      }\n      if (localDepth < depth) {\n        // push kid of current tos\n        yc = youngestChild[tosOrdinal];\n        while (yc >= endOffset) {\n          yc = olderSibling[yc];\n        }\n        ordinalStack[++localDepth] = yc;\n      } else { // localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL\n        ordinalStack[++localDepth] = TaxonomyReader.INVALID_ORDINAL;\n      }\n    } // endof while stack is not empty\n    \n    return childrenCounter; // we're done\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/search/TopKFacetResultsHandler#heapDescendants(int,Heap[FacetResultNode],MutableFacetResultNode,FacetArrays,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Finds the top K descendants of ordinal, which are at most facetRequest.getDepth()\n   * deeper than facetRequest.getCategoryPath (whose ordinal is input parameter ordinal). \n   * Candidates are restricted to current \"counting list\" and current \"partition\",\n   * they join the overall priority queue pq of size K.  \n   * @return total number of descendants considered here by pq, excluding ordinal itself.\n   */\n  private int heapDescendants(int ordinal, Heap<FacetResultNode> pq,\n      MutableFacetResultNode parentResultNode, FacetArrays facetArrays, int offset) {\n    int partitionSize = facetArrays.getArraysLength();\n    int endOffset = offset + partitionSize;\n    ChildrenArrays childrenArray = taxonomyReader.getChildrenArrays();\n    int[] youngestChild = childrenArray.getYoungestChildArray();\n    int[] olderSibling = childrenArray.getOlderSiblingArray();\n    FacetResultNode reusable = null;\n    int localDepth = 0;\n    int depth = facetRequest.getDepth();\n    int[] ordinalStack = new int[2+Math.min(Short.MAX_VALUE, depth)];\n    int childrenCounter = 0;\n    \n    int tosOrdinal; // top of stack element\n    \n    int yc = youngestChild[ordinal];\n    while (yc >= endOffset) {\n      yc = olderSibling[yc];\n    }\n    // make use of the fact that TaxonomyReader.INVALID_ORDINAL == -1, < endOffset\n    // and it, too, can stop the loop.\n    ordinalStack[++localDepth] = yc;\n    \n    /*\n     * stack holds input parameter ordinal in position 0.\n     * Other elements are < endoffset.\n     * Only top of stack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if\n     * the element below it exhausted all its children: has them all processed.\n     * \n     * stack elements are processed (counted and accumulated) only if they \n     * belong to current partition (between offset and endoffset) and first time\n     * they are on top of stack \n     * \n     * loop as long as stack is not empty of elements other than input ordinal, or for a little while -- it sibling\n     */\n    while (localDepth > 0) {\n      tosOrdinal = ordinalStack[localDepth];\n      if (tosOrdinal == TaxonomyReader.INVALID_ORDINAL) {\n        // element below tos has all its children, and itself, all processed\n        // need to proceed to its sibling\n        localDepth--;\n        // change element now on top of stack to its sibling.\n        ordinalStack[localDepth] = olderSibling[ordinalStack[localDepth]];\n        continue;\n      }\n      // top of stack is not invalid, this is the first time we see it on top of stack.\n      // collect it, if belongs to current partition, and then push its kids on itself, if applicable\n      if (tosOrdinal >= offset) { // tosOrdinal resides in current partition\n        int relativeOrdinal = tosOrdinal % partitionSize;\n        double value = facetRequest.getValueOf(facetArrays, relativeOrdinal);\n        if (value != 0 && !Double.isNaN(value)) {\n          // Count current ordinal -- the TOS\n          if (reusable == null) {\n            reusable = new MutableFacetResultNode(tosOrdinal, value);\n          } else {\n            // it is safe to cast since reusable was created here.\n            ((MutableFacetResultNode)reusable).reset(tosOrdinal, value);\n          }\n          ++childrenCounter;\n          reusable = pq.insertWithOverflow(reusable);\n          if (reusable != null) {\n            // TODO (Facet): is other logic (not add) needed, per aggregator?\n            parentResultNode.increaseResidue(reusable.getValue());\n          }\n        }\n      }\n      if (localDepth < depth) {\n        // push kid of current tos\n        yc = youngestChild[tosOrdinal];\n        while (yc >= endOffset) {\n          yc = olderSibling[yc];\n        }\n        ordinalStack[++localDepth] = yc;\n      } else { // localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL\n        ordinalStack[++localDepth] = TaxonomyReader.INVALID_ORDINAL;\n      }\n    } // endof while stack is not empty\n    \n    return childrenCounter; // we're done\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/search/TopKFacetResultsHandler#heapDescendants(int,Heap[FacetResultNode],MutableFacetResultNode,FacetArrays,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Finds the top K descendants of ordinal, which are at most facetRequest.getDepth()\n   * deeper than facetRequest.getCategoryPath (whose ordinal is input parameter ordinal). \n   * Candidates are restricted to current \"counting list\" and current \"partition\",\n   * they join the overall priority queue pq of size K.  \n   * @return total number of descendants considered here by pq, excluding ordinal itself.\n   */\n  private int heapDescendants(int ordinal, Heap<FacetResultNode> pq,\n      MutableFacetResultNode parentResultNode, FacetArrays facetArrays, int offset) {\n    int partitionSize = facetArrays.getArraysLength();\n    int endOffset = offset + partitionSize;\n    ChildrenArrays childrenArray = taxonomyReader.getChildrenArrays();\n    int[] youngestChild = childrenArray.getYoungestChildArray();\n    int[] olderSibling = childrenArray.getOlderSiblingArray();\n    FacetResultNode reusable = null;\n    int localDepth = 0;\n    int depth = facetRequest.getDepth();\n    int[] ordinalStack = new int[2+Math.min(Short.MAX_VALUE, depth)];\n    int childrenCounter = 0;\n    \n    int tosOrdinal; // top of stack element\n    \n    int yc = youngestChild[ordinal];\n    while (yc >= endOffset) {\n      yc = olderSibling[yc];\n    }\n    // make use of the fact that TaxonomyReader.INVALID_ORDINAL == -1, < endOffset\n    // and it, too, can stop the loop.\n    ordinalStack[++localDepth] = yc;\n    \n    /*\n     * stack holds input parameter ordinal in position 0.\n     * Other elements are < endoffset.\n     * Only top of stack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if\n     * the element below it exhausted all its children: has them all processed.\n     * \n     * stack elements are processed (counted and accumulated) only if they \n     * belong to current partition (between offset and endoffset) and first time\n     * they are on top of stack \n     * \n     * loop as long as stack is not empty of elements other than input ordinal, or for a little while -- it sibling\n     */\n    while (localDepth > 0) {\n      tosOrdinal = ordinalStack[localDepth];\n      if (tosOrdinal == TaxonomyReader.INVALID_ORDINAL) {\n        // element below tos has all its children, and itself, all processed\n        // need to proceed to its sibling\n        localDepth--;\n        // change element now on top of stack to its sibling.\n        ordinalStack[localDepth] = olderSibling[ordinalStack[localDepth]];\n        continue;\n      }\n      // top of stack is not invalid, this is the first time we see it on top of stack.\n      // collect it, if belongs to current partition, and then push its kids on itself, if applicable\n      if (tosOrdinal >= offset) { // tosOrdinal resides in current partition\n        int relativeOrdinal = tosOrdinal % partitionSize;\n        double value = facetRequest.getValueOf(facetArrays, relativeOrdinal);\n        if (value != 0 && !Double.isNaN(value)) {\n          // Count current ordinal -- the TOS\n          if (reusable == null) {\n            reusable = new MutableFacetResultNode(tosOrdinal, value);\n          } else {\n            // it is safe to cast since reusable was created here.\n            ((MutableFacetResultNode)reusable).reset(tosOrdinal, value);\n          }\n          ++childrenCounter;\n          reusable = pq.insertWithOverflow(reusable);\n          if (reusable != null) {\n            // TODO (Facet): is other logic (not add) needed, per aggregator?\n            parentResultNode.increaseResidue(reusable.getValue());\n          }\n        }\n      }\n      if (localDepth < depth) {\n        // push kid of current tos\n        yc = youngestChild[tosOrdinal];\n        while (yc >= endOffset) {\n          yc = olderSibling[yc];\n        }\n        ordinalStack[++localDepth] = yc;\n      } else { // localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL\n        ordinalStack[++localDepth] = TaxonomyReader.INVALID_ORDINAL;\n      }\n    } // endof while stack is not empty\n    \n    return childrenCounter; // we're done\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKFacetResultsHandler#heapDescendants(int,Heap[FacetResultNode],MutableFacetResultNode,FacetArrays,int).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/search/TopKFacetResultsHandler#heapDescendants(int,Heap[FacetResultNode],MutableFacetResultNode,FacetArrays,int).mjava","sourceNew":"  /**\n   * Finds the top K descendants of ordinal, which are at most facetRequest.getDepth()\n   * deeper than facetRequest.getCategoryPath (whose ordinal is input parameter ordinal). \n   * Candidates are restricted to current \"counting list\" and current \"partition\",\n   * they join the overall priority queue pq of size K.  \n   * @return total number of descendants considered here by pq, excluding ordinal itself.\n   */\n  private int heapDescendants(int ordinal, Heap<FacetResultNode> pq,\n      MutableFacetResultNode parentResultNode, FacetArrays facetArrays, int offset) {\n    int partitionSize = facetArrays.getArraysLength();\n    int endOffset = offset + partitionSize;\n    ChildrenArrays childrenArray = taxonomyReader.getChildrenArrays();\n    int[] youngestChild = childrenArray.getYoungestChildArray();\n    int[] olderSibling = childrenArray.getOlderSiblingArray();\n    FacetResultNode reusable = null;\n    int localDepth = 0;\n    int depth = facetRequest.getDepth();\n    int[] ordinalStack = new int[2+Math.min(Short.MAX_VALUE, depth)];\n    int childrenCounter = 0;\n    \n    int tosOrdinal; // top of stack element\n    \n    int yc = youngestChild[ordinal];\n    while (yc >= endOffset) {\n      yc = olderSibling[yc];\n    }\n    // make use of the fact that TaxonomyReader.INVALID_ORDINAL == -1, < endOffset\n    // and it, too, can stop the loop.\n    ordinalStack[++localDepth] = yc;\n    \n    /*\n     * stack holds input parameter ordinal in position 0.\n     * Other elements are < endoffset.\n     * Only top of stack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if\n     * the element below it exhausted all its children: has them all processed.\n     * \n     * stack elements are processed (counted and accumulated) only if they \n     * belong to current partition (between offset and endoffset) and first time\n     * they are on top of stack \n     * \n     * loop as long as stack is not empty of elements other than input ordinal, or for a little while -- it sibling\n     */\n    while (localDepth > 0) {\n      tosOrdinal = ordinalStack[localDepth];\n      if (tosOrdinal == TaxonomyReader.INVALID_ORDINAL) {\n        // element below tos has all its children, and itself, all processed\n        // need to proceed to its sibling\n        localDepth--;\n        // change element now on top of stack to its sibling.\n        ordinalStack[localDepth] = olderSibling[ordinalStack[localDepth]];\n        continue;\n      }\n      // top of stack is not invalid, this is the first time we see it on top of stack.\n      // collect it, if belongs to current partition, and then push its kids on itself, if applicable\n      if (tosOrdinal >= offset) { // tosOrdinal resides in current partition\n        int relativeOrdinal = tosOrdinal % partitionSize;\n        double value = facetRequest.getValueOf(facetArrays, relativeOrdinal);\n        if (value != 0 && !Double.isNaN(value)) {\n          // Count current ordinal -- the TOS\n          if (reusable == null) {\n            reusable = new MutableFacetResultNode(tosOrdinal, value);\n          } else {\n            // it is safe to cast since reusable was created here.\n            ((MutableFacetResultNode)reusable).reset(tosOrdinal, value);\n          }\n          ++childrenCounter;\n          reusable = pq.insertWithOverflow(reusable);\n          if (reusable != null) {\n            // TODO (Facet): is other logic (not add) needed, per aggregator?\n            parentResultNode.increaseResidue(reusable.getValue());\n          }\n        }\n      }\n      if (localDepth < depth) {\n        // push kid of current tos\n        yc = youngestChild[tosOrdinal];\n        while (yc >= endOffset) {\n          yc = olderSibling[yc];\n        }\n        ordinalStack[++localDepth] = yc;\n      } else { // localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL\n        ordinalStack[++localDepth] = TaxonomyReader.INVALID_ORDINAL;\n      }\n    } // endof while stack is not empty\n    \n    return childrenCounter; // we're done\n  }\n\n","sourceOld":"  /**\n   * Finds the top K descendants of ordinal, which are at most facetRequest.getDepth()\n   * deeper than facetRequest.getCategoryPath (whose ordinal is input parameter ordinal). \n   * Candidates are restricted to current \"counting list\" and current \"partition\",\n   * they join the overall priority queue pq of size K.  \n   * @return total number of descendants considered here by pq, excluding ordinal itself.\n   */\n  private int heapDescendants(int ordinal, Heap<FacetResultNode> pq,\n      MutableFacetResultNode parentResultNode, FacetArrays facetArrays, int offset) {\n    int partitionSize = facetArrays.getArraysLength();\n    int endOffset = offset + partitionSize;\n    ChildrenArrays childrenArray = taxonomyReader.getChildrenArrays();\n    int[] youngestChild = childrenArray.getYoungestChildArray();\n    int[] olderSibling = childrenArray.getOlderSiblingArray();\n    FacetResultNode reusable = null;\n    int localDepth = 0;\n    int depth = facetRequest.getDepth();\n    int[] ordinalStack = new int[2+Math.min(Short.MAX_VALUE, depth)];\n    int childrenCounter = 0;\n    \n    int tosOrdinal; // top of stack element\n    \n    int yc = youngestChild[ordinal];\n    while (yc >= endOffset) {\n      yc = olderSibling[yc];\n    }\n    // make use of the fact that TaxonomyReader.INVALID_ORDINAL == -1, < endOffset\n    // and it, too, can stop the loop.\n    ordinalStack[++localDepth] = yc;\n    \n    /*\n     * stack holds input parameter ordinal in position 0.\n     * Other elements are < endoffset.\n     * Only top of stack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if\n     * the element below it exhausted all its children: has them all processed.\n     * \n     * stack elements are processed (counted and accumulated) only if they \n     * belong to current partition (between offset and endoffset) and first time\n     * they are on top of stack \n     * \n     * loop as long as stack is not empty of elements other than input ordinal, or for a little while -- it sibling\n     */\n    while (localDepth > 0) {\n      tosOrdinal = ordinalStack[localDepth];\n      if (tosOrdinal == TaxonomyReader.INVALID_ORDINAL) {\n        // element below tos has all its children, and itself, all processed\n        // need to proceed to its sibling\n        localDepth--;\n        // change element now on top of stack to its sibling.\n        ordinalStack[localDepth] = olderSibling[ordinalStack[localDepth]];\n        continue;\n      }\n      // top of stack is not invalid, this is the first time we see it on top of stack.\n      // collect it, if belongs to current partition, and then push its kids on itself, if applicable\n      if (tosOrdinal >= offset) { // tosOrdinal resides in current partition\n        int relativeOrdinal = tosOrdinal % partitionSize;\n        double value = facetRequest.getValueOf(facetArrays, relativeOrdinal);\n        if (value != 0 && !Double.isNaN(value)) {\n          // Count current ordinal -- the TOS\n          if (reusable == null) {\n            reusable = new MutableFacetResultNode(tosOrdinal, value);\n          } else {\n            // it is safe to cast since reusable was created here.\n            ((MutableFacetResultNode)reusable).reset(tosOrdinal, value);\n          }\n          ++childrenCounter;\n          reusable = pq.insertWithOverflow(reusable);\n          if (reusable != null) {\n            // TODO (Facet): is other logic (not add) needed, per aggregator?\n            parentResultNode.increaseResidue(reusable.getValue());\n          }\n        }\n      }\n      if (localDepth < depth) {\n        // push kid of current tos\n        yc = youngestChild[tosOrdinal];\n        while (yc >= endOffset) {\n          yc = olderSibling[yc];\n        }\n        ordinalStack[++localDepth] = yc;\n      } else { // localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL\n        ordinalStack[++localDepth] = TaxonomyReader.INVALID_ORDINAL;\n      }\n    } // endof while stack is not empty\n    \n    return childrenCounter; // we're done\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["89f15687f60bd49cd3d9de427e85c17fd9397d61"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","89f15687f60bd49cd3d9de427e85c17fd9397d61"],"89f15687f60bd49cd3d9de427e85c17fd9397d61":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","89f15687f60bd49cd3d9de427e85c17fd9397d61"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d083e83f225b11e5fdd900e83d26ddb385b6955c","89f15687f60bd49cd3d9de427e85c17fd9397d61","817d8435e9135b756f08ce6710ab0baac51bdf88"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"89f15687f60bd49cd3d9de427e85c17fd9397d61":["b89678825b68eccaf09e6ab71675fc0b0af1e099","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}