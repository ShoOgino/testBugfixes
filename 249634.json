{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","sourceNew":"  /**\n   * Forces merge policy to merge segments until there's <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once the this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupt and no\n   * documents will have been lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n  */\n  public void forceMerge(int maxNumSegments) throws CorruptIndexException, IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","sourceOld":"  /**\n   * Forces merge policy to merge segments until there's <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once the this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupt and no\n   * documents will have been lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n  */\n  public void forceMerge(int maxNumSegments) throws CorruptIndexException, IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fd43b17cc944b4bce6e8d9fd052d58110fdf7b","date":1333817259,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","sourceNew":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n  */\n  public void forceMerge(int maxNumSegments) throws CorruptIndexException, IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","sourceOld":"  /**\n   * Forces merge policy to merge segments until there's <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once the this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupt and no\n   * documents will have been lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n  */\n  public void forceMerge(int maxNumSegments) throws CorruptIndexException, IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","bugFix":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","sourceNew":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","sourceOld":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n  */\n  public void forceMerge(int maxNumSegments) throws CorruptIndexException, IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","bugFix":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bd9ddb59e9d33950773d186a8b726b5610ae3aad","date":1341258232,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","sourceNew":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @param maxNumSegments maximum number of segments left\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n   * in the index after merging finishes\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","sourceOld":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ea3e0a145f5d081c0155e21319794c17ca4c0b39","date":1341258635,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","sourceNew":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","sourceOld":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @param maxNumSegments maximum number of segments left\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n   * in the index after merging finishes\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","sourceNew":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","sourceOld":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n  */\n  public void forceMerge(int maxNumSegments) throws CorruptIndexException, IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","sourceNew":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}.\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","sourceOld":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","bugFix":null,"bugIntro":["15fbe8579d34349a8c79cbc5c933530dd5b6742a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"949847c0040cd70a68222d526cb0da7bf6cbb3c2","date":1410997182,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","sourceNew":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}.\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","sourceOld":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}.\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e02c236171fb81c2cbf0b1d1e188e90c2ee8af92","date":1411368491,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","sourceNew":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires free space that is proportional\n   * to the size of the index in your Directory (2X if you're\n   * using compound file format). For example, if your index\n   * size is 10 MB then you need an additional 10 MB free for\n   * this to complete (20 MB if you're using compound file\n   * format). This is also affected by the {@link Codec} that\n   * is used to execute the merge, and may result in even a\n   * bigger index. Also, it's best to call {@link #commit()}\n   * afterwards, to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}.\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","sourceOld":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}.\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","bugFix":null,"bugIntro":["30766374cfdb9f7a09a8ff617a4859604982b05e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","sourceNew":"  /**\n   * Forces merge policy to merge segments until there are\n   * {@code <= maxNumSegments}.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires free space that is proportional\n   * to the size of the index in your Directory (2X if you're\n   * using compound file format). For example, if your index\n   * size is 10 MB then you need an additional 10 MB free for\n   * this to complete (20 MB if you're using compound file\n   * format). This is also affected by the {@link Codec} that\n   * is used to execute the merge, and may result in even a\n   * bigger index. Also, it's best to call {@link #commit()}\n   * afterwards, to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause {@code > 2X} temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}.\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","sourceOld":"  /**\n   * Forces merge policy to merge segments until there are <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires free space that is proportional\n   * to the size of the index in your Directory (2X if you're\n   * using compound file format). For example, if your index\n   * size is 10 MB then you need an additional 10 MB free for\n   * this to complete (20 MB if you're using compound file\n   * format). This is also affected by the {@link Codec} that\n   * is used to execute the merge, and may result in even a\n   * bigger index. Also, it's best to call {@link #commit()}\n   * afterwards, to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}.\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15fbe8579d34349a8c79cbc5c933530dd5b6742a","date":1418066328,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","sourceNew":"  /**\n   * Forces merge policy to merge segments until there are\n   * {@code <= maxNumSegments}.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires free space that is proportional\n   * to the size of the index in your Directory (2X if you're\n   * using compound file format). For example, if your index\n   * size is 10 MB then you need an additional 10 MB free for\n   * this to complete (20 MB if you're using compound file\n   * format). This is also affected by the {@link Codec} that\n   * is used to execute the merge, and may result in even a\n   * bigger index. Also, it's best to call {@link #commit()}\n   * afterwards, to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause {@code > 2X} temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","sourceOld":"  /**\n   * Forces merge policy to merge segments until there are\n   * {@code <= maxNumSegments}.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires free space that is proportional\n   * to the size of the index in your Directory (2X if you're\n   * using compound file format). For example, if your index\n   * size is 10 MB then you need an additional 10 MB free for\n   * this to complete (20 MB if you're using compound file\n   * format). This is also affected by the {@link Codec} that\n   * is used to execute the merge, and may result in even a\n   * bigger index. Also, it's best to call {@link #commit()}\n   * afterwards, to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause {@code > 2X} temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}.\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","bugFix":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30766374cfdb9f7a09a8ff617a4859604982b05e","date":1428006183,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","sourceNew":"  /**\n   * Forces merge policy to merge segments until there are\n   * {@code <= maxNumSegments}.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires free space that is proportional\n   * to the size of the index in your Directory: 2X if you are\n   * not using compound file format, and 3X if you are.\n   * For example, if your index size is 10 MB then you need\n   * an additional 20 MB free for this to complete (30 MB if\n   * you're using compound file format). This is also affected\n   * by the {@link Codec} that is used to execute the merge,\n   * and may result in even a bigger index. Also, it's best\n   * to call {@link #commit()} afterwards, to allow IndexWriter\n   * to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause {@code > 2X} temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","sourceOld":"  /**\n   * Forces merge policy to merge segments until there are\n   * {@code <= maxNumSegments}.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires free space that is proportional\n   * to the size of the index in your Directory (2X if you're\n   * using compound file format). For example, if your index\n   * size is 10 MB then you need an additional 10 MB free for\n   * this to complete (20 MB if you're using compound file\n   * format). This is also affected by the {@link Codec} that\n   * is used to execute the merge, and may result in even a\n   * bigger index. Also, it's best to call {@link #commit()}\n   * afterwards, to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause {@code > 2X} temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","bugFix":["e02c236171fb81c2cbf0b1d1e188e90c2ee8af92"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","date":1428091986,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","sourceNew":"  /**\n   * Forces merge policy to merge segments until there are\n   * {@code <= maxNumSegments}.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires free space that is proportional\n   * to the size of the index in your Directory: 2X if you are\n   * not using compound file format, and 3X if you are.\n   * For example, if your index size is 10 MB then you need\n   * an additional 20 MB free for this to complete (30 MB if\n   * you're using compound file format). This is also affected\n   * by the {@link Codec} that is used to execute the merge,\n   * and may result in even a bigger index. Also, it's best\n   * to call {@link #commit()} afterwards, to allow IndexWriter\n   * to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause {@code > 2X} temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","sourceOld":"  /**\n   * Forces merge policy to merge segments until there are\n   * {@code <= maxNumSegments}.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires free space that is proportional\n   * to the size of the index in your Directory (2X if you're\n   * using compound file format). For example, if your index\n   * size is 10 MB then you need an additional 10 MB free for\n   * this to complete (20 MB if you're using compound file\n   * format). This is also affected by the {@link Codec} that\n   * is used to execute the merge, and may result in even a\n   * bigger index. Also, it's best to call {@link #commit()}\n   * afterwards, to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause {@code > 2X} temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupted and no\n   * documents will be lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n  */\n  public void forceMerge(int maxNumSegments) throws IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["e02c236171fb81c2cbf0b1d1e188e90c2ee8af92"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e02c236171fb81c2cbf0b1d1e188e90c2ee8af92":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"ea3e0a145f5d081c0155e21319794c17ca4c0b39":["bd9ddb59e9d33950773d186a8b726b5610ae3aad"],"bd9ddb59e9d33950773d186a8b726b5610ae3aad":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"d3fd43b17cc944b4bce6e8d9fd052d58110fdf7b":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["d3fd43b17cc944b4bce6e8d9fd052d58110fdf7b","ea3e0a145f5d081c0155e21319794c17ca4c0b39"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":["15fbe8579d34349a8c79cbc5c933530dd5b6742a","30766374cfdb9f7a09a8ff617a4859604982b05e"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["ea3e0a145f5d081c0155e21319794c17ca4c0b39"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["d3fd43b17cc944b4bce6e8d9fd052d58110fdf7b"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"15fbe8579d34349a8c79cbc5c933530dd5b6742a":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["30766374cfdb9f7a09a8ff617a4859604982b05e"],"30766374cfdb9f7a09a8ff617a4859604982b05e":["15fbe8579d34349a8c79cbc5c933530dd5b6742a"]},"commit2Childs":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["15fbe8579d34349a8c79cbc5c933530dd5b6742a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d3fd43b17cc944b4bce6e8d9fd052d58110fdf7b"],"e02c236171fb81c2cbf0b1d1e188e90c2ee8af92":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"ea3e0a145f5d081c0155e21319794c17ca4c0b39":["fe33227f6805edab2036cbb80645cc4e2d1fa424","ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"bd9ddb59e9d33950773d186a8b726b5610ae3aad":["ea3e0a145f5d081c0155e21319794c17ca4c0b39"],"d3fd43b17cc944b4bce6e8d9fd052d58110fdf7b":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":[],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["bd9ddb59e9d33950773d186a8b726b5610ae3aad"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["e02c236171fb81c2cbf0b1d1e188e90c2ee8af92"],"15fbe8579d34349a8c79cbc5c933530dd5b6742a":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","30766374cfdb9f7a09a8ff617a4859604982b05e"],"30766374cfdb9f7a09a8ff617a4859604982b05e":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe33227f6805edab2036cbb80645cc4e2d1fa424","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}