{"path":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      float fieldBoost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n\n      if (applyBoost == false && fieldBoost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves \n      float compoundBoost = fieldBoost * docBoost;\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? compoundBoost : 1f, \n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                          destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                // we can't copy any boost unless the dest field is \n                // indexed & !omitNorms, but which boost we copy depends\n                // on whether the dest field already contains values (we\n                // don't want to apply the compounded docBoost more then once)\n                final float destBoost = \n                    (destinationField.indexed() && !destinationField.omitNorms()) ?\n                        (destHasValues ? fieldBoost : compoundBoost) : 1.0F;\n\n                addField(out, destinationField, val, destBoost, \n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n\n          // The final boost for a given field named is the product of the \n          // *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          fieldBoost = compoundBoost = 1.0f;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), 1.0f, false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["57273019d2938b9b30faae55f6983a2e71a56ec5","f47793eb80fc739be7036084303ca062ad7aa87d","92f8ab19a30ff70981e43b8cc78069cb0941476e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      float fieldBoost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n\n      if (applyBoost == false && fieldBoost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves \n      float compoundBoost = fieldBoost * docBoost;\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? compoundBoost : 1f, \n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                          destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                // we can't copy any boost unless the dest field is \n                // indexed & !omitNorms, but which boost we copy depends\n                // on whether the dest field already contains values (we\n                // don't want to apply the compounded docBoost more then once)\n                final float destBoost = \n                    (destinationField.indexed() && !destinationField.omitNorms()) ?\n                        (destHasValues ? fieldBoost : compoundBoost) : 1.0F;\n\n                addField(out, destinationField, val, destBoost, \n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n\n          // The final boost for a given field named is the product of the \n          // *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          fieldBoost = compoundBoost = 1.0f;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), 1.0f, false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acd9883560fd89e6448b2b447302fe543040cd4f","date":1488478696,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                          destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    final float docBoost = doc.getDocumentBoost();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      float fieldBoost = field.getBoost();\n      boolean applyBoost = sfield != null && sfield.indexed() && !sfield.omitNorms();\n\n      if (applyBoost == false && fieldBoost != 1.0F) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"cannot set an index-time boost, unindexed or norms are omitted for field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      // Lucene no longer has a native docBoost, so we have to multiply \n      // it ourselves \n      float compoundBoost = fieldBoost * docBoost;\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v, applyBoost ? compoundBoost : 1f, \n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                          destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                // we can't copy any boost unless the dest field is \n                // indexed & !omitNorms, but which boost we copy depends\n                // on whether the dest field already contains values (we\n                // don't want to apply the compounded docBoost more then once)\n                final float destBoost = \n                    (destinationField.indexed() && !destinationField.omitNorms()) ?\n                        (destHasValues ? fieldBoost : compoundBoost) : 1.0F;\n\n                addField(out, destinationField, val, destBoost, \n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n\n          // The final boost for a given field named is the product of the \n          // *all* boosts on values of that field. \n          // For multi-valued fields, we only want to set the boost on the\n          // first field.\n          fieldBoost = compoundBoost = 1.0f;\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), 1.0f, false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"24686226124dab7a26bcb1ed0653aa7fa4a18c9e","date":1489713728,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                          destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                          destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4359f613ec1bd44a86b91e052b90aadb3804b51","date":1490280010,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                          destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                          destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92f8ab19a30ff70981e43b8cc78069cb0941476e","date":1497374252,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                          destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","bugFix":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                          destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued copy field \" +\n                          destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw ex;\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5ce7c704ca874aa623a99f2669737b52ec71cfc","date":1528728510,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","bugFix":null,"bugIntro":["f47793eb80fc739be7036084303ca062ad7aa87d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":4,"author":"Michael Braun","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","sourceNew":null,"sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":4,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","sourceNew":null,"sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"92f8ab19a30ff70981e43b8cc78069cb0941476e":["24686226124dab7a26bcb1ed0653aa7fa4a18c9e"],"c4359f613ec1bd44a86b91e052b90aadb3804b51":["acd9883560fd89e6448b2b447302fe543040cd4f"],"28288370235ed02234a64753cdbf0c6ec096304a":["24686226124dab7a26bcb1ed0653aa7fa4a18c9e","92f8ab19a30ff70981e43b8cc78069cb0941476e"],"24686226124dab7a26bcb1ed0653aa7fa4a18c9e":["acd9883560fd89e6448b2b447302fe543040cd4f"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["28288370235ed02234a64753cdbf0c6ec096304a","c5ce7c704ca874aa623a99f2669737b52ec71cfc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"acd9883560fd89e6448b2b447302fe543040cd4f":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"c5ce7c704ca874aa623a99f2669737b52ec71cfc":["28288370235ed02234a64753cdbf0c6ec096304a"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["c4359f613ec1bd44a86b91e052b90aadb3804b51","92f8ab19a30ff70981e43b8cc78069cb0941476e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c5ce7c704ca874aa623a99f2669737b52ec71cfc"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["28288370235ed02234a64753cdbf0c6ec096304a","c5ce7c704ca874aa623a99f2669737b52ec71cfc"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","acd9883560fd89e6448b2b447302fe543040cd4f"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"92f8ab19a30ff70981e43b8cc78069cb0941476e":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"c4359f613ec1bd44a86b91e052b90aadb3804b51":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"28288370235ed02234a64753cdbf0c6ec096304a":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","c5ce7c704ca874aa623a99f2669737b52ec71cfc","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"24686226124dab7a26bcb1ed0653aa7fa4a18c9e":["92f8ab19a30ff70981e43b8cc78069cb0941476e","28288370235ed02234a64753cdbf0c6ec096304a"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"acd9883560fd89e6448b2b447302fe543040cd4f":["c4359f613ec1bd44a86b91e052b90aadb3804b51","24686226124dab7a26bcb1ed0653aa7fa4a18c9e"],"c5ce7c704ca874aa623a99f2669737b52ec71cfc":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}