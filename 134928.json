{"path":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","sourceNew":"  /**\n   * TODO: Doc\n   * \n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","sourceOld":"  /**\n   * TODO: Doc\n   * \n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","sourceNew":"  /**\n   * TODO: Doc\n   * \n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","sourceOld":"  /**\n   * TODO: Doc\n   * \n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","sourceNew":"  /**\n   * TODO: Doc\n   * \n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","sourceOld":"  /**\n   * TODO: Doc\n   * \n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","sourceNew":"  /*\n   * TODO: Doc\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","sourceOld":"  /**\n   * TODO: Doc\n   * \n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cdb67100dc016748799a77218aa409478372d79","date":1353699950,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","sourceNew":"  /*\n   * TODO: Doc\n   */\n  public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","sourceOld":"  /*\n   * TODO: Doc\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","sourceNew":"  /*\n   * TODO: Doc\n   */\n  public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","sourceOld":"  /*\n   * TODO: Doc\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","sourceNew":"  /*\n   * TODO: Doc\n   */\n  public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","sourceOld":"  /*\n   * TODO: Doc\n   */\n  public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","sourceNew":"  /*\n   * TODO: Doc\n   */\n  public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","sourceOld":"  /*\n   * TODO: Doc\n   */\n  public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a2e3a7d2549a34fb7ec9be55424e41388025336","date":1452801298,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","sourceNew":"  /*\n   * TODO: Doc\n   */\n  public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      ModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","sourceOld":"  /*\n   * TODO: Doc\n   */\n  public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"efff98a8632f3c2f5b05f961e22a67f122db81e0","date":1550955355,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","sourceNew":"  /*\n   * TODO: Doc\n   */\n  public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n\n      // nestedQuery would be null when de-referenced query value is not specified\n      // Ex: query($qq) in request with no qq param specified\n      if (nestedQuery == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      ModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n      // handling null check on nestedQuery separately, so that proper error can be returned\n      // one case this would be possible when v is specified but v's value is empty or has only spaces\n      if (nestedQuery == null) {\n        throw new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n      }\n    }\n    consumeArgumentDelimiter();\n\n    return nestedQuery;\n  }\n\n","sourceOld":"  /*\n   * TODO: Doc\n   */\n  public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      ModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","bugFix":["1833c624d42634c14299628650e0a70626349a71"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d2d6c361b65277d72b2f3dd0f83b9721875e6b4","date":1551083645,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","sourceNew":"  /*\n   * TODO: Doc\n   */\n  public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n\n      // nestedQuery would be null when de-referenced query value is not specified\n      // Ex: query($qq) in request with no qq param specified\n      if (nestedQuery == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      ModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n      // handling null check on nestedQuery separately, so that proper error can be returned\n      // one case this would be possible when v is specified but v's value is empty or has only spaces\n      if (nestedQuery == null) {\n        throw new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n      }\n    }\n    consumeArgumentDelimiter();\n\n    return nestedQuery;\n  }\n\n","sourceOld":"  /*\n   * TODO: Doc\n   */\n  public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      ModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["c26f00b574427b55127e869b935845554afde1fa"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["3cdb67100dc016748799a77218aa409478372d79","19275ba31e621f6da1b83bf13af75233876fd3d4"],"3a2e3a7d2549a34fb7ec9be55424e41388025336":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"3cdb67100dc016748799a77218aa409478372d79":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"407687e67faf6e1f02a211ca078d8e3eed631027":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","3cdb67100dc016748799a77218aa409478372d79"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["3cdb67100dc016748799a77218aa409478372d79"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"efff98a8632f3c2f5b05f961e22a67f122db81e0":["3a2e3a7d2549a34fb7ec9be55424e41388025336"],"0d2d6c361b65277d72b2f3dd0f83b9721875e6b4":["3a2e3a7d2549a34fb7ec9be55424e41388025336","efff98a8632f3c2f5b05f961e22a67f122db81e0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0d2d6c361b65277d72b2f3dd0f83b9721875e6b4"]},"commit2Childs":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["3cdb67100dc016748799a77218aa409478372d79","407687e67faf6e1f02a211ca078d8e3eed631027"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"3cdb67100dc016748799a77218aa409478372d79":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","407687e67faf6e1f02a211ca078d8e3eed631027","19275ba31e621f6da1b83bf13af75233876fd3d4"],"3a2e3a7d2549a34fb7ec9be55424e41388025336":["efff98a8632f3c2f5b05f961e22a67f122db81e0","0d2d6c361b65277d72b2f3dd0f83b9721875e6b4"],"c26f00b574427b55127e869b935845554afde1fa":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"19275ba31e621f6da1b83bf13af75233876fd3d4":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","3a2e3a7d2549a34fb7ec9be55424e41388025336"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"efff98a8632f3c2f5b05f961e22a67f122db81e0":["0d2d6c361b65277d72b2f3dd0f83b9721875e6b4"],"0d2d6c361b65277d72b2f3dd0f83b9721875e6b4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","407687e67faf6e1f02a211ca078d8e3eed631027","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}