{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleFilterExclusions().mjava","commits":[{"id":"9e13d0d4d8b6dc352cb304974502b9a36c153f78","date":1436492687,"type":1,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleFilterExclusions().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor[FacetRequest]#handleFilterExclusions().mjava","sourceNew":"  private void handleFilterExclusions() throws IOException {\n    List<String> excludeTags = freq.domain.excludeTags;\n\n    if (excludeTags == null || excludeTags.size() == 0) {\n      return;\n    }\n\n    // TODO: somehow remove responsebuilder dependency\n    ResponseBuilder rb = SolrRequestInfo.getRequestInfo().getResponseBuilder();\n    Map tagMap = (Map) rb.req.getContext().get(\"tags\");\n    if (tagMap == null) {\n      // no filters were tagged\n      return;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTags) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          // This should not happen since we should only be retrieving a previously parsed query\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    if (excludeSet.size() == 0) return;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // now walk back up the context tree\n    // TODO: we lose parent exclusions...\n    for (FacetContext curr = fcontext; curr != null; curr = curr.parent) {\n      if (curr.filter != null) {\n        qlist.add( curr.filter );\n      }\n    }\n\n    // recompute the base domain\n    fcontext.base = fcontext.searcher.getDocSet(qlist);\n  }\n\n","sourceOld":"  private void handleFilterExclusions() throws IOException {\n    List<String> excludeTags = freq.domain.excludeTags;\n\n    if (excludeTags == null || excludeTags.size() == 0) {\n      return;\n    }\n\n    // TODO: somehow remove responsebuilder dependency\n    ResponseBuilder rb = SolrRequestInfo.getRequestInfo().getResponseBuilder();\n    Map tagMap = (Map) rb.req.getContext().get(\"tags\");\n    if (tagMap == null) {\n      // no filters were tagged\n      return;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTags) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          // This should not happen since we should only be retrieving a previously parsed query\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    if (excludeSet.size() == 0) return;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // now walk back up the context tree\n    // TODO: we lose parent exclusions...\n    for (FacetContext curr = fcontext; curr != null; curr = curr.parent) {\n      if (curr.filter != null) {\n        qlist.add( curr.filter );\n      }\n    }\n\n    // recompute the base domain\n    fcontext.base = fcontext.searcher.getDocSet(qlist);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ab027bdfe663227636ccbeda13ae82add302939","date":1529980633,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleFilterExclusions().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleFilterExclusions().mjava","sourceNew":"  private void handleFilterExclusions() throws IOException {\n    List<String> excludeTags = freq.domain.excludeTags;\n\n    if (excludeTags == null || excludeTags.size() == 0) {\n      return;\n    }\n\n    Map tagMap = (Map) fcontext.req.getContext().get(\"tags\");\n    if (tagMap == null) {\n      // no filters were tagged\n      return;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTags) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          // This should not happen since we should only be retrieving a previously parsed query\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    if (excludeSet.size() == 0) return;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // TODO: somehow remove responsebuilder dependency\n    ResponseBuilder rb = SolrRequestInfo.getRequestInfo().getResponseBuilder();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // now walk back up the context tree\n    // TODO: we lose parent exclusions...\n    for (FacetContext curr = fcontext; curr != null; curr = curr.parent) {\n      if (curr.filter != null) {\n        qlist.add( curr.filter );\n      }\n    }\n\n    // recompute the base domain\n    fcontext.base = fcontext.searcher.getDocSet(qlist);\n  }\n\n","sourceOld":"  private void handleFilterExclusions() throws IOException {\n    List<String> excludeTags = freq.domain.excludeTags;\n\n    if (excludeTags == null || excludeTags.size() == 0) {\n      return;\n    }\n\n    // TODO: somehow remove responsebuilder dependency\n    ResponseBuilder rb = SolrRequestInfo.getRequestInfo().getResponseBuilder();\n    Map tagMap = (Map) rb.req.getContext().get(\"tags\");\n    if (tagMap == null) {\n      // no filters were tagged\n      return;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTags) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          // This should not happen since we should only be retrieving a previously parsed query\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    if (excludeSet.size() == 0) return;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // now walk back up the context tree\n    // TODO: we lose parent exclusions...\n    for (FacetContext curr = fcontext; curr != null; curr = curr.parent) {\n      if (curr.filter != null) {\n        qlist.add( curr.filter );\n      }\n    }\n\n    // recompute the base domain\n    fcontext.base = fcontext.searcher.getDocSet(qlist);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleFilterExclusions().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleFilterExclusions().mjava","sourceNew":"  private void handleFilterExclusions() throws IOException {\n    List<String> excludeTags = freq.domain.excludeTags;\n\n    if (excludeTags == null || excludeTags.size() == 0) {\n      return;\n    }\n\n    Map tagMap = (Map) fcontext.req.getContext().get(\"tags\");\n    if (tagMap == null) {\n      // no filters were tagged\n      return;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTags) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          // This should not happen since we should only be retrieving a previously parsed query\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    if (excludeSet.size() == 0) return;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // TODO: somehow remove responsebuilder dependency\n    ResponseBuilder rb = SolrRequestInfo.getRequestInfo().getResponseBuilder();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // now walk back up the context tree\n    // TODO: we lose parent exclusions...\n    for (FacetContext curr = fcontext; curr != null; curr = curr.parent) {\n      if (curr.filter != null) {\n        qlist.add( curr.filter );\n      }\n    }\n\n    // recompute the base domain\n    fcontext.base = fcontext.searcher.getDocSet(qlist);\n  }\n\n","sourceOld":"  private void handleFilterExclusions() throws IOException {\n    List<String> excludeTags = freq.domain.excludeTags;\n\n    if (excludeTags == null || excludeTags.size() == 0) {\n      return;\n    }\n\n    // TODO: somehow remove responsebuilder dependency\n    ResponseBuilder rb = SolrRequestInfo.getRequestInfo().getResponseBuilder();\n    Map tagMap = (Map) rb.req.getContext().get(\"tags\");\n    if (tagMap == null) {\n      // no filters were tagged\n      return;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTags) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          // This should not happen since we should only be retrieving a previously parsed query\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    if (excludeSet.size() == 0) return;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // now walk back up the context tree\n    // TODO: we lose parent exclusions...\n    for (FacetContext curr = fcontext; curr != null; curr = curr.parent) {\n      if (curr.filter != null) {\n        qlist.add( curr.filter );\n      }\n    }\n\n    // recompute the base domain\n    fcontext.base = fcontext.searcher.getDocSet(qlist);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleFilterExclusions().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleFilterExclusions().mjava","sourceNew":"  private void handleFilterExclusions() throws IOException {\n    List<String> excludeTags = freq.domain.excludeTags;\n\n    if (excludeTags == null || excludeTags.size() == 0) {\n      return;\n    }\n\n    Map tagMap = (Map) fcontext.req.getContext().get(\"tags\");\n    if (tagMap == null) {\n      // no filters were tagged\n      return;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTags) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          // This should not happen since we should only be retrieving a previously parsed query\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    if (excludeSet.size() == 0) return;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // TODO: somehow remove responsebuilder dependency\n    ResponseBuilder rb = SolrRequestInfo.getRequestInfo().getResponseBuilder();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // now walk back up the context tree\n    // TODO: we lose parent exclusions...\n    for (FacetContext curr = fcontext; curr != null; curr = curr.parent) {\n      if (curr.filter != null) {\n        qlist.add( curr.filter );\n      }\n    }\n\n    // recompute the base domain\n    fcontext.base = fcontext.searcher.getDocSet(qlist);\n  }\n\n","sourceOld":"  private void handleFilterExclusions() throws IOException {\n    List<String> excludeTags = freq.domain.excludeTags;\n\n    if (excludeTags == null || excludeTags.size() == 0) {\n      return;\n    }\n\n    // TODO: somehow remove responsebuilder dependency\n    ResponseBuilder rb = SolrRequestInfo.getRequestInfo().getResponseBuilder();\n    Map tagMap = (Map) rb.req.getContext().get(\"tags\");\n    if (tagMap == null) {\n      // no filters were tagged\n      return;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTags) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          // This should not happen since we should only be retrieving a previously parsed query\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    if (excludeSet.size() == 0) return;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // now walk back up the context tree\n    // TODO: we lose parent exclusions...\n    for (FacetContext curr = fcontext; curr != null; curr = curr.parent) {\n      if (curr.filter != null) {\n        qlist.add( curr.filter );\n      }\n    }\n\n    // recompute the base domain\n    fcontext.base = fcontext.searcher.getDocSet(qlist);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"248f6ecc900c3a5633fd5ca6f564ea8b717720da","date":1588863846,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleFilterExclusions().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleFilterExclusions().mjava","sourceNew":"  private void handleFilterExclusions() throws IOException {\n    List<String> excludeTags = freq.domain.excludeTags;\n\n    if (excludeTags == null || excludeTags.size() == 0) {\n      return;\n    }\n\n    Map tagMap = (Map) fcontext.req.getContext().get(\"tags\");\n    if (tagMap == null) {\n      // no filters were tagged\n      return;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTags) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          // This should not happen since we should only be retrieving a previously parsed query\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    if (excludeSet.size() == 0) return;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // TODO: somehow remove responsebuilder dependency\n    ResponseBuilder rb = SolrRequestInfo.getRequestInfo().getResponseBuilder();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // now walk back up the context tree\n    // TODO: we lose parent exclusions...\n    for (FacetRequest.FacetContext curr = fcontext; curr != null; curr = curr.parent) {\n      if (curr.filter != null) {\n        qlist.add( curr.filter );\n      }\n    }\n\n    // recompute the base domain\n    fcontext.base = fcontext.searcher.getDocSet(qlist);\n  }\n\n","sourceOld":"  private void handleFilterExclusions() throws IOException {\n    List<String> excludeTags = freq.domain.excludeTags;\n\n    if (excludeTags == null || excludeTags.size() == 0) {\n      return;\n    }\n\n    Map tagMap = (Map) fcontext.req.getContext().get(\"tags\");\n    if (tagMap == null) {\n      // no filters were tagged\n      return;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTags) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          // This should not happen since we should only be retrieving a previously parsed query\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    if (excludeSet.size() == 0) return;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // TODO: somehow remove responsebuilder dependency\n    ResponseBuilder rb = SolrRequestInfo.getRequestInfo().getResponseBuilder();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // now walk back up the context tree\n    // TODO: we lose parent exclusions...\n    for (FacetContext curr = fcontext; curr != null; curr = curr.parent) {\n      if (curr.filter != null) {\n        qlist.add( curr.filter );\n      }\n    }\n\n    // recompute the base domain\n    fcontext.base = fcontext.searcher.getDocSet(qlist);\n  }\n\n","bugFix":["9e47fba8dd946896c408eb448f6199f5a9f0da2d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a56a9893014b284af4d1af451e6c02e7ffdf5b6e","date":1590065972,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleFilterExclusions().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleFilterExclusions().mjava","sourceNew":"  private void handleFilterExclusions() throws IOException {\n    List<String> excludeTags = freq.domain.excludeTags;\n\n    if (excludeTags == null || excludeTags.size() == 0) {\n      return;\n    }\n\n    @SuppressWarnings({\"rawtypes\"})\n    Map tagMap = (Map) fcontext.req.getContext().get(\"tags\");\n    if (tagMap == null) {\n      // no filters were tagged\n      return;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTags) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          // This should not happen since we should only be retrieving a previously parsed query\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    if (excludeSet.size() == 0) return;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // TODO: somehow remove responsebuilder dependency\n    ResponseBuilder rb = SolrRequestInfo.getRequestInfo().getResponseBuilder();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // now walk back up the context tree\n    // TODO: we lose parent exclusions...\n    for (FacetContext curr = fcontext; curr != null; curr = curr.parent) {\n      if (curr.filter != null) {\n        qlist.add( curr.filter );\n      }\n    }\n\n    // recompute the base domain\n    fcontext.base = fcontext.searcher.getDocSet(qlist);\n  }\n\n","sourceOld":"  private void handleFilterExclusions() throws IOException {\n    List<String> excludeTags = freq.domain.excludeTags;\n\n    if (excludeTags == null || excludeTags.size() == 0) {\n      return;\n    }\n\n    Map tagMap = (Map) fcontext.req.getContext().get(\"tags\");\n    if (tagMap == null) {\n      // no filters were tagged\n      return;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTags) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          // This should not happen since we should only be retrieving a previously parsed query\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    if (excludeSet.size() == 0) return;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // TODO: somehow remove responsebuilder dependency\n    ResponseBuilder rb = SolrRequestInfo.getRequestInfo().getResponseBuilder();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // now walk back up the context tree\n    // TODO: we lose parent exclusions...\n    for (FacetRequest.FacetContext curr = fcontext; curr != null; curr = curr.parent) {\n      if (curr.filter != null) {\n        qlist.add( curr.filter );\n      }\n    }\n\n    // recompute the base domain\n    fcontext.base = fcontext.searcher.getDocSet(qlist);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2ab027bdfe663227636ccbeda13ae82add302939":["9e13d0d4d8b6dc352cb304974502b9a36c153f78"],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["9e13d0d4d8b6dc352cb304974502b9a36c153f78","2ab027bdfe663227636ccbeda13ae82add302939"],"9e13d0d4d8b6dc352cb304974502b9a36c153f78":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["2ab027bdfe663227636ccbeda13ae82add302939"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["9e13d0d4d8b6dc352cb304974502b9a36c153f78","2ab027bdfe663227636ccbeda13ae82add302939"]},"commit2Childs":{"2ab027bdfe663227636ccbeda13ae82add302939":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","248f6ecc900c3a5633fd5ca6f564ea8b717720da","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"9e13d0d4d8b6dc352cb304974502b9a36c153f78":["2ab027bdfe663227636ccbeda13ae82add302939","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9e13d0d4d8b6dc352cb304974502b9a36c153f78"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}