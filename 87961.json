{"path":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","sourceNew":"  /**\n   * Returns a DocIdSet with documents that should be\n   * permitted in search results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final TermEnum enumerator = query.getEnum(reader);\n    try {\n      // if current term in enum is null, the enum is empty -> shortcut\n      if (enumerator.term() == null)\n        return DocIdSet.EMPTY_DOCIDSET;\n      // else fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      final int[] docs = new int[32];\n      final int[] freqs = new int[32];\n      TermDocs termDocs = reader.termDocs();\n      try {\n        int termCount = 0;\n        do {\n          Term term = enumerator.term();\n          if (term == null)\n            break;\n          termCount++;\n          termDocs.seek(term);\n          while (true) {\n            final int count = termDocs.read(docs, freqs);\n            if (count != 0) {\n              for(int i=0;i<count;i++) {\n                bitSet.set(docs[i]);\n              }\n            } else {\n              break;\n            }\n          }\n        } while (enumerator.next());\n\n        query.incTotalNumberOfTerms(termCount);\n\n      } finally {\n        termDocs.close();\n      }\n      return bitSet;\n    } finally {\n      enumerator.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a DocIdSet with documents that should be\n   * permitted in search results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final TermEnum enumerator = query.getEnum(reader);\n    try {\n      // if current term in enum is null, the enum is empty -> shortcut\n      if (enumerator.term() == null)\n        return DocIdSet.EMPTY_DOCIDSET;\n      // else fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      final int[] docs = new int[32];\n      final int[] freqs = new int[32];\n      TermDocs termDocs = reader.termDocs();\n      try {\n        int termCount = 0;\n        do {\n          Term term = enumerator.term();\n          if (term == null)\n            break;\n          termCount++;\n          termDocs.seek(term);\n          while (true) {\n            final int count = termDocs.read(docs, freqs);\n            if (count != 0) {\n              for(int i=0;i<count;i++) {\n                bitSet.set(docs[i]);\n              }\n            } else {\n              break;\n            }\n          }\n        } while (enumerator.next());\n\n        query.incTotalNumberOfTerms(termCount);\n\n      } finally {\n        termDocs.close();\n      }\n      return bitSet;\n    } finally {\n      enumerator.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","sourceNew":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    if (query.hasNewAPI) {\n      if (query.field == null) {\n        throw new NullPointerException(\"If you implement getTermsEnum(), you must specify a non-null field in the constructor of MultiTermQuery.\");\n      }\n\n      final Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        // reader has no fields\n        return DocIdSet.EMPTY_DOCIDSET;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        return DocIdSet.EMPTY_DOCIDSET;\n      }\n\n      final TermsEnum termsEnum = query.getTermsEnum(reader);\n      assert termsEnum != null;\n      if (termsEnum.next() != null) {\n        // fill into a OpenBitSet\n        final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n        int termCount = 0;\n        final Bits delDocs = MultiFields.getDeletedDocs(reader);\n        DocsEnum docsEnum = null;\n        do {\n          termCount++;\n          // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n          // enumerator.term().toBytesString());\n          docsEnum = termsEnum.docs(delDocs, docsEnum);\n          final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n          while (true) {\n            final int count = docsEnum.read();\n            if (count != 0) {\n              final int[] docs = result.docs.ints;\n              for (int i = 0; i < count; i++) {\n                bitSet.set(docs[i]);\n              }\n            } else {\n              break;\n            }\n          }\n        } while (termsEnum.next() != null);\n        // System.out.println(\"  done termCount=\" + termCount);\n\n        query.incTotalNumberOfTerms(termCount);\n        return bitSet;\n      } else {\n        return DocIdSet.EMPTY_DOCIDSET;\n      }\n    } else {\n      final TermEnum enumerator = query.getEnum(reader);\n      try {\n        // if current term in enum is null, the enum is empty -> shortcut\n        if (enumerator.term() == null)\n          return DocIdSet.EMPTY_DOCIDSET;\n        // else fill into a OpenBitSet\n        final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n        final int[] docs = new int[32];\n        final int[] freqs = new int[32];\n        TermDocs termDocs = reader.termDocs();\n        try {\n          int termCount = 0;\n          do {\n            Term term = enumerator.term();\n            if (term == null)\n              break;\n            termCount++;\n            termDocs.seek(term);\n            while (true) {\n              final int count = termDocs.read(docs, freqs);\n              if (count != 0) {\n                for (int i = 0; i < count; i++) {\n                  bitSet.set(docs[i]);\n                }\n              } else {\n                break;\n              }\n            }\n          } while (enumerator.next());\n\n          query.incTotalNumberOfTerms(termCount);\n\n        } finally {\n          termDocs.close();\n        }\n        return bitSet;\n      } finally {\n        enumerator.close();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a DocIdSet with documents that should be\n   * permitted in search results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final TermEnum enumerator = query.getEnum(reader);\n    try {\n      // if current term in enum is null, the enum is empty -> shortcut\n      if (enumerator.term() == null)\n        return DocIdSet.EMPTY_DOCIDSET;\n      // else fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      final int[] docs = new int[32];\n      final int[] freqs = new int[32];\n      TermDocs termDocs = reader.termDocs();\n      try {\n        int termCount = 0;\n        do {\n          Term term = enumerator.term();\n          if (term == null)\n            break;\n          termCount++;\n          termDocs.seek(term);\n          while (true) {\n            final int count = termDocs.read(docs, freqs);\n            if (count != 0) {\n              for(int i=0;i<count;i++) {\n                bitSet.set(docs[i]);\n              }\n            } else {\n              break;\n            }\n          }\n        } while (enumerator.next());\n\n        query.incTotalNumberOfTerms(termCount);\n\n      } finally {\n        termDocs.close();\n      }\n      return bitSet;\n    } finally {\n      enumerator.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28427ef110c4c5bf5b4057731b83110bd1e13724","date":1276701452,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","sourceNew":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    if (query.field == null) {\n      throw new NullPointerException(\"If you implement getTermsEnum(), you must specify a non-null field in the constructor of MultiTermQuery.\");\n    }\n\n    final Fields fields = MultiFields.getFields(reader);\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(reader);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    if (query.hasNewAPI) {\n      if (query.field == null) {\n        throw new NullPointerException(\"If you implement getTermsEnum(), you must specify a non-null field in the constructor of MultiTermQuery.\");\n      }\n\n      final Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        // reader has no fields\n        return DocIdSet.EMPTY_DOCIDSET;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        return DocIdSet.EMPTY_DOCIDSET;\n      }\n\n      final TermsEnum termsEnum = query.getTermsEnum(reader);\n      assert termsEnum != null;\n      if (termsEnum.next() != null) {\n        // fill into a OpenBitSet\n        final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n        int termCount = 0;\n        final Bits delDocs = MultiFields.getDeletedDocs(reader);\n        DocsEnum docsEnum = null;\n        do {\n          termCount++;\n          // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n          // enumerator.term().toBytesString());\n          docsEnum = termsEnum.docs(delDocs, docsEnum);\n          final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n          while (true) {\n            final int count = docsEnum.read();\n            if (count != 0) {\n              final int[] docs = result.docs.ints;\n              for (int i = 0; i < count; i++) {\n                bitSet.set(docs[i]);\n              }\n            } else {\n              break;\n            }\n          }\n        } while (termsEnum.next() != null);\n        // System.out.println(\"  done termCount=\" + termCount);\n\n        query.incTotalNumberOfTerms(termCount);\n        return bitSet;\n      } else {\n        return DocIdSet.EMPTY_DOCIDSET;\n      }\n    } else {\n      final TermEnum enumerator = query.getEnum(reader);\n      try {\n        // if current term in enum is null, the enum is empty -> shortcut\n        if (enumerator.term() == null)\n          return DocIdSet.EMPTY_DOCIDSET;\n        // else fill into a OpenBitSet\n        final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n        final int[] docs = new int[32];\n        final int[] freqs = new int[32];\n        TermDocs termDocs = reader.termDocs();\n        try {\n          int termCount = 0;\n          do {\n            Term term = enumerator.term();\n            if (term == null)\n              break;\n            termCount++;\n            termDocs.seek(term);\n            while (true) {\n              final int count = termDocs.read(docs, freqs);\n              if (count != 0) {\n                for (int i = 0; i < count; i++) {\n                  bitSet.set(docs[i]);\n                }\n              } else {\n                break;\n              }\n            }\n          } while (enumerator.next());\n\n          query.incTotalNumberOfTerms(termCount);\n\n        } finally {\n          termDocs.close();\n        }\n        return bitSet;\n      } finally {\n        enumerator.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f29ba80b723649f5feb7e37afe1a558dd2c1304","date":1278318805,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","sourceNew":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final Fields fields = MultiFields.getFields(reader);\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(reader);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    if (query.field == null) {\n      throw new NullPointerException(\"If you implement getTermsEnum(), you must specify a non-null field in the constructor of MultiTermQuery.\");\n    }\n\n    final Fields fields = MultiFields.getFields(reader);\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(reader);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","sourceNew":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final Fields fields = MultiFields.getFields(reader);\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(reader);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    if (query.hasNewAPI) {\n      if (query.field == null) {\n        throw new NullPointerException(\"If you implement getTermsEnum(), you must specify a non-null field in the constructor of MultiTermQuery.\");\n      }\n\n      final Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        // reader has no fields\n        return DocIdSet.EMPTY_DOCIDSET;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        return DocIdSet.EMPTY_DOCIDSET;\n      }\n\n      final TermsEnum termsEnum = query.getTermsEnum(reader);\n      assert termsEnum != null;\n      if (termsEnum.next() != null) {\n        // fill into a OpenBitSet\n        final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n        int termCount = 0;\n        final Bits delDocs = MultiFields.getDeletedDocs(reader);\n        DocsEnum docsEnum = null;\n        do {\n          termCount++;\n          // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n          // enumerator.term().toBytesString());\n          docsEnum = termsEnum.docs(delDocs, docsEnum);\n          final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n          while (true) {\n            final int count = docsEnum.read();\n            if (count != 0) {\n              final int[] docs = result.docs.ints;\n              for (int i = 0; i < count; i++) {\n                bitSet.set(docs[i]);\n              }\n            } else {\n              break;\n            }\n          }\n        } while (termsEnum.next() != null);\n        // System.out.println(\"  done termCount=\" + termCount);\n\n        query.incTotalNumberOfTerms(termCount);\n        return bitSet;\n      } else {\n        return DocIdSet.EMPTY_DOCIDSET;\n      }\n    } else {\n      final TermEnum enumerator = query.getEnum(reader);\n      try {\n        // if current term in enum is null, the enum is empty -> shortcut\n        if (enumerator.term() == null)\n          return DocIdSet.EMPTY_DOCIDSET;\n        // else fill into a OpenBitSet\n        final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n        final int[] docs = new int[32];\n        final int[] freqs = new int[32];\n        TermDocs termDocs = reader.termDocs();\n        try {\n          int termCount = 0;\n          do {\n            Term term = enumerator.term();\n            if (term == null)\n              break;\n            termCount++;\n            termDocs.seek(term);\n            while (true) {\n              final int count = termDocs.read(docs, freqs);\n              if (count != 0) {\n                for (int i = 0; i < count; i++) {\n                  bitSet.set(docs[i]);\n                }\n              } else {\n                break;\n              }\n            }\n          } while (enumerator.next());\n\n          query.incTotalNumberOfTerms(termCount);\n\n        } finally {\n          termDocs.close();\n        }\n        return bitSet;\n      } finally {\n        enumerator.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8dd2a69747e9f2922fd8b6970bd1661b26a692d","date":1291080135,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","sourceNew":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final Fields fields = MultiFields.getFields(reader);\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(terms);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final Fields fields = MultiFields.getFields(reader);\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(reader);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","sourceNew":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final Fields fields = MultiFields.getFields(reader);\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(terms);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final Fields fields = MultiFields.getFields(reader);\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(reader);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","sourceNew":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final Fields fields = MultiFields.getFields(reader);\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(terms);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final Fields fields = MultiFields.getFields(reader);\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(reader);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df3efec034da1483899681baabb1df029e8628c4","date":1294243646,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","sourceNew":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final Fields fields = reader.fields();\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(terms);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = reader.getDeletedDocs();\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final Fields fields = MultiFields.getFields(reader);\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(terms);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","sourceNew":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final Fields fields = reader.fields();\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(terms);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = reader.getDeletedDocs();\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final Fields fields = MultiFields.getFields(reader);\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(terms);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dadf0f3286a34a0fee6e788ffce88624bf2984e","date":1294260428,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(ReaderContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","sourceNew":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(ReaderContext context) throws IOException {\n    final IndexReader reader = context.reader;\n    final Fields fields = reader.fields();\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(terms);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(context.reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = reader.getDeletedDocs();\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final Fields fields = reader.fields();\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(terms);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = reader.getDeletedDocs();\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","sourceNew":null,"sourceOld":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final Fields fields = MultiFields.getFields(reader);\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(terms);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter#getDocIdSet(IndexReader).mjava","sourceNew":null,"sourceOld":"  /**\n   * Returns a DocIdSet with documents that should be permitted in search\n   * results.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    final Fields fields = reader.fields();\n    if (fields == null) {\n      // reader has no fields\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final Terms terms = fields.terms(query.field);\n    if (terms == null) {\n      // field does not exist\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n\n    final TermsEnum termsEnum = query.getTermsEnum(terms);\n    assert termsEnum != null;\n    if (termsEnum.next() != null) {\n      // fill into a OpenBitSet\n      final OpenBitSet bitSet = new OpenBitSet(reader.maxDoc());\n      int termCount = 0;\n      final Bits delDocs = reader.getDeletedDocs();\n      DocsEnum docsEnum = null;\n      do {\n        termCount++;\n        // System.out.println(\"  iter termCount=\" + termCount + \" term=\" +\n        // enumerator.term().toBytesString());\n        docsEnum = termsEnum.docs(delDocs, docsEnum);\n        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();\n        while (true) {\n          final int count = docsEnum.read();\n          if (count != 0) {\n            final int[] docs = result.docs.ints;\n            for (int i = 0; i < count; i++) {\n              bitSet.set(docs[i]);\n            }\n          } else {\n            break;\n          }\n        }\n      } while (termsEnum.next() != null);\n      // System.out.println(\"  done termCount=\" + termCount);\n\n      query.incTotalNumberOfTerms(termCount);\n      return bitSet;\n    } else {\n      return DocIdSet.EMPTY_DOCIDSET;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["3bb13258feba31ab676502787ab2e1779f129b7a","df3efec034da1483899681baabb1df029e8628c4"],"4f29ba80b723649f5feb7e37afe1a558dd2c1304":["28427ef110c4c5bf5b4057731b83110bd1e13724"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5f4e87790277826a2aea119328600dfb07761f32":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","e8dd2a69747e9f2922fd8b6970bd1661b26a692d"],"df3efec034da1483899681baabb1df029e8628c4":["e8dd2a69747e9f2922fd8b6970bd1661b26a692d"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["70ad682703b8585f5d0a637efec044d57ec05efb","2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["df3efec034da1483899681baabb1df029e8628c4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"28427ef110c4c5bf5b4057731b83110bd1e13724":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"e8dd2a69747e9f2922fd8b6970bd1661b26a692d":["4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"3bb13258feba31ab676502787ab2e1779f129b7a":["4f29ba80b723649f5feb7e37afe1a558dd2c1304","e8dd2a69747e9f2922fd8b6970bd1661b26a692d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"4f29ba80b723649f5feb7e37afe1a558dd2c1304":["5f4e87790277826a2aea119328600dfb07761f32","e8dd2a69747e9f2922fd8b6970bd1661b26a692d","3bb13258feba31ab676502787ab2e1779f129b7a"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5f4e87790277826a2aea119328600dfb07761f32","28427ef110c4c5bf5b4057731b83110bd1e13724"],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"df3efec034da1483899681baabb1df029e8628c4":["70ad682703b8585f5d0a637efec044d57ec05efb","2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"28427ef110c4c5bf5b4057731b83110bd1e13724":["4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"3bb13258feba31ab676502787ab2e1779f129b7a":["70ad682703b8585f5d0a637efec044d57ec05efb"],"e8dd2a69747e9f2922fd8b6970bd1661b26a692d":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","df3efec034da1483899681baabb1df029e8628c4","3bb13258feba31ab676502787ab2e1779f129b7a"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}