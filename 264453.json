{"path":"lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","pathOld":"src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // this isn't as useful as calling directly from the scope where the\n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    if (!uncaughtExceptions.isEmpty()) {\n      System.err.println(\"The following exceptions were thrown by threads:\");\n      for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n        System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n        entry.exception.printStackTrace(System.err);\n      }\n      fail(\"Some threads throwed uncaught exceptions!\");\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // this isn't as useful as calling directly from the scope where the\n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    if (!uncaughtExceptions.isEmpty()) {\n      System.err.println(\"The following exceptions were thrown by threads:\");\n      for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n        System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n        entry.exception.printStackTrace(System.err);\n      }\n      fail(\"Some threads throwed uncaught exceptions!\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98a8a68e6714cb8742c790308b9f5180d63417d4","date":1272554039,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // this isn't as useful as calling directly from the scope where the\n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      if (checkFieldCacheSanity)\n        assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    if (!uncaughtExceptions.isEmpty()) {\n      System.err.println(\"The following exceptions were thrown by threads:\");\n      for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n        System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n        entry.exception.printStackTrace(System.err);\n      }\n      fail(\"Some threads throwed uncaught exceptions!\");\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // this isn't as useful as calling directly from the scope where the\n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    if (!uncaughtExceptions.isEmpty()) {\n      System.err.println(\"The following exceptions were thrown by threads:\");\n      for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n        System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n        entry.exception.printStackTrace(System.err);\n      }\n      fail(\"Some threads throwed uncaught exceptions!\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a257b2b86880e14f69d8487adb032ad450f10866","date":1272675024,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    if (!uncaughtExceptions.isEmpty()) {\n      System.err.println(\"The following exceptions were thrown by threads:\");\n      for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n        System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n        entry.exception.printStackTrace(System.err);\n      }\n      fail(\"Some threads throwed uncaught exceptions!\");\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // this isn't as useful as calling directly from the scope where the\n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      if (checkFieldCacheSanity)\n        assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    if (!uncaughtExceptions.isEmpty()) {\n      System.err.println(\"The following exceptions were thrown by threads:\");\n      for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n        System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n        entry.exception.printStackTrace(System.err);\n      }\n      fail(\"Some threads throwed uncaught exceptions!\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71bf57f9fbd585ba127a996bec8e9afe5570b91c","date":1275648414,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    if (!uncaughtExceptions.isEmpty()) {\n      System.err.println(\"The following exceptions were thrown by threads:\");\n      for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n        System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n        entry.exception.printStackTrace(System.err);\n      }\n      fail(\"Some threads throwed uncaught exceptions!\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37087ea13c0fde1ce1a3b5579f60f827414045a9","date":1279206637,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    Assert.assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    Assert.assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43b04c27924fe393e38e9f0986e32c634f261859","date":1284399440,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","sourceNew":null,"sourceOld":"  @After\n  public void tearDown() throws Exception {\n    Assert.assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ca38aecd0204be91049ec782668f642a68d9935","date":1292975343,"type":4,"author":"Michael Busch","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","sourceNew":null,"sourceOld":"  @After\n  public void tearDown() throws Exception {\n    Assert.assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a257b2b86880e14f69d8487adb032ad450f10866":["98a8a68e6714cb8742c790308b9f5180d63417d4"],"71bf57f9fbd585ba127a996bec8e9afe5570b91c":["a257b2b86880e14f69d8487adb032ad450f10866"],"1ca38aecd0204be91049ec782668f642a68d9935":["5f4e87790277826a2aea119328600dfb07761f32"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"98a8a68e6714cb8742c790308b9f5180d63417d4":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5f4e87790277826a2aea119328600dfb07761f32":["71bf57f9fbd585ba127a996bec8e9afe5570b91c","37087ea13c0fde1ce1a3b5579f60f827414045a9"],"37087ea13c0fde1ce1a3b5579f60f827414045a9":["71bf57f9fbd585ba127a996bec8e9afe5570b91c"],"43b04c27924fe393e38e9f0986e32c634f261859":["37087ea13c0fde1ce1a3b5579f60f827414045a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["43b04c27924fe393e38e9f0986e32c634f261859"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a257b2b86880e14f69d8487adb032ad450f10866":["71bf57f9fbd585ba127a996bec8e9afe5570b91c"],"71bf57f9fbd585ba127a996bec8e9afe5570b91c":["5f4e87790277826a2aea119328600dfb07761f32","37087ea13c0fde1ce1a3b5579f60f827414045a9"],"1ca38aecd0204be91049ec782668f642a68d9935":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"98a8a68e6714cb8742c790308b9f5180d63417d4":["a257b2b86880e14f69d8487adb032ad450f10866"],"5f4e87790277826a2aea119328600dfb07761f32":["1ca38aecd0204be91049ec782668f642a68d9935"],"37087ea13c0fde1ce1a3b5579f60f827414045a9":["5f4e87790277826a2aea119328600dfb07761f32","43b04c27924fe393e38e9f0986e32c634f261859"],"43b04c27924fe393e38e9f0986e32c634f261859":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["98a8a68e6714cb8742c790308b9f5180d63417d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1ca38aecd0204be91049ec782668f642a68d9935","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}