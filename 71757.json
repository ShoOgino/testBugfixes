{"path":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#advanceRepeats(PhrasePositions,int).mjava","commits":[{"id":"c9ff635e6838a2facda02727dec5b77d9e64dc4c","date":1316672863,"type":0,"author":"Doron Cohen","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#advanceRepeats(PhrasePositions,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Advance repeating pps of an input (non-repeating) pp.\n   * Return a modified 'end' in case pp or its repeats exceeds original 'end'.\n   * \"Dirty\" trick: when there are repeats, modifies pp's position to that of \n   * least repeater of pp (needed when due to holes repeaters' positions are \"back\").\n   */\n  private int advanceRepeats(PhrasePositions pp, int end) throws IOException {\n    int repeatsEnd = end;\n    if (pp.position > repeatsEnd) {\n      repeatsEnd = pp.position;\n    }\n    if (!hasRepeats) {\n      return repeatsEnd;\n    }\n    int tpPos = tpPos(pp);\n    for (PhrasePositions pp2=pp.nextRepeating; pp2!=null; pp2=pp2.nextRepeating) {\n      while (tpPos(pp2) <= tpPos) {\n        if (!pp2.nextPosition()) {\n          return Integer.MIN_VALUE;\n        }\n      }\n      tpPos = tpPos(pp2);\n      if (pp2.position > repeatsEnd) {\n        repeatsEnd = pp2.position;\n      }\n      // \"dirty\" trick: with holes, given a pp, its repeating pp2 might have smaller position.\n      // so in order to have the right \"start\" in matchLength computation we fake pp.position.\n      // this relies on pp.nextPosition() not using pp.position.\n      if (pp2.position < pp.position) { \n        pp.position = pp2.position;     \n      }\n    }\n    return repeatsEnd;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#advanceRepeats(PhrasePositions,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#advanceRepeats(PhrasePositions,int).mjava","sourceNew":"  /**\n   * Advance repeating pps of an input (non-repeating) pp.\n   * Return a modified 'end' in case pp or its repeats exceeds original 'end'.\n   * \"Dirty\" trick: when there are repeats, modifies pp's position to that of \n   * least repeater of pp (needed when due to holes repeaters' positions are \"back\").\n   */\n  private int advanceRepeats(PhrasePositions pp, int end) throws IOException {\n    int repeatsEnd = end;\n    if (pp.position > repeatsEnd) {\n      repeatsEnd = pp.position;\n    }\n    if (!hasRepeats) {\n      return repeatsEnd;\n    }\n    int tpPos = tpPos(pp);\n    for (PhrasePositions pp2=pp.nextRepeating; pp2!=null; pp2=pp2.nextRepeating) {\n      while (tpPos(pp2) <= tpPos) {\n        if (!pp2.nextPosition()) {\n          return Integer.MIN_VALUE;\n        }\n      }\n      tpPos = tpPos(pp2);\n      if (pp2.position > repeatsEnd) {\n        repeatsEnd = pp2.position;\n      }\n      // \"dirty\" trick: with holes, given a pp, its repeating pp2 might have smaller position.\n      // so in order to have the right \"start\" in matchLength computation we fake pp.position.\n      // this relies on pp.nextPosition() not using pp.position.\n      if (pp2.position < pp.position) { \n        pp.position = pp2.position;     \n      }\n    }\n    return repeatsEnd;\n  }\n\n","sourceOld":"  /**\n   * Advance repeating pps of an input (non-repeating) pp.\n   * Return a modified 'end' in case pp or its repeats exceeds original 'end'.\n   * \"Dirty\" trick: when there are repeats, modifies pp's position to that of \n   * least repeater of pp (needed when due to holes repeaters' positions are \"back\").\n   */\n  private int advanceRepeats(PhrasePositions pp, int end) throws IOException {\n    int repeatsEnd = end;\n    if (pp.position > repeatsEnd) {\n      repeatsEnd = pp.position;\n    }\n    if (!hasRepeats) {\n      return repeatsEnd;\n    }\n    int tpPos = tpPos(pp);\n    for (PhrasePositions pp2=pp.nextRepeating; pp2!=null; pp2=pp2.nextRepeating) {\n      while (tpPos(pp2) <= tpPos) {\n        if (!pp2.nextPosition()) {\n          return Integer.MIN_VALUE;\n        }\n      }\n      tpPos = tpPos(pp2);\n      if (pp2.position > repeatsEnd) {\n        repeatsEnd = pp2.position;\n      }\n      // \"dirty\" trick: with holes, given a pp, its repeating pp2 might have smaller position.\n      // so in order to have the right \"start\" in matchLength computation we fake pp.position.\n      // this relies on pp.nextPosition() not using pp.position.\n      if (pp2.position < pp.position) { \n        pp.position = pp2.position;     \n      }\n    }\n    return repeatsEnd;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c9ff635e6838a2facda02727dec5b77d9e64dc4c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"c9ff635e6838a2facda02727dec5b77d9e64dc4c":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}