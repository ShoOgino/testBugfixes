{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnumFrame#scanToFloorFrame(long).mjava","commits":[{"id":"0cdf9cc6702d60334a616bd7db3ae91501d1dce7","date":1405858112,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnumFrame#scanToFloorFrame(long).mjava","pathOld":"/dev/null","sourceNew":"  // TODO: make this array'd so we can do bin search?\n  // likely not worth it?  need to measure how many\n  // floor blocks we \"typically\" get\n  public void scanToFloorFrame(long targetOrd) {\n    // System.out.println(\"  scanToFloorFrame targetOrd=\" + targetOrd + \" vs nextFloorTermOrd=\" + nextFloorTermOrd + \" numFollowFloorBlocks=\" + numFollowFloorBlocks + \" termOrdOrig=\" + termOrdOrig);\n\n    if (!isFloor || targetOrd < nextFloorTermOrd) {\n      return;\n    }\n\n    assert numFollowFloorBlocks != 0;\n    long lastFloorTermOrd = nextFloorTermOrd;\n\n    long newFP = fpOrig;\n    while (true) {\n      final long code = floorDataReader.readVLong();\n      newFP = fpOrig + (code >>> 1);\n      hasTerms = (code & 1) != 0;\n      // if (DEBUG) {\n      //    System.out.println(\"      label=\" + ((char) nextFloorLabel) + \" fp=\" + newFP + \" hasTerms?=\" + hasTerms + \" numFollowFloor=\" + numFollowFloorBlocks);\n      //  }\n            \n      isLastInFloor = numFollowFloorBlocks == 1;\n      numFollowFloorBlocks--;\n\n      lastFloorTermOrd = nextFloorTermOrd;\n\n      if (isLastInFloor) {\n        nextFloorLabel = 256;\n        nextFloorTermOrd = Long.MAX_VALUE;\n        // if (DEBUG) {\n        //    System.out.println(\"        stop!  last block nextFloorLabel=\" + ((char) nextFloorLabel));\n        //  }\n        break;\n      } else {\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        nextFloorTermOrd += floorDataReader.readVLong();\n        if (targetOrd < nextFloorTermOrd) {\n          // if (DEBUG) {\n          //    System.out.println(\"        stop!  nextFloorLabel=\" + ((char) nextFloorLabel));\n          //  }\n          break;\n        }\n      }\n    }\n    // System.out.println(\"  after: lastFloorTermOrd=\" + lastFloorTermOrd + \" newFP=\" + newFP + \" vs fp=\" + fp + \" lastFloorTermOrd=\" + lastFloorTermOrd);\n\n    if (newFP != fp) {\n      // Force re-load of the block:\n      // if (DEBUG) {\n      //    System.out.println(\"      force switch to fp=\" + newFP + \" oldFP=\" + fp);\n      //  }\n      nextEnt = -1;\n      termOrd = lastFloorTermOrd;\n      fp = newFP;\n    } else {\n      // if (DEBUG) {\n      //    System.out.println(\"      stay on same fp=\" + newFP);\n      //  }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"]},"commit2Childs":{"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}