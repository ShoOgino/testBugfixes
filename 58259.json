{"path":"lucene/core/src/java/org/apache/lucene/geo/Rectangle#axisLat(double,double).mjava","commits":[{"id":"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe","date":1459623422,"type":1,"author":"nknize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/Rectangle#axisLat(double,double).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRect#axisLat(double,double).mjava","sourceNew":"  /**\n   * Calculate the latitude of a circle's intersections with its bbox meridians.\n   * <p>\n   * <b>NOTE:</b> the returned value will be +/- {@link #AXISLAT_ERROR} of the actual value.\n   * @param centerLat The latitude of the circle center\n   * @param radiusMeters The radius of the circle in meters\n   * @return A latitude\n   */\n  public static double axisLat(double centerLat, double radiusMeters) {\n    // A spherical triangle with:\n    // r is the radius of the circle in radians\n    // l1 is the latitude of the circle center\n    // l2 is the latitude of the point at which the circle intersect's its bbox longitudes\n    // We know r is tangent to the bbox meridians at l2, therefore it is a right angle.\n    // So from the law of cosines, with the angle of l1 being 90, we have:\n    // cos(l1) = cos(r) * cos(l2) + sin(r) * sin(l2) * cos(90)\n    // The second part cancels out because cos(90) == 0, so we have:\n    // cos(l1) = cos(r) * cos(l2)\n    // Solving for l2, we get:\n    // l2 = acos( cos(l1) / cos(r) )\n    // We ensure r is in the range (0, PI/2) and l1 in the range (0, PI/2]. This means we\n    // cannot divide by 0, and we will always get a positive value in the range [0, 1) as\n    // the argument to arc cosine, resulting in a range (0, PI/2].\n    final double PIO2 = Math.PI / 2D;\n    double l1 = toRadians(centerLat);\n    double r = (radiusMeters + 7E-2) / EARTH_MEAN_RADIUS_METERS;\n\n    // if we are within radius range of a pole, the lat is the pole itself\n    if (Math.abs(l1) + r >= MAX_LAT_RADIANS) {\n      return centerLat >= 0 ? MAX_LAT_INCL : MIN_LAT_INCL;\n    }\n\n    // adjust l1 as distance from closest pole, to form a right triangle with bbox meridians\n    // and ensure it is in the range (0, PI/2]\n    l1 = centerLat >= 0 ? PIO2 - l1 : l1 + PIO2;\n\n    double l2 = Math.acos(Math.cos(l1) / Math.cos(r));\n    assert !Double.isNaN(l2);\n\n    // now adjust back to range [-pi/2, pi/2], ie latitude in radians\n    l2 = centerLat >= 0 ? PIO2 - l2 : l2 - PIO2;\n\n    return toDegrees(l2);\n  }\n\n","sourceOld":"  /**\n   * Calculate the latitude of a circle's intersections with its bbox meridians.\n   * <p>\n   * <b>NOTE:</b> the returned value will be +/- {@link #AXISLAT_ERROR} of the actual value.\n   * @param centerLat The latitude of the circle center\n   * @param radiusMeters The radius of the circle in meters\n   * @return A latitude\n   */\n  public static double axisLat(double centerLat, double radiusMeters) {\n    // A spherical triangle with:\n    // r is the radius of the circle in radians\n    // l1 is the latitude of the circle center\n    // l2 is the latitude of the point at which the circle intersect's its bbox longitudes\n    // We know r is tangent to the bbox meridians at l2, therefore it is a right angle.\n    // So from the law of cosines, with the angle of l1 being 90, we have:\n    // cos(l1) = cos(r) * cos(l2) + sin(r) * sin(l2) * cos(90)\n    // The second part cancels out because cos(90) == 0, so we have:\n    // cos(l1) = cos(r) * cos(l2)\n    // Solving for l2, we get:\n    // l2 = acos( cos(l1) / cos(r) )\n    // We ensure r is in the range (0, PI/2) and l1 in the range (0, PI/2]. This means we\n    // cannot divide by 0, and we will always get a positive value in the range [0, 1) as\n    // the argument to arc cosine, resulting in a range (0, PI/2].\n    final double PIO2 = Math.PI / 2D;\n    double l1 = toRadians(centerLat);\n    double r = (radiusMeters + 7E-2) / EARTH_MEAN_RADIUS_METERS;\n\n    // if we are within radius range of a pole, the lat is the pole itself\n    if (Math.abs(l1) + r >= MAX_LAT_RADIANS) {\n      return centerLat >= 0 ? MAX_LAT_INCL : MIN_LAT_INCL;\n    }\n\n    // adjust l1 as distance from closest pole, to form a right triangle with bbox meridians\n    // and ensure it is in the range (0, PI/2]\n    l1 = centerLat >= 0 ? PIO2 - l1 : l1 + PIO2;\n\n    double l2 = Math.acos(Math.cos(l1) / Math.cos(r));\n    assert !Double.isNaN(l2);\n\n    // now adjust back to range [-pi/2, pi/2], ie latitude in radians\n    l2 = centerLat >= 0 ? PIO2 - l2 : l2 - PIO2;\n\n    return toDegrees(l2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71a92b21a4564a0dd5e0559cebf435a5fe34542e","date":1573666298,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/Rectangle#axisLat(double,double).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/geo/Rectangle#axisLat(double,double).mjava","sourceNew":"  /**\n   * Calculate the latitude of a circle's intersections with its bbox meridians.\n   * <p>\n   * <b>NOTE:</b> the returned value will be +/- {@link #AXISLAT_ERROR} of the actual value.\n   * @param centerLat The latitude of the circle center\n   * @param radiusMeters The radius of the circle in meters\n   * @return A latitude\n   */\n  public static double axisLat(double centerLat, double radiusMeters) {\n    // A spherical triangle with:\n    // r is the radius of the circle in radians\n    // l1 is the latitude of the circle center\n    // l2 is the latitude of the point at which the circle intersect's its bbox longitudes\n    // We know r is tangent to the bbox meridians at l2, therefore it is a right angle.\n    // So from the law of cosines, with the angle of l1 being 90, we have:\n    // cos(l1) = cos(r) * cos(l2) + sin(r) * sin(l2) * cos(90)\n    // The second part cancels out because cos(90) == 0, so we have:\n    // cos(l1) = cos(r) * cos(l2)\n    // Solving for l2, we get:\n    // l2 = acos( cos(l1) / cos(r) )\n    // We ensure r is in the range (0, PI/2) and l1 in the range (0, PI/2]. This means we\n    // cannot divide by 0, and we will always get a positive value in the range [0, 1) as\n    // the argument to arc cosine, resulting in a range (0, PI/2].\n    final double PIO2 = Math.PI / 2D;\n    double l1 = Math.toRadians(centerLat);\n    double r = (radiusMeters + 7E-2) / EARTH_MEAN_RADIUS_METERS;\n\n    // if we are within radius range of a pole, the lat is the pole itself\n    if (Math.abs(l1) + r >= MAX_LAT_RADIANS) {\n      return centerLat >= 0 ? MAX_LAT_INCL : MIN_LAT_INCL;\n    }\n\n    // adjust l1 as distance from closest pole, to form a right triangle with bbox meridians\n    // and ensure it is in the range (0, PI/2]\n    l1 = centerLat >= 0 ? PIO2 - l1 : l1 + PIO2;\n\n    double l2 = Math.acos(Math.cos(l1) / Math.cos(r));\n    assert !Double.isNaN(l2);\n\n    // now adjust back to range [-pi/2, pi/2], ie latitude in radians\n    l2 = centerLat >= 0 ? PIO2 - l2 : l2 - PIO2;\n\n    return Math.toDegrees(l2);\n  }\n\n","sourceOld":"  /**\n   * Calculate the latitude of a circle's intersections with its bbox meridians.\n   * <p>\n   * <b>NOTE:</b> the returned value will be +/- {@link #AXISLAT_ERROR} of the actual value.\n   * @param centerLat The latitude of the circle center\n   * @param radiusMeters The radius of the circle in meters\n   * @return A latitude\n   */\n  public static double axisLat(double centerLat, double radiusMeters) {\n    // A spherical triangle with:\n    // r is the radius of the circle in radians\n    // l1 is the latitude of the circle center\n    // l2 is the latitude of the point at which the circle intersect's its bbox longitudes\n    // We know r is tangent to the bbox meridians at l2, therefore it is a right angle.\n    // So from the law of cosines, with the angle of l1 being 90, we have:\n    // cos(l1) = cos(r) * cos(l2) + sin(r) * sin(l2) * cos(90)\n    // The second part cancels out because cos(90) == 0, so we have:\n    // cos(l1) = cos(r) * cos(l2)\n    // Solving for l2, we get:\n    // l2 = acos( cos(l1) / cos(r) )\n    // We ensure r is in the range (0, PI/2) and l1 in the range (0, PI/2]. This means we\n    // cannot divide by 0, and we will always get a positive value in the range [0, 1) as\n    // the argument to arc cosine, resulting in a range (0, PI/2].\n    final double PIO2 = Math.PI / 2D;\n    double l1 = toRadians(centerLat);\n    double r = (radiusMeters + 7E-2) / EARTH_MEAN_RADIUS_METERS;\n\n    // if we are within radius range of a pole, the lat is the pole itself\n    if (Math.abs(l1) + r >= MAX_LAT_RADIANS) {\n      return centerLat >= 0 ? MAX_LAT_INCL : MIN_LAT_INCL;\n    }\n\n    // adjust l1 as distance from closest pole, to form a right triangle with bbox meridians\n    // and ensure it is in the range (0, PI/2]\n    l1 = centerLat >= 0 ? PIO2 - l1 : l1 + PIO2;\n\n    double l2 = Math.acos(Math.cos(l1) / Math.cos(r));\n    assert !Double.isNaN(l2);\n\n    // now adjust back to range [-pi/2, pi/2], ie latitude in radians\n    l2 = centerLat >= 0 ? PIO2 - l2 : l2 - PIO2;\n\n    return toDegrees(l2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"71a92b21a4564a0dd5e0559cebf435a5fe34542e":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["71a92b21a4564a0dd5e0559cebf435a5fe34542e"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["71a92b21a4564a0dd5e0559cebf435a5fe34542e"],"71a92b21a4564a0dd5e0559cebf435a5fe34542e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}