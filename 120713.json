{"path":"solr/core/src/test/org/apache/solr/cloud/api/collections/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","sourceNew":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getProperty(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","sourceOld":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getProperty(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","sourceNew":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getProperty(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","sourceOld":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getProperty(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}