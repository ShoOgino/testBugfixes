{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int,String).mjava","commits":[{"id":"a67285d1a68175d877eb9fd1624fccad3db028ff","date":1402779028,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toLightAutomaton(int).mjava","sourceNew":"  public LightAutomaton toAutomaton(int n, String prefix) {\n    assert prefix != null;\n    if (n == 0) {\n      return BasicAutomata.makeStringLight(prefix + UnicodeUtil.newString(word, 0, word.length));\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    LightAutomaton a = new LightAutomaton();\n    int lastState;\n    if (prefix != null) {\n      // Insert prefix\n      lastState = a.createState();\n      for (int i = 0, cp = 0; i < prefix.length(); i += Character.charCount(cp)) {\n        int state = a.createState();\n        cp = prefix.codePointAt(i);\n        a.addTransition(lastState, state, cp, cp);\n        lastState = state;\n      }\n    } else {\n      lastState = a.createState();\n    }\n\n    // nocommit why are so many dead states created here?\n\n    int stateOffset = lastState;\n    a.setAccept(lastState, description.isAccept(0));\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 1; i < numStates; i++) {\n      int state = a.createState();\n      a.setAccept(state, description.isAccept(i));\n    }\n\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          // nocommit why do we create cycles in dead states?\n          if (k != dest) {\n            a.addTransition(stateOffset+k, stateOffset+dest, ch);\n          }\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          // nocommit why do we create cycles in dead states?\n          if (k != dest) {\n            a.addTransition(stateOffset+k, stateOffset+dest, rangeLower[r], rangeUpper[r]);\n          }\n        }\n      }\n    }\n\n    a.finish();\n    assert a.isDeterministic();\n    return a;\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public LightAutomaton toLightAutomaton(int n) {\n    if (n == 0) {\n      return BasicAutomata.makeStringLight(word, 0, word.length);\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    LightAutomaton a = new LightAutomaton();\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < numStates; i++) {\n      a.createState();\n      a.setAccept(i, description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          a.addTransition(k, dest, ch);\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          a.addTransition(k, dest, rangeLower[r], rangeUpper[r]);\n        }\n      }\n    }\n\n    a.finish();\n\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9","date":1402946522,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int,String).mjava","sourceNew":"  public LightAutomaton toAutomaton(int n, String prefix) {\n    assert prefix != null;\n    if (n == 0) {\n      return BasicAutomata.makeStringLight(prefix + UnicodeUtil.newString(word, 0, word.length));\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    LightAutomaton a = new LightAutomaton();\n    int lastState;\n    if (prefix != null) {\n      // Insert prefix\n      lastState = a.createState();\n      for (int i = 0, cp = 0; i < prefix.length(); i += Character.charCount(cp)) {\n        int state = a.createState();\n        cp = prefix.codePointAt(i);\n        a.addTransition(lastState, state, cp, cp);\n        lastState = state;\n      }\n    } else {\n      lastState = a.createState();\n    }\n\n    int stateOffset = lastState;\n    a.setAccept(lastState, description.isAccept(0));\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 1; i < numStates; i++) {\n      int state = a.createState();\n      a.setAccept(state, description.isAccept(i));\n    }\n\n    // TODO: this creates bogus states/transitions (states are final, have self loops, and can't be reached from an init state)\n\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          a.addTransition(stateOffset+k, stateOffset+dest, ch);\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          a.addTransition(stateOffset+k, stateOffset+dest, rangeLower[r], rangeUpper[r]);\n        }\n      }\n    }\n\n    a.finishState();\n    assert a.isDeterministic();\n    return a;\n  }\n\n","sourceOld":"  public LightAutomaton toAutomaton(int n, String prefix) {\n    assert prefix != null;\n    if (n == 0) {\n      return BasicAutomata.makeStringLight(prefix + UnicodeUtil.newString(word, 0, word.length));\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    LightAutomaton a = new LightAutomaton();\n    int lastState;\n    if (prefix != null) {\n      // Insert prefix\n      lastState = a.createState();\n      for (int i = 0, cp = 0; i < prefix.length(); i += Character.charCount(cp)) {\n        int state = a.createState();\n        cp = prefix.codePointAt(i);\n        a.addTransition(lastState, state, cp, cp);\n        lastState = state;\n      }\n    } else {\n      lastState = a.createState();\n    }\n\n    // nocommit why are so many dead states created here?\n\n    int stateOffset = lastState;\n    a.setAccept(lastState, description.isAccept(0));\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 1; i < numStates; i++) {\n      int state = a.createState();\n      a.setAccept(state, description.isAccept(i));\n    }\n\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          // nocommit why do we create cycles in dead states?\n          if (k != dest) {\n            a.addTransition(stateOffset+k, stateOffset+dest, ch);\n          }\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          // nocommit why do we create cycles in dead states?\n          if (k != dest) {\n            a.addTransition(stateOffset+k, stateOffset+dest, rangeLower[r], rangeUpper[r]);\n          }\n        }\n      }\n    }\n\n    a.finish();\n    assert a.isDeterministic();\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int,String).mjava","sourceNew":"  public Automaton toAutomaton(int n, String prefix) {\n    assert prefix != null;\n    if (n == 0) {\n      return Automata.makeString(prefix + UnicodeUtil.newString(word, 0, word.length));\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    Automaton a = new Automaton();\n    int lastState;\n    if (prefix != null) {\n      // Insert prefix\n      lastState = a.createState();\n      for (int i = 0, cp = 0; i < prefix.length(); i += Character.charCount(cp)) {\n        int state = a.createState();\n        cp = prefix.codePointAt(i);\n        a.addTransition(lastState, state, cp, cp);\n        lastState = state;\n      }\n    } else {\n      lastState = a.createState();\n    }\n\n    int stateOffset = lastState;\n    a.setAccept(lastState, description.isAccept(0));\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 1; i < numStates; i++) {\n      int state = a.createState();\n      a.setAccept(state, description.isAccept(i));\n    }\n\n    // TODO: this creates bogus states/transitions (states are final, have self loops, and can't be reached from an init state)\n\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          a.addTransition(stateOffset+k, stateOffset+dest, ch);\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          a.addTransition(stateOffset+k, stateOffset+dest, rangeLower[r], rangeUpper[r]);\n        }\n      }\n    }\n\n    a.finishState();\n    assert a.isDeterministic();\n    return a;\n  }\n\n","sourceOld":"  public LightAutomaton toAutomaton(int n, String prefix) {\n    assert prefix != null;\n    if (n == 0) {\n      return BasicAutomata.makeStringLight(prefix + UnicodeUtil.newString(word, 0, word.length));\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    LightAutomaton a = new LightAutomaton();\n    int lastState;\n    if (prefix != null) {\n      // Insert prefix\n      lastState = a.createState();\n      for (int i = 0, cp = 0; i < prefix.length(); i += Character.charCount(cp)) {\n        int state = a.createState();\n        cp = prefix.codePointAt(i);\n        a.addTransition(lastState, state, cp, cp);\n        lastState = state;\n      }\n    } else {\n      lastState = a.createState();\n    }\n\n    int stateOffset = lastState;\n    a.setAccept(lastState, description.isAccept(0));\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 1; i < numStates; i++) {\n      int state = a.createState();\n      a.setAccept(state, description.isAccept(i));\n    }\n\n    // TODO: this creates bogus states/transitions (states are final, have self loops, and can't be reached from an init state)\n\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          a.addTransition(stateOffset+k, stateOffset+dest, ch);\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          a.addTransition(stateOffset+k, stateOffset+dest, rangeLower[r], rangeUpper[r]);\n        }\n      }\n    }\n\n    a.finishState();\n    assert a.isDeterministic();\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bab620c8ab32bb77a62753eca4afb8e47efa87c","date":1402997861,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int,String).mjava","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>,\n   * matching the specified exact prefix.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n, String prefix) {\n    assert prefix != null;\n    if (n == 0) {\n      return Automata.makeString(prefix + UnicodeUtil.newString(word, 0, word.length));\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    Automaton a = new Automaton();\n    int lastState;\n    if (prefix != null) {\n      // Insert prefix\n      lastState = a.createState();\n      for (int i = 0, cp = 0; i < prefix.length(); i += Character.charCount(cp)) {\n        int state = a.createState();\n        cp = prefix.codePointAt(i);\n        a.addTransition(lastState, state, cp, cp);\n        lastState = state;\n      }\n    } else {\n      lastState = a.createState();\n    }\n\n    int stateOffset = lastState;\n    a.setAccept(lastState, description.isAccept(0));\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 1; i < numStates; i++) {\n      int state = a.createState();\n      a.setAccept(state, description.isAccept(i));\n    }\n\n    // TODO: this creates bogus states/transitions (states are final, have self loops, and can't be reached from an init state)\n\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          a.addTransition(stateOffset+k, stateOffset+dest, ch);\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          a.addTransition(stateOffset+k, stateOffset+dest, rangeLower[r], rangeUpper[r]);\n        }\n      }\n    }\n\n    a.finishState();\n    assert a.isDeterministic();\n    return a;\n  }\n\n","sourceOld":"  public Automaton toAutomaton(int n, String prefix) {\n    assert prefix != null;\n    if (n == 0) {\n      return Automata.makeString(prefix + UnicodeUtil.newString(word, 0, word.length));\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    Automaton a = new Automaton();\n    int lastState;\n    if (prefix != null) {\n      // Insert prefix\n      lastState = a.createState();\n      for (int i = 0, cp = 0; i < prefix.length(); i += Character.charCount(cp)) {\n        int state = a.createState();\n        cp = prefix.codePointAt(i);\n        a.addTransition(lastState, state, cp, cp);\n        lastState = state;\n      }\n    } else {\n      lastState = a.createState();\n    }\n\n    int stateOffset = lastState;\n    a.setAccept(lastState, description.isAccept(0));\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 1; i < numStates; i++) {\n      int state = a.createState();\n      a.setAccept(state, description.isAccept(i));\n    }\n\n    // TODO: this creates bogus states/transitions (states are final, have self loops, and can't be reached from an init state)\n\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          a.addTransition(stateOffset+k, stateOffset+dest, ch);\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          a.addTransition(stateOffset+k, stateOffset+dest, rangeLower[r], rangeUpper[r]);\n        }\n      }\n    }\n\n    a.finishState();\n    assert a.isDeterministic();\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>,\n   * matching the specified exact prefix.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n, String prefix) {\n    assert prefix != null;\n    if (n == 0) {\n      return Automata.makeString(prefix + UnicodeUtil.newString(word, 0, word.length));\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    Automaton a = new Automaton();\n    int lastState;\n    if (prefix != null) {\n      // Insert prefix\n      lastState = a.createState();\n      for (int i = 0, cp = 0; i < prefix.length(); i += Character.charCount(cp)) {\n        int state = a.createState();\n        cp = prefix.codePointAt(i);\n        a.addTransition(lastState, state, cp, cp);\n        lastState = state;\n      }\n    } else {\n      lastState = a.createState();\n    }\n\n    int stateOffset = lastState;\n    a.setAccept(lastState, description.isAccept(0));\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 1; i < numStates; i++) {\n      int state = a.createState();\n      a.setAccept(state, description.isAccept(i));\n    }\n\n    // TODO: this creates bogus states/transitions (states are final, have self loops, and can't be reached from an init state)\n\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          a.addTransition(stateOffset+k, stateOffset+dest, ch);\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          a.addTransition(stateOffset+k, stateOffset+dest, rangeLower[r], rangeUpper[r]);\n        }\n      }\n    }\n\n    a.finishState();\n    assert a.isDeterministic();\n    return a;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14600834a1fbc7c12faf344466e00cca8cc67de4","date":1423303834,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int,String).mjava","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>,\n   * matching the specified exact prefix.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   */\n  public Automaton toAutomaton(int n, String prefix) {\n    assert prefix != null;\n    if (n == 0) {\n      return Automata.makeString(prefix + UnicodeUtil.newString(word, 0, word.length));\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    Automaton a = new Automaton();\n    int lastState;\n    if (prefix != null) {\n      // Insert prefix\n      lastState = a.createState();\n      for (int i = 0, cp = 0; i < prefix.length(); i += Character.charCount(cp)) {\n        int state = a.createState();\n        cp = prefix.codePointAt(i);\n        a.addTransition(lastState, state, cp, cp);\n        lastState = state;\n      }\n    } else {\n      lastState = a.createState();\n    }\n\n    int stateOffset = lastState;\n    a.setAccept(lastState, description.isAccept(0));\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 1; i < numStates; i++) {\n      int state = a.createState();\n      a.setAccept(state, description.isAccept(i));\n    }\n\n    // TODO: this creates bogus states/transitions (states are final, have self loops, and can't be reached from an init state)\n\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          a.addTransition(stateOffset+k, stateOffset+dest, ch);\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          a.addTransition(stateOffset+k, stateOffset+dest, rangeLower[r], rangeUpper[r]);\n        }\n      }\n    }\n\n    a.finishState();\n    assert a.isDeterministic();\n    return a;\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>,\n   * matching the specified exact prefix.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n, String prefix) {\n    assert prefix != null;\n    if (n == 0) {\n      return Automata.makeString(prefix + UnicodeUtil.newString(word, 0, word.length));\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    Automaton a = new Automaton();\n    int lastState;\n    if (prefix != null) {\n      // Insert prefix\n      lastState = a.createState();\n      for (int i = 0, cp = 0; i < prefix.length(); i += Character.charCount(cp)) {\n        int state = a.createState();\n        cp = prefix.codePointAt(i);\n        a.addTransition(lastState, state, cp, cp);\n        lastState = state;\n      }\n    } else {\n      lastState = a.createState();\n    }\n\n    int stateOffset = lastState;\n    a.setAccept(lastState, description.isAccept(0));\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 1; i < numStates; i++) {\n      int state = a.createState();\n      a.setAccept(state, description.isAccept(i));\n    }\n\n    // TODO: this creates bogus states/transitions (states are final, have self loops, and can't be reached from an init state)\n\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          a.addTransition(stateOffset+k, stateOffset+dest, ch);\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          a.addTransition(stateOffset+k, stateOffset+dest, rangeLower[r], rangeUpper[r]);\n        }\n      }\n    }\n\n    a.finishState();\n    assert a.isDeterministic();\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5298b00b07db6c1a9607c196a0dd1e07f7f8a3bc","date":1521731429,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int,String).mjava","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>,\n   * matching the specified exact prefix.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   */\n  public Automaton toAutomaton(int n, String prefix) {\n    assert prefix != null;\n    if (n == 0) {\n      return Automata.makeString(prefix + UnicodeUtil.newString(word, 0, word.length));\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    final int numStates = description.size();\n    final int numTransitions = numStates * Math.min(1 + 2 * n, alphabet.length);\n    final int prefixStates = prefix != null ? prefix.codePointCount(0, prefix.length()) : 0;\n\n    final Automaton a = new Automaton(numStates + prefixStates, numTransitions);\n    int lastState;\n    if (prefix != null) {\n      // Insert prefix\n      lastState = a.createState();\n      for (int i = 0, cp = 0; i < prefix.length(); i += Character.charCount(cp)) {\n        int state = a.createState();\n        cp = prefix.codePointAt(i);\n        a.addTransition(lastState, state, cp, cp);\n        lastState = state;\n      }\n    } else {\n      lastState = a.createState();\n    }\n\n    int stateOffset = lastState;\n    a.setAccept(lastState, description.isAccept(0));\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 1; i < numStates; i++) {\n      int state = a.createState();\n      a.setAccept(state, description.isAccept(i));\n    }\n\n    // TODO: this creates bogus states/transitions (states are final, have self loops, and can't be reached from an init state)\n\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          a.addTransition(stateOffset+k, stateOffset+dest, ch);\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          a.addTransition(stateOffset+k, stateOffset+dest, rangeLower[r], rangeUpper[r]);\n        }\n      }\n    }\n\n    a.finishState();\n    assert a.isDeterministic();\n    return a;\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>,\n   * matching the specified exact prefix.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   */\n  public Automaton toAutomaton(int n, String prefix) {\n    assert prefix != null;\n    if (n == 0) {\n      return Automata.makeString(prefix + UnicodeUtil.newString(word, 0, word.length));\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    Automaton a = new Automaton();\n    int lastState;\n    if (prefix != null) {\n      // Insert prefix\n      lastState = a.createState();\n      for (int i = 0, cp = 0; i < prefix.length(); i += Character.charCount(cp)) {\n        int state = a.createState();\n        cp = prefix.codePointAt(i);\n        a.addTransition(lastState, state, cp, cp);\n        lastState = state;\n      }\n    } else {\n      lastState = a.createState();\n    }\n\n    int stateOffset = lastState;\n    a.setAccept(lastState, description.isAccept(0));\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 1; i < numStates; i++) {\n      int state = a.createState();\n      a.setAccept(state, description.isAccept(i));\n    }\n\n    // TODO: this creates bogus states/transitions (states are final, have self loops, and can't be reached from an init state)\n\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          a.addTransition(stateOffset+k, stateOffset+dest, ch);\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          a.addTransition(stateOffset+k, stateOffset+dest, rangeLower[r], rangeUpper[r]);\n        }\n      }\n    }\n\n    a.finishState();\n    assert a.isDeterministic();\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6bab620c8ab32bb77a62753eca4afb8e47efa87c":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["a67285d1a68175d877eb9fd1624fccad3db028ff"],"5298b00b07db6c1a9607c196a0dd1e07f7f8a3bc":["14600834a1fbc7c12faf344466e00cca8cc67de4"],"a67285d1a68175d877eb9fd1624fccad3db028ff":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"14600834a1fbc7c12faf344466e00cca8cc67de4":["5c84485629d80d203608e8975a1139de9933cc38"],"5c84485629d80d203608e8975a1139de9933cc38":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6bab620c8ab32bb77a62753eca4afb8e47efa87c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5298b00b07db6c1a9607c196a0dd1e07f7f8a3bc"]},"commit2Childs":{"6bab620c8ab32bb77a62753eca4afb8e47efa87c":["5c84485629d80d203608e8975a1139de9933cc38"],"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"a67285d1a68175d877eb9fd1624fccad3db028ff":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"5298b00b07db6c1a9607c196a0dd1e07f7f8a3bc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["6bab620c8ab32bb77a62753eca4afb8e47efa87c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a67285d1a68175d877eb9fd1624fccad3db028ff","5c84485629d80d203608e8975a1139de9933cc38"],"14600834a1fbc7c12faf344466e00cca8cc67de4":["5298b00b07db6c1a9607c196a0dd1e07f7f8a3bc"],"5c84485629d80d203608e8975a1139de9933cc38":["14600834a1fbc7c12faf344466e00cca8cc67de4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}