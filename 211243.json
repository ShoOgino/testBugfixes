{"path":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!delegate.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = delegate.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput in = delegate.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(in, in.length()/2);\n        tempOut.close();\n        in.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        in = delegate.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(in, in.length());\n        out.close();\n        in.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!delegate.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = delegate.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput in = delegate.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(in, in.length()/2);\n        tempOut.close();\n        in.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        in = delegate.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(in, in.length());\n        out.close();\n        in.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d19974432be9aed28ee7dca73bdf01d139e763a9","date":1342822166,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!delegate.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = delegate.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = delegate.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = delegate.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!delegate.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = delegate.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput in = delegate.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(in, in.length()/2);\n        tempOut.close();\n        in.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        in = delegate.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(in, in.length());\n        out.close();\n        in.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":["f592e183306e8e4efabf3e7e08d3e709c9b97dbb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!delegate.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = delegate.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = delegate.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = delegate.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!delegate.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = delegate.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput in = delegate.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(in, in.length()/2);\n        tempOut.close();\n        in.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        in = delegate.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(in, in.length());\n        out.close();\n        in.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!delegate.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = delegate.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = delegate.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = delegate.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!delegate.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = delegate.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput in = delegate.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(in, in.length()/2);\n        tempOut.close();\n        in.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        in = delegate.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(in, in.length());\n        out.close();\n        in.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9eae2a56dc810a17cf807d831f720dec931a03de","date":1349262073,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!delegate.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = delegate.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = delegate.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = delegate.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!delegate.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = delegate.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = delegate.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = delegate.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"399ef3ff6c22f0627c82ac65f32726f3587a2aa1","date":1379005174,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!in.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!delegate.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = delegate.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = delegate.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = delegate.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!in.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!in.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd4e13d997cf4fb810398a20a299c2c5a9f6b796","date":1395594336,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!in.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46885bf5f669268ac6235cce5c62fdd68b4e490c","date":1397242003,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() {\n    crashed = true;\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    corruptFiles(unSyncedFiles);\n    unSyncedFiles = new HashSet<>();\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFiles(Collections.singleton(name));\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFiles(Collections.singleton(name));\n        \n        try(IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n          out.copyBytes(ii, ii.length());\n          ii.close();\n        } catch (IOException ioe) {\n          // VirusCheckingFS may have blocked the delete, at which point FSDir cannot overwrite here\n          if (ioe.getMessage().equals(\"file \\\"\" + name + \"\\\" is pending delete and cannot be overwritten\")) {\n            // OK\n            action = \"deleted\";\n          } else {\n            throw ioe;\n          }\n        }\n        deleteFiles(Collections.singleton(tempFileName));\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFiles(Collections.singleton(name));\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        } catch (IOException ioe) {\n          // VirusCheckingFS may have blocked the delete, at which point FSDir cannot overwrite here\n          if (ioe.getMessage().equals(\"file \\\"\" + name + \"\\\" is pending delete and cannot be overwritten\")) {\n            // OK\n            action = \"deleted\";\n          } else {\n            throw ioe;\n          }\n        }\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n    crashed = true;\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","date":1454513757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name);\n        \n        try(IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n          out.copyBytes(ii, ii.length());\n          ii.close();\n        } catch (IOException ioe) {\n          // VirusCheckingFS may have blocked the delete, at which point FSDir cannot overwrite here\n          if (ioe.getMessage().equals(\"file \\\"\" + name + \"\\\" is pending delete and cannot be overwritten\")) {\n            // OK\n            action = \"deleted\";\n          } else {\n            throw ioe;\n          }\n        }\n        deleteFile(tempFileName);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        } catch (IOException ioe) {\n          // VirusCheckingFS may have blocked the delete, at which point FSDir cannot overwrite here\n          if (ioe.getMessage().equals(\"file \\\"\" + name + \"\\\" is pending delete and cannot be overwritten\")) {\n            // OK\n            action = \"deleted\";\n          } else {\n            throw ioe;\n          }\n        }\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n    crashed = true;\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFiles(Collections.singleton(name));\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFiles(Collections.singleton(name));\n        \n        try(IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n          out.copyBytes(ii, ii.length());\n          ii.close();\n        } catch (IOException ioe) {\n          // VirusCheckingFS may have blocked the delete, at which point FSDir cannot overwrite here\n          if (ioe.getMessage().equals(\"file \\\"\" + name + \"\\\" is pending delete and cannot be overwritten\")) {\n            // OK\n            action = \"deleted\";\n          } else {\n            throw ioe;\n          }\n        }\n        deleteFiles(Collections.singleton(tempFileName));\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFiles(Collections.singleton(name));\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        } catch (IOException ioe) {\n          // VirusCheckingFS may have blocked the delete, at which point FSDir cannot overwrite here\n          if (ioe.getMessage().equals(\"file \\\"\" + name + \"\\\" is pending delete and cannot be overwritten\")) {\n            // OK\n            action = \"deleted\";\n          } else {\n            throw ioe;\n          }\n        }\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n    crashed = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34d6426cef006e0c3625cabe7a7ec1c2b08bc501","date":1454683374,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n\n    // Maybe disable virus checker so it doesn't interfere with our efforts to corrupt files below:\n    boolean virusCheckerWasEnabled = TestUtil.disableVirusChecker(in);\n\n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name);\n        \n        try(IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n          out.copyBytes(ii, ii.length());\n          ii.close();\n        }\n        deleteFile(tempFileName);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        }\n      }\n      // Re-enable\n      if (virusCheckerWasEnabled) {\n        TestUtil.enableVirusChecker(in);\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n    crashed = true;\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name);\n        \n        try(IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n          out.copyBytes(ii, ii.length());\n          ii.close();\n        } catch (IOException ioe) {\n          // VirusCheckingFS may have blocked the delete, at which point FSDir cannot overwrite here\n          if (ioe.getMessage().equals(\"file \\\"\" + name + \"\\\" is pending delete and cannot be overwritten\")) {\n            // OK\n            action = \"deleted\";\n          } else {\n            throw ioe;\n          }\n        }\n        deleteFile(tempFileName);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        } catch (IOException ioe) {\n          // VirusCheckingFS may have blocked the delete, at which point FSDir cannot overwrite here\n          if (ioe.getMessage().equals(\"file \\\"\" + name + \"\\\" is pending delete and cannot be overwritten\")) {\n            // OK\n            action = \"deleted\";\n          } else {\n            throw ioe;\n          }\n        }\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n    crashed = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n\n    // Maybe disable virus checker so it doesn't interfere with our efforts to corrupt files below:\n    boolean virusCheckerWasEnabled = TestUtil.disableVirusChecker(in);\n\n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name);\n        \n        try(IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n          out.copyBytes(ii, ii.length());\n          ii.close();\n        }\n        deleteFile(tempFileName);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        }\n      }\n      // Re-enable\n      if (virusCheckerWasEnabled) {\n        TestUtil.enableVirusChecker(in);\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n    crashed = true;\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    corruptFiles(unSyncedFiles);\n    unSyncedFiles = new HashSet<>();\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() {\n    crashed = true;\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    corruptFiles(unSyncedFiles);\n    unSyncedFiles = new HashSet<>();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n\n    // Maybe disable virus checker so it doesn't interfere with our efforts to corrupt files below:\n    boolean virusCheckerWasEnabled = TestUtil.disableVirusChecker(in);\n\n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name);\n        \n        try(IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n          out.copyBytes(ii, ii.length());\n          ii.close();\n        }\n        deleteFile(tempFileName);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        }\n      }\n      // Re-enable\n      if (virusCheckerWasEnabled) {\n        TestUtil.enableVirusChecker(in);\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n    crashed = true;\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(ii, ii.length());\n        out.close();\n        ii.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a8ec0889b27701f0ad90a25c95b75454e898cf3","date":1454871481,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    corruptFiles(unSyncedFiles);\n    crashed = true;\n    unSyncedFiles = new HashSet<>();\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    corruptFiles(unSyncedFiles);\n    unSyncedFiles = new HashSet<>();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n    corruptFiles(unSyncedFiles);\n    crashed = true;\n    unSyncedFiles = new HashSet<>();\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    openFiles = new HashMap<>();\n    openFilesForWrite = new HashSet<>();\n    openFilesDeleted = new HashSet<>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);\n    for (Closeable f : m.keySet()) {\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    }\n\n    // Maybe disable virus checker so it doesn't interfere with our efforts to corrupt files below:\n    boolean virusCheckerWasEnabled = TestUtil.disableVirusChecker(in);\n\n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(ii, ii.length()/2);\n        tempOut.close();\n        ii.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name);\n        \n        try(IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n          out.copyBytes(ii, ii.length());\n          ii.close();\n        }\n        deleteFile(tempFileName);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        }\n      }\n      // Re-enable\n      if (virusCheckerWasEnabled) {\n        TestUtil.enableVirusChecker(in);\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n    crashed = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"34d6426cef006e0c3625cabe7a7ec1c2b08bc501":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"4a8ec0889b27701f0ad90a25c95b75454e898cf3":["1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["399ef3ff6c22f0627c82ac65f32726f3587a2aa1"],"9eae2a56dc810a17cf807d831f720dec931a03de":["d19974432be9aed28ee7dca73bdf01d139e763a9"],"cd4e13d997cf4fb810398a20a299c2c5a9f6b796":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5a207d19eac354d649c3f0e2cce070017c78125e":["46885bf5f669268ac6235cce5c62fdd68b4e490c","b470f36a9372c97283360b1304eacbde22df6c0d"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["0d49a158012a8ff48f328a4558e4bfcffbaed16f","b470f36a9372c97283360b1304eacbde22df6c0d"],"399ef3ff6c22f0627c82ac65f32726f3587a2aa1":["9eae2a56dc810a17cf807d831f720dec931a03de"],"aba371508186796cc6151d8223a5b4e16d02e26e":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","d19974432be9aed28ee7dca73bdf01d139e763a9"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"d19974432be9aed28ee7dca73bdf01d139e763a9":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b470f36a9372c97283360b1304eacbde22df6c0d":["46885bf5f669268ac6235cce5c62fdd68b4e490c","34d6426cef006e0c3625cabe7a7ec1c2b08bc501"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["46885bf5f669268ac6235cce5c62fdd68b4e490c"],"68496c2200e559fb7802f7575427b7a482659afb":["5a207d19eac354d649c3f0e2cce070017c78125e","4a8ec0889b27701f0ad90a25c95b75454e898cf3"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","d19974432be9aed28ee7dca73bdf01d139e763a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["68496c2200e559fb7802f7575427b7a482659afb"],"46885bf5f669268ac6235cce5c62fdd68b4e490c":["cd4e13d997cf4fb810398a20a299c2c5a9f6b796"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["46885bf5f669268ac6235cce5c62fdd68b4e490c"]},"commit2Childs":{"34d6426cef006e0c3625cabe7a7ec1c2b08bc501":["b470f36a9372c97283360b1304eacbde22df6c0d"],"4a8ec0889b27701f0ad90a25c95b75454e898cf3":["68496c2200e559fb7802f7575427b7a482659afb"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd4e13d997cf4fb810398a20a299c2c5a9f6b796"],"9eae2a56dc810a17cf807d831f720dec931a03de":["399ef3ff6c22f0627c82ac65f32726f3587a2aa1"],"cd4e13d997cf4fb810398a20a299c2c5a9f6b796":["46885bf5f669268ac6235cce5c62fdd68b4e490c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["aba371508186796cc6151d8223a5b4e16d02e26e","d19974432be9aed28ee7dca73bdf01d139e763a9","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"5a207d19eac354d649c3f0e2cce070017c78125e":["68496c2200e559fb7802f7575427b7a482659afb"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["4a8ec0889b27701f0ad90a25c95b75454e898cf3"],"399ef3ff6c22f0627c82ac65f32726f3587a2aa1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["34d6426cef006e0c3625cabe7a7ec1c2b08bc501"],"d19974432be9aed28ee7dca73bdf01d139e763a9":["9eae2a56dc810a17cf807d831f720dec931a03de","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"68496c2200e559fb7802f7575427b7a482659afb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":[],"46885bf5f669268ac6235cce5c62fdd68b4e490c":["5a207d19eac354d649c3f0e2cce070017c78125e","b470f36a9372c97283360b1304eacbde22df6c0d","6bfe104fc023fadc9e709f8d17403d2cc61133fe","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}