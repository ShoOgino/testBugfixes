{"path":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#PersistentSnapshotDeletionPolicy(IndexDeletionPolicy,Directory,OpenMode,Version).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#PersistentSnapshotDeletionPolicy(IndexDeletionPolicy,Directory,OpenMode,Version).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#PersistentSnapshotDeletionPolicy(IndexDeletionPolicy,Directory,OpenMode,Version).mjava","sourceNew":"  /**\n   * {@link PersistentSnapshotDeletionPolicy} wraps another\n   * {@link IndexDeletionPolicy} to enable flexible snapshotting.\n   * \n   * @param primary\n   *          the {@link IndexDeletionPolicy} that is used on non-snapshotted\n   *          commits. Snapshotted commits, by definition, are not deleted until\n   *          explicitly released via {@link #release(String)}.\n   * @param dir\n   *          the {@link Directory} which will be used to persist the snapshots\n   *          information.\n   * @param mode\n   *          specifies whether a new index should be created, deleting all\n   *          existing snapshots information (immediately), or open an existing\n   *          index, initializing the class with the snapshots information.\n   * @param matchVersion\n   *          specifies the {@link Version} that should be used when opening the\n   *          IndexWriter.\n   */\n  public PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary,\n      Directory dir, OpenMode mode, Version matchVersion)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    super(primary, null);\n\n    // Initialize the index writer over the snapshot directory.\n    writer = new IndexWriter(dir, new IndexWriterConfig(matchVersion, null).setOpenMode(mode));\n    if (mode != OpenMode.APPEND) {\n      // IndexWriter no longer creates a first commit on an empty Directory. So\n      // if we were asked to CREATE*, call commit() just to be sure. If the\n      // index contains information and mode is CREATE_OR_APPEND, it's a no-op.\n      writer.commit();\n    }\n\n    try {\n      // Initializes the snapshots information. This code should basically run\n      // only if mode != CREATE, but if it is, it's no harm as we only open the\n      // reader once and immediately close it.\n      for (Entry<String, String> e : readSnapshotsInfo(dir).entrySet()) {\n        registerSnapshotInfo(e.getKey(), e.getValue(), null);\n      }\n    } catch (RuntimeException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    } catch (IOException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    }\n  }\n\n","sourceOld":"  /**\n   * {@link PersistentSnapshotDeletionPolicy} wraps another\n   * {@link IndexDeletionPolicy} to enable flexible snapshotting.\n   * \n   * @param primary\n   *          the {@link IndexDeletionPolicy} that is used on non-snapshotted\n   *          commits. Snapshotted commits, by definition, are not deleted until\n   *          explicitly released via {@link #release(String)}.\n   * @param dir\n   *          the {@link Directory} which will be used to persist the snapshots\n   *          information.\n   * @param mode\n   *          specifies whether a new index should be created, deleting all\n   *          existing snapshots information (immediately), or open an existing\n   *          index, initializing the class with the snapshots information.\n   * @param matchVersion\n   *          specifies the {@link Version} that should be used when opening the\n   *          IndexWriter.\n   */\n  public PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary,\n      Directory dir, OpenMode mode, Version matchVersion)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    super(primary, null);\n\n    // Initialize the index writer over the snapshot directory.\n    writer = new IndexWriter(dir, new IndexWriterConfig(matchVersion, null).setOpenMode(mode));\n    if (mode != OpenMode.APPEND) {\n      // IndexWriter no longer creates a first commit on an empty Directory. So\n      // if we were asked to CREATE*, call commit() just to be sure. If the\n      // index contains information and mode is CREATE_OR_APPEND, it's a no-op.\n      writer.commit();\n    }\n\n    try {\n      // Initializes the snapshots information. This code should basically run\n      // only if mode != CREATE, but if it is, it's no harm as we only open the\n      // reader once and immediately close it.\n      for (Entry<String, String> e : readSnapshotsInfo(dir).entrySet()) {\n        registerSnapshotInfo(e.getKey(), e.getValue(), null);\n      }\n    } catch (RuntimeException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    } catch (IOException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#PersistentSnapshotDeletionPolicy(IndexDeletionPolicy,Directory,OpenMode,Version).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#PersistentSnapshotDeletionPolicy(IndexDeletionPolicy,Directory,OpenMode,Version).mjava","sourceNew":"  /**\n   * {@link PersistentSnapshotDeletionPolicy} wraps another\n   * {@link IndexDeletionPolicy} to enable flexible snapshotting.\n   * \n   * @param primary\n   *          the {@link IndexDeletionPolicy} that is used on non-snapshotted\n   *          commits. Snapshotted commits, by definition, are not deleted until\n   *          explicitly released via {@link #release(String)}.\n   * @param dir\n   *          the {@link Directory} which will be used to persist the snapshots\n   *          information.\n   * @param mode\n   *          specifies whether a new index should be created, deleting all\n   *          existing snapshots information (immediately), or open an existing\n   *          index, initializing the class with the snapshots information.\n   * @param matchVersion\n   *          specifies the {@link Version} that should be used when opening the\n   *          IndexWriter.\n   */\n  public PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary,\n      Directory dir, OpenMode mode, Version matchVersion) throws IOException {\n    super(primary, null);\n\n    // Initialize the index writer over the snapshot directory.\n    writer = new IndexWriter(dir, new IndexWriterConfig(matchVersion, null).setOpenMode(mode));\n    if (mode != OpenMode.APPEND) {\n      // IndexWriter no longer creates a first commit on an empty Directory. So\n      // if we were asked to CREATE*, call commit() just to be sure. If the\n      // index contains information and mode is CREATE_OR_APPEND, it's a no-op.\n      writer.commit();\n    }\n\n    try {\n      // Initializes the snapshots information. This code should basically run\n      // only if mode != CREATE, but if it is, it's no harm as we only open the\n      // reader once and immediately close it.\n      for (Entry<String, String> e : readSnapshotsInfo(dir).entrySet()) {\n        registerSnapshotInfo(e.getKey(), e.getValue(), null);\n      }\n    } catch (RuntimeException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    } catch (IOException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    }\n  }\n\n","sourceOld":"  /**\n   * {@link PersistentSnapshotDeletionPolicy} wraps another\n   * {@link IndexDeletionPolicy} to enable flexible snapshotting.\n   * \n   * @param primary\n   *          the {@link IndexDeletionPolicy} that is used on non-snapshotted\n   *          commits. Snapshotted commits, by definition, are not deleted until\n   *          explicitly released via {@link #release(String)}.\n   * @param dir\n   *          the {@link Directory} which will be used to persist the snapshots\n   *          information.\n   * @param mode\n   *          specifies whether a new index should be created, deleting all\n   *          existing snapshots information (immediately), or open an existing\n   *          index, initializing the class with the snapshots information.\n   * @param matchVersion\n   *          specifies the {@link Version} that should be used when opening the\n   *          IndexWriter.\n   */\n  public PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary,\n      Directory dir, OpenMode mode, Version matchVersion)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    super(primary, null);\n\n    // Initialize the index writer over the snapshot directory.\n    writer = new IndexWriter(dir, new IndexWriterConfig(matchVersion, null).setOpenMode(mode));\n    if (mode != OpenMode.APPEND) {\n      // IndexWriter no longer creates a first commit on an empty Directory. So\n      // if we were asked to CREATE*, call commit() just to be sure. If the\n      // index contains information and mode is CREATE_OR_APPEND, it's a no-op.\n      writer.commit();\n    }\n\n    try {\n      // Initializes the snapshots information. This code should basically run\n      // only if mode != CREATE, but if it is, it's no harm as we only open the\n      // reader once and immediately close it.\n      for (Entry<String, String> e : readSnapshotsInfo(dir).entrySet()) {\n        registerSnapshotInfo(e.getKey(), e.getValue(), null);\n      }\n    } catch (RuntimeException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    } catch (IOException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    }\n  }\n\n","bugFix":["b3cefb552695b930cefe85eb7880cccdb914be6b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#PersistentSnapshotDeletionPolicy(IndexDeletionPolicy,Directory,OpenMode,Version).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#PersistentSnapshotDeletionPolicy(IndexDeletionPolicy,Directory,OpenMode,Version).mjava","sourceNew":"  /**\n   * {@link PersistentSnapshotDeletionPolicy} wraps another\n   * {@link IndexDeletionPolicy} to enable flexible snapshotting.\n   * \n   * @param primary\n   *          the {@link IndexDeletionPolicy} that is used on non-snapshotted\n   *          commits. Snapshotted commits, by definition, are not deleted until\n   *          explicitly released via {@link #release(String)}.\n   * @param dir\n   *          the {@link Directory} which will be used to persist the snapshots\n   *          information.\n   * @param mode\n   *          specifies whether a new index should be created, deleting all\n   *          existing snapshots information (immediately), or open an existing\n   *          index, initializing the class with the snapshots information.\n   * @param matchVersion\n   *          specifies the {@link Version} that should be used when opening the\n   *          IndexWriter.\n   */\n  public PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary,\n      Directory dir, OpenMode mode, Version matchVersion) throws IOException {\n    super(primary, null);\n\n    // Initialize the index writer over the snapshot directory.\n    writer = new IndexWriter(dir, new IndexWriterConfig(matchVersion, null).setOpenMode(mode));\n    if (mode != OpenMode.APPEND) {\n      // IndexWriter no longer creates a first commit on an empty Directory. So\n      // if we were asked to CREATE*, call commit() just to be sure. If the\n      // index contains information and mode is CREATE_OR_APPEND, it's a no-op.\n      writer.commit();\n    }\n\n    try {\n      // Initializes the snapshots information. This code should basically run\n      // only if mode != CREATE, but if it is, it's no harm as we only open the\n      // reader once and immediately close it.\n      for (Entry<String, String> e : readSnapshotsInfo(dir).entrySet()) {\n        registerSnapshotInfo(e.getKey(), e.getValue(), null);\n      }\n    } catch (RuntimeException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    } catch (IOException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    }\n  }\n\n","sourceOld":"  /**\n   * {@link PersistentSnapshotDeletionPolicy} wraps another\n   * {@link IndexDeletionPolicy} to enable flexible snapshotting.\n   * \n   * @param primary\n   *          the {@link IndexDeletionPolicy} that is used on non-snapshotted\n   *          commits. Snapshotted commits, by definition, are not deleted until\n   *          explicitly released via {@link #release(String)}.\n   * @param dir\n   *          the {@link Directory} which will be used to persist the snapshots\n   *          information.\n   * @param mode\n   *          specifies whether a new index should be created, deleting all\n   *          existing snapshots information (immediately), or open an existing\n   *          index, initializing the class with the snapshots information.\n   * @param matchVersion\n   *          specifies the {@link Version} that should be used when opening the\n   *          IndexWriter.\n   */\n  public PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary,\n      Directory dir, OpenMode mode, Version matchVersion)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    super(primary, null);\n\n    // Initialize the index writer over the snapshot directory.\n    writer = new IndexWriter(dir, new IndexWriterConfig(matchVersion, null).setOpenMode(mode));\n    if (mode != OpenMode.APPEND) {\n      // IndexWriter no longer creates a first commit on an empty Directory. So\n      // if we were asked to CREATE*, call commit() just to be sure. If the\n      // index contains information and mode is CREATE_OR_APPEND, it's a no-op.\n      writer.commit();\n    }\n\n    try {\n      // Initializes the snapshots information. This code should basically run\n      // only if mode != CREATE, but if it is, it's no harm as we only open the\n      // reader once and immediately close it.\n      for (Entry<String, String> e : readSnapshotsInfo(dir).entrySet()) {\n        registerSnapshotInfo(e.getKey(), e.getValue(), null);\n      }\n    } catch (RuntimeException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    } catch (IOException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a207624ce3e468bca1819861084438d936e3b1c","date":1367514967,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#PersistentSnapshotDeletionPolicy(IndexDeletionPolicy,Directory,OpenMode,Version).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#PersistentSnapshotDeletionPolicy(IndexDeletionPolicy,Directory,OpenMode,Version).mjava","sourceNew":"  /**\n   * {@link PersistentSnapshotDeletionPolicy} wraps another\n   * {@link IndexDeletionPolicy} to enable flexible snapshotting.\n   * \n   * @param primary\n   *          the {@link IndexDeletionPolicy} that is used on non-snapshotted\n   *          commits. Snapshotted commits, by definition, are not deleted until\n   *          explicitly released via {@link #release}.\n   * @param dir\n   *          the {@link Directory} which will be used to persist the snapshots\n   *          information.\n   * @param mode\n   *          specifies whether a new index should be created, deleting all\n   *          existing snapshots information (immediately), or open an existing\n   *          index, initializing the class with the snapshots information.\n   * @param matchVersion\n   *          specifies the {@link Version} that should be used when opening the\n   *          IndexWriter.\n   */\n  public PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary,\n      Directory dir, OpenMode mode, Version matchVersion) throws IOException {\n    super(primary);\n\n    // Initialize the index writer over the snapshot directory.\n    writer = new IndexWriter(dir, new IndexWriterConfig(matchVersion, null).setOpenMode(mode));\n    if (mode != OpenMode.APPEND) {\n      // IndexWriter no longer creates a first commit on an empty Directory. So\n      // if we were asked to CREATE*, call commit() just to be sure. If the\n      // index contains information and mode is CREATE_OR_APPEND, it's a no-op.\n      writer.commit();\n    }\n\n    try {\n      // Initializes the snapshots information. This code should basically run\n      // only if mode != CREATE, but if it is, it's no harm as we only open the\n      // reader once and immediately close it.\n      loadPriorSnapshots(dir);\n    } catch (RuntimeException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    } catch (IOException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    }\n  }\n\n","sourceOld":"  /**\n   * {@link PersistentSnapshotDeletionPolicy} wraps another\n   * {@link IndexDeletionPolicy} to enable flexible snapshotting.\n   * \n   * @param primary\n   *          the {@link IndexDeletionPolicy} that is used on non-snapshotted\n   *          commits. Snapshotted commits, by definition, are not deleted until\n   *          explicitly released via {@link #release(String)}.\n   * @param dir\n   *          the {@link Directory} which will be used to persist the snapshots\n   *          information.\n   * @param mode\n   *          specifies whether a new index should be created, deleting all\n   *          existing snapshots information (immediately), or open an existing\n   *          index, initializing the class with the snapshots information.\n   * @param matchVersion\n   *          specifies the {@link Version} that should be used when opening the\n   *          IndexWriter.\n   */\n  public PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary,\n      Directory dir, OpenMode mode, Version matchVersion) throws IOException {\n    super(primary, null);\n\n    // Initialize the index writer over the snapshot directory.\n    writer = new IndexWriter(dir, new IndexWriterConfig(matchVersion, null).setOpenMode(mode));\n    if (mode != OpenMode.APPEND) {\n      // IndexWriter no longer creates a first commit on an empty Directory. So\n      // if we were asked to CREATE*, call commit() just to be sure. If the\n      // index contains information and mode is CREATE_OR_APPEND, it's a no-op.\n      writer.commit();\n    }\n\n    try {\n      // Initializes the snapshots information. This code should basically run\n      // only if mode != CREATE, but if it is, it's no harm as we only open the\n      // reader once and immediately close it.\n      for (Entry<String, String> e : readSnapshotsInfo(dir).entrySet()) {\n        registerSnapshotInfo(e.getKey(), e.getValue(), null);\n      }\n    } catch (RuntimeException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    } catch (IOException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dce99db8590cdd065839ae4e6b228b66eeee8f38","date":1367579599,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#PersistentSnapshotDeletionPolicy(IndexDeletionPolicy,Directory,OpenMode).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#PersistentSnapshotDeletionPolicy(IndexDeletionPolicy,Directory,OpenMode,Version).mjava","sourceNew":"  /**\n   * {@link PersistentSnapshotDeletionPolicy} wraps another\n   * {@link IndexDeletionPolicy} to enable flexible snapshotting.\n   * \n   * @param primary\n   *          the {@link IndexDeletionPolicy} that is used on non-snapshotted\n   *          commits. Snapshotted commits, by definition, are not deleted until\n   *          explicitly released via {@link #release}.\n   * @param dir\n   *          the {@link Directory} which will be used to persist the snapshots\n   *          information.\n   * @param mode\n   *          specifies whether a new index should be created, deleting all\n   *          existing snapshots information (immediately), or open an existing\n   *          index, initializing the class with the snapshots information.\n   */\n  public PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary,\n      Directory dir, OpenMode mode) throws IOException {\n    super(primary);\n\n    this.dir = dir;\n\n    if (mode == OpenMode.CREATE) {\n      clearPriorSnapshots();\n    }\n\n    loadPriorSnapshots();\n\n    if (mode == OpenMode.APPEND && nextWriteGen == 0) {\n      throw new IllegalStateException(\"no snapshots stored in this directory\");\n    }\n  }\n\n","sourceOld":"  /**\n   * {@link PersistentSnapshotDeletionPolicy} wraps another\n   * {@link IndexDeletionPolicy} to enable flexible snapshotting.\n   * \n   * @param primary\n   *          the {@link IndexDeletionPolicy} that is used on non-snapshotted\n   *          commits. Snapshotted commits, by definition, are not deleted until\n   *          explicitly released via {@link #release}.\n   * @param dir\n   *          the {@link Directory} which will be used to persist the snapshots\n   *          information.\n   * @param mode\n   *          specifies whether a new index should be created, deleting all\n   *          existing snapshots information (immediately), or open an existing\n   *          index, initializing the class with the snapshots information.\n   * @param matchVersion\n   *          specifies the {@link Version} that should be used when opening the\n   *          IndexWriter.\n   */\n  public PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary,\n      Directory dir, OpenMode mode, Version matchVersion) throws IOException {\n    super(primary);\n\n    // Initialize the index writer over the snapshot directory.\n    writer = new IndexWriter(dir, new IndexWriterConfig(matchVersion, null).setOpenMode(mode));\n    if (mode != OpenMode.APPEND) {\n      // IndexWriter no longer creates a first commit on an empty Directory. So\n      // if we were asked to CREATE*, call commit() just to be sure. If the\n      // index contains information and mode is CREATE_OR_APPEND, it's a no-op.\n      writer.commit();\n    }\n\n    try {\n      // Initializes the snapshots information. This code should basically run\n      // only if mode != CREATE, but if it is, it's no harm as we only open the\n      // reader once and immediately close it.\n      loadPriorSnapshots(dir);\n    } catch (RuntimeException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    } catch (IOException e) {\n      writer.close(); // don't leave any open file handles\n      throw e;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"dce99db8590cdd065839ae4e6b228b66eeee8f38":["8a207624ce3e468bca1819861084438d936e3b1c"],"8a207624ce3e468bca1819861084438d936e3b1c":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dce99db8590cdd065839ae4e6b228b66eeee8f38"]},"commit2Childs":{"dce99db8590cdd065839ae4e6b228b66eeee8f38":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8a207624ce3e468bca1819861084438d936e3b1c":["dce99db8590cdd065839ae4e6b228b66eeee8f38"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["8a207624ce3e468bca1819861084438d936e3b1c","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}