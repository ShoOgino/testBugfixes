{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication#promoteReplica().mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication#promoteReplica().mjava","pathOld":"/dev/null","sourceNew":"  /** Picks a replica and promotes it as new primary. */\n  private void promoteReplica() throws IOException {\n    message(\"top: primary crashed; now pick replica to promote\");\n    long maxSearchingVersion = -1;\n    NodeProcess replicaToPromote = null;\n\n    // We must promote the most current replica, because otherwise file name reuse can cause a replication to fail when it needs to copy\n    // over a file currently held open for searching.  This also minimizes recovery work since the most current replica means less xlog\n    // replay to catch up:\n    for (NodeProcess node : nodes) {\n      if (node != null) {\n        message(\"ask \" + node + \" for its current searching version\");\n        long searchingVersion = node.getSearchingVersion();\n        message(node + \" has searchingVersion=\" + searchingVersion);\n        if (searchingVersion > maxSearchingVersion) {\n          maxSearchingVersion = searchingVersion;\n          replicaToPromote = node;\n        }\n      }\n    }\n\n    if (replicaToPromote == null) {\n      message(\"top: no replicas running; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: promote \" + replicaToPromote + \" version=\" + maxSearchingVersion + \"; now commit\");\n    if (replicaToPromote.commit() == false) {\n      message(\"top: commit failed; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: now shutdown \" + replicaToPromote);\n    if (replicaToPromote.shutdown() == false) {\n      message(\"top: shutdown failed for R\" + replicaToPromote.id + \"; skipping primary promotion\");\n      return;\n    }\n\n    int id = replicaToPromote.id;\n    message(\"top: now startPrimary \" + replicaToPromote);\n    startPrimary(replicaToPromote.id);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","date":1453892412,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#promoteReplica().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication#promoteReplica().mjava","sourceNew":"  /** Picks a replica and promotes it as new primary. */\n  private void promoteReplica() throws IOException {\n    message(\"top: primary crashed; now pick replica to promote\");\n    long maxSearchingVersion = -1;\n    NodeProcess replicaToPromote = null;\n\n    // We must promote the most current replica, because otherwise file name reuse can cause a replication to fail when it needs to copy\n    // over a file currently held open for searching.  This also minimizes recovery work since the most current replica means less xlog\n    // replay to catch up:\n    for (NodeProcess node : nodes) {\n      if (node != null) {\n        message(\"ask \" + node + \" for its current searching version\");\n        long searchingVersion = node.getSearchingVersion();\n        message(node + \" has searchingVersion=\" + searchingVersion);\n        if (searchingVersion > maxSearchingVersion) {\n          maxSearchingVersion = searchingVersion;\n          replicaToPromote = node;\n        }\n      }\n    }\n\n    if (replicaToPromote == null) {\n      message(\"top: no replicas running; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: promote \" + replicaToPromote + \" version=\" + maxSearchingVersion + \"; now commit\");\n    if (replicaToPromote.commit() == false) {\n      message(\"top: commit failed; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: now shutdown \" + replicaToPromote);\n    if (replicaToPromote.shutdown() == false) {\n      message(\"top: shutdown failed for R\" + replicaToPromote.id + \"; skipping primary promotion\");\n      return;\n    }\n\n    int id = replicaToPromote.id;\n    message(\"top: now startPrimary \" + replicaToPromote);\n    startPrimary(replicaToPromote.id);\n  }\n\n","sourceOld":"  /** Picks a replica and promotes it as new primary. */\n  private void promoteReplica() throws IOException {\n    message(\"top: primary crashed; now pick replica to promote\");\n    long maxSearchingVersion = -1;\n    NodeProcess replicaToPromote = null;\n\n    // We must promote the most current replica, because otherwise file name reuse can cause a replication to fail when it needs to copy\n    // over a file currently held open for searching.  This also minimizes recovery work since the most current replica means less xlog\n    // replay to catch up:\n    for (NodeProcess node : nodes) {\n      if (node != null) {\n        message(\"ask \" + node + \" for its current searching version\");\n        long searchingVersion = node.getSearchingVersion();\n        message(node + \" has searchingVersion=\" + searchingVersion);\n        if (searchingVersion > maxSearchingVersion) {\n          maxSearchingVersion = searchingVersion;\n          replicaToPromote = node;\n        }\n      }\n    }\n\n    if (replicaToPromote == null) {\n      message(\"top: no replicas running; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: promote \" + replicaToPromote + \" version=\" + maxSearchingVersion + \"; now commit\");\n    if (replicaToPromote.commit() == false) {\n      message(\"top: commit failed; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: now shutdown \" + replicaToPromote);\n    if (replicaToPromote.shutdown() == false) {\n      message(\"top: shutdown failed for R\" + replicaToPromote.id + \"; skipping primary promotion\");\n      return;\n    }\n\n    int id = replicaToPromote.id;\n    message(\"top: now startPrimary \" + replicaToPromote);\n    startPrimary(replicaToPromote.id);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}