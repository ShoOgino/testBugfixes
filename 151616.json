{"path":"solr/core/src/test/org/apache/solr/util/hll/HLLSerializationTest#assertCardinality(HLLType,Collection[Long]).mjava","commits":[{"id":"6faa211c4af605e3cf078a76d200c1dc348973f5","date":1437043657,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/util/hll/HLLSerializationTest#assertCardinality(HLLType,Collection[Long]).mjava","pathOld":"/dev/null","sourceNew":"    // NOTE: log2m<=16 was chosen as the max log2m parameter so that the test\n    //       completes in a reasonable amount of time. Not much is gained by\n    //       testing larger values - there are no more known serialization\n    //       related edge cases that appear as log2m gets even larger.\n    // NOTE: This test completed successfully with log2m<=MAXIMUM_LOG2M_PARAM\n    //       on 2014-01-30.\n    private static void assertCardinality(final HLLType hllType, final Collection<Long> items)\n           throws CloneNotSupportedException {\n        for(int log2m=MINIMUM_LOG2M_PARAM; log2m<=16; log2m++) {\n            for(int regw=MINIMUM_REGWIDTH_PARAM; regw<=MAXIMUM_REGWIDTH_PARAM; regw++) {\n                for(int expthr=MINIMUM_EXPTHRESH_PARAM; expthr<=MAXIMUM_EXPTHRESH_PARAM; expthr++ ) {\n                    for(final boolean sparse: new boolean[]{true, false}) {\n                        HLL hll = new HLL(log2m, regw, expthr, sparse, hllType);\n                        for(final Long item: items) {\n                            hll.addRaw(item);\n                        }\n                        HLL copy = HLL.fromBytes(hll.toBytes());\n                        assertEquals(copy.cardinality(), hll.cardinality());\n                        assertEquals(copy.getType(), hll.getType());\n                        assertTrue(Arrays.equals(copy.toBytes(), hll.toBytes()));\n\n                        HLL clone = hll.clone();\n                        assertEquals(clone.cardinality(), hll.cardinality());\n                        assertEquals(clone.getType(), hll.getType());\n                        assertTrue(Arrays.equals(clone.toBytes(), hll.toBytes()));\n                    }\n                }\n            }\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b5ee4c66244bdfcc4796a114519d47701b2c026","date":1437132013,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/util/hll/HLLSerializationTest#assertCardinality(HLLType,Collection[Long]).mjava","pathOld":"/dev/null","sourceNew":"    // NOTE: log2m<=16 was chosen as the max log2m parameter so that the test\n    //       completes in a reasonable amount of time. Not much is gained by\n    //       testing larger values - there are no more known serialization\n    //       related edge cases that appear as log2m gets even larger.\n    // NOTE: This test completed successfully with log2m<=MAXIMUM_LOG2M_PARAM\n    //       on 2014-01-30.\n    private static void assertCardinality(final HLLType hllType, final Collection<Long> items)\n           throws CloneNotSupportedException {\n        for(int log2m=MINIMUM_LOG2M_PARAM; log2m<=16; log2m++) {\n            for(int regw=MINIMUM_REGWIDTH_PARAM; regw<=MAXIMUM_REGWIDTH_PARAM; regw++) {\n                for(int expthr=MINIMUM_EXPTHRESH_PARAM; expthr<=MAXIMUM_EXPTHRESH_PARAM; expthr++ ) {\n                    for(final boolean sparse: new boolean[]{true, false}) {\n                        HLL hll = new HLL(log2m, regw, expthr, sparse, hllType);\n                        for(final Long item: items) {\n                            hll.addRaw(item);\n                        }\n                        HLL copy = HLL.fromBytes(hll.toBytes());\n                        assertEquals(copy.cardinality(), hll.cardinality());\n                        assertEquals(copy.getType(), hll.getType());\n                        assertTrue(Arrays.equals(copy.toBytes(), hll.toBytes()));\n\n                        HLL clone = hll.clone();\n                        assertEquals(clone.cardinality(), hll.cardinality());\n                        assertEquals(clone.getType(), hll.getType());\n                        assertTrue(Arrays.equals(clone.toBytes(), hll.toBytes()));\n                    }\n                }\n            }\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a81b342a33a0e68d2bb194ebcc3dfadcc69868b2","date":1440606819,"type":4,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/util/hll/HLLSerializationTest#assertCardinality(HLLType,Collection[Long]).mjava","sourceNew":null,"sourceOld":"    // NOTE: log2m<=16 was chosen as the max log2m parameter so that the test\n    //       completes in a reasonable amount of time. Not much is gained by\n    //       testing larger values - there are no more known serialization\n    //       related edge cases that appear as log2m gets even larger.\n    // NOTE: This test completed successfully with log2m<=MAXIMUM_LOG2M_PARAM\n    //       on 2014-01-30.\n    private static void assertCardinality(final HLLType hllType, final Collection<Long> items)\n           throws CloneNotSupportedException {\n        for(int log2m=MINIMUM_LOG2M_PARAM; log2m<=16; log2m++) {\n            for(int regw=MINIMUM_REGWIDTH_PARAM; regw<=MAXIMUM_REGWIDTH_PARAM; regw++) {\n                for(int expthr=MINIMUM_EXPTHRESH_PARAM; expthr<=MAXIMUM_EXPTHRESH_PARAM; expthr++ ) {\n                    for(final boolean sparse: new boolean[]{true, false}) {\n                        HLL hll = new HLL(log2m, regw, expthr, sparse, hllType);\n                        for(final Long item: items) {\n                            hll.addRaw(item);\n                        }\n                        HLL copy = HLL.fromBytes(hll.toBytes());\n                        assertEquals(copy.cardinality(), hll.cardinality());\n                        assertEquals(copy.getType(), hll.getType());\n                        assertTrue(Arrays.equals(copy.toBytes(), hll.toBytes()));\n\n                        HLL clone = hll.clone();\n                        assertEquals(clone.cardinality(), hll.cardinality());\n                        assertEquals(clone.getType(), hll.getType());\n                        assertTrue(Arrays.equals(clone.toBytes(), hll.toBytes()));\n                    }\n                }\n            }\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a81b342a33a0e68d2bb194ebcc3dfadcc69868b2":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6faa211c4af605e3cf078a76d200c1dc348973f5"],"6faa211c4af605e3cf078a76d200c1dc348973f5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a81b342a33a0e68d2bb194ebcc3dfadcc69868b2"]},"commit2Childs":{"a81b342a33a0e68d2bb194ebcc3dfadcc69868b2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b5ee4c66244bdfcc4796a114519d47701b2c026","6faa211c4af605e3cf078a76d200c1dc348973f5"],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a81b342a33a0e68d2bb194ebcc3dfadcc69868b2"],"6faa211c4af605e3cf078a76d200c1dc348973f5":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}