{"path":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPConnection#handleRequest(Request,HTTPResponse,Response,boolean).mjava","commits":[{"id":"bc6055f4a2e8e9f9caaec2297010c9502480ed69","date":1050060580,"type":0,"author":"cmarschner","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPConnection#handleRequest(Request,HTTPResponse,Response,boolean).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * handles the Request. First the request handler for each module is is\n     * invoked, and then if no response was generated the request is sent.\n     *\n     * @param req                  the Request\n     * @param http_resp            the HTTPResponse\n     * @param resp                 the Response\n     * @param usemodules           if false then skip module loop\n     * @exception IOException      if any module or sendRequest throws it\n     * @exception ModuleException  if any module throws it\n     */\n    void handleRequest(Request req, HTTPResponse http_resp, Response resp,\n            boolean usemodules)\n        throws IOException, ModuleException\n    {\n        Response[] rsp_arr = {resp};\n        HTTPClientModule[] modules = http_resp.getModules();\n\n        // invoke requestHandler for each module\n\n        if (usemodules)\n        {\n            doModules :\n            for (int idx = 0; idx < modules.length; idx++)\n            {\n                int sts = modules[idx].requestHandler(req, rsp_arr);\n                switch (sts)\n                {\n                    case REQ_CONTINUE:\n                        // continue processing\n                        break;\n                    case REQ_RESTART:\n                        // restart processing with first module\n                        idx = -1;\n                        continue doModules;\n                    case REQ_SHORTCIRC:\n                        // stop processing and send\n                        break doModules;\n                    case REQ_RESPONSE:\n                    // go to phase 2\n                    case REQ_RETURN:\n                        // return response immediately\n                        if (rsp_arr[0] == null)\n                        {\n                            throw new Error(\"HTTPClient Internal Error: no \" +\n                                    \"response returned by module \" +\n                                    modules[idx].getClass().getName());\n                        }\n                        http_resp.set(req, rsp_arr[0]);\n                        if (req.getStream() != null)\n                        {\n                            req.getStream().ignoreData(req);\n                        }\n                        if (req.internal_subrequest)\n                        {\n                            return;\n                        }\n                        if (sts == REQ_RESPONSE)\n                        {\n                            http_resp.handleResponse();\n                        }\n                        else\n                        {\n                            http_resp.init(rsp_arr[0]);\n                        }\n                        return;\n                    case REQ_NEWCON_RST:\n                        // new connection\n                        if (req.internal_subrequest)\n                        {\n                            return;\n                        }\n                        req.getConnection().\n                                handleRequest(req, http_resp, rsp_arr[0], true);\n                        return;\n                    case REQ_NEWCON_SND:\n                        // new connection, send immediately\n                        if (req.internal_subrequest)\n                        {\n                            return;\n                        }\n                        req.getConnection().\n                                handleRequest(req, http_resp, rsp_arr[0], false);\n                        return;\n                    default:\n                        // not valid\n                        throw new Error(\"HTTPClient Internal Error: invalid status\" +\n                                \" \" + sts + \" returned by module \" +\n                                modules[idx].getClass().getName());\n                }\n            }\n        }\n\n        if (req.internal_subrequest)\n        {\n            return;\n        }\n\n        // Send the request across the wire\n\n        if (req.getStream() != null && req.getStream().getLength() == -1)\n        {\n            if (!ServProtVersKnown || ServerProtocolVersion < HTTP_1_1 ||\n                    no_chunked)\n            {\n                req.getStream().goAhead(req, null, http_resp.getTimeout());\n                http_resp.set(req, req.getStream());\n            }\n            else\n            {\n                // add Transfer-Encoding header if necessary\n                int idx;\n                NVPair[] hdrs = req.getHeaders();\n                for (idx = 0; idx < hdrs.length; idx++)\n                {\n                    if (hdrs[idx].getName().equalsIgnoreCase(\"Transfer-Encoding\"))\n                    {\n                        break;\n                    }\n                }\n\n                if (idx == hdrs.length)\n                {\n                    hdrs = Util.resizeArray(hdrs, idx + 1);\n                    hdrs[idx] = new NVPair(\"Transfer-Encoding\", \"chunked\");\n                    req.setHeaders(hdrs);\n                }\n                else\n                {\n                    String v = hdrs[idx].getValue();\n                    try\n                    {\n                        if (!Util.hasToken(v, \"chunked\"))\n                        {\n                            hdrs[idx] = new NVPair(\"Transfer-Encoding\",\n                                    v + \", chunked\");\n                        }\n                    }\n                    catch (ParseException pe)\n                    {\n                        throw new IOException(pe.toString());\n                    }\n                }\n\n                http_resp.set(req, sendRequest(req, http_resp.getTimeout()));\n            }\n        }\n        else\n        {\n            http_resp.set(req, sendRequest(req, http_resp.getTimeout()));\n        }\n\n        if (req.aborted)\n        {\n            throw new IOException(\"Request aborted by user\");\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"afc16d717d9ed1a8e45371668ca6de674164d624","date":1103345442,"type":4,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"/dev/null","pathOld":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPConnection#handleRequest(Request,HTTPResponse,Response,boolean).mjava","sourceNew":null,"sourceOld":"    /**\n     * handles the Request. First the request handler for each module is is\n     * invoked, and then if no response was generated the request is sent.\n     *\n     * @param req                  the Request\n     * @param http_resp            the HTTPResponse\n     * @param resp                 the Response\n     * @param usemodules           if false then skip module loop\n     * @exception IOException      if any module or sendRequest throws it\n     * @exception ModuleException  if any module throws it\n     */\n    void handleRequest(Request req, HTTPResponse http_resp, Response resp,\n            boolean usemodules)\n        throws IOException, ModuleException\n    {\n        Response[] rsp_arr = {resp};\n        HTTPClientModule[] modules = http_resp.getModules();\n\n        // invoke requestHandler for each module\n\n        if (usemodules)\n        {\n            doModules :\n            for (int idx = 0; idx < modules.length; idx++)\n            {\n                int sts = modules[idx].requestHandler(req, rsp_arr);\n                switch (sts)\n                {\n                    case REQ_CONTINUE:\n                        // continue processing\n                        break;\n                    case REQ_RESTART:\n                        // restart processing with first module\n                        idx = -1;\n                        continue doModules;\n                    case REQ_SHORTCIRC:\n                        // stop processing and send\n                        break doModules;\n                    case REQ_RESPONSE:\n                    // go to phase 2\n                    case REQ_RETURN:\n                        // return response immediately\n                        if (rsp_arr[0] == null)\n                        {\n                            throw new Error(\"HTTPClient Internal Error: no \" +\n                                    \"response returned by module \" +\n                                    modules[idx].getClass().getName());\n                        }\n                        http_resp.set(req, rsp_arr[0]);\n                        if (req.getStream() != null)\n                        {\n                            req.getStream().ignoreData(req);\n                        }\n                        if (req.internal_subrequest)\n                        {\n                            return;\n                        }\n                        if (sts == REQ_RESPONSE)\n                        {\n                            http_resp.handleResponse();\n                        }\n                        else\n                        {\n                            http_resp.init(rsp_arr[0]);\n                        }\n                        return;\n                    case REQ_NEWCON_RST:\n                        // new connection\n                        if (req.internal_subrequest)\n                        {\n                            return;\n                        }\n                        req.getConnection().\n                                handleRequest(req, http_resp, rsp_arr[0], true);\n                        return;\n                    case REQ_NEWCON_SND:\n                        // new connection, send immediately\n                        if (req.internal_subrequest)\n                        {\n                            return;\n                        }\n                        req.getConnection().\n                                handleRequest(req, http_resp, rsp_arr[0], false);\n                        return;\n                    default:\n                        // not valid\n                        throw new Error(\"HTTPClient Internal Error: invalid status\" +\n                                \" \" + sts + \" returned by module \" +\n                                modules[idx].getClass().getName());\n                }\n            }\n        }\n\n        if (req.internal_subrequest)\n        {\n            return;\n        }\n\n        // Send the request across the wire\n\n        if (req.getStream() != null && req.getStream().getLength() == -1)\n        {\n            if (!ServProtVersKnown || ServerProtocolVersion < HTTP_1_1 ||\n                    no_chunked)\n            {\n                req.getStream().goAhead(req, null, http_resp.getTimeout());\n                http_resp.set(req, req.getStream());\n            }\n            else\n            {\n                // add Transfer-Encoding header if necessary\n                int idx;\n                NVPair[] hdrs = req.getHeaders();\n                for (idx = 0; idx < hdrs.length; idx++)\n                {\n                    if (hdrs[idx].getName().equalsIgnoreCase(\"Transfer-Encoding\"))\n                    {\n                        break;\n                    }\n                }\n\n                if (idx == hdrs.length)\n                {\n                    hdrs = Util.resizeArray(hdrs, idx + 1);\n                    hdrs[idx] = new NVPair(\"Transfer-Encoding\", \"chunked\");\n                    req.setHeaders(hdrs);\n                }\n                else\n                {\n                    String v = hdrs[idx].getValue();\n                    try\n                    {\n                        if (!Util.hasToken(v, \"chunked\"))\n                        {\n                            hdrs[idx] = new NVPair(\"Transfer-Encoding\",\n                                    v + \", chunked\");\n                        }\n                    }\n                    catch (ParseException pe)\n                    {\n                        throw new IOException(pe.toString());\n                    }\n                }\n\n                http_resp.set(req, sendRequest(req, http_resp.getTimeout()));\n            }\n        }\n        else\n        {\n            http_resp.set(req, sendRequest(req, http_resp.getTimeout()));\n        }\n\n        if (req.aborted)\n        {\n            throw new IOException(\"Request aborted by user\");\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bc6055f4a2e8e9f9caaec2297010c9502480ed69":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"afc16d717d9ed1a8e45371668ca6de674164d624":["bc6055f4a2e8e9f9caaec2297010c9502480ed69"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["afc16d717d9ed1a8e45371668ca6de674164d624"]},"commit2Childs":{"bc6055f4a2e8e9f9caaec2297010c9502480ed69":["afc16d717d9ed1a8e45371668ca6de674164d624"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bc6055f4a2e8e9f9caaec2297010c9502480ed69"],"afc16d717d9ed1a8e45371668ca6de674164d624":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}