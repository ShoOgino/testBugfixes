{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimSolrCloudTestCase#tearDown().mjava","commits":[{"id":"a4422b331d00607258b0ed3e43934306e67764aa","date":1513943901,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimSolrCloudTestCase#tearDown().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void tearDown() throws Exception {\n    super.tearDown();\n    if (cluster != null) {\n      log.info(\"\\n\");\n      log.info(\"#############################################\");\n      log.info(\"############ FINAL CLUSTER STATS ############\");\n      log.info(\"#############################################\\n\");\n      log.info(\"## Live nodes:\\t\\t\" + cluster.getLiveNodesSet().size());\n      int emptyNodes = 0;\n      int maxReplicas = 0;\n      int minReplicas = Integer.MAX_VALUE;\n      Map<String, Map<Replica.State, AtomicInteger>> replicaStates = new TreeMap<>();\n      int numReplicas = 0;\n      for (String node : cluster.getLiveNodesSet().get()) {\n        List<ReplicaInfo> replicas = cluster.getSimClusterStateProvider().simGetReplicaInfos(node);\n        numReplicas += replicas.size();\n        if (replicas.size() > maxReplicas) {\n          maxReplicas = replicas.size();\n        }\n        if (minReplicas > replicas.size()) {\n          minReplicas = replicas.size();\n        }\n        for (ReplicaInfo ri : replicas) {\n          replicaStates.computeIfAbsent(ri.getCollection(), c -> new TreeMap<>())\n              .computeIfAbsent(ri.getState(), s -> new AtomicInteger())\n              .incrementAndGet();\n        }\n        if (replicas.isEmpty()) {\n          emptyNodes++;\n        }\n      }\n      if (minReplicas == Integer.MAX_VALUE) {\n        minReplicas = 0;\n      }\n      log.info(\"## Empty nodes:\\t\" + emptyNodes);\n      Set<String> deadNodes = cluster.getSimNodeStateProvider().simGetDeadNodes();\n      log.info(\"## Dead nodes:\\t\\t\" + deadNodes.size());\n      deadNodes.forEach(n -> log.info(\"##\\t\\t\" + n));\n      log.info(\"## Collections:\\t\" + cluster.getSimClusterStateProvider().simListCollections());\n      log.info(\"## Max replicas per node:\\t\" + maxReplicas);\n      log.info(\"## Min replicas per node:\\t\" + minReplicas);\n      log.info(\"## Total replicas:\\t\\t\" + numReplicas);\n      replicaStates.forEach((c, map) -> {\n        AtomicInteger repCnt = new AtomicInteger();\n        map.forEach((s, cnt) -> repCnt.addAndGet(cnt.get()));\n        log.info(\"## * \" + c + \"\\t\\t\" + repCnt.get());\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-12s  %4d\", s, cnt.get())));\n      });\n      log.info(\"######### Final Solr op counts ##########\");\n      cluster.simGetOpCounts().forEach((k, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-14s  %4d\", k, cnt.get())));\n      log.info(\"######### Autoscaling event counts ###########\");\n      TreeMap<String, Map<String, AtomicInteger>> counts = new TreeMap<>();\n      for (SolrInputDocument d : cluster.simGetSystemCollection()) {\n        if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n          continue;\n        }\n        counts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new TreeMap<>())\n            .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n            .incrementAndGet();\n      }\n      counts.forEach((trigger, map) -> {\n        log.info(\"## * Trigger: \" + trigger);\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-11s  %4d\", s, cnt.get())));\n      });\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4c6d7fbed9c3bc14668e17ddb41c13d435d3ba9b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c6d7fbed9c3bc14668e17ddb41c13d435d3ba9b","date":1515400451,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimSolrCloudTestCase#tearDown().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimSolrCloudTestCase#tearDown().mjava","sourceNew":"  @Override\n  public void tearDown() throws Exception {\n    super.tearDown();\n    if (cluster != null) {\n      log.info(\"\\n\");\n      log.info(\"#############################################\");\n      log.info(\"############ FINAL CLUSTER STATS ############\");\n      log.info(\"#############################################\\n\");\n      log.info(\"## Live nodes:\\t\\t\" + cluster.getLiveNodesSet().size());\n      int emptyNodes = 0;\n      int maxReplicas = 0;\n      int minReplicas = Integer.MAX_VALUE;\n      Map<String, Map<Replica.State, AtomicInteger>> replicaStates = new TreeMap<>();\n      int numReplicas = 0;\n      for (String node : cluster.getLiveNodesSet().get()) {\n        List<ReplicaInfo> replicas = cluster.getSimClusterStateProvider().simGetReplicaInfos(node);\n        numReplicas += replicas.size();\n        if (replicas.size() > maxReplicas) {\n          maxReplicas = replicas.size();\n        }\n        if (minReplicas > replicas.size()) {\n          minReplicas = replicas.size();\n        }\n        for (ReplicaInfo ri : replicas) {\n          replicaStates.computeIfAbsent(ri.getCollection(), c -> new TreeMap<>())\n              .computeIfAbsent(ri.getState(), s -> new AtomicInteger())\n              .incrementAndGet();\n        }\n        if (replicas.isEmpty()) {\n          emptyNodes++;\n        }\n      }\n      if (minReplicas == Integer.MAX_VALUE) {\n        minReplicas = 0;\n      }\n      log.info(\"## Empty nodes:\\t\" + emptyNodes);\n      Set<String> deadNodes = cluster.getSimNodeStateProvider().simGetDeadNodes();\n      log.info(\"## Dead nodes:\\t\\t\" + deadNodes.size());\n      deadNodes.forEach(n -> log.info(\"##\\t\\t\" + n));\n      log.info(\"## Collections:\\t\" + cluster.getSimClusterStateProvider().simListCollections());\n      log.info(\"## Max replicas per node:\\t\" + maxReplicas);\n      log.info(\"## Min replicas per node:\\t\" + minReplicas);\n      log.info(\"## Total replicas:\\t\\t\" + numReplicas);\n      replicaStates.forEach((c, map) -> {\n        AtomicInteger repCnt = new AtomicInteger();\n        map.forEach((s, cnt) -> repCnt.addAndGet(cnt.get()));\n        log.info(\"## * \" + c + \"\\t\\t\" + repCnt.get());\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-12s  %4d\", s, cnt.get())));\n      });\n      log.info(\"######### Final Solr op counts ##########\");\n      cluster.simGetOpCounts().forEach((k, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-14s  %4d\", k, cnt.get())));\n      log.info(\"######### Autoscaling event counts ###########\");\n      TreeMap<String, Map<String, AtomicInteger>> counts = new TreeMap<>();\n\n      List<SolrInputDocument> solrInputDocuments = cluster.simGetSystemCollection();\n      synchronized (solrInputDocuments) {\n        for (SolrInputDocument d : solrInputDocuments) {\n          if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n            continue;\n          }\n          counts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new TreeMap<>())\n              .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n              .incrementAndGet();\n        }\n      }\n      counts.forEach((trigger, map) -> {\n        log.info(\"## * Trigger: \" + trigger);\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-11s  %4d\", s, cnt.get())));\n      });\n    }\n  }\n\n","sourceOld":"  @Override\n  public void tearDown() throws Exception {\n    super.tearDown();\n    if (cluster != null) {\n      log.info(\"\\n\");\n      log.info(\"#############################################\");\n      log.info(\"############ FINAL CLUSTER STATS ############\");\n      log.info(\"#############################################\\n\");\n      log.info(\"## Live nodes:\\t\\t\" + cluster.getLiveNodesSet().size());\n      int emptyNodes = 0;\n      int maxReplicas = 0;\n      int minReplicas = Integer.MAX_VALUE;\n      Map<String, Map<Replica.State, AtomicInteger>> replicaStates = new TreeMap<>();\n      int numReplicas = 0;\n      for (String node : cluster.getLiveNodesSet().get()) {\n        List<ReplicaInfo> replicas = cluster.getSimClusterStateProvider().simGetReplicaInfos(node);\n        numReplicas += replicas.size();\n        if (replicas.size() > maxReplicas) {\n          maxReplicas = replicas.size();\n        }\n        if (minReplicas > replicas.size()) {\n          minReplicas = replicas.size();\n        }\n        for (ReplicaInfo ri : replicas) {\n          replicaStates.computeIfAbsent(ri.getCollection(), c -> new TreeMap<>())\n              .computeIfAbsent(ri.getState(), s -> new AtomicInteger())\n              .incrementAndGet();\n        }\n        if (replicas.isEmpty()) {\n          emptyNodes++;\n        }\n      }\n      if (minReplicas == Integer.MAX_VALUE) {\n        minReplicas = 0;\n      }\n      log.info(\"## Empty nodes:\\t\" + emptyNodes);\n      Set<String> deadNodes = cluster.getSimNodeStateProvider().simGetDeadNodes();\n      log.info(\"## Dead nodes:\\t\\t\" + deadNodes.size());\n      deadNodes.forEach(n -> log.info(\"##\\t\\t\" + n));\n      log.info(\"## Collections:\\t\" + cluster.getSimClusterStateProvider().simListCollections());\n      log.info(\"## Max replicas per node:\\t\" + maxReplicas);\n      log.info(\"## Min replicas per node:\\t\" + minReplicas);\n      log.info(\"## Total replicas:\\t\\t\" + numReplicas);\n      replicaStates.forEach((c, map) -> {\n        AtomicInteger repCnt = new AtomicInteger();\n        map.forEach((s, cnt) -> repCnt.addAndGet(cnt.get()));\n        log.info(\"## * \" + c + \"\\t\\t\" + repCnt.get());\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-12s  %4d\", s, cnt.get())));\n      });\n      log.info(\"######### Final Solr op counts ##########\");\n      cluster.simGetOpCounts().forEach((k, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-14s  %4d\", k, cnt.get())));\n      log.info(\"######### Autoscaling event counts ###########\");\n      TreeMap<String, Map<String, AtomicInteger>> counts = new TreeMap<>();\n      for (SolrInputDocument d : cluster.simGetSystemCollection()) {\n        if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n          continue;\n        }\n        counts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new TreeMap<>())\n            .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n            .incrementAndGet();\n      }\n      counts.forEach((trigger, map) -> {\n        log.info(\"## * Trigger: \" + trigger);\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-11s  %4d\", s, cnt.get())));\n      });\n    }\n  }\n\n","bugFix":["a4422b331d00607258b0ed3e43934306e67764aa"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"278895e10265b1174eef1ab0be0cbeba446484a4","date":1515420497,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimSolrCloudTestCase#tearDown().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimSolrCloudTestCase#tearDown().mjava","sourceNew":"  @Override\n  public void tearDown() throws Exception {\n    super.tearDown();\n    if (cluster != null) {\n      log.info(\"\\n\");\n      log.info(\"#############################################\");\n      log.info(\"############ FINAL CLUSTER STATS ############\");\n      log.info(\"#############################################\\n\");\n      log.info(\"## Live nodes:\\t\\t\" + cluster.getLiveNodesSet().size());\n      int emptyNodes = 0;\n      int maxReplicas = 0;\n      int minReplicas = Integer.MAX_VALUE;\n      Map<String, Map<Replica.State, AtomicInteger>> replicaStates = new TreeMap<>();\n      int numReplicas = 0;\n      for (String node : cluster.getLiveNodesSet().get()) {\n        List<ReplicaInfo> replicas = cluster.getSimClusterStateProvider().simGetReplicaInfos(node);\n        numReplicas += replicas.size();\n        if (replicas.size() > maxReplicas) {\n          maxReplicas = replicas.size();\n        }\n        if (minReplicas > replicas.size()) {\n          minReplicas = replicas.size();\n        }\n        for (ReplicaInfo ri : replicas) {\n          replicaStates.computeIfAbsent(ri.getCollection(), c -> new TreeMap<>())\n              .computeIfAbsent(ri.getState(), s -> new AtomicInteger())\n              .incrementAndGet();\n        }\n        if (replicas.isEmpty()) {\n          emptyNodes++;\n        }\n      }\n      if (minReplicas == Integer.MAX_VALUE) {\n        minReplicas = 0;\n      }\n      log.info(\"## Empty nodes:\\t\" + emptyNodes);\n      Set<String> deadNodes = cluster.getSimNodeStateProvider().simGetDeadNodes();\n      log.info(\"## Dead nodes:\\t\\t\" + deadNodes.size());\n      deadNodes.forEach(n -> log.info(\"##\\t\\t\" + n));\n      log.info(\"## Collections:\\t\" + cluster.getSimClusterStateProvider().simListCollections());\n      log.info(\"## Max replicas per node:\\t\" + maxReplicas);\n      log.info(\"## Min replicas per node:\\t\" + minReplicas);\n      log.info(\"## Total replicas:\\t\\t\" + numReplicas);\n      replicaStates.forEach((c, map) -> {\n        AtomicInteger repCnt = new AtomicInteger();\n        map.forEach((s, cnt) -> repCnt.addAndGet(cnt.get()));\n        log.info(\"## * \" + c + \"\\t\\t\" + repCnt.get());\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-12s  %4d\", s, cnt.get())));\n      });\n      log.info(\"######### Final Solr op counts ##########\");\n      cluster.simGetOpCounts().forEach((k, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-14s  %4d\", k, cnt.get())));\n      log.info(\"######### Autoscaling event counts ###########\");\n      Map<String, Map<String, AtomicInteger>> counts = cluster.simGetEventCounts();\n      counts.forEach((trigger, map) -> {\n        log.info(\"## * Trigger: \" + trigger);\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-11s  %4d\", s, cnt.get())));\n      });\n    }\n  }\n\n","sourceOld":"  @Override\n  public void tearDown() throws Exception {\n    super.tearDown();\n    if (cluster != null) {\n      log.info(\"\\n\");\n      log.info(\"#############################################\");\n      log.info(\"############ FINAL CLUSTER STATS ############\");\n      log.info(\"#############################################\\n\");\n      log.info(\"## Live nodes:\\t\\t\" + cluster.getLiveNodesSet().size());\n      int emptyNodes = 0;\n      int maxReplicas = 0;\n      int minReplicas = Integer.MAX_VALUE;\n      Map<String, Map<Replica.State, AtomicInteger>> replicaStates = new TreeMap<>();\n      int numReplicas = 0;\n      for (String node : cluster.getLiveNodesSet().get()) {\n        List<ReplicaInfo> replicas = cluster.getSimClusterStateProvider().simGetReplicaInfos(node);\n        numReplicas += replicas.size();\n        if (replicas.size() > maxReplicas) {\n          maxReplicas = replicas.size();\n        }\n        if (minReplicas > replicas.size()) {\n          minReplicas = replicas.size();\n        }\n        for (ReplicaInfo ri : replicas) {\n          replicaStates.computeIfAbsent(ri.getCollection(), c -> new TreeMap<>())\n              .computeIfAbsent(ri.getState(), s -> new AtomicInteger())\n              .incrementAndGet();\n        }\n        if (replicas.isEmpty()) {\n          emptyNodes++;\n        }\n      }\n      if (minReplicas == Integer.MAX_VALUE) {\n        minReplicas = 0;\n      }\n      log.info(\"## Empty nodes:\\t\" + emptyNodes);\n      Set<String> deadNodes = cluster.getSimNodeStateProvider().simGetDeadNodes();\n      log.info(\"## Dead nodes:\\t\\t\" + deadNodes.size());\n      deadNodes.forEach(n -> log.info(\"##\\t\\t\" + n));\n      log.info(\"## Collections:\\t\" + cluster.getSimClusterStateProvider().simListCollections());\n      log.info(\"## Max replicas per node:\\t\" + maxReplicas);\n      log.info(\"## Min replicas per node:\\t\" + minReplicas);\n      log.info(\"## Total replicas:\\t\\t\" + numReplicas);\n      replicaStates.forEach((c, map) -> {\n        AtomicInteger repCnt = new AtomicInteger();\n        map.forEach((s, cnt) -> repCnt.addAndGet(cnt.get()));\n        log.info(\"## * \" + c + \"\\t\\t\" + repCnt.get());\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-12s  %4d\", s, cnt.get())));\n      });\n      log.info(\"######### Final Solr op counts ##########\");\n      cluster.simGetOpCounts().forEach((k, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-14s  %4d\", k, cnt.get())));\n      log.info(\"######### Autoscaling event counts ###########\");\n      TreeMap<String, Map<String, AtomicInteger>> counts = new TreeMap<>();\n\n      List<SolrInputDocument> solrInputDocuments = cluster.simGetSystemCollection();\n      synchronized (solrInputDocuments) {\n        for (SolrInputDocument d : solrInputDocuments) {\n          if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n            continue;\n          }\n          counts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new TreeMap<>())\n              .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n              .incrementAndGet();\n        }\n      }\n      counts.forEach((trigger, map) -> {\n        log.info(\"## * Trigger: \" + trigger);\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-11s  %4d\", s, cnt.get())));\n      });\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimSolrCloudTestCase#tearDown().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimSolrCloudTestCase#tearDown().mjava","sourceNew":"  @Override\n  public void tearDown() throws Exception {\n    super.tearDown();\n    if (cluster != null) {\n      log.info(\"\\n\");\n      log.info(\"#############################################\");\n      log.info(\"############ FINAL CLUSTER STATS ############\");\n      log.info(\"#############################################\\n\");\n      log.info(\"## Live nodes:\\t\\t\" + cluster.getLiveNodesSet().size());\n      int emptyNodes = 0;\n      int maxReplicas = 0;\n      int minReplicas = Integer.MAX_VALUE;\n      Map<String, Map<Replica.State, AtomicInteger>> replicaStates = new TreeMap<>();\n      int numReplicas = 0;\n      for (String node : cluster.getLiveNodesSet().get()) {\n        List<ReplicaInfo> replicas = cluster.getSimClusterStateProvider().simGetReplicaInfos(node);\n        numReplicas += replicas.size();\n        if (replicas.size() > maxReplicas) {\n          maxReplicas = replicas.size();\n        }\n        if (minReplicas > replicas.size()) {\n          minReplicas = replicas.size();\n        }\n        for (ReplicaInfo ri : replicas) {\n          replicaStates.computeIfAbsent(ri.getCollection(), c -> new TreeMap<>())\n              .computeIfAbsent(ri.getState(), s -> new AtomicInteger())\n              .incrementAndGet();\n        }\n        if (replicas.isEmpty()) {\n          emptyNodes++;\n        }\n      }\n      if (minReplicas == Integer.MAX_VALUE) {\n        minReplicas = 0;\n      }\n      log.info(\"## Empty nodes:\\t\" + emptyNodes);\n      Set<String> deadNodes = cluster.getSimNodeStateProvider().simGetDeadNodes();\n      log.info(\"## Dead nodes:\\t\\t\" + deadNodes.size());\n      deadNodes.forEach(n -> log.info(\"##\\t\\t\" + n));\n      log.info(\"## Collections:\\t\" + cluster.getSimClusterStateProvider().simListCollections());\n      log.info(\"## Max replicas per node:\\t\" + maxReplicas);\n      log.info(\"## Min replicas per node:\\t\" + minReplicas);\n      log.info(\"## Total replicas:\\t\\t\" + numReplicas);\n      replicaStates.forEach((c, map) -> {\n        AtomicInteger repCnt = new AtomicInteger();\n        map.forEach((s, cnt) -> repCnt.addAndGet(cnt.get()));\n        log.info(\"## * \" + c + \"\\t\\t\" + repCnt.get());\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-12s  %4d\", s, cnt.get())));\n      });\n      log.info(\"######### Final Solr op counts ##########\");\n      cluster.simGetOpCounts().forEach((k, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-14s  %4d\", k, cnt.get())));\n      log.info(\"######### Autoscaling event counts ###########\");\n      Map<String, Map<String, AtomicInteger>> counts = cluster.simGetEventCounts();\n      counts.forEach((trigger, map) -> {\n        log.info(\"## * Trigger: \" + trigger);\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-11s  %4d\", s, cnt.get())));\n      });\n    }\n  }\n\n","sourceOld":"  @Override\n  public void tearDown() throws Exception {\n    super.tearDown();\n    if (cluster != null) {\n      log.info(\"\\n\");\n      log.info(\"#############################################\");\n      log.info(\"############ FINAL CLUSTER STATS ############\");\n      log.info(\"#############################################\\n\");\n      log.info(\"## Live nodes:\\t\\t\" + cluster.getLiveNodesSet().size());\n      int emptyNodes = 0;\n      int maxReplicas = 0;\n      int minReplicas = Integer.MAX_VALUE;\n      Map<String, Map<Replica.State, AtomicInteger>> replicaStates = new TreeMap<>();\n      int numReplicas = 0;\n      for (String node : cluster.getLiveNodesSet().get()) {\n        List<ReplicaInfo> replicas = cluster.getSimClusterStateProvider().simGetReplicaInfos(node);\n        numReplicas += replicas.size();\n        if (replicas.size() > maxReplicas) {\n          maxReplicas = replicas.size();\n        }\n        if (minReplicas > replicas.size()) {\n          minReplicas = replicas.size();\n        }\n        for (ReplicaInfo ri : replicas) {\n          replicaStates.computeIfAbsent(ri.getCollection(), c -> new TreeMap<>())\n              .computeIfAbsent(ri.getState(), s -> new AtomicInteger())\n              .incrementAndGet();\n        }\n        if (replicas.isEmpty()) {\n          emptyNodes++;\n        }\n      }\n      if (minReplicas == Integer.MAX_VALUE) {\n        minReplicas = 0;\n      }\n      log.info(\"## Empty nodes:\\t\" + emptyNodes);\n      Set<String> deadNodes = cluster.getSimNodeStateProvider().simGetDeadNodes();\n      log.info(\"## Dead nodes:\\t\\t\" + deadNodes.size());\n      deadNodes.forEach(n -> log.info(\"##\\t\\t\" + n));\n      log.info(\"## Collections:\\t\" + cluster.getSimClusterStateProvider().simListCollections());\n      log.info(\"## Max replicas per node:\\t\" + maxReplicas);\n      log.info(\"## Min replicas per node:\\t\" + minReplicas);\n      log.info(\"## Total replicas:\\t\\t\" + numReplicas);\n      replicaStates.forEach((c, map) -> {\n        AtomicInteger repCnt = new AtomicInteger();\n        map.forEach((s, cnt) -> repCnt.addAndGet(cnt.get()));\n        log.info(\"## * \" + c + \"\\t\\t\" + repCnt.get());\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-12s  %4d\", s, cnt.get())));\n      });\n      log.info(\"######### Final Solr op counts ##########\");\n      cluster.simGetOpCounts().forEach((k, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-14s  %4d\", k, cnt.get())));\n      log.info(\"######### Autoscaling event counts ###########\");\n      TreeMap<String, Map<String, AtomicInteger>> counts = new TreeMap<>();\n      for (SolrInputDocument d : cluster.simGetSystemCollection()) {\n        if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n          continue;\n        }\n        counts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new TreeMap<>())\n            .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n            .incrementAndGet();\n      }\n      counts.forEach((trigger, map) -> {\n        log.info(\"## * Trigger: \" + trigger);\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-11s  %4d\", s, cnt.get())));\n      });\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1","date":1523453934,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimSolrCloudTestCase#tearDown().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimSolrCloudTestCase#tearDown().mjava","sourceNew":"  @Override\n  public void tearDown() throws Exception {\n    super.tearDown();\n    if (cluster != null) {\n      log.info(cluster.dumpClusterState(false));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void tearDown() throws Exception {\n    super.tearDown();\n    if (cluster != null) {\n      log.info(\"\\n\");\n      log.info(\"#############################################\");\n      log.info(\"############ FINAL CLUSTER STATS ############\");\n      log.info(\"#############################################\\n\");\n      log.info(\"## Live nodes:\\t\\t\" + cluster.getLiveNodesSet().size());\n      int emptyNodes = 0;\n      int maxReplicas = 0;\n      int minReplicas = Integer.MAX_VALUE;\n      Map<String, Map<Replica.State, AtomicInteger>> replicaStates = new TreeMap<>();\n      int numReplicas = 0;\n      for (String node : cluster.getLiveNodesSet().get()) {\n        List<ReplicaInfo> replicas = cluster.getSimClusterStateProvider().simGetReplicaInfos(node);\n        numReplicas += replicas.size();\n        if (replicas.size() > maxReplicas) {\n          maxReplicas = replicas.size();\n        }\n        if (minReplicas > replicas.size()) {\n          minReplicas = replicas.size();\n        }\n        for (ReplicaInfo ri : replicas) {\n          replicaStates.computeIfAbsent(ri.getCollection(), c -> new TreeMap<>())\n              .computeIfAbsent(ri.getState(), s -> new AtomicInteger())\n              .incrementAndGet();\n        }\n        if (replicas.isEmpty()) {\n          emptyNodes++;\n        }\n      }\n      if (minReplicas == Integer.MAX_VALUE) {\n        minReplicas = 0;\n      }\n      log.info(\"## Empty nodes:\\t\" + emptyNodes);\n      Set<String> deadNodes = cluster.getSimNodeStateProvider().simGetDeadNodes();\n      log.info(\"## Dead nodes:\\t\\t\" + deadNodes.size());\n      deadNodes.forEach(n -> log.info(\"##\\t\\t\" + n));\n      log.info(\"## Collections:\\t\" + cluster.getSimClusterStateProvider().simListCollections());\n      log.info(\"## Max replicas per node:\\t\" + maxReplicas);\n      log.info(\"## Min replicas per node:\\t\" + minReplicas);\n      log.info(\"## Total replicas:\\t\\t\" + numReplicas);\n      replicaStates.forEach((c, map) -> {\n        AtomicInteger repCnt = new AtomicInteger();\n        map.forEach((s, cnt) -> repCnt.addAndGet(cnt.get()));\n        log.info(\"## * \" + c + \"\\t\\t\" + repCnt.get());\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-12s  %4d\", s, cnt.get())));\n      });\n      log.info(\"######### Final Solr op counts ##########\");\n      cluster.simGetOpCounts().forEach((k, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-14s  %4d\", k, cnt.get())));\n      log.info(\"######### Autoscaling event counts ###########\");\n      Map<String, Map<String, AtomicInteger>> counts = cluster.simGetEventCounts();\n      counts.forEach((trigger, map) -> {\n        log.info(\"## * Trigger: \" + trigger);\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-11s  %4d\", s, cnt.get())));\n      });\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43345f1452f9510f8aaadae6156fe0c834e7d957","date":1523483670,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimSolrCloudTestCase#tearDown().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimSolrCloudTestCase#tearDown().mjava","sourceNew":"  @Override\n  public void tearDown() throws Exception {\n    super.tearDown();\n    if (cluster != null) {\n      log.info(cluster.dumpClusterState(false));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void tearDown() throws Exception {\n    super.tearDown();\n    if (cluster != null) {\n      log.info(\"\\n\");\n      log.info(\"#############################################\");\n      log.info(\"############ FINAL CLUSTER STATS ############\");\n      log.info(\"#############################################\\n\");\n      log.info(\"## Live nodes:\\t\\t\" + cluster.getLiveNodesSet().size());\n      int emptyNodes = 0;\n      int maxReplicas = 0;\n      int minReplicas = Integer.MAX_VALUE;\n      Map<String, Map<Replica.State, AtomicInteger>> replicaStates = new TreeMap<>();\n      int numReplicas = 0;\n      for (String node : cluster.getLiveNodesSet().get()) {\n        List<ReplicaInfo> replicas = cluster.getSimClusterStateProvider().simGetReplicaInfos(node);\n        numReplicas += replicas.size();\n        if (replicas.size() > maxReplicas) {\n          maxReplicas = replicas.size();\n        }\n        if (minReplicas > replicas.size()) {\n          minReplicas = replicas.size();\n        }\n        for (ReplicaInfo ri : replicas) {\n          replicaStates.computeIfAbsent(ri.getCollection(), c -> new TreeMap<>())\n              .computeIfAbsent(ri.getState(), s -> new AtomicInteger())\n              .incrementAndGet();\n        }\n        if (replicas.isEmpty()) {\n          emptyNodes++;\n        }\n      }\n      if (minReplicas == Integer.MAX_VALUE) {\n        minReplicas = 0;\n      }\n      log.info(\"## Empty nodes:\\t\" + emptyNodes);\n      Set<String> deadNodes = cluster.getSimNodeStateProvider().simGetDeadNodes();\n      log.info(\"## Dead nodes:\\t\\t\" + deadNodes.size());\n      deadNodes.forEach(n -> log.info(\"##\\t\\t\" + n));\n      log.info(\"## Collections:\\t\" + cluster.getSimClusterStateProvider().simListCollections());\n      log.info(\"## Max replicas per node:\\t\" + maxReplicas);\n      log.info(\"## Min replicas per node:\\t\" + minReplicas);\n      log.info(\"## Total replicas:\\t\\t\" + numReplicas);\n      replicaStates.forEach((c, map) -> {\n        AtomicInteger repCnt = new AtomicInteger();\n        map.forEach((s, cnt) -> repCnt.addAndGet(cnt.get()));\n        log.info(\"## * \" + c + \"\\t\\t\" + repCnt.get());\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-12s  %4d\", s, cnt.get())));\n      });\n      log.info(\"######### Final Solr op counts ##########\");\n      cluster.simGetOpCounts().forEach((k, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-14s  %4d\", k, cnt.get())));\n      log.info(\"######### Autoscaling event counts ###########\");\n      Map<String, Map<String, AtomicInteger>> counts = cluster.simGetEventCounts();\n      counts.forEach((trigger, map) -> {\n        log.info(\"## * Trigger: \" + trigger);\n        map.forEach((s, cnt) -> log.info(\"##\\t\\t- \" + String.format(Locale.ROOT, \"%-11s  %4d\", s, cnt.get())));\n      });\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","date":1588172214,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimSolrCloudTestCase#tearDown().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimSolrCloudTestCase#tearDown().mjava","sourceNew":"  @Override\n  public void tearDown() throws Exception {\n    super.tearDown();\n    if (cluster != null) {\n      if (log.isInfoEnabled()) {\n        log.info(cluster.dumpClusterState(false));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void tearDown() throws Exception {\n    super.tearDown();\n    if (cluster != null) {\n      log.info(cluster.dumpClusterState(false));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimSolrCloudTestCase#tearDown().mjava","sourceNew":null,"sourceOld":"  @Override\n  public void tearDown() throws Exception {\n    super.tearDown();\n    if (cluster != null) {\n      if (log.isInfoEnabled()) {\n        log.info(cluster.dumpClusterState(false));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a4422b331d00607258b0ed3e43934306e67764aa","278895e10265b1174eef1ab0be0cbeba446484a4"],"278895e10265b1174eef1ab0be0cbeba446484a4":["4c6d7fbed9c3bc14668e17ddb41c13d435d3ba9b"],"3f504512a03d978990cbff30db0522b354e846db":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1":["b94236357aaa22b76c10629851fe4e376e0cea82"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a4422b331d00607258b0ed3e43934306e67764aa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4c6d7fbed9c3bc14668e17ddb41c13d435d3ba9b":["a4422b331d00607258b0ed3e43934306e67764aa"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["b94236357aaa22b76c10629851fe4e376e0cea82","ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1","43345f1452f9510f8aaadae6156fe0c834e7d957"],"278895e10265b1174eef1ab0be0cbeba446484a4":["b94236357aaa22b76c10629851fe4e376e0cea82"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["3f504512a03d978990cbff30db0522b354e846db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a4422b331d00607258b0ed3e43934306e67764aa"],"a4422b331d00607258b0ed3e43934306e67764aa":["b94236357aaa22b76c10629851fe4e376e0cea82","4c6d7fbed9c3bc14668e17ddb41c13d435d3ba9b"],"4c6d7fbed9c3bc14668e17ddb41c13d435d3ba9b":["278895e10265b1174eef1ab0be0cbeba446484a4"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}