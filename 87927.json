{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","commits":[{"id":"09f37c23448e2f162cd158c9a5f575d10ad19308","date":1355253672,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    boolean round = rangeStep >= (1<<bits)*16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask2) != mask2)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask2) - increment ;\n        long roundUp = (end | mask2) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    boolean round = rangeStep >= (1<<bits)*16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask2) != mask2)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask2) - increment ;\n        long roundUp = (end | mask2) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7623716022a9a68898e329e8ffe6c36d168fba7","date":1384524101,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","sourceNew":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1<<bits)*16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask) - increment ;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","sourceOld":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    boolean round = rangeStep >= (1<<bits)*16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask2) != mask2)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask2) - increment ;\n        long roundUp = (end | mask2) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe","date":1384867512,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","sourceNew":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","sourceOld":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1<<bits)*16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask) - increment ;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","sourceNew":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","sourceOld":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    boolean round = rangeStep >= (1<<bits)*16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask2) != mask2)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask2) - increment ;\n        long roundUp = (end | mask2) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","sourceNew":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","sourceOld":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9","date":1574619880,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","sourceNew":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.emptyList();\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","sourceOld":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9c3baacabd473e8ecd6c4948aabacead49b88e","date":1574700980,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","sourceNew":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","sourceOld":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.emptyList();\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7dfea4f7c80813344b0152e37fc18b31369e8ff","date":1592136683,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","sourceOld":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3adc4d119a7deba35b2721853853464857d9d0a9","date":1594608068,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRange(int,Range).mjava","sourceNew":"  @Override\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.emptyList();\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    // keep track of the idealized target to avoid accumulating rounding errors\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    // Round to avoid splitting hash domains across ranges if such rounding is not significant.\n    // With default bits==16, one would need to create more than 4000 shards before this\n    // becomes false by default.\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        // round up or down?\n        int increment = 1 << bits;  // 0x00010000\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","09f37c23448e2f162cd158c9a5f575d10ad19308"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3adc4d119a7deba35b2721853853464857d9d0a9":["a7dfea4f7c80813344b0152e37fc18b31369e8ff"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["09f37c23448e2f162cd158c9a5f575d10ad19308","c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe"],"c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe":["f7623716022a9a68898e329e8ffe6c36d168fba7"],"09f37c23448e2f162cd158c9a5f575d10ad19308":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f7623716022a9a68898e329e8ffe6c36d168fba7":["09f37c23448e2f162cd158c9a5f575d10ad19308"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3adc4d119a7deba35b2721853853464857d9d0a9"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"3adc4d119a7deba35b2721853853464857d9d0a9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","09f37c23448e2f162cd158c9a5f575d10ad19308"],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["3adc4d119a7deba35b2721853853464857d9d0a9"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a7dfea4f7c80813344b0152e37fc18b31369e8ff"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"09f37c23448e2f162cd158c9a5f575d10ad19308":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","74f45af4339b0daf7a95c820ab88c1aea74fbce0","f7623716022a9a68898e329e8ffe6c36d168fba7"],"c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"f7623716022a9a68898e329e8ffe6c36d168fba7":["c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}