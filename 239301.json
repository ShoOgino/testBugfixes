{"path":"solr/core/src/java/org/apache/solr/security/JWTAuthPlugin#authenticate(String).mjava","commits":[{"id":"bb3e075eaa5788b2762ec235bf72b069cefe3f50","date":1548244981,"type":0,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/JWTAuthPlugin#authenticate(String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Testable authentication method\n   *\n   * @param authorizationHeader the http header \"Authentication\"\n   * @return AuthenticationResponse object\n   */\n  protected JWTAuthenticationResponse authenticate(String authorizationHeader) {\n    if (authorizationHeader != null) {\n      StringTokenizer st = new StringTokenizer(authorizationHeader);\n      if (st.hasMoreTokens()) {\n        String bearer = st.nextToken();\n        if (bearer.equalsIgnoreCase(\"Bearer\") && st.hasMoreTokens()) {\n          try {\n            String jwtCompact = st.nextToken();\n            try {\n              JwtClaims jwtClaims = jwtConsumer.processToClaims(jwtCompact);\n              String principal = jwtClaims.getStringClaimValue(principalClaim);\n              if (principal == null || principal.isEmpty()) {\n                return new JWTAuthenticationResponse(AuthCode.PRINCIPAL_MISSING, \"Cannot identify principal from JWT. Required claim \" + principalClaim + \" missing. Cannot authenticate\");\n              }\n              if (claimsMatchCompiled != null) {\n                for (Map.Entry<String, Pattern> entry : claimsMatchCompiled.entrySet()) {\n                  String claim = entry.getKey();\n                  if (jwtClaims.hasClaim(claim)) {\n                    if (!entry.getValue().matcher(jwtClaims.getStringClaimValue(claim)).matches()) {\n                      return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH,\n                          \"Claim \" + claim + \"=\" + jwtClaims.getStringClaimValue(claim)\n                              + \" does not match required regular expression \" + entry.getValue().pattern());\n                    }\n                  } else {\n                    return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + claim + \" is required but does not exist in JWT\");\n                  }\n                }\n              }\n              if (!requiredScopes.isEmpty() && !jwtClaims.hasClaim(CLAIM_SCOPE)) {\n                // Fail if we require scopes but they don't exist\n                return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + CLAIM_SCOPE + \" is required but does not exist in JWT\");\n              }\n              Set<String> scopes = Collections.emptySet();\n              Object scopesObj = jwtClaims.getClaimValue(CLAIM_SCOPE);\n              if (scopesObj != null) {\n                if (scopesObj instanceof String) {\n                  scopes = new HashSet<>(Arrays.asList(((String) scopesObj).split(\"\\\\s+\")));\n                } else if (scopesObj instanceof List) {\n                  scopes = new HashSet<>(jwtClaims.getStringListClaimValue(CLAIM_SCOPE));\n                }\n                // Validate that at least one of the required scopes are present in the scope claim \n                if (!requiredScopes.isEmpty()) {\n                  if (scopes.stream().noneMatch(requiredScopes::contains)) {\n                    return new JWTAuthenticationResponse(AuthCode.SCOPE_MISSING, \"Claim \" + CLAIM_SCOPE + \" does not contain any of the required scopes: \" + requiredScopes);\n                  }\n                }\n                final Set<String> finalScopes = new HashSet<>(scopes);\n                finalScopes.remove(\"openid\"); // Remove standard scope\n                // Pass scopes with principal to signal to any Authorization plugins that user has some verified role claims\n                return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipalWithUserRoles(principal, jwtCompact, jwtClaims.getClaimsMap(), finalScopes));\n              } else {\n                return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipal(principal, jwtCompact, jwtClaims.getClaimsMap()));\n              }\n            } catch (InvalidJwtException e) {\n              // Whether or not the JWT has expired being one common reason for invalidity\n              System.out.println(\"Exception is \" + e.getClass().getName() + \", \" + e.getMessage() + \", code=\" + e.getErrorDetails().get(0).getErrorCode());\n              if (e.hasExpired()) {\n                return new JWTAuthenticationResponse(AuthCode.JWT_EXPIRED, \"Authentication failed due to expired JWT token. Expired at \" + e.getJwtContext().getJwtClaims().getExpirationTime());\n              }\n              if (e.getCause() != null && e.getCause() instanceof JoseException && e.getCause().getMessage().contains(\"Invalid JOSE Compact Serialization\")) {\n                return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, e.getCause().getMessage());\n              }\n              return new JWTAuthenticationResponse(AuthCode.JWT_VALIDATION_EXCEPTION, e);\n            }\n          } catch (MalformedClaimException e) {\n            return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, \"Malformed claim, error was: \" + e.getMessage());\n          }\n        } else {\n          return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n        }\n      } else {\n        return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n      }\n    } else {\n      // No Authorization header\n      if (blockUnknown) {\n        return new JWTAuthenticationResponse(AuthCode.NO_AUTZ_HEADER, \"Missing Authorization header\");\n      } else {\n        log.debug(\"No user authenticated, but blockUnknown=false, so letting request through\");\n        return new JWTAuthenticationResponse(AuthCode.PASS_THROUGH);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2682a1cd25864ccdc1b44bf047bd08700f28ba06","date":1548321910,"type":0,"author":"Tommaso Teofili","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/security/JWTAuthPlugin#authenticate(String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Testable authentication method\n   *\n   * @param authorizationHeader the http header \"Authentication\"\n   * @return AuthenticationResponse object\n   */\n  protected JWTAuthenticationResponse authenticate(String authorizationHeader) {\n    if (authorizationHeader != null) {\n      StringTokenizer st = new StringTokenizer(authorizationHeader);\n      if (st.hasMoreTokens()) {\n        String bearer = st.nextToken();\n        if (bearer.equalsIgnoreCase(\"Bearer\") && st.hasMoreTokens()) {\n          try {\n            String jwtCompact = st.nextToken();\n            try {\n              JwtClaims jwtClaims = jwtConsumer.processToClaims(jwtCompact);\n              String principal = jwtClaims.getStringClaimValue(principalClaim);\n              if (principal == null || principal.isEmpty()) {\n                return new JWTAuthenticationResponse(AuthCode.PRINCIPAL_MISSING, \"Cannot identify principal from JWT. Required claim \" + principalClaim + \" missing. Cannot authenticate\");\n              }\n              if (claimsMatchCompiled != null) {\n                for (Map.Entry<String, Pattern> entry : claimsMatchCompiled.entrySet()) {\n                  String claim = entry.getKey();\n                  if (jwtClaims.hasClaim(claim)) {\n                    if (!entry.getValue().matcher(jwtClaims.getStringClaimValue(claim)).matches()) {\n                      return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH,\n                          \"Claim \" + claim + \"=\" + jwtClaims.getStringClaimValue(claim)\n                              + \" does not match required regular expression \" + entry.getValue().pattern());\n                    }\n                  } else {\n                    return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + claim + \" is required but does not exist in JWT\");\n                  }\n                }\n              }\n              if (!requiredScopes.isEmpty() && !jwtClaims.hasClaim(CLAIM_SCOPE)) {\n                // Fail if we require scopes but they don't exist\n                return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + CLAIM_SCOPE + \" is required but does not exist in JWT\");\n              }\n              Set<String> scopes = Collections.emptySet();\n              Object scopesObj = jwtClaims.getClaimValue(CLAIM_SCOPE);\n              if (scopesObj != null) {\n                if (scopesObj instanceof String) {\n                  scopes = new HashSet<>(Arrays.asList(((String) scopesObj).split(\"\\\\s+\")));\n                } else if (scopesObj instanceof List) {\n                  scopes = new HashSet<>(jwtClaims.getStringListClaimValue(CLAIM_SCOPE));\n                }\n                // Validate that at least one of the required scopes are present in the scope claim \n                if (!requiredScopes.isEmpty()) {\n                  if (scopes.stream().noneMatch(requiredScopes::contains)) {\n                    return new JWTAuthenticationResponse(AuthCode.SCOPE_MISSING, \"Claim \" + CLAIM_SCOPE + \" does not contain any of the required scopes: \" + requiredScopes);\n                  }\n                }\n                final Set<String> finalScopes = new HashSet<>(scopes);\n                finalScopes.remove(\"openid\"); // Remove standard scope\n                // Pass scopes with principal to signal to any Authorization plugins that user has some verified role claims\n                return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipalWithUserRoles(principal, jwtCompact, jwtClaims.getClaimsMap(), finalScopes));\n              } else {\n                return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipal(principal, jwtCompact, jwtClaims.getClaimsMap()));\n              }\n            } catch (InvalidJwtException e) {\n              // Whether or not the JWT has expired being one common reason for invalidity\n              System.out.println(\"Exception is \" + e.getClass().getName() + \", \" + e.getMessage() + \", code=\" + e.getErrorDetails().get(0).getErrorCode());\n              if (e.hasExpired()) {\n                return new JWTAuthenticationResponse(AuthCode.JWT_EXPIRED, \"Authentication failed due to expired JWT token. Expired at \" + e.getJwtContext().getJwtClaims().getExpirationTime());\n              }\n              if (e.getCause() != null && e.getCause() instanceof JoseException && e.getCause().getMessage().contains(\"Invalid JOSE Compact Serialization\")) {\n                return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, e.getCause().getMessage());\n              }\n              return new JWTAuthenticationResponse(AuthCode.JWT_VALIDATION_EXCEPTION, e);\n            }\n          } catch (MalformedClaimException e) {\n            return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, \"Malformed claim, error was: \" + e.getMessage());\n          }\n        } else {\n          return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n        }\n      } else {\n        return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n      }\n    } else {\n      // No Authorization header\n      if (blockUnknown) {\n        return new JWTAuthenticationResponse(AuthCode.NO_AUTZ_HEADER, \"Missing Authorization header\");\n      } else {\n        log.debug(\"No user authenticated, but blockUnknown=false, so letting request through\");\n        return new JWTAuthenticationResponse(AuthCode.PASS_THROUGH);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"931a54d2addc8e4bbdf29a803b7567559695f6e5","date":1552556889,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/JWTAuthPlugin#authenticate(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/JWTAuthPlugin#authenticate(String).mjava","sourceNew":"  /**\n   * Testable authentication method\n   *\n   * @param authorizationHeader the http header \"Authentication\"\n   * @return AuthenticationResponse object\n   */\n  protected JWTAuthenticationResponse authenticate(String authorizationHeader) {\n    if (authorizationHeader != null) {\n      StringTokenizer st = new StringTokenizer(authorizationHeader);\n      if (st.hasMoreTokens()) {\n        String bearer = st.nextToken();\n        if (bearer.equalsIgnoreCase(\"Bearer\") && st.hasMoreTokens()) {\n          try {\n            String jwtCompact = st.nextToken();\n            try {\n              JwtClaims jwtClaims = jwtConsumer.processToClaims(jwtCompact);\n              String principal = jwtClaims.getStringClaimValue(principalClaim);\n              if (principal == null || principal.isEmpty()) {\n                return new JWTAuthenticationResponse(AuthCode.PRINCIPAL_MISSING, \"Cannot identify principal from JWT. Required claim \" + principalClaim + \" missing. Cannot authenticate\");\n              }\n              if (claimsMatchCompiled != null) {\n                for (Map.Entry<String, Pattern> entry : claimsMatchCompiled.entrySet()) {\n                  String claim = entry.getKey();\n                  if (jwtClaims.hasClaim(claim)) {\n                    if (!entry.getValue().matcher(jwtClaims.getStringClaimValue(claim)).matches()) {\n                      return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH,\n                          \"Claim \" + claim + \"=\" + jwtClaims.getStringClaimValue(claim)\n                              + \" does not match required regular expression \" + entry.getValue().pattern());\n                    }\n                  } else {\n                    return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + claim + \" is required but does not exist in JWT\");\n                  }\n                }\n              }\n              if (!requiredScopes.isEmpty() && !jwtClaims.hasClaim(CLAIM_SCOPE)) {\n                // Fail if we require scopes but they don't exist\n                return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + CLAIM_SCOPE + \" is required but does not exist in JWT\");\n              }\n              Set<String> scopes = Collections.emptySet();\n              Object scopesObj = jwtClaims.getClaimValue(CLAIM_SCOPE);\n              if (scopesObj != null) {\n                if (scopesObj instanceof String) {\n                  scopes = new HashSet<>(Arrays.asList(((String) scopesObj).split(\"\\\\s+\")));\n                } else if (scopesObj instanceof List) {\n                  scopes = new HashSet<>(jwtClaims.getStringListClaimValue(CLAIM_SCOPE));\n                }\n                // Validate that at least one of the required scopes are present in the scope claim \n                if (!requiredScopes.isEmpty()) {\n                  if (scopes.stream().noneMatch(requiredScopes::contains)) {\n                    return new JWTAuthenticationResponse(AuthCode.SCOPE_MISSING, \"Claim \" + CLAIM_SCOPE + \" does not contain any of the required scopes: \" + requiredScopes);\n                  }\n                }\n                final Set<String> finalScopes = new HashSet<>(scopes);\n                finalScopes.remove(\"openid\"); // Remove standard scope\n                // Pass scopes with principal to signal to any Authorization plugins that user has some verified role claims\n                return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipalWithUserRoles(principal, jwtCompact, jwtClaims.getClaimsMap(), finalScopes));\n              } else {\n                return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipal(principal, jwtCompact, jwtClaims.getClaimsMap()));\n              }\n            } catch (InvalidJwtException e) {\n              // Whether or not the JWT has expired being one common reason for invalidity\n              if (e.hasExpired()) {\n                return new JWTAuthenticationResponse(AuthCode.JWT_EXPIRED, \"Authentication failed due to expired JWT token. Expired at \" + e.getJwtContext().getJwtClaims().getExpirationTime());\n              }\n              if (e.getCause() != null && e.getCause() instanceof JoseException && e.getCause().getMessage().contains(\"Invalid JOSE Compact Serialization\")) {\n                return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, e.getCause().getMessage());\n              }\n              return new JWTAuthenticationResponse(AuthCode.JWT_VALIDATION_EXCEPTION, e);\n            }\n          } catch (MalformedClaimException e) {\n            return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, \"Malformed claim, error was: \" + e.getMessage());\n          }\n        } else {\n          return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n        }\n      } else {\n        return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n      }\n    } else {\n      // No Authorization header\n      if (blockUnknown) {\n        return new JWTAuthenticationResponse(AuthCode.NO_AUTZ_HEADER, \"Missing Authorization header\");\n      } else {\n        log.debug(\"No user authenticated, but blockUnknown=false, so letting request through\");\n        return new JWTAuthenticationResponse(AuthCode.PASS_THROUGH);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Testable authentication method\n   *\n   * @param authorizationHeader the http header \"Authentication\"\n   * @return AuthenticationResponse object\n   */\n  protected JWTAuthenticationResponse authenticate(String authorizationHeader) {\n    if (authorizationHeader != null) {\n      StringTokenizer st = new StringTokenizer(authorizationHeader);\n      if (st.hasMoreTokens()) {\n        String bearer = st.nextToken();\n        if (bearer.equalsIgnoreCase(\"Bearer\") && st.hasMoreTokens()) {\n          try {\n            String jwtCompact = st.nextToken();\n            try {\n              JwtClaims jwtClaims = jwtConsumer.processToClaims(jwtCompact);\n              String principal = jwtClaims.getStringClaimValue(principalClaim);\n              if (principal == null || principal.isEmpty()) {\n                return new JWTAuthenticationResponse(AuthCode.PRINCIPAL_MISSING, \"Cannot identify principal from JWT. Required claim \" + principalClaim + \" missing. Cannot authenticate\");\n              }\n              if (claimsMatchCompiled != null) {\n                for (Map.Entry<String, Pattern> entry : claimsMatchCompiled.entrySet()) {\n                  String claim = entry.getKey();\n                  if (jwtClaims.hasClaim(claim)) {\n                    if (!entry.getValue().matcher(jwtClaims.getStringClaimValue(claim)).matches()) {\n                      return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH,\n                          \"Claim \" + claim + \"=\" + jwtClaims.getStringClaimValue(claim)\n                              + \" does not match required regular expression \" + entry.getValue().pattern());\n                    }\n                  } else {\n                    return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + claim + \" is required but does not exist in JWT\");\n                  }\n                }\n              }\n              if (!requiredScopes.isEmpty() && !jwtClaims.hasClaim(CLAIM_SCOPE)) {\n                // Fail if we require scopes but they don't exist\n                return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + CLAIM_SCOPE + \" is required but does not exist in JWT\");\n              }\n              Set<String> scopes = Collections.emptySet();\n              Object scopesObj = jwtClaims.getClaimValue(CLAIM_SCOPE);\n              if (scopesObj != null) {\n                if (scopesObj instanceof String) {\n                  scopes = new HashSet<>(Arrays.asList(((String) scopesObj).split(\"\\\\s+\")));\n                } else if (scopesObj instanceof List) {\n                  scopes = new HashSet<>(jwtClaims.getStringListClaimValue(CLAIM_SCOPE));\n                }\n                // Validate that at least one of the required scopes are present in the scope claim \n                if (!requiredScopes.isEmpty()) {\n                  if (scopes.stream().noneMatch(requiredScopes::contains)) {\n                    return new JWTAuthenticationResponse(AuthCode.SCOPE_MISSING, \"Claim \" + CLAIM_SCOPE + \" does not contain any of the required scopes: \" + requiredScopes);\n                  }\n                }\n                final Set<String> finalScopes = new HashSet<>(scopes);\n                finalScopes.remove(\"openid\"); // Remove standard scope\n                // Pass scopes with principal to signal to any Authorization plugins that user has some verified role claims\n                return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipalWithUserRoles(principal, jwtCompact, jwtClaims.getClaimsMap(), finalScopes));\n              } else {\n                return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipal(principal, jwtCompact, jwtClaims.getClaimsMap()));\n              }\n            } catch (InvalidJwtException e) {\n              // Whether or not the JWT has expired being one common reason for invalidity\n              System.out.println(\"Exception is \" + e.getClass().getName() + \", \" + e.getMessage() + \", code=\" + e.getErrorDetails().get(0).getErrorCode());\n              if (e.hasExpired()) {\n                return new JWTAuthenticationResponse(AuthCode.JWT_EXPIRED, \"Authentication failed due to expired JWT token. Expired at \" + e.getJwtContext().getJwtClaims().getExpirationTime());\n              }\n              if (e.getCause() != null && e.getCause() instanceof JoseException && e.getCause().getMessage().contains(\"Invalid JOSE Compact Serialization\")) {\n                return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, e.getCause().getMessage());\n              }\n              return new JWTAuthenticationResponse(AuthCode.JWT_VALIDATION_EXCEPTION, e);\n            }\n          } catch (MalformedClaimException e) {\n            return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, \"Malformed claim, error was: \" + e.getMessage());\n          }\n        } else {\n          return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n        }\n      } else {\n        return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n      }\n    } else {\n      // No Authorization header\n      if (blockUnknown) {\n        return new JWTAuthenticationResponse(AuthCode.NO_AUTZ_HEADER, \"Missing Authorization header\");\n      } else {\n        log.debug(\"No user authenticated, but blockUnknown=false, so letting request through\");\n        return new JWTAuthenticationResponse(AuthCode.PASS_THROUGH);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f67fad1a752e06d753afa1c41bcc27141d258f5","date":1555055351,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/JWTAuthPlugin#authenticate(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/JWTAuthPlugin#authenticate(String).mjava","sourceNew":"  /**\n   * Testable authentication method\n   *\n   * @param authorizationHeader the http header \"Authentication\"\n   * @return AuthenticationResponse object\n   */\n  protected JWTAuthenticationResponse authenticate(String authorizationHeader) {\n    if (authorizationHeader != null) {\n      StringTokenizer st = new StringTokenizer(authorizationHeader);\n      if (st.hasMoreTokens()) {\n        String bearer = st.nextToken();\n        if (bearer.equalsIgnoreCase(\"Bearer\") && st.hasMoreTokens()) {\n          try {\n            String jwtCompact = st.nextToken();\n            try {\n              JwtClaims jwtClaims = jwtConsumer.processToClaims(jwtCompact);\n              String principal = jwtClaims.getStringClaimValue(principalClaim);\n              if (principal == null || principal.isEmpty()) {\n                return new JWTAuthenticationResponse(AuthCode.PRINCIPAL_MISSING, \"Cannot identify principal from JWT. Required claim \" + principalClaim + \" missing. Cannot authenticate\");\n              }\n              if (claimsMatchCompiled != null) {\n                for (Map.Entry<String, Pattern> entry : claimsMatchCompiled.entrySet()) {\n                  String claim = entry.getKey();\n                  if (jwtClaims.hasClaim(claim)) {\n                    if (!entry.getValue().matcher(jwtClaims.getStringClaimValue(claim)).matches()) {\n                      return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH,\n                          \"Claim \" + claim + \"=\" + jwtClaims.getStringClaimValue(claim)\n                              + \" does not match required regular expression \" + entry.getValue().pattern());\n                    }\n                  } else {\n                    return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + claim + \" is required but does not exist in JWT\");\n                  }\n                }\n              }\n              if (!requiredScopes.isEmpty() && !jwtClaims.hasClaim(CLAIM_SCOPE)) {\n                // Fail if we require scopes but they don't exist\n                return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + CLAIM_SCOPE + \" is required but does not exist in JWT\");\n              }\n              Set<String> scopes = Collections.emptySet();\n              Object scopesObj = jwtClaims.getClaimValue(CLAIM_SCOPE);\n              if (scopesObj != null) {\n                if (scopesObj instanceof String) {\n                  scopes = new HashSet<>(Arrays.asList(((String) scopesObj).split(\"\\\\s+\")));\n                } else if (scopesObj instanceof List) {\n                  scopes = new HashSet<>(jwtClaims.getStringListClaimValue(CLAIM_SCOPE));\n                }\n                // Validate that at least one of the required scopes are present in the scope claim \n                if (!requiredScopes.isEmpty()) {\n                  if (scopes.stream().noneMatch(requiredScopes::contains)) {\n                    return new JWTAuthenticationResponse(AuthCode.SCOPE_MISSING, \"Claim \" + CLAIM_SCOPE + \" does not contain any of the required scopes: \" + requiredScopes);\n                  }\n                }\n                final Set<String> finalScopes = new HashSet<>(scopes);\n                finalScopes.remove(\"openid\"); // Remove standard scope\n                // Pass scopes with principal to signal to any Authorization plugins that user has some verified role claims\n                return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipalWithUserRoles(principal, jwtCompact, jwtClaims.getClaimsMap(), finalScopes));\n              } else {\n                return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipal(principal, jwtCompact, jwtClaims.getClaimsMap()));\n              }\n            } catch (InvalidJwtSignatureException ise) {\n              return new JWTAuthenticationResponse(AuthCode.SIGNATURE_INVALID, ise);\n            } catch (InvalidJwtException e) {\n              // Whether or not the JWT has expired being one common reason for invalidity\n              if (e.hasExpired()) {\n                return new JWTAuthenticationResponse(AuthCode.JWT_EXPIRED, \"Authentication failed due to expired JWT token. Expired at \" + e.getJwtContext().getJwtClaims().getExpirationTime());\n              }\n              if (e.getCause() != null && e.getCause() instanceof JoseException && e.getCause().getMessage().contains(\"Invalid JOSE Compact Serialization\")) {\n                return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, e.getCause().getMessage());\n              }\n              return new JWTAuthenticationResponse(AuthCode.JWT_VALIDATION_EXCEPTION, e);\n            }\n          } catch (MalformedClaimException e) {\n            return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, \"Malformed claim, error was: \" + e.getMessage());\n          }\n        } else {\n          return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n        }\n      } else {\n        return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n      }\n    } else {\n      // No Authorization header\n      if (blockUnknown) {\n        return new JWTAuthenticationResponse(AuthCode.NO_AUTZ_HEADER, \"Missing Authorization header\");\n      } else {\n        log.debug(\"No user authenticated, but blockUnknown=false, so letting request through\");\n        return new JWTAuthenticationResponse(AuthCode.PASS_THROUGH);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Testable authentication method\n   *\n   * @param authorizationHeader the http header \"Authentication\"\n   * @return AuthenticationResponse object\n   */\n  protected JWTAuthenticationResponse authenticate(String authorizationHeader) {\n    if (authorizationHeader != null) {\n      StringTokenizer st = new StringTokenizer(authorizationHeader);\n      if (st.hasMoreTokens()) {\n        String bearer = st.nextToken();\n        if (bearer.equalsIgnoreCase(\"Bearer\") && st.hasMoreTokens()) {\n          try {\n            String jwtCompact = st.nextToken();\n            try {\n              JwtClaims jwtClaims = jwtConsumer.processToClaims(jwtCompact);\n              String principal = jwtClaims.getStringClaimValue(principalClaim);\n              if (principal == null || principal.isEmpty()) {\n                return new JWTAuthenticationResponse(AuthCode.PRINCIPAL_MISSING, \"Cannot identify principal from JWT. Required claim \" + principalClaim + \" missing. Cannot authenticate\");\n              }\n              if (claimsMatchCompiled != null) {\n                for (Map.Entry<String, Pattern> entry : claimsMatchCompiled.entrySet()) {\n                  String claim = entry.getKey();\n                  if (jwtClaims.hasClaim(claim)) {\n                    if (!entry.getValue().matcher(jwtClaims.getStringClaimValue(claim)).matches()) {\n                      return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH,\n                          \"Claim \" + claim + \"=\" + jwtClaims.getStringClaimValue(claim)\n                              + \" does not match required regular expression \" + entry.getValue().pattern());\n                    }\n                  } else {\n                    return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + claim + \" is required but does not exist in JWT\");\n                  }\n                }\n              }\n              if (!requiredScopes.isEmpty() && !jwtClaims.hasClaim(CLAIM_SCOPE)) {\n                // Fail if we require scopes but they don't exist\n                return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + CLAIM_SCOPE + \" is required but does not exist in JWT\");\n              }\n              Set<String> scopes = Collections.emptySet();\n              Object scopesObj = jwtClaims.getClaimValue(CLAIM_SCOPE);\n              if (scopesObj != null) {\n                if (scopesObj instanceof String) {\n                  scopes = new HashSet<>(Arrays.asList(((String) scopesObj).split(\"\\\\s+\")));\n                } else if (scopesObj instanceof List) {\n                  scopes = new HashSet<>(jwtClaims.getStringListClaimValue(CLAIM_SCOPE));\n                }\n                // Validate that at least one of the required scopes are present in the scope claim \n                if (!requiredScopes.isEmpty()) {\n                  if (scopes.stream().noneMatch(requiredScopes::contains)) {\n                    return new JWTAuthenticationResponse(AuthCode.SCOPE_MISSING, \"Claim \" + CLAIM_SCOPE + \" does not contain any of the required scopes: \" + requiredScopes);\n                  }\n                }\n                final Set<String> finalScopes = new HashSet<>(scopes);\n                finalScopes.remove(\"openid\"); // Remove standard scope\n                // Pass scopes with principal to signal to any Authorization plugins that user has some verified role claims\n                return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipalWithUserRoles(principal, jwtCompact, jwtClaims.getClaimsMap(), finalScopes));\n              } else {\n                return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipal(principal, jwtCompact, jwtClaims.getClaimsMap()));\n              }\n            } catch (InvalidJwtException e) {\n              // Whether or not the JWT has expired being one common reason for invalidity\n              if (e.hasExpired()) {\n                return new JWTAuthenticationResponse(AuthCode.JWT_EXPIRED, \"Authentication failed due to expired JWT token. Expired at \" + e.getJwtContext().getJwtClaims().getExpirationTime());\n              }\n              if (e.getCause() != null && e.getCause() instanceof JoseException && e.getCause().getMessage().contains(\"Invalid JOSE Compact Serialization\")) {\n                return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, e.getCause().getMessage());\n              }\n              return new JWTAuthenticationResponse(AuthCode.JWT_VALIDATION_EXCEPTION, e);\n            }\n          } catch (MalformedClaimException e) {\n            return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, \"Malformed claim, error was: \" + e.getMessage());\n          }\n        } else {\n          return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n        }\n      } else {\n        return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n      }\n    } else {\n      // No Authorization header\n      if (blockUnknown) {\n        return new JWTAuthenticationResponse(AuthCode.NO_AUTZ_HEADER, \"Missing Authorization header\");\n      } else {\n        log.debug(\"No user authenticated, but blockUnknown=false, so letting request through\");\n        return new JWTAuthenticationResponse(AuthCode.PASS_THROUGH);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ac780c217504f0ca673ac5dcb98768984267c60","date":1568879420,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/JWTAuthPlugin#authenticate(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/JWTAuthPlugin#authenticate(String).mjava","sourceNew":"  /**\n   * Testable authentication method\n   *\n   * @param authorizationHeader the http header \"Authentication\"\n   * @return AuthenticationResponse object\n   */\n  protected JWTAuthenticationResponse authenticate(String authorizationHeader) {\n    if (authorizationHeader != null) {\n      String jwtCompact = parseAuthorizationHeader(authorizationHeader);\n      if (jwtCompact != null) {\n        try {\n          try {\n            JwtClaims jwtClaims = jwtConsumer.processToClaims(jwtCompact);\n            String principal = jwtClaims.getStringClaimValue(principalClaim);\n            if (principal == null || principal.isEmpty()) {\n              return new JWTAuthenticationResponse(AuthCode.PRINCIPAL_MISSING, \"Cannot identify principal from JWT. Required claim \" + principalClaim + \" missing. Cannot authenticate\");\n            }\n            if (claimsMatchCompiled != null) {\n              for (Map.Entry<String, Pattern> entry : claimsMatchCompiled.entrySet()) {\n                String claim = entry.getKey();\n                if (jwtClaims.hasClaim(claim)) {\n                  if (!entry.getValue().matcher(jwtClaims.getStringClaimValue(claim)).matches()) {\n                    return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH,\n                        \"Claim \" + claim + \"=\" + jwtClaims.getStringClaimValue(claim)\n                            + \" does not match required regular expression \" + entry.getValue().pattern());\n                  }\n                } else {\n                  return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + claim + \" is required but does not exist in JWT\");\n                }\n              }\n            }\n            if (!requiredScopes.isEmpty() && !jwtClaims.hasClaim(CLAIM_SCOPE)) {\n              // Fail if we require scopes but they don't exist\n              return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + CLAIM_SCOPE + \" is required but does not exist in JWT\");\n            }\n            Set<String> scopes = Collections.emptySet();\n            Object scopesObj = jwtClaims.getClaimValue(CLAIM_SCOPE);\n            if (scopesObj != null) {\n              if (scopesObj instanceof String) {\n                scopes = new HashSet<>(Arrays.asList(((String) scopesObj).split(\"\\\\s+\")));\n              } else if (scopesObj instanceof List) {\n                scopes = new HashSet<>(jwtClaims.getStringListClaimValue(CLAIM_SCOPE));\n              }\n              // Validate that at least one of the required scopes are present in the scope claim\n              if (!requiredScopes.isEmpty()) {\n                if (scopes.stream().noneMatch(requiredScopes::contains)) {\n                  return new JWTAuthenticationResponse(AuthCode.SCOPE_MISSING, \"Claim \" + CLAIM_SCOPE + \" does not contain any of the required scopes: \" + requiredScopes);\n                }\n              }\n              final Set<String> finalScopes = new HashSet<>(scopes);\n              finalScopes.remove(\"openid\"); // Remove standard scope\n              // Pass scopes with principal to signal to any Authorization plugins that user has some verified role claims\n              return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipalWithUserRoles(principal, jwtCompact, jwtClaims.getClaimsMap(), finalScopes));\n            } else {\n              return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipal(principal, jwtCompact, jwtClaims.getClaimsMap()));\n            }\n          } catch (InvalidJwtSignatureException ise) {\n            return new JWTAuthenticationResponse(AuthCode.SIGNATURE_INVALID, ise);\n          } catch (InvalidJwtException e) {\n            // Whether or not the JWT has expired being one common reason for invalidity\n            if (e.hasExpired()) {\n              return new JWTAuthenticationResponse(AuthCode.JWT_EXPIRED, \"Authentication failed due to expired JWT token. Expired at \" + e.getJwtContext().getJwtClaims().getExpirationTime());\n            }\n            if (e.getCause() != null && e.getCause() instanceof JoseException && e.getCause().getMessage().contains(\"Invalid JOSE Compact Serialization\")) {\n              return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, e.getCause().getMessage());\n            }\n            return new JWTAuthenticationResponse(AuthCode.JWT_VALIDATION_EXCEPTION, e);\n          }\n        } catch (MalformedClaimException e) {\n          return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, \"Malformed claim, error was: \" + e.getMessage());\n        }\n      } else {\n        return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n      }\n    } else {\n      // No Authorization header\n      if (blockUnknown) {\n        return new JWTAuthenticationResponse(AuthCode.NO_AUTZ_HEADER, \"Missing Authorization header\");\n      } else {\n        log.debug(\"No user authenticated, but blockUnknown=false, so letting request through\");\n        return new JWTAuthenticationResponse(AuthCode.PASS_THROUGH);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Testable authentication method\n   *\n   * @param authorizationHeader the http header \"Authentication\"\n   * @return AuthenticationResponse object\n   */\n  protected JWTAuthenticationResponse authenticate(String authorizationHeader) {\n    if (authorizationHeader != null) {\n      StringTokenizer st = new StringTokenizer(authorizationHeader);\n      if (st.hasMoreTokens()) {\n        String bearer = st.nextToken();\n        if (bearer.equalsIgnoreCase(\"Bearer\") && st.hasMoreTokens()) {\n          try {\n            String jwtCompact = st.nextToken();\n            try {\n              JwtClaims jwtClaims = jwtConsumer.processToClaims(jwtCompact);\n              String principal = jwtClaims.getStringClaimValue(principalClaim);\n              if (principal == null || principal.isEmpty()) {\n                return new JWTAuthenticationResponse(AuthCode.PRINCIPAL_MISSING, \"Cannot identify principal from JWT. Required claim \" + principalClaim + \" missing. Cannot authenticate\");\n              }\n              if (claimsMatchCompiled != null) {\n                for (Map.Entry<String, Pattern> entry : claimsMatchCompiled.entrySet()) {\n                  String claim = entry.getKey();\n                  if (jwtClaims.hasClaim(claim)) {\n                    if (!entry.getValue().matcher(jwtClaims.getStringClaimValue(claim)).matches()) {\n                      return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH,\n                          \"Claim \" + claim + \"=\" + jwtClaims.getStringClaimValue(claim)\n                              + \" does not match required regular expression \" + entry.getValue().pattern());\n                    }\n                  } else {\n                    return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + claim + \" is required but does not exist in JWT\");\n                  }\n                }\n              }\n              if (!requiredScopes.isEmpty() && !jwtClaims.hasClaim(CLAIM_SCOPE)) {\n                // Fail if we require scopes but they don't exist\n                return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + CLAIM_SCOPE + \" is required but does not exist in JWT\");\n              }\n              Set<String> scopes = Collections.emptySet();\n              Object scopesObj = jwtClaims.getClaimValue(CLAIM_SCOPE);\n              if (scopesObj != null) {\n                if (scopesObj instanceof String) {\n                  scopes = new HashSet<>(Arrays.asList(((String) scopesObj).split(\"\\\\s+\")));\n                } else if (scopesObj instanceof List) {\n                  scopes = new HashSet<>(jwtClaims.getStringListClaimValue(CLAIM_SCOPE));\n                }\n                // Validate that at least one of the required scopes are present in the scope claim \n                if (!requiredScopes.isEmpty()) {\n                  if (scopes.stream().noneMatch(requiredScopes::contains)) {\n                    return new JWTAuthenticationResponse(AuthCode.SCOPE_MISSING, \"Claim \" + CLAIM_SCOPE + \" does not contain any of the required scopes: \" + requiredScopes);\n                  }\n                }\n                final Set<String> finalScopes = new HashSet<>(scopes);\n                finalScopes.remove(\"openid\"); // Remove standard scope\n                // Pass scopes with principal to signal to any Authorization plugins that user has some verified role claims\n                return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipalWithUserRoles(principal, jwtCompact, jwtClaims.getClaimsMap(), finalScopes));\n              } else {\n                return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipal(principal, jwtCompact, jwtClaims.getClaimsMap()));\n              }\n            } catch (InvalidJwtSignatureException ise) {\n              return new JWTAuthenticationResponse(AuthCode.SIGNATURE_INVALID, ise);\n            } catch (InvalidJwtException e) {\n              // Whether or not the JWT has expired being one common reason for invalidity\n              if (e.hasExpired()) {\n                return new JWTAuthenticationResponse(AuthCode.JWT_EXPIRED, \"Authentication failed due to expired JWT token. Expired at \" + e.getJwtContext().getJwtClaims().getExpirationTime());\n              }\n              if (e.getCause() != null && e.getCause() instanceof JoseException && e.getCause().getMessage().contains(\"Invalid JOSE Compact Serialization\")) {\n                return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, e.getCause().getMessage());\n              }\n              return new JWTAuthenticationResponse(AuthCode.JWT_VALIDATION_EXCEPTION, e);\n            }\n          } catch (MalformedClaimException e) {\n            return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, \"Malformed claim, error was: \" + e.getMessage());\n          }\n        } else {\n          return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n        }\n      } else {\n        return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n      }\n    } else {\n      // No Authorization header\n      if (blockUnknown) {\n        return new JWTAuthenticationResponse(AuthCode.NO_AUTZ_HEADER, \"Missing Authorization header\");\n      } else {\n        log.debug(\"No user authenticated, but blockUnknown=false, so letting request through\");\n        return new JWTAuthenticationResponse(AuthCode.PASS_THROUGH);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8076096f334b0665d0a69a63ee98ac09baad402b","date":1589405373,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/JWTAuthPlugin#authenticate(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/JWTAuthPlugin#authenticate(String).mjava","sourceNew":"  /**\n   * Testable authentication method\n   *\n   * @param authorizationHeader the http header \"Authentication\"\n   * @return AuthenticationResponse object\n   */\n  protected JWTAuthenticationResponse authenticate(String authorizationHeader) {\n    if (authorizationHeader != null) {\n      String jwtCompact = parseAuthorizationHeader(authorizationHeader);\n      if (jwtCompact != null) {\n        try {\n          try {\n            JwtClaims jwtClaims = jwtConsumer.processToClaims(jwtCompact);\n            String principal = jwtClaims.getStringClaimValue(principalClaim);\n            if (principal == null || principal.isEmpty()) {\n              return new JWTAuthenticationResponse(AuthCode.PRINCIPAL_MISSING, \"Cannot identify principal from JWT. Required claim \" + principalClaim + \" missing. Cannot authenticate\");\n            }\n            if (claimsMatchCompiled != null) {\n              for (Map.Entry<String, Pattern> entry : claimsMatchCompiled.entrySet()) {\n                String claim = entry.getKey();\n                if (jwtClaims.hasClaim(claim)) {\n                  if (!entry.getValue().matcher(jwtClaims.getStringClaimValue(claim)).matches()) {\n                    return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH,\n                        \"Claim \" + claim + \"=\" + jwtClaims.getStringClaimValue(claim)\n                            + \" does not match required regular expression \" + entry.getValue().pattern());\n                  }\n                } else {\n                  return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + claim + \" is required but does not exist in JWT\");\n                }\n              }\n            }\n            if (!requiredScopes.isEmpty() && !jwtClaims.hasClaim(CLAIM_SCOPE)) {\n              // Fail if we require scopes but they don't exist\n              return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + CLAIM_SCOPE + \" is required but does not exist in JWT\");\n            }\n\n            // Find scopes for user\n            Set<String> scopes = Collections.emptySet();\n            Object scopesObj = jwtClaims.getClaimValue(CLAIM_SCOPE);\n            if (scopesObj != null) {\n              if (scopesObj instanceof String) {\n                scopes = new HashSet<>(Arrays.asList(((String) scopesObj).split(\"\\\\s+\")));\n              } else if (scopesObj instanceof List) {\n                scopes = new HashSet<>(jwtClaims.getStringListClaimValue(CLAIM_SCOPE));\n              }\n              // Validate that at least one of the required scopes are present in the scope claim\n              if (!requiredScopes.isEmpty()) {\n                if (scopes.stream().noneMatch(requiredScopes::contains)) {\n                  return new JWTAuthenticationResponse(AuthCode.SCOPE_MISSING, \"Claim \" + CLAIM_SCOPE + \" does not contain any of the required scopes: \" + requiredScopes);\n                }\n              }\n            }\n\n            // Determine roles of user, either from 'rolesClaim' or from 'scope' as parsed above\n            final Set<String> finalRoles = new HashSet<>();\n            if (rolesClaim == null) {\n              // Pass scopes with principal to signal to any Authorization plugins that user has some verified role claims\n              finalRoles.addAll(scopes);\n              finalRoles.remove(\"openid\"); // Remove standard scope\n            } else {\n              // Pull roles from separate claim, either as whitespace separated list or as JSON array\n              Object rolesObj = jwtClaims.getClaimValue(rolesClaim);\n              if (rolesObj != null) {\n                if (rolesObj instanceof String) {\n                  finalRoles.addAll(Arrays.asList(((String) rolesObj).split(\"\\\\s+\")));\n                } else if (rolesObj instanceof List) {\n                  finalRoles.addAll(jwtClaims.getStringListClaimValue(rolesClaim));\n                }\n              }\n            }\n            if (finalRoles.size() > 0) {\n              return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipalWithUserRoles(principal, jwtCompact, jwtClaims.getClaimsMap(), finalRoles));\n            } else {\n              return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipal(principal, jwtCompact, jwtClaims.getClaimsMap()));\n            }\n          } catch (InvalidJwtSignatureException ise) {\n            return new JWTAuthenticationResponse(AuthCode.SIGNATURE_INVALID, ise);\n          } catch (InvalidJwtException e) {\n            // Whether or not the JWT has expired being one common reason for invalidity\n            if (e.hasExpired()) {\n              return new JWTAuthenticationResponse(AuthCode.JWT_EXPIRED, \"Authentication failed due to expired JWT token. Expired at \" + e.getJwtContext().getJwtClaims().getExpirationTime());\n            }\n            if (e.getCause() != null && e.getCause() instanceof JoseException && e.getCause().getMessage().contains(\"Invalid JOSE Compact Serialization\")) {\n              return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, e.getCause().getMessage());\n            }\n            return new JWTAuthenticationResponse(AuthCode.JWT_VALIDATION_EXCEPTION, e);\n          }\n        } catch (MalformedClaimException e) {\n          return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, \"Malformed claim, error was: \" + e.getMessage());\n        }\n      } else {\n        return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n      }\n    } else {\n      // No Authorization header\n      if (blockUnknown) {\n        return new JWTAuthenticationResponse(AuthCode.NO_AUTZ_HEADER, \"Missing Authorization header\");\n      } else {\n        log.debug(\"No user authenticated, but blockUnknown=false, so letting request through\");\n        return new JWTAuthenticationResponse(AuthCode.PASS_THROUGH);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Testable authentication method\n   *\n   * @param authorizationHeader the http header \"Authentication\"\n   * @return AuthenticationResponse object\n   */\n  protected JWTAuthenticationResponse authenticate(String authorizationHeader) {\n    if (authorizationHeader != null) {\n      String jwtCompact = parseAuthorizationHeader(authorizationHeader);\n      if (jwtCompact != null) {\n        try {\n          try {\n            JwtClaims jwtClaims = jwtConsumer.processToClaims(jwtCompact);\n            String principal = jwtClaims.getStringClaimValue(principalClaim);\n            if (principal == null || principal.isEmpty()) {\n              return new JWTAuthenticationResponse(AuthCode.PRINCIPAL_MISSING, \"Cannot identify principal from JWT. Required claim \" + principalClaim + \" missing. Cannot authenticate\");\n            }\n            if (claimsMatchCompiled != null) {\n              for (Map.Entry<String, Pattern> entry : claimsMatchCompiled.entrySet()) {\n                String claim = entry.getKey();\n                if (jwtClaims.hasClaim(claim)) {\n                  if (!entry.getValue().matcher(jwtClaims.getStringClaimValue(claim)).matches()) {\n                    return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH,\n                        \"Claim \" + claim + \"=\" + jwtClaims.getStringClaimValue(claim)\n                            + \" does not match required regular expression \" + entry.getValue().pattern());\n                  }\n                } else {\n                  return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + claim + \" is required but does not exist in JWT\");\n                }\n              }\n            }\n            if (!requiredScopes.isEmpty() && !jwtClaims.hasClaim(CLAIM_SCOPE)) {\n              // Fail if we require scopes but they don't exist\n              return new JWTAuthenticationResponse(AuthCode.CLAIM_MISMATCH, \"Claim \" + CLAIM_SCOPE + \" is required but does not exist in JWT\");\n            }\n            Set<String> scopes = Collections.emptySet();\n            Object scopesObj = jwtClaims.getClaimValue(CLAIM_SCOPE);\n            if (scopesObj != null) {\n              if (scopesObj instanceof String) {\n                scopes = new HashSet<>(Arrays.asList(((String) scopesObj).split(\"\\\\s+\")));\n              } else if (scopesObj instanceof List) {\n                scopes = new HashSet<>(jwtClaims.getStringListClaimValue(CLAIM_SCOPE));\n              }\n              // Validate that at least one of the required scopes are present in the scope claim\n              if (!requiredScopes.isEmpty()) {\n                if (scopes.stream().noneMatch(requiredScopes::contains)) {\n                  return new JWTAuthenticationResponse(AuthCode.SCOPE_MISSING, \"Claim \" + CLAIM_SCOPE + \" does not contain any of the required scopes: \" + requiredScopes);\n                }\n              }\n              final Set<String> finalScopes = new HashSet<>(scopes);\n              finalScopes.remove(\"openid\"); // Remove standard scope\n              // Pass scopes with principal to signal to any Authorization plugins that user has some verified role claims\n              return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipalWithUserRoles(principal, jwtCompact, jwtClaims.getClaimsMap(), finalScopes));\n            } else {\n              return new JWTAuthenticationResponse(AuthCode.AUTHENTICATED, new JWTPrincipal(principal, jwtCompact, jwtClaims.getClaimsMap()));\n            }\n          } catch (InvalidJwtSignatureException ise) {\n            return new JWTAuthenticationResponse(AuthCode.SIGNATURE_INVALID, ise);\n          } catch (InvalidJwtException e) {\n            // Whether or not the JWT has expired being one common reason for invalidity\n            if (e.hasExpired()) {\n              return new JWTAuthenticationResponse(AuthCode.JWT_EXPIRED, \"Authentication failed due to expired JWT token. Expired at \" + e.getJwtContext().getJwtClaims().getExpirationTime());\n            }\n            if (e.getCause() != null && e.getCause() instanceof JoseException && e.getCause().getMessage().contains(\"Invalid JOSE Compact Serialization\")) {\n              return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, e.getCause().getMessage());\n            }\n            return new JWTAuthenticationResponse(AuthCode.JWT_VALIDATION_EXCEPTION, e);\n          }\n        } catch (MalformedClaimException e) {\n          return new JWTAuthenticationResponse(AuthCode.JWT_PARSE_ERROR, \"Malformed claim, error was: \" + e.getMessage());\n        }\n      } else {\n        return new JWTAuthenticationResponse(AuthCode.AUTZ_HEADER_PROBLEM, \"Authorization header is not in correct format\");\n      }\n    } else {\n      // No Authorization header\n      if (blockUnknown) {\n        return new JWTAuthenticationResponse(AuthCode.NO_AUTZ_HEADER, \"Missing Authorization header\");\n      } else {\n        log.debug(\"No user authenticated, but blockUnknown=false, so letting request through\");\n        return new JWTAuthenticationResponse(AuthCode.PASS_THROUGH);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8076096f334b0665d0a69a63ee98ac09baad402b":["1ac780c217504f0ca673ac5dcb98768984267c60"],"931a54d2addc8e4bbdf29a803b7567559695f6e5":["bb3e075eaa5788b2762ec235bf72b069cefe3f50"],"1ac780c217504f0ca673ac5dcb98768984267c60":["3f67fad1a752e06d753afa1c41bcc27141d258f5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3f67fad1a752e06d753afa1c41bcc27141d258f5":["931a54d2addc8e4bbdf29a803b7567559695f6e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8076096f334b0665d0a69a63ee98ac09baad402b"],"bb3e075eaa5788b2762ec235bf72b069cefe3f50":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2682a1cd25864ccdc1b44bf047bd08700f28ba06":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bb3e075eaa5788b2762ec235bf72b069cefe3f50"]},"commit2Childs":{"8076096f334b0665d0a69a63ee98ac09baad402b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"931a54d2addc8e4bbdf29a803b7567559695f6e5":["3f67fad1a752e06d753afa1c41bcc27141d258f5"],"1ac780c217504f0ca673ac5dcb98768984267c60":["8076096f334b0665d0a69a63ee98ac09baad402b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bb3e075eaa5788b2762ec235bf72b069cefe3f50","2682a1cd25864ccdc1b44bf047bd08700f28ba06"],"3f67fad1a752e06d753afa1c41bcc27141d258f5":["1ac780c217504f0ca673ac5dcb98768984267c60"],"bb3e075eaa5788b2762ec235bf72b069cefe3f50":["931a54d2addc8e4bbdf29a803b7567559695f6e5","2682a1cd25864ccdc1b44bf047bd08700f28ba06"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2682a1cd25864ccdc1b44bf047bd08700f28ba06":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","2682a1cd25864ccdc1b44bf047bd08700f28ba06"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}