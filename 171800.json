{"path":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","commits":[{"id":"0d67fb624729051d4895ed643a9d1bae6285c564","date":1428429726,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","pathOld":"/dev/null","sourceNew":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = newMockDirectory();\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setPreventDoubleWrite(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (Exception e) {\n          if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n            exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n            e.printStackTrace(exceptionStream);\n            allowAlreadyClosed = true;\n          } else {\n            Rethrow.rethrow(e);\n          }\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean());\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n              allowAlreadyClosed = true;\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (Exception e) {\n        if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n          exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n          e.printStackTrace(exceptionStream);\n          try {\n            iw.rollback();\n          } catch (Throwable t) {}\n        } else {\n          Rethrow.rethrow(e);\n        }\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","sourceNew":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = newMockDirectory();\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setPreventDoubleWrite(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (Exception e) {\n          if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n            exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n            e.printStackTrace(exceptionStream);\n            allowAlreadyClosed = true;\n          } else {\n            Rethrow.rethrow(e);\n          }\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n              allowAlreadyClosed = true;\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (Exception e) {\n        if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n          exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n          e.printStackTrace(exceptionStream);\n          try {\n            iw.rollback();\n          } catch (Throwable t) {}\n        } else {\n          Rethrow.rethrow(e);\n        }\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = newMockDirectory();\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setPreventDoubleWrite(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (Exception e) {\n          if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n            exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n            e.printStackTrace(exceptionStream);\n            allowAlreadyClosed = true;\n          } else {\n            Rethrow.rethrow(e);\n          }\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean());\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n              allowAlreadyClosed = true;\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (Exception e) {\n        if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n          exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n          e.printStackTrace(exceptionStream);\n          try {\n            iw.rollback();\n          } catch (Throwable t) {}\n        } else {\n          Rethrow.rethrow(e);\n        }\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","sourceNew":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = newMockDirectory();\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setPreventDoubleWrite(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (Exception e) {\n          if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n            exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n            e.printStackTrace(exceptionStream);\n            allowAlreadyClosed = true;\n          } else {\n            Rethrow.rethrow(e);\n          }\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n              allowAlreadyClosed = true;\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (Exception e) {\n        if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n          exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n          e.printStackTrace(exceptionStream);\n          try {\n            iw.rollback();\n          } catch (Throwable t) {}\n        } else {\n          Rethrow.rethrow(e);\n        }\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = newMockDirectory();\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setPreventDoubleWrite(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (Exception e) {\n          if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n            exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n            e.printStackTrace(exceptionStream);\n            allowAlreadyClosed = true;\n          } else {\n            Rethrow.rethrow(e);\n          }\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean());\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n              allowAlreadyClosed = true;\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (Exception e) {\n        if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n          exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n          e.printStackTrace(exceptionStream);\n          try {\n            iw.rollback();\n          } catch (Throwable t) {}\n        } else {\n          Rethrow.rethrow(e);\n        }\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11c6df42fb3eba174c3ca0d9a5194eaecd893b77","date":1465931757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","sourceNew":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = newMockDirectory();\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (Exception e) {\n          if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n            exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n            e.printStackTrace(exceptionStream);\n            allowAlreadyClosed = true;\n          } else {\n            Rethrow.rethrow(e);\n          }\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n              allowAlreadyClosed = true;\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (Exception e) {\n        if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n          exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n          e.printStackTrace(exceptionStream);\n          try {\n            iw.rollback();\n          } catch (Throwable t) {}\n        } else {\n          Rethrow.rethrow(e);\n        }\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = newMockDirectory();\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setPreventDoubleWrite(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (Exception e) {\n          if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n            exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n            e.printStackTrace(exceptionStream);\n            allowAlreadyClosed = true;\n          } else {\n            Rethrow.rethrow(e);\n          }\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n              allowAlreadyClosed = true;\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (Exception e) {\n        if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n          exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n          e.printStackTrace(exceptionStream);\n          try {\n            iw.rollback();\n          } catch (Throwable t) {}\n        } else {\n          Rethrow.rethrow(e);\n        }\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","bugFix":["0d67fb624729051d4895ed643a9d1bae6285c564"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","sourceNew":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = newMockDirectory();\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (Exception e) {\n          if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n            exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n            e.printStackTrace(exceptionStream);\n            allowAlreadyClosed = true;\n          } else {\n            Rethrow.rethrow(e);\n          }\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n              allowAlreadyClosed = true;\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (Exception e) {\n        if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n          exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n          e.printStackTrace(exceptionStream);\n          try {\n            iw.rollback();\n          } catch (Throwable t) {}\n        } else {\n          Rethrow.rethrow(e);\n        }\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = newMockDirectory();\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setPreventDoubleWrite(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (Exception e) {\n          if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n            exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n            e.printStackTrace(exceptionStream);\n            allowAlreadyClosed = true;\n          } else {\n            Rethrow.rethrow(e);\n          }\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n              allowAlreadyClosed = true;\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (Exception e) {\n        if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n          exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n          e.printStackTrace(exceptionStream);\n          try {\n            iw.rollback();\n          } catch (Throwable t) {}\n        } else {\n          Rethrow.rethrow(e);\n        }\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"379ac53fe9f85e4560f02f2ff25f97eb7b5694a1","date":1486776053,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","sourceNew":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = newMockDirectory();\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (IOException e) {\n          handleFakeIOException(e, exceptionStream);\n          allowAlreadyClosed = true;\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (IOException e) {\n            handleFakeIOException(e, exceptionStream);\n            allowAlreadyClosed = true;\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (IOException e) {\n        handleFakeIOException(e, exceptionStream);\n        try {\n          iw.rollback();\n        } catch (Throwable t) {}\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = newMockDirectory();\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (Exception e) {\n          if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n            exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n            e.printStackTrace(exceptionStream);\n            allowAlreadyClosed = true;\n          } else {\n            Rethrow.rethrow(e);\n          }\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (Exception e) {\n            if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n              exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n              e.printStackTrace(exceptionStream);\n              allowAlreadyClosed = true;\n            } else {\n              Rethrow.rethrow(e);\n            }\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (Exception e) {\n        if (e.getMessage() != null && e.getMessage().startsWith(\"a random IOException\")) {\n          exceptionStream.println(\"\\nTEST: got expected fake exc:\" + e.getMessage());\n          e.printStackTrace(exceptionStream);\n          try {\n            iw.rollback();\n          } catch (Throwable t) {}\n        } else {\n          Rethrow.rethrow(e);\n        }\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31741cf1390044e38a2ec3127cf302ba841bfd75","date":1491292636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","sourceNew":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = applyCreatedVersionMajor(newMockDirectory());\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (IOException e) {\n          handleFakeIOException(e, exceptionStream);\n          allowAlreadyClosed = true;\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (IOException e) {\n            handleFakeIOException(e, exceptionStream);\n            allowAlreadyClosed = true;\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (IOException e) {\n        handleFakeIOException(e, exceptionStream);\n        try {\n          iw.rollback();\n        } catch (Throwable t) {}\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = newMockDirectory();\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (IOException e) {\n          handleFakeIOException(e, exceptionStream);\n          allowAlreadyClosed = true;\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (IOException e) {\n            handleFakeIOException(e, exceptionStream);\n            allowAlreadyClosed = true;\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (IOException e) {\n        handleFakeIOException(e, exceptionStream);\n        try {\n          iw.rollback();\n        } catch (Throwable t) {}\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92212fd254551a0b1156aafc3a1a6ed1a43932ad","date":1491296431,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","sourceNew":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = applyCreatedVersionMajor(newMockDirectory());\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (IOException e) {\n          handleFakeIOException(e, exceptionStream);\n          allowAlreadyClosed = true;\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (IOException e) {\n            handleFakeIOException(e, exceptionStream);\n            allowAlreadyClosed = true;\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (IOException e) {\n        handleFakeIOException(e, exceptionStream);\n        try {\n          iw.rollback();\n        } catch (Throwable t) {}\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = newMockDirectory();\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (IOException e) {\n          handleFakeIOException(e, exceptionStream);\n          allowAlreadyClosed = true;\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (IOException e) {\n            handleFakeIOException(e, exceptionStream);\n            allowAlreadyClosed = true;\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (IOException e) {\n        handleFakeIOException(e, exceptionStream);\n        try {\n          iw.rollback();\n        } catch (Throwable t) {}\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","sourceNew":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = applyCreatedVersionMajor(newMockDirectory());\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (IOException e) {\n          handleFakeIOException(e, exceptionStream);\n          allowAlreadyClosed = true;\n        }\n\n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (IOException e) {\n            handleFakeIOException(e, exceptionStream);\n            allowAlreadyClosed = true;\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (IOException e) {\n        handleFakeIOException(e, exceptionStream);\n        try {\n          iw.rollback();\n        } catch (Throwable t) {}\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = applyCreatedVersionMajor(newMockDirectory());\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (IOException e) {\n          handleFakeIOException(e, exceptionStream);\n          allowAlreadyClosed = true;\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (IOException e) {\n            handleFakeIOException(e, exceptionStream);\n            allowAlreadyClosed = true;\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (IOException e) {\n        handleFakeIOException(e, exceptionStream);\n        try {\n          iw.rollback();\n        } catch (Throwable t) {}\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","sourceNew":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = applyCreatedVersionMajor(newMockDirectory());\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (IOException e) {\n          handleFakeIOException(e, exceptionStream);\n          allowAlreadyClosed = true;\n        }\n\n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (IOException e) {\n            handleFakeIOException(e, exceptionStream);\n            allowAlreadyClosed = true;\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (IOException e) {\n        handleFakeIOException(e, exceptionStream);\n        try {\n          iw.rollback();\n        } catch (Throwable t) {}\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = applyCreatedVersionMajor(newMockDirectory());\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (IOException e) {\n          handleFakeIOException(e, exceptionStream);\n          allowAlreadyClosed = true;\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (IOException e) {\n            handleFakeIOException(e, exceptionStream);\n            allowAlreadyClosed = true;\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (IOException e) {\n        handleFakeIOException(e, exceptionStream);\n        try {\n          iw.rollback();\n        } catch (Throwable t) {}\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","sourceNew":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = applyCreatedVersionMajor(newMockDirectory());\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (IOException e) {\n          handleFakeIOException(e, exceptionStream);\n          allowAlreadyClosed = true;\n        }\n\n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (IOException e) {\n            handleFakeIOException(e, exceptionStream);\n            allowAlreadyClosed = true;\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (IOException e) {\n        handleFakeIOException(e, exceptionStream);\n        try {\n          iw.rollback();\n        } catch (Throwable t) {}\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = applyCreatedVersionMajor(newMockDirectory());\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (IOException e) {\n          handleFakeIOException(e, exceptionStream);\n          allowAlreadyClosed = true;\n        }\n        \n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (IOException e) {\n            handleFakeIOException(e, exceptionStream);\n            allowAlreadyClosed = true;\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (IOException e) {\n        handleFakeIOException(e, exceptionStream);\n        try {\n          iw.rollback();\n        } catch (Throwable t) {}\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2","date":1588002560,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testRandomExceptions().mjava","sourceNew":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = applyCreatedVersionMajor(newMockDirectory());\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.isDeleterClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (IOException e) {\n          handleFakeIOException(e, exceptionStream);\n          allowAlreadyClosed = true;\n        }\n\n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.isDeleterClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (IOException e) {\n            handleFakeIOException(e, exceptionStream);\n            allowAlreadyClosed = true;\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (IOException e) {\n        handleFakeIOException(e, exceptionStream);\n        try {\n          iw.rollback();\n        } catch (Throwable t) {}\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":"  /** Tests exception handling on write and openInput/createOutput */\n  // TODO: this is really not ideal. each BaseXXXTestCase should have unit tests doing this.\n  // but we use this shotgun approach to prevent bugs in the meantime: it just ensures the\n  // codec does not corrupt the index or leak file handles.\n  public void testRandomExceptions() throws Exception {\n    // disable slow things: we don't rely upon sleeps here.\n    MockDirectoryWrapper dir = applyCreatedVersionMajor(newMockDirectory());\n    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n    dir.setUseSlowOpenClosers(false);\n    dir.setRandomIOExceptionRate(0.001); // more rare\n    \n    // log all exceptions we hit, in case we fail (for debugging)\n    ByteArrayOutputStream exceptionLog = new ByteArrayOutputStream();\n    PrintStream exceptionStream = new PrintStream(exceptionLog, true, \"UTF-8\");\n    //PrintStream exceptionStream = System.out;\n    \n    Analyzer analyzer = new MockAnalyzer(random());\n    \n    IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n    // just for now, try to keep this test reproducible\n    conf.setMergeScheduler(new SerialMergeScheduler());\n    conf.setCodec(getCodec());\n    \n    int numDocs = atLeast(500);\n    \n    IndexWriter iw = new IndexWriter(dir, conf);\n    try {\n      boolean allowAlreadyClosed = false;\n      for (int i = 0; i < numDocs; i++) {\n        dir.setRandomIOExceptionRateOnOpen(0.02); // turn on exceptions for openInput/createOutput\n        \n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(i), Field.Store.NO));\n        addRandomFields(doc);\n        \n        // single doc\n        try {\n          iw.addDocument(doc);\n          // we made it, sometimes delete our doc\n          iw.deleteDocuments(new Term(\"id\", Integer.toString(i)));\n        } catch (AlreadyClosedException ace) {\n          // OK: writer was closed by abort; we just reopen now:\n          dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n          assertTrue(iw.deleter.isClosed());\n          assertTrue(allowAlreadyClosed);\n          allowAlreadyClosed = false;\n          conf = newIndexWriterConfig(analyzer);\n          // just for now, try to keep this test reproducible\n          conf.setMergeScheduler(new SerialMergeScheduler());\n          conf.setCodec(getCodec());\n          iw = new IndexWriter(dir, conf);            \n        } catch (IOException e) {\n          handleFakeIOException(e, exceptionStream);\n          allowAlreadyClosed = true;\n        }\n\n        if (random().nextInt(10) == 0) {\n          // trigger flush:\n          try {\n            if (random().nextBoolean()) {\n              DirectoryReader ir = null;\n              try {\n                ir = DirectoryReader.open(iw, random().nextBoolean(), false);\n                dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n                TestUtil.checkReader(ir);\n              } finally {\n                IOUtils.closeWhileHandlingException(ir);\n              }\n            } else {\n              dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                       // or we make slowExists angry and trip a scarier assert!\n              iw.commit();\n            }\n            if (DirectoryReader.indexExists(dir)) {\n              TestUtil.checkIndex(dir);\n            }\n          } catch (AlreadyClosedException ace) {\n            // OK: writer was closed by abort; we just reopen now:\n            dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration\n            assertTrue(iw.deleter.isClosed());\n            assertTrue(allowAlreadyClosed);\n            allowAlreadyClosed = false;\n            conf = newIndexWriterConfig(analyzer);\n            // just for now, try to keep this test reproducible\n            conf.setMergeScheduler(new SerialMergeScheduler());\n            conf.setCodec(getCodec());\n            iw = new IndexWriter(dir, conf);            \n          } catch (IOException e) {\n            handleFakeIOException(e, exceptionStream);\n            allowAlreadyClosed = true;\n          }\n        }\n      }\n      \n      try {\n        dir.setRandomIOExceptionRateOnOpen(0.0); // disable exceptions on openInput until next iteration: \n                                                 // or we make slowExists angry and trip a scarier assert!\n        iw.close();\n      } catch (IOException e) {\n        handleFakeIOException(e, exceptionStream);\n        try {\n          iw.rollback();\n        } catch (Throwable t) {}\n      }\n      dir.close();\n    } catch (Throwable t) {\n      System.out.println(\"Unexpected exception: dumping fake-exception-log:...\");\n      exceptionStream.flush();\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n      System.out.flush();\n      Rethrow.rethrow(t);\n    }\n    \n    if (VERBOSE) {\n      System.out.println(\"TEST PASSED: dumping fake-exception-log:...\");\n      System.out.println(exceptionLog.toString(\"UTF-8\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["31741cf1390044e38a2ec3127cf302ba841bfd75"],"11c6df42fb3eba174c3ca0d9a5194eaecd893b77":["68496c2200e559fb7802f7575427b7a482659afb"],"0d67fb624729051d4895ed643a9d1bae6285c564":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"379ac53fe9f85e4560f02f2ff25f97eb7b5694a1":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["92212fd254551a0b1156aafc3a1a6ed1a43932ad","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["31741cf1390044e38a2ec3127cf302ba841bfd75","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["68496c2200e559fb7802f7575427b7a482659afb","11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["379ac53fe9f85e4560f02f2ff25f97eb7b5694a1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["28288370235ed02234a64753cdbf0c6ec096304a"],"68496c2200e559fb7802f7575427b7a482659afb":["0d67fb624729051d4895ed643a9d1bae6285c564","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["379ac53fe9f85e4560f02f2ff25f97eb7b5694a1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["0d67fb624729051d4895ed643a9d1bae6285c564"]},"commit2Childs":{"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"11c6df42fb3eba174c3ca0d9a5194eaecd893b77":["379ac53fe9f85e4560f02f2ff25f97eb7b5694a1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"0d67fb624729051d4895ed643a9d1bae6285c564":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"379ac53fe9f85e4560f02f2ff25f97eb7b5694a1":["31741cf1390044e38a2ec3127cf302ba841bfd75","92212fd254551a0b1156aafc3a1a6ed1a43932ad"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"31741cf1390044e38a2ec3127cf302ba841bfd75":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d67fb624729051d4895ed643a9d1bae6285c564"],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"68496c2200e559fb7802f7575427b7a482659afb":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}