{"path":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#testDoRecoveryOnRestart().mjava","commits":[{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#testDoRecoveryOnRestart().mjava","pathOld":"/dev/null","sourceNew":"  private void testDoRecoveryOnRestart() throws Exception {\n    String testCollectionName = \"collDoRecoveryOnRestart\";\n    try {\n      // Inject pausing in recovery op, hence the replica won't be able to finish recovery\n      System.setProperty(\"solr.cloud.wait-for-updates-with-stale-state-pause\", String.valueOf(Integer.MAX_VALUE));\n\n      createCollection(testCollectionName, \"conf1\", 1, 2, 1);\n      cloudClient.setDefaultCollection(testCollectionName);\n\n      sendDoc(1, 2);\n\n      JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(getShardLeader(testCollectionName, \"shard1\", 1000)));\n      List<Replica> notLeaders =\n          ensureAllReplicasAreActive(testCollectionName, \"shard1\", 1, 2, maxWaitSecsToSeeAllActive);\n      assertDocsExistInAllReplicas(notLeaders, testCollectionName, 1, 1);\n\n      SocketProxy proxy0 = getProxyForReplica(notLeaders.get(0));\n      SocketProxy leaderProxy = getProxyForReplica(getShardLeader(testCollectionName, \"shard1\", 1000));\n\n      proxy0.close();\n      leaderProxy.close();\n\n      // indexing during a partition\n      int achievedRf = sendDoc(2, 1, leaderJetty);\n      assertEquals(\"Unexpected achieved replication factor\", 1, achievedRf);\n      try (ZkShardTerms zkShardTerms = new ZkShardTerms(testCollectionName, \"shard1\", cloudClient.getZkStateReader().getZkClient())) {\n        assertFalse(zkShardTerms.canBecomeLeader(notLeaders.get(0).getName()));\n      }\n      waitForState(testCollectionName, notLeaders.get(0).getName(), DOWN, 10000);\n\n      // heal partition\n      proxy0.reopen();\n      leaderProxy.reopen();\n\n      waitForState(testCollectionName, notLeaders.get(0).getName(), RECOVERING, 10000);\n\n      System.clearProperty(\"solr.cloud.wait-for-updates-with-stale-state-pause\");\n      JettySolrRunner notLeaderJetty = getJettyOnPort(getReplicaPort(notLeaders.get(0)));\n      ChaosMonkey.stop(notLeaderJetty);\n\n      ChaosMonkey.start(notLeaderJetty);\n      ensureAllReplicasAreActive(testCollectionName, \"shard1\", 1, 2, 100);\n      assertDocsExistInAllReplicas(notLeaders, testCollectionName, 1, 2);\n    } finally {\n      System.clearProperty(\"solr.cloud.wait-for-updates-with-stale-state-pause\");\n    }\n\n    // try to clean up\n    attemptCollectionDelete(cloudClient, testCollectionName);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#testDoRecoveryOnRestart().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#testDoRecoveryOnRestart().mjava","sourceNew":"  private void testDoRecoveryOnRestart() throws Exception {\n    String testCollectionName = \"collDoRecoveryOnRestart\";\n    try {\n      // Inject pausing in recovery op, hence the replica won't be able to finish recovery\n\n      TestInjection.prepRecoveryOpPauseForever = \"true:100\";\n      \n      createCollection(testCollectionName, \"conf1\", 1, 2, 1);\n      cloudClient.setDefaultCollection(testCollectionName);\n\n      sendDoc(1, 2);\n\n      JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(getShardLeader(testCollectionName, \"shard1\", 1000)));\n      List<Replica> notLeaders =\n          ensureAllReplicasAreActive(testCollectionName, \"shard1\", 1, 2, maxWaitSecsToSeeAllActive);\n      assertDocsExistInAllReplicas(notLeaders, testCollectionName, 1, 1);\n\n      SocketProxy proxy0 = getProxyForReplica(notLeaders.get(0));\n      SocketProxy leaderProxy = getProxyForReplica(getShardLeader(testCollectionName, \"shard1\", 1000));\n\n      proxy0.close();\n      leaderProxy.close();\n\n      // indexing during a partition\n      int achievedRf = sendDoc(2, 1, leaderJetty);\n      assertEquals(\"Unexpected achieved replication factor\", 1, achievedRf);\n      try (ZkShardTerms zkShardTerms = new ZkShardTerms(testCollectionName, \"shard1\", cloudClient.getZkStateReader().getZkClient())) {\n        assertFalse(zkShardTerms.canBecomeLeader(notLeaders.get(0).getName()));\n      }\n      waitForState(testCollectionName, notLeaders.get(0).getName(), DOWN, 10000);\n\n      // heal partition\n      proxy0.reopen();\n      leaderProxy.reopen();\n\n      waitForState(testCollectionName, notLeaders.get(0).getName(), RECOVERING, 10000);\n\n      System.clearProperty(\"solrcloud.skip.autorecovery\");\n      JettySolrRunner notLeaderJetty = getJettyOnPort(getReplicaPort(notLeaders.get(0)));\n      String notLeaderNodeName = notLeaderJetty.getNodeName();\n      notLeaderJetty.stop();\n      \n      cloudClient.getZkStateReader().waitForLiveNodes(15, TimeUnit.SECONDS, SolrCloudTestCase.missingLiveNode(notLeaderNodeName));\n\n      notLeaderJetty.start();\n      ensureAllReplicasAreActive(testCollectionName, \"shard1\", 1, 2, 130);\n      assertDocsExistInAllReplicas(notLeaders, testCollectionName, 1, 2);\n    } finally {\n      TestInjection.prepRecoveryOpPauseForever = null;\n      TestInjection.notifyPauseForeverDone();\n    }\n\n    // try to clean up\n    attemptCollectionDelete(cloudClient, testCollectionName);\n  }\n\n","sourceOld":"  private void testDoRecoveryOnRestart() throws Exception {\n    String testCollectionName = \"collDoRecoveryOnRestart\";\n    try {\n      // Inject pausing in recovery op, hence the replica won't be able to finish recovery\n      System.setProperty(\"solr.cloud.wait-for-updates-with-stale-state-pause\", String.valueOf(Integer.MAX_VALUE));\n\n      createCollection(testCollectionName, \"conf1\", 1, 2, 1);\n      cloudClient.setDefaultCollection(testCollectionName);\n\n      sendDoc(1, 2);\n\n      JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(getShardLeader(testCollectionName, \"shard1\", 1000)));\n      List<Replica> notLeaders =\n          ensureAllReplicasAreActive(testCollectionName, \"shard1\", 1, 2, maxWaitSecsToSeeAllActive);\n      assertDocsExistInAllReplicas(notLeaders, testCollectionName, 1, 1);\n\n      SocketProxy proxy0 = getProxyForReplica(notLeaders.get(0));\n      SocketProxy leaderProxy = getProxyForReplica(getShardLeader(testCollectionName, \"shard1\", 1000));\n\n      proxy0.close();\n      leaderProxy.close();\n\n      // indexing during a partition\n      int achievedRf = sendDoc(2, 1, leaderJetty);\n      assertEquals(\"Unexpected achieved replication factor\", 1, achievedRf);\n      try (ZkShardTerms zkShardTerms = new ZkShardTerms(testCollectionName, \"shard1\", cloudClient.getZkStateReader().getZkClient())) {\n        assertFalse(zkShardTerms.canBecomeLeader(notLeaders.get(0).getName()));\n      }\n      waitForState(testCollectionName, notLeaders.get(0).getName(), DOWN, 10000);\n\n      // heal partition\n      proxy0.reopen();\n      leaderProxy.reopen();\n\n      waitForState(testCollectionName, notLeaders.get(0).getName(), RECOVERING, 10000);\n\n      System.clearProperty(\"solr.cloud.wait-for-updates-with-stale-state-pause\");\n      JettySolrRunner notLeaderJetty = getJettyOnPort(getReplicaPort(notLeaders.get(0)));\n      ChaosMonkey.stop(notLeaderJetty);\n\n      ChaosMonkey.start(notLeaderJetty);\n      ensureAllReplicasAreActive(testCollectionName, \"shard1\", 1, 2, 100);\n      assertDocsExistInAllReplicas(notLeaders, testCollectionName, 1, 2);\n    } finally {\n      System.clearProperty(\"solr.cloud.wait-for-updates-with-stale-state-pause\");\n    }\n\n    // try to clean up\n    attemptCollectionDelete(cloudClient, testCollectionName);\n  }\n\n","bugFix":["84f20f331d8001864545c7021812d8c6509c7593"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#testDoRecoveryOnRestart().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#testDoRecoveryOnRestart().mjava","sourceNew":"  private void testDoRecoveryOnRestart() throws Exception {\n    String testCollectionName = \"collDoRecoveryOnRestart\";\n    try {\n      // Inject pausing in recovery op, hence the replica won't be able to finish recovery\n\n      TestInjection.prepRecoveryOpPauseForever = \"true:100\";\n      \n      createCollection(testCollectionName, \"conf1\", 1, 2);\n      cloudClient.setDefaultCollection(testCollectionName);\n\n      sendDoc(1, 2);\n\n      JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(getShardLeader(testCollectionName, \"shard1\", 1000)));\n      List<Replica> notLeaders =\n          ensureAllReplicasAreActive(testCollectionName, \"shard1\", 1, 2, maxWaitSecsToSeeAllActive);\n      assertDocsExistInAllReplicas(notLeaders, testCollectionName, 1, 1);\n\n      SocketProxy proxy0 = getProxyForReplica(notLeaders.get(0));\n      SocketProxy leaderProxy = getProxyForReplica(getShardLeader(testCollectionName, \"shard1\", 1000));\n\n      proxy0.close();\n      leaderProxy.close();\n\n      // indexing during a partition\n      int achievedRf = sendDoc(2, 1, leaderJetty);\n      assertEquals(\"Unexpected achieved replication factor\", 1, achievedRf);\n      try (ZkShardTerms zkShardTerms = new ZkShardTerms(testCollectionName, \"shard1\", cloudClient.getZkStateReader().getZkClient())) {\n        assertFalse(zkShardTerms.canBecomeLeader(notLeaders.get(0).getName()));\n      }\n      waitForState(testCollectionName, notLeaders.get(0).getName(), DOWN, 10000);\n\n      // heal partition\n      proxy0.reopen();\n      leaderProxy.reopen();\n\n      waitForState(testCollectionName, notLeaders.get(0).getName(), RECOVERING, 10000);\n\n      System.clearProperty(\"solrcloud.skip.autorecovery\");\n      JettySolrRunner notLeaderJetty = getJettyOnPort(getReplicaPort(notLeaders.get(0)));\n      String notLeaderNodeName = notLeaderJetty.getNodeName();\n      notLeaderJetty.stop();\n      \n      cloudClient.getZkStateReader().waitForLiveNodes(15, TimeUnit.SECONDS, SolrCloudTestCase.missingLiveNode(notLeaderNodeName));\n\n      notLeaderJetty.start();\n      ensureAllReplicasAreActive(testCollectionName, \"shard1\", 1, 2, 130);\n      assertDocsExistInAllReplicas(notLeaders, testCollectionName, 1, 2);\n    } finally {\n      TestInjection.prepRecoveryOpPauseForever = null;\n      TestInjection.notifyPauseForeverDone();\n    }\n\n    // try to clean up\n    attemptCollectionDelete(cloudClient, testCollectionName);\n  }\n\n","sourceOld":"  private void testDoRecoveryOnRestart() throws Exception {\n    String testCollectionName = \"collDoRecoveryOnRestart\";\n    try {\n      // Inject pausing in recovery op, hence the replica won't be able to finish recovery\n\n      TestInjection.prepRecoveryOpPauseForever = \"true:100\";\n      \n      createCollection(testCollectionName, \"conf1\", 1, 2, 1);\n      cloudClient.setDefaultCollection(testCollectionName);\n\n      sendDoc(1, 2);\n\n      JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(getShardLeader(testCollectionName, \"shard1\", 1000)));\n      List<Replica> notLeaders =\n          ensureAllReplicasAreActive(testCollectionName, \"shard1\", 1, 2, maxWaitSecsToSeeAllActive);\n      assertDocsExistInAllReplicas(notLeaders, testCollectionName, 1, 1);\n\n      SocketProxy proxy0 = getProxyForReplica(notLeaders.get(0));\n      SocketProxy leaderProxy = getProxyForReplica(getShardLeader(testCollectionName, \"shard1\", 1000));\n\n      proxy0.close();\n      leaderProxy.close();\n\n      // indexing during a partition\n      int achievedRf = sendDoc(2, 1, leaderJetty);\n      assertEquals(\"Unexpected achieved replication factor\", 1, achievedRf);\n      try (ZkShardTerms zkShardTerms = new ZkShardTerms(testCollectionName, \"shard1\", cloudClient.getZkStateReader().getZkClient())) {\n        assertFalse(zkShardTerms.canBecomeLeader(notLeaders.get(0).getName()));\n      }\n      waitForState(testCollectionName, notLeaders.get(0).getName(), DOWN, 10000);\n\n      // heal partition\n      proxy0.reopen();\n      leaderProxy.reopen();\n\n      waitForState(testCollectionName, notLeaders.get(0).getName(), RECOVERING, 10000);\n\n      System.clearProperty(\"solrcloud.skip.autorecovery\");\n      JettySolrRunner notLeaderJetty = getJettyOnPort(getReplicaPort(notLeaders.get(0)));\n      String notLeaderNodeName = notLeaderJetty.getNodeName();\n      notLeaderJetty.stop();\n      \n      cloudClient.getZkStateReader().waitForLiveNodes(15, TimeUnit.SECONDS, SolrCloudTestCase.missingLiveNode(notLeaderNodeName));\n\n      notLeaderJetty.start();\n      ensureAllReplicasAreActive(testCollectionName, \"shard1\", 1, 2, 130);\n      assertDocsExistInAllReplicas(notLeaders, testCollectionName, 1, 2);\n    } finally {\n      TestInjection.prepRecoveryOpPauseForever = null;\n      TestInjection.notifyPauseForeverDone();\n    }\n\n    // try to clean up\n    attemptCollectionDelete(cloudClient, testCollectionName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["84f20f331d8001864545c7021812d8c6509c7593"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"84f20f331d8001864545c7021812d8c6509c7593":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"]},"commit2Childs":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["84f20f331d8001864545c7021812d8c6509c7593"],"84f20f331d8001864545c7021812d8c6509c7593":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}