{"path":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,Replica.State,CoreDescriptor,boolean).mjava","commits":[{"id":"3e0300d1df37d7e9662d491269e91b6f66dca8bd","date":1443011762,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,Replica.State,CoreDescriptor,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,Replica.State,String,boolean).mjava","sourceNew":"  public void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName,\n      Replica.State state, CoreDescriptor leaderCd, boolean retryOnConnLoss) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"\n          + state.toString() + \" using: collection=\" + collection\n          + \"; shardId=\" + shardId + \"; coreNodeName=\" + coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n    \n    assert leaderCd != null;\n    assert leaderCd.getCloudDescriptor() != null;\n\n    String leaderCoreNodeName = leaderCd.getCloudDescriptor().getCoreNodeName();\n    \n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n\n    if (state == Replica.State.ACTIVE) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, retryOnConnLoss);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \" + znodePath, justLogIt);\n      }\n      return;\n    }\n\n    Map<String, Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null) {\n      stateObj = Utils.makeMap();\n    }\n\n    stateObj.put(ZkStateReader.STATE_PROP, state.toString());\n    // only update the createdBy value if it's not set\n    if (stateObj.get(\"createdByNodeName\") == null) {\n      stateObj.put(\"createdByNodeName\", this.nodeName);\n    }\n    if (stateObj.get(\"createdByCoreNodeName\") == null && leaderCoreNodeName != null)  {\n      stateObj.put(\"createdByCoreNodeName\", leaderCoreNodeName);\n    }\n\n    byte[] znodeData = Utils.toJSON(stateObj);\n\n    try {\n      if (state == Replica.State.DOWN) {\n        markShardAsDownIfLeader(collection, shardId, leaderCd, znodePath, znodeData, retryOnConnLoss);\n      } else {\n        // must retry on conn loss otherwise future election attempts may assume wrong LIR state\n        if (zkClient.exists(znodePath, true)) {\n          zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n        } else {\n          zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n        }\n      }\n      log.info(\"Wrote {} to {}\", state.toString(), znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException) exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Failed to update data to \" + state.toString() + \" for znode: \" + znodePath, exc);\n      }\n    }\n  }\n\n","sourceOld":"  public void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName,\n      Replica.State state, String leaderCoreNodeName, boolean retryOnConnLoss) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"\n          + state.toString() + \" using: collection=\" + collection\n          + \"; shardId=\" + shardId + \"; coreNodeName=\" + coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n\n    if (state == Replica.State.ACTIVE) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, retryOnConnLoss);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \" + znodePath, justLogIt);\n      }\n      return;\n    }\n\n    Map<String, Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null) {\n      stateObj = Utils.makeMap();\n    }\n\n    stateObj.put(ZkStateReader.STATE_PROP, state.toString());\n    // only update the createdBy value if it's not set\n    if (stateObj.get(\"createdByNodeName\") == null) {\n      stateObj.put(\"createdByNodeName\", this.nodeName);\n    }\n    if (stateObj.get(\"createdByCoreNodeName\") == null && leaderCoreNodeName != null)  {\n      stateObj.put(\"createdByCoreNodeName\", leaderCoreNodeName);\n    }\n\n    byte[] znodeData = Utils.toJSON(stateObj);\n\n    try {\n      if (state == Replica.State.DOWN) {\n        markShardAsDownIfLeader(collection, shardId, leaderCoreNodeName, znodePath, znodeData, retryOnConnLoss);\n      } else {\n        // must retry on conn loss otherwise future election attempts may assume wrong LIR state\n        if (zkClient.exists(znodePath, true)) {\n          zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n        } else {\n          zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n        }\n      }\n      log.info(\"Wrote {} to {}\", state.toString(), znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException) exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Failed to update data to \" + state.toString() + \" for znode: \" + znodePath, exc);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"962cd4f5e313777f35da8f521265323e84184929","date":1474533758,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,Replica.State,CoreDescriptor,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,Replica.State,CoreDescriptor,boolean).mjava","sourceNew":"  public void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName,\n      Replica.State state, CoreDescriptor leaderCd, boolean retryOnConnLoss) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"\n          + state.toString() + \" using: collection=\" + collection\n          + \"; shardId=\" + shardId + \"; coreNodeName=\" + coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n    \n    assert leaderCd != null;\n    assert leaderCd.getCloudDescriptor() != null;\n\n    String leaderCoreNodeName = leaderCd.getCloudDescriptor().getCoreNodeName();\n    \n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n\n    if (state == Replica.State.ACTIVE) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, retryOnConnLoss);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \" + znodePath, justLogIt);\n      }\n      return;\n    }\n\n    Map<String, Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null) {\n      stateObj = Utils.makeMap();\n    }\n\n    stateObj.put(ZkStateReader.STATE_PROP, state.toString());\n    // only update the createdBy value if it's not set\n    if (stateObj.get(\"createdByNodeName\") == null) {\n      stateObj.put(\"createdByNodeName\", this.nodeName);\n    }\n    if (stateObj.get(\"createdByCoreNodeName\") == null && leaderCoreNodeName != null)  {\n      stateObj.put(\"createdByCoreNodeName\", leaderCoreNodeName);\n    }\n\n    byte[] znodeData = Utils.toJSON(stateObj);\n\n    try {\n      if (state == Replica.State.DOWN) {\n        markShardAsDownIfLeader(collection, shardId, leaderCd, znodePath, znodeData, retryOnConnLoss);\n      } else {\n        // must retry on conn loss otherwise future election attempts may assume wrong LIR state\n        if (zkClient.exists(znodePath, true)) {\n          zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n        } else {\n          zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n        }\n      }\n      log.debug(\"Wrote {} to {}\", state.toString(), znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException) exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Failed to update data to \" + state.toString() + \" for znode: \" + znodePath, exc);\n      }\n    }\n  }\n\n","sourceOld":"  public void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName,\n      Replica.State state, CoreDescriptor leaderCd, boolean retryOnConnLoss) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"\n          + state.toString() + \" using: collection=\" + collection\n          + \"; shardId=\" + shardId + \"; coreNodeName=\" + coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n    \n    assert leaderCd != null;\n    assert leaderCd.getCloudDescriptor() != null;\n\n    String leaderCoreNodeName = leaderCd.getCloudDescriptor().getCoreNodeName();\n    \n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n\n    if (state == Replica.State.ACTIVE) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, retryOnConnLoss);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \" + znodePath, justLogIt);\n      }\n      return;\n    }\n\n    Map<String, Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null) {\n      stateObj = Utils.makeMap();\n    }\n\n    stateObj.put(ZkStateReader.STATE_PROP, state.toString());\n    // only update the createdBy value if it's not set\n    if (stateObj.get(\"createdByNodeName\") == null) {\n      stateObj.put(\"createdByNodeName\", this.nodeName);\n    }\n    if (stateObj.get(\"createdByCoreNodeName\") == null && leaderCoreNodeName != null)  {\n      stateObj.put(\"createdByCoreNodeName\", leaderCoreNodeName);\n    }\n\n    byte[] znodeData = Utils.toJSON(stateObj);\n\n    try {\n      if (state == Replica.State.DOWN) {\n        markShardAsDownIfLeader(collection, shardId, leaderCd, znodePath, znodeData, retryOnConnLoss);\n      } else {\n        // must retry on conn loss otherwise future election attempts may assume wrong LIR state\n        if (zkClient.exists(znodePath, true)) {\n          zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n        } else {\n          zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n        }\n      }\n      log.info(\"Wrote {} to {}\", state.toString(), znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException) exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Failed to update data to \" + state.toString() + \" for znode: \" + znodePath, exc);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,Replica.State,CoreDescriptor,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,Replica.State,CoreDescriptor,boolean).mjava","sourceNew":"  public void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName,\n      Replica.State state, CoreDescriptor leaderCd, boolean retryOnConnLoss) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"\n          + state.toString() + \" using: collection=\" + collection\n          + \"; shardId=\" + shardId + \"; coreNodeName=\" + coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n    \n    assert leaderCd != null;\n    assert leaderCd.getCloudDescriptor() != null;\n\n    String leaderCoreNodeName = leaderCd.getCloudDescriptor().getCoreNodeName();\n    \n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n\n    if (state == Replica.State.ACTIVE) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, retryOnConnLoss);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \" + znodePath, justLogIt);\n      }\n      return;\n    }\n\n    Map<String, Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null) {\n      stateObj = Utils.makeMap();\n    }\n\n    stateObj.put(ZkStateReader.STATE_PROP, state.toString());\n    // only update the createdBy value if it's not set\n    if (stateObj.get(\"createdByNodeName\") == null) {\n      stateObj.put(\"createdByNodeName\", this.nodeName);\n    }\n    if (stateObj.get(\"createdByCoreNodeName\") == null && leaderCoreNodeName != null)  {\n      stateObj.put(\"createdByCoreNodeName\", leaderCoreNodeName);\n    }\n\n    byte[] znodeData = Utils.toJSON(stateObj);\n\n    try {\n      if (state == Replica.State.DOWN) {\n        markShardAsDownIfLeader(collection, shardId, leaderCd, znodePath, znodeData, retryOnConnLoss);\n      } else {\n        // must retry on conn loss otherwise future election attempts may assume wrong LIR state\n        if (zkClient.exists(znodePath, true)) {\n          zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n        } else {\n          zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n        }\n      }\n      log.debug(\"Wrote {} to {}\", state.toString(), znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException) exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Failed to update data to \" + state.toString() + \" for znode: \" + znodePath, exc);\n      }\n    }\n  }\n\n","sourceOld":"  public void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName,\n      Replica.State state, CoreDescriptor leaderCd, boolean retryOnConnLoss) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"\n          + state.toString() + \" using: collection=\" + collection\n          + \"; shardId=\" + shardId + \"; coreNodeName=\" + coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n    \n    assert leaderCd != null;\n    assert leaderCd.getCloudDescriptor() != null;\n\n    String leaderCoreNodeName = leaderCd.getCloudDescriptor().getCoreNodeName();\n    \n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n\n    if (state == Replica.State.ACTIVE) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, retryOnConnLoss);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \" + znodePath, justLogIt);\n      }\n      return;\n    }\n\n    Map<String, Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null) {\n      stateObj = Utils.makeMap();\n    }\n\n    stateObj.put(ZkStateReader.STATE_PROP, state.toString());\n    // only update the createdBy value if it's not set\n    if (stateObj.get(\"createdByNodeName\") == null) {\n      stateObj.put(\"createdByNodeName\", this.nodeName);\n    }\n    if (stateObj.get(\"createdByCoreNodeName\") == null && leaderCoreNodeName != null)  {\n      stateObj.put(\"createdByCoreNodeName\", leaderCoreNodeName);\n    }\n\n    byte[] znodeData = Utils.toJSON(stateObj);\n\n    try {\n      if (state == Replica.State.DOWN) {\n        markShardAsDownIfLeader(collection, shardId, leaderCd, znodePath, znodeData, retryOnConnLoss);\n      } else {\n        // must retry on conn loss otherwise future election attempts may assume wrong LIR state\n        if (zkClient.exists(znodePath, true)) {\n          zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n        } else {\n          zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n        }\n      }\n      log.info(\"Wrote {} to {}\", state.toString(), znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException) exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Failed to update data to \" + state.toString() + \" for znode: \" + znodePath, exc);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,Replica.State,CoreDescriptor,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,Replica.State,CoreDescriptor,boolean).mjava","sourceNew":"  public void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName,\n      Replica.State state, CoreDescriptor leaderCd, boolean retryOnConnLoss) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"\n          + state.toString() + \" using: collection=\" + collection\n          + \"; shardId=\" + shardId + \"; coreNodeName=\" + coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n    \n    assert leaderCd != null;\n    assert leaderCd.getCloudDescriptor() != null;\n\n    String leaderCoreNodeName = leaderCd.getCloudDescriptor().getCoreNodeName();\n    \n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n\n    if (state == Replica.State.ACTIVE) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, retryOnConnLoss);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \" + znodePath, justLogIt);\n      }\n      return;\n    }\n\n    Map<String, Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null) {\n      stateObj = Utils.makeMap();\n    }\n\n    stateObj.put(ZkStateReader.STATE_PROP, state.toString());\n    // only update the createdBy value if it's not set\n    if (stateObj.get(\"createdByNodeName\") == null) {\n      stateObj.put(\"createdByNodeName\", this.nodeName);\n    }\n    if (stateObj.get(\"createdByCoreNodeName\") == null && leaderCoreNodeName != null)  {\n      stateObj.put(\"createdByCoreNodeName\", leaderCoreNodeName);\n    }\n\n    byte[] znodeData = Utils.toJSON(stateObj);\n\n    try {\n      if (state == Replica.State.DOWN) {\n        markShardAsDownIfLeader(collection, shardId, leaderCd, znodePath, znodeData, retryOnConnLoss);\n      } else {\n        // must retry on conn loss otherwise future election attempts may assume wrong LIR state\n        if (zkClient.exists(znodePath, true)) {\n          zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n        } else {\n          zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n        }\n      }\n      log.debug(\"Wrote {} to {}\", state.toString(), znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException) exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Failed to update data to \" + state.toString() + \" for znode: \" + znodePath, exc);\n      }\n    }\n  }\n\n","sourceOld":"  public void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName,\n      Replica.State state, CoreDescriptor leaderCd, boolean retryOnConnLoss) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"\n          + state.toString() + \" using: collection=\" + collection\n          + \"; shardId=\" + shardId + \"; coreNodeName=\" + coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n    \n    assert leaderCd != null;\n    assert leaderCd.getCloudDescriptor() != null;\n\n    String leaderCoreNodeName = leaderCd.getCloudDescriptor().getCoreNodeName();\n    \n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n\n    if (state == Replica.State.ACTIVE) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, retryOnConnLoss);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \" + znodePath, justLogIt);\n      }\n      return;\n    }\n\n    Map<String, Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null) {\n      stateObj = Utils.makeMap();\n    }\n\n    stateObj.put(ZkStateReader.STATE_PROP, state.toString());\n    // only update the createdBy value if it's not set\n    if (stateObj.get(\"createdByNodeName\") == null) {\n      stateObj.put(\"createdByNodeName\", this.nodeName);\n    }\n    if (stateObj.get(\"createdByCoreNodeName\") == null && leaderCoreNodeName != null)  {\n      stateObj.put(\"createdByCoreNodeName\", leaderCoreNodeName);\n    }\n\n    byte[] znodeData = Utils.toJSON(stateObj);\n\n    try {\n      if (state == Replica.State.DOWN) {\n        markShardAsDownIfLeader(collection, shardId, leaderCd, znodePath, znodeData, retryOnConnLoss);\n      } else {\n        // must retry on conn loss otherwise future election attempts may assume wrong LIR state\n        if (zkClient.exists(znodePath, true)) {\n          zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n        } else {\n          zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n        }\n      }\n      log.info(\"Wrote {} to {}\", state.toString(), znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException) exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Failed to update data to \" + state.toString() + \" for znode: \" + znodePath, exc);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,Replica.State,CoreDescriptor,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,Replica.State,CoreDescriptor,boolean).mjava","sourceNew":"  @Deprecated\n  public void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName,\n      Replica.State state, CoreDescriptor leaderCd, boolean retryOnConnLoss) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"\n          + state.toString() + \" using: collection=\" + collection\n          + \"; shardId=\" + shardId + \"; coreNodeName=\" + coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    assert leaderCd != null;\n    assert leaderCd.getCloudDescriptor() != null;\n\n    String leaderCoreNodeName = leaderCd.getCloudDescriptor().getCoreNodeName();\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n\n    if (state == Replica.State.ACTIVE) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, retryOnConnLoss);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \" + znodePath, justLogIt);\n      }\n      return;\n    }\n\n    Map<String, Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null) {\n      stateObj = Utils.makeMap();\n    }\n\n    stateObj.put(ZkStateReader.STATE_PROP, state.toString());\n    // only update the createdBy value if it's not set\n    if (stateObj.get(\"createdByNodeName\") == null) {\n      stateObj.put(\"createdByNodeName\", this.nodeName);\n    }\n    if (stateObj.get(\"createdByCoreNodeName\") == null && leaderCoreNodeName != null)  {\n      stateObj.put(\"createdByCoreNodeName\", leaderCoreNodeName);\n    }\n\n    byte[] znodeData = Utils.toJSON(stateObj);\n\n    try {\n      if (state == Replica.State.DOWN) {\n        markShardAsDownIfLeader(collection, shardId, leaderCd, znodePath, znodeData, retryOnConnLoss);\n      } else {\n        // must retry on conn loss otherwise future election attempts may assume wrong LIR state\n        if (zkClient.exists(znodePath, true)) {\n          zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n        } else {\n          zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n        }\n      }\n      log.debug(\"Wrote {} to {}\", state.toString(), znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException) exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Failed to update data to \" + state.toString() + \" for znode: \" + znodePath, exc);\n      }\n    }\n  }\n\n","sourceOld":"  public void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName,\n      Replica.State state, CoreDescriptor leaderCd, boolean retryOnConnLoss) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"\n          + state.toString() + \" using: collection=\" + collection\n          + \"; shardId=\" + shardId + \"; coreNodeName=\" + coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n    \n    assert leaderCd != null;\n    assert leaderCd.getCloudDescriptor() != null;\n\n    String leaderCoreNodeName = leaderCd.getCloudDescriptor().getCoreNodeName();\n    \n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n\n    if (state == Replica.State.ACTIVE) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, retryOnConnLoss);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \" + znodePath, justLogIt);\n      }\n      return;\n    }\n\n    Map<String, Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null) {\n      stateObj = Utils.makeMap();\n    }\n\n    stateObj.put(ZkStateReader.STATE_PROP, state.toString());\n    // only update the createdBy value if it's not set\n    if (stateObj.get(\"createdByNodeName\") == null) {\n      stateObj.put(\"createdByNodeName\", this.nodeName);\n    }\n    if (stateObj.get(\"createdByCoreNodeName\") == null && leaderCoreNodeName != null)  {\n      stateObj.put(\"createdByCoreNodeName\", leaderCoreNodeName);\n    }\n\n    byte[] znodeData = Utils.toJSON(stateObj);\n\n    try {\n      if (state == Replica.State.DOWN) {\n        markShardAsDownIfLeader(collection, shardId, leaderCd, znodePath, znodeData, retryOnConnLoss);\n      } else {\n        // must retry on conn loss otherwise future election attempts may assume wrong LIR state\n        if (zkClient.exists(znodePath, true)) {\n          zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n        } else {\n          zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n        }\n      }\n      log.debug(\"Wrote {} to {}\", state.toString(), znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException) exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Failed to update data to \" + state.toString() + \" for znode: \" + znodePath, exc);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180","date":1539076849,"type":4,"author":"Cao Manh Dat","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,Replica.State,CoreDescriptor,boolean).mjava","sourceNew":null,"sourceOld":"  @Deprecated\n  public void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName,\n      Replica.State state, CoreDescriptor leaderCd, boolean retryOnConnLoss) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"\n          + state.toString() + \" using: collection=\" + collection\n          + \"; shardId=\" + shardId + \"; coreNodeName=\" + coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    assert leaderCd != null;\n    assert leaderCd.getCloudDescriptor() != null;\n\n    String leaderCoreNodeName = leaderCd.getCloudDescriptor().getCoreNodeName();\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n\n    if (state == Replica.State.ACTIVE) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, retryOnConnLoss);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \" + znodePath, justLogIt);\n      }\n      return;\n    }\n\n    Map<String, Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null) {\n      stateObj = Utils.makeMap();\n    }\n\n    stateObj.put(ZkStateReader.STATE_PROP, state.toString());\n    // only update the createdBy value if it's not set\n    if (stateObj.get(\"createdByNodeName\") == null) {\n      stateObj.put(\"createdByNodeName\", this.nodeName);\n    }\n    if (stateObj.get(\"createdByCoreNodeName\") == null && leaderCoreNodeName != null)  {\n      stateObj.put(\"createdByCoreNodeName\", leaderCoreNodeName);\n    }\n\n    byte[] znodeData = Utils.toJSON(stateObj);\n\n    try {\n      if (state == Replica.State.DOWN) {\n        markShardAsDownIfLeader(collection, shardId, leaderCd, znodePath, znodeData, retryOnConnLoss);\n      } else {\n        // must retry on conn loss otherwise future election attempts may assume wrong LIR state\n        if (zkClient.exists(znodePath, true)) {\n          zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n        } else {\n          zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n        }\n      }\n      log.debug(\"Wrote {} to {}\", state.toString(), znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException) exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Failed to update data to \" + state.toString() + \" for znode: \" + znodePath, exc);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"962cd4f5e313777f35da8f521265323e84184929":["3e0300d1df37d7e9662d491269e91b6f66dca8bd"],"3e0300d1df37d7e9662d491269e91b6f66dca8bd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["3e0300d1df37d7e9662d491269e91b6f66dca8bd","962cd4f5e313777f35da8f521265323e84184929"],"84f20f331d8001864545c7021812d8c6509c7593":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["84f20f331d8001864545c7021812d8c6509c7593"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3e0300d1df37d7e9662d491269e91b6f66dca8bd","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"]},"commit2Childs":{"962cd4f5e313777f35da8f521265323e84184929":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"3e0300d1df37d7e9662d491269e91b6f66dca8bd":["962cd4f5e313777f35da8f521265323e84184929","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3e0300d1df37d7e9662d491269e91b6f66dca8bd"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["84f20f331d8001864545c7021812d8c6509c7593","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"84f20f331d8001864545c7021812d8c6509c7593":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}