{"path":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","commits":[{"id":"9088bc86d5a0e967da50b566ea1dd0c5458ba6f5","date":1418915621,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter).mjava","sourceNew":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      ZkWriteCommand zkWriteCommand = null;\n      final TimerContext timerContext = stats.time(operation);\n      try {\n        zkWriteCommand = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommand != null) {\n        clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommand, callback);\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","sourceOld":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter) throws KeeperException, InterruptedException {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      ZkWriteCommand zkWriteCommand = null;\n      final TimerContext timerContext = stats.time(operation);\n      try {\n        zkWriteCommand = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommand != null) {\n        clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommand);\n      }\n      return clusterState;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4820e7931c05e4eb25ac34917774fbacab59c3a3","date":1454991883,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","sourceNew":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      List<ZkWriteCommand> zkWriteCommands = null;\n      final TimerContext timerContext = stats.time(operation);\n      try {\n        zkWriteCommands = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommands != null) {\n        for (ZkWriteCommand zkWriteCommand : zkWriteCommands) {\n          clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommand, callback);\n        }\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","sourceOld":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      ZkWriteCommand zkWriteCommand = null;\n      final TimerContext timerContext = stats.time(operation);\n      try {\n        zkWriteCommand = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommand != null) {\n        clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommand, callback);\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","bugFix":null,"bugIntro":["4e42079c4c34cc1868518eff79f79ebaeb6d1965"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f3e7752e8a5e963c6939aaa99c36134147a5ece","date":1479805653,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","sourceNew":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      List<ZkWriteCommand> zkWriteCommands = null;\n      final Timer.Context timerContext = stats.time(operation);\n      try {\n        zkWriteCommands = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommands != null) {\n        for (ZkWriteCommand zkWriteCommand : zkWriteCommands) {\n          clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommand, callback);\n        }\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","sourceOld":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      List<ZkWriteCommand> zkWriteCommands = null;\n      final TimerContext timerContext = stats.time(operation);\n      try {\n        zkWriteCommands = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommands != null) {\n        for (ZkWriteCommand zkWriteCommand : zkWriteCommands) {\n          clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommand, callback);\n        }\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","sourceNew":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      List<ZkWriteCommand> zkWriteCommands = null;\n      final Timer.Context timerContext = stats.time(operation);\n      try {\n        zkWriteCommands = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommands != null) {\n        for (ZkWriteCommand zkWriteCommand : zkWriteCommands) {\n          clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommand, callback);\n        }\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","sourceOld":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      List<ZkWriteCommand> zkWriteCommands = null;\n      final TimerContext timerContext = stats.time(operation);\n      try {\n        zkWriteCommands = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommands != null) {\n        for (ZkWriteCommand zkWriteCommand : zkWriteCommands) {\n          clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommand, callback);\n        }\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e42079c4c34cc1868518eff79f79ebaeb6d1965","date":1507883024,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","sourceNew":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      List<ZkWriteCommand> zkWriteCommands = null;\n      final Timer.Context timerContext = stats.time(operation);\n      try {\n        zkWriteCommands = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommands != null) {\n        clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommands, callback);\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","sourceOld":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      List<ZkWriteCommand> zkWriteCommands = null;\n      final Timer.Context timerContext = stats.time(operation);\n      try {\n        zkWriteCommands = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommands != null) {\n        for (ZkWriteCommand zkWriteCommand : zkWriteCommands) {\n          clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommand, callback);\n        }\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","bugFix":["4820e7931c05e4eb25ac34917774fbacab59c3a3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","sourceNew":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      List<ZkWriteCommand> zkWriteCommands = null;\n      final Timer.Context timerContext = stats.time(operation);\n      try {\n        zkWriteCommands = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message: \" + message, e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommands != null) {\n        clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommands, callback);\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","sourceOld":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      List<ZkWriteCommand> zkWriteCommands = null;\n      final Timer.Context timerContext = stats.time(operation);\n      try {\n        zkWriteCommands = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommands != null) {\n        clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommands, callback);\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af3e10d8a1fbcc5c79b22f7477e79de467dd326c","date":1515178406,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","sourceNew":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      if (operation == null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Message missing \" + QUEUE_OPERATION + \":\" + message);\n      }\n      List<ZkWriteCommand> zkWriteCommands = null;\n      final Timer.Context timerContext = stats.time(operation);\n      try {\n        zkWriteCommands = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message: \" + message, e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommands != null) {\n        clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommands, callback);\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","sourceOld":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      List<ZkWriteCommand> zkWriteCommands = null;\n      final Timer.Context timerContext = stats.time(operation);\n      try {\n        zkWriteCommands = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message: \" + message, e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommands != null) {\n        clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommands, callback);\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","sourceNew":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      if (operation == null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Message missing \" + QUEUE_OPERATION + \":\" + message);\n      }\n      List<ZkWriteCommand> zkWriteCommands = null;\n      final Timer.Context timerContext = stats.time(operation);\n      try {\n        zkWriteCommands = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message: \" + message, e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommands != null) {\n        clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommands, callback);\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","sourceOld":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      List<ZkWriteCommand> zkWriteCommands = null;\n      final Timer.Context timerContext = stats.time(operation);\n      try {\n        zkWriteCommands = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message: \" + message, e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommands != null) {\n        clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommands, callback);\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad4957cde742defe6db19689abdc267c5d948066","date":1587990850,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#processQueueItem(ZkNodeProps,ClusterState,ZkStateWriter,boolean,ZkStateWriter.ZkWriteCallback).mjava","sourceNew":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      if (operation == null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Message missing \" + QUEUE_OPERATION + \":\" + message);\n      }\n      List<ZkWriteCommand> zkWriteCommands = null;\n      final Timer.Context timerContext = stats.time(operation);\n      try {\n        zkWriteCommands = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message: {}\", message, e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommands != null) {\n        clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommands, callback);\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","sourceOld":"    private ClusterState processQueueItem(ZkNodeProps message, ClusterState clusterState, ZkStateWriter zkStateWriter, boolean enableBatching, ZkStateWriter.ZkWriteCallback callback) throws Exception {\n      final String operation = message.getStr(QUEUE_OPERATION);\n      if (operation == null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Message missing \" + QUEUE_OPERATION + \":\" + message);\n      }\n      List<ZkWriteCommand> zkWriteCommands = null;\n      final Timer.Context timerContext = stats.time(operation);\n      try {\n        zkWriteCommands = processMessage(clusterState, message, operation);\n        stats.success(operation);\n      } catch (Exception e) {\n        // generally there is nothing we can do - in most cases, we have\n        // an issue that will fail again on retry or we cannot communicate with     a\n        // ZooKeeper in which case another Overseer should take over\n        // TODO: if ordering for the message is not important, we could\n        // track retries and put it back on the end of the queue\n        log.error(\"Overseer could not process the current clusterstate state update message, skipping the message: \" + message, e);\n        stats.error(operation);\n      } finally {\n        timerContext.stop();\n      }\n      if (zkWriteCommands != null) {\n        clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommands, callback);\n        if (!enableBatching)  {\n          clusterState = zkStateWriter.writePendingUpdates();\n        }\n      }\n      return clusterState;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8","af3e10d8a1fbcc5c79b22f7477e79de467dd326c"],"0f3e7752e8a5e963c6939aaa99c36134147a5ece":["4820e7931c05e4eb25ac34917774fbacab59c3a3"],"4e42079c4c34cc1868518eff79f79ebaeb6d1965":["0f3e7752e8a5e963c6939aaa99c36134147a5ece"],"727bb765ff2542275f6d31f67be18d7104bae148":["4820e7931c05e4eb25ac34917774fbacab59c3a3","0f3e7752e8a5e963c6939aaa99c36134147a5ece"],"9088bc86d5a0e967da50b566ea1dd0c5458ba6f5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"af3e10d8a1fbcc5c79b22f7477e79de467dd326c":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["4e42079c4c34cc1868518eff79f79ebaeb6d1965"],"ad4957cde742defe6db19689abdc267c5d948066":["b94236357aaa22b76c10629851fe4e376e0cea82"],"4820e7931c05e4eb25ac34917774fbacab59c3a3":["9088bc86d5a0e967da50b566ea1dd0c5458ba6f5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ad4957cde742defe6db19689abdc267c5d948066"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["ad4957cde742defe6db19689abdc267c5d948066"],"0f3e7752e8a5e963c6939aaa99c36134147a5ece":["4e42079c4c34cc1868518eff79f79ebaeb6d1965","727bb765ff2542275f6d31f67be18d7104bae148"],"4e42079c4c34cc1868518eff79f79ebaeb6d1965":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"727bb765ff2542275f6d31f67be18d7104bae148":[],"af3e10d8a1fbcc5c79b22f7477e79de467dd326c":["b94236357aaa22b76c10629851fe4e376e0cea82"],"9088bc86d5a0e967da50b566ea1dd0c5458ba6f5":["4820e7931c05e4eb25ac34917774fbacab59c3a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9088bc86d5a0e967da50b566ea1dd0c5458ba6f5"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["b94236357aaa22b76c10629851fe4e376e0cea82","af3e10d8a1fbcc5c79b22f7477e79de467dd326c"],"ad4957cde742defe6db19689abdc267c5d948066":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4820e7931c05e4eb25ac34917774fbacab59c3a3":["0f3e7752e8a5e963c6939aaa99c36134147a5ece","727bb765ff2542275f6d31f67be18d7104bae148"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}