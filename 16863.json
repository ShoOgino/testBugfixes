{"path":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","commits":[{"id":"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76","date":1204055227,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new NamedList();\n    NamedList facet_queries = new NamedList();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (Map.Entry<String,Long> entry : fi.queryFacets.entrySet()) {\n      facet_queries.add(entry.getKey(), num(entry.getValue()));\n    }\n\n    NamedList facet_fields = new NamedList();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      SimpleOrderedMap fieldCounts = new SimpleOrderedMap();\n      facet_fields.add(dff.field, fieldCounts);\n\n      ShardFacetCount[] counts = dff.countSorted;\n      if (dff.needRefinements) {\n        counts = dff.getSorted();\n      }\n\n      int end = Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: list facets (sorted by natural order)\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new NamedList());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9eeefc9a351a2910959c41bf241877a3d60eec37","718ab708b1705aae7831111fcddfc834665eee61","9ac277fcde6efbfb4b34a6b2cdbda483003cda18","d1c5c000a4f7db9f84794088342aa428d80dfa37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da0acfe5ceed804451d76c8f887855b3d060e132","date":1208287358,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (Map.Entry<String,Long> entry : fi.queryFacets.entrySet()) {\n      facet_queries.add(entry.getKey(), num(entry.getValue()));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.field, fieldCounts);\n\n      ShardFacetCount[] counts = dff.countSorted;\n      if (dff.needRefinements) {\n        counts = dff.getSorted();\n      }\n\n      int end = Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: list facets (sorted by natural order)\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new NamedList();\n    NamedList facet_queries = new NamedList();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (Map.Entry<String,Long> entry : fi.queryFacets.entrySet()) {\n      facet_queries.add(entry.getKey(), num(entry.getValue()));\n    }\n\n    NamedList facet_fields = new NamedList();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      SimpleOrderedMap fieldCounts = new SimpleOrderedMap();\n      facet_fields.add(dff.field, fieldCounts);\n\n      ShardFacetCount[] counts = dff.countSorted;\n      if (dff.needRefinements) {\n        counts = dff.getSorted();\n      }\n\n      int end = Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: list facets (sorted by natural order)\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new NamedList());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4db78c8781346b675fa5f1a6db8adcb96889c2ca","date":1213723536,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (Map.Entry<String,Long> entry : fi.queryFacets.entrySet()) {\n      facet_queries.add(entry.getKey(), num(entry.getValue()));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.field, fieldCounts);\n\n      ShardFacetCount[] counts = dff.countSorted;\n      if (counts == null || dff.needRefinements) {\n        counts = dff.getSorted();\n      }\n\n      int end = Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: list facets (sorted by natural order)\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (Map.Entry<String,Long> entry : fi.queryFacets.entrySet()) {\n      facet_queries.add(entry.getKey(), num(entry.getValue()));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.field, fieldCounts);\n\n      ShardFacetCount[] counts = dff.countSorted;\n      if (dff.needRefinements) {\n        counts = dff.getSorted();\n      }\n\n      int end = Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: list facets (sorted by natural order)\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ac277fcde6efbfb4b34a6b2cdbda483003cda18","date":1220648479,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (Map.Entry<String,Long> entry : fi.queryFacets.entrySet()) {\n      facet_queries.add(entry.getKey(), num(entry.getValue()));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.field, fieldCounts);\n\n      ShardFacetCount[] counts = dff.countSorted;\n      if (counts == null || dff.needRefinements) {\n        counts = dff.getSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: list facets (sorted by natural order)\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (Map.Entry<String,Long> entry : fi.queryFacets.entrySet()) {\n      facet_queries.add(entry.getKey(), num(entry.getValue()));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.field, fieldCounts);\n\n      ShardFacetCount[] counts = dff.countSorted;\n      if (counts == null || dff.needRefinements) {\n        counts = dff.getSorted();\n      }\n\n      int end = Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: list facets (sorted by natural order)\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"bugIntro":["d1c5c000a4f7db9f84794088342aa428d80dfa37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5a95ce1d7a3779af6db59b6b39d3b89172d7445","date":1228620032,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (Map.Entry<String,Long> entry : fi.queryFacets.entrySet()) {\n      facet_queries.add(entry.getKey(), num(entry.getValue()));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.field, fieldCounts);\n\n      ShardFacetCount[] counts;\n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT) || dff.sort.equals(FacetParams.FACET_SORT_COUNT_LEGACY)) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_LEX) || dff.sort.equals(FacetParams.FACET_SORT_LEX_LEGACY)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: list facets (sorted by natural order)\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (Map.Entry<String,Long> entry : fi.queryFacets.entrySet()) {\n      facet_queries.add(entry.getKey(), num(entry.getValue()));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.field, fieldCounts);\n\n      ShardFacetCount[] counts = dff.countSorted;\n      if (counts == null || dff.needRefinements) {\n        counts = dff.getSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: list facets (sorted by natural order)\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba2bd485bcfb228fadd0d133a947f88f0cc2058d","date":1228666670,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (Map.Entry<String,Long> entry : fi.queryFacets.entrySet()) {\n      facet_queries.add(entry.getKey(), num(entry.getValue()));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.field, fieldCounts);\n\n      ShardFacetCount[] counts;\n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_LEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: list facets (sorted by natural order)\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (Map.Entry<String,Long> entry : fi.queryFacets.entrySet()) {\n      facet_queries.add(entry.getKey(), num(entry.getValue()));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.field, fieldCounts);\n\n      ShardFacetCount[] counts;\n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT) || dff.sort.equals(FacetParams.FACET_SORT_COUNT_LEGACY)) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_LEX) || dff.sort.equals(FacetParams.FACET_SORT_LEX_LEGACY)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: list facets (sorted by natural order)\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":["9eeefc9a351a2910959c41bf241877a3d60eec37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9cb179b2fab2183d2f6041e450ff8022c592ecf0","date":1229553695,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_LEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (Map.Entry<String,Long> entry : fi.queryFacets.entrySet()) {\n      facet_queries.add(entry.getKey(), num(entry.getValue()));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.field, fieldCounts);\n\n      ShardFacetCount[] counts;\n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_LEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: list facets (sorted by natural order)\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1161f19bd84204b140d97fea16ff621e86ce7ab4","date":1235924971,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_LEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"718ab708b1705aae7831111fcddfc834665eee61","date":1241122833,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n      \n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9eeefc9a351a2910959c41bf241877a3d60eec37","date":1244136536,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) break;\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":["ba2bd485bcfb228fadd0d133a947f88f0cc2058d","5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"bugIntro":["d1c5c000a4f7db9f84794088342aa428d80dfa37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"718ab708b1705aae7831111fcddfc834665eee61":["1161f19bd84204b140d97fea16ff621e86ce7ab4"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"9cb179b2fab2183d2f6041e450ff8022c592ecf0":["ba2bd485bcfb228fadd0d133a947f88f0cc2058d"],"ba2bd485bcfb228fadd0d133a947f88f0cc2058d":["e5a95ce1d7a3779af6db59b6b39d3b89172d7445"],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"e5a95ce1d7a3779af6db59b6b39d3b89172d7445":["9ac277fcde6efbfb4b34a6b2cdbda483003cda18"],"4db78c8781346b675fa5f1a6db8adcb96889c2ca":["da0acfe5ceed804451d76c8f887855b3d060e132"],"da0acfe5ceed804451d76c8f887855b3d060e132":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"9eeefc9a351a2910959c41bf241877a3d60eec37":["718ab708b1705aae7831111fcddfc834665eee61"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1161f19bd84204b140d97fea16ff621e86ce7ab4":["9cb179b2fab2183d2f6041e450ff8022c592ecf0"],"ad94625fb8d088209f46650c8097196fec67f00c":["9eeefc9a351a2910959c41bf241877a3d60eec37"],"9ac277fcde6efbfb4b34a6b2cdbda483003cda18":["4db78c8781346b675fa5f1a6db8adcb96889c2ca"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"718ab708b1705aae7831111fcddfc834665eee61":["9eeefc9a351a2910959c41bf241877a3d60eec37"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"9cb179b2fab2183d2f6041e450ff8022c592ecf0":["1161f19bd84204b140d97fea16ff621e86ce7ab4"],"ba2bd485bcfb228fadd0d133a947f88f0cc2058d":["9cb179b2fab2183d2f6041e450ff8022c592ecf0"],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":["da0acfe5ceed804451d76c8f887855b3d060e132"],"e5a95ce1d7a3779af6db59b6b39d3b89172d7445":["ba2bd485bcfb228fadd0d133a947f88f0cc2058d"],"4db78c8781346b675fa5f1a6db8adcb96889c2ca":["9ac277fcde6efbfb4b34a6b2cdbda483003cda18"],"da0acfe5ceed804451d76c8f887855b3d060e132":["4db78c8781346b675fa5f1a6db8adcb96889c2ca"],"9eeefc9a351a2910959c41bf241877a3d60eec37":["ad94625fb8d088209f46650c8097196fec67f00c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1161f19bd84204b140d97fea16ff621e86ce7ab4":["718ab708b1705aae7831111fcddfc834665eee61"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"9ac277fcde6efbfb4b34a6b2cdbda483003cda18":["e5a95ce1d7a3779af6db59b6b39d3b89172d7445"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}