{"path":"lucene/core/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(10000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(10000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(10000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random().nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random().nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random().nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(10000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":["7b90dce9d2510a4adffa447c4dbb85717693b5c3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b90dce9d2510a4adffa447c4dbb85717693b5c3","date":1343916644,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(3000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream;\n        if (random().nextBoolean()) {\n          stream = random().nextInt(3);\n        } else {\n          stream = random().nextInt(NUM_STREAM);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"write stream=\" + stream);\n        }\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE) {\n            System.out.println(\"  init to \" + starts[stream]);\n          }\n        }\n\n        writer.init(uptos[stream]);\n        int numValue;\n        if (random().nextInt(10) == 3) {\n          numValue = random().nextInt(100);\n        } else if (random().nextInt(5) == 3) {\n          numValue = random().nextInt(3);\n        } else {\n          numValue = random().nextInt(20);\n        }\n\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE) {\n            System.out.println(\"    write \" + (counters[stream]+j));\n          }\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random().nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(10000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random().nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random().nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random().nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","42607aa380c892dc1ec0ab26e86a575c28e13618","0762b640e0d0d12b6edb96db68986e13145c3484"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(3000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream;\n        if (random().nextBoolean()) {\n          stream = random().nextInt(3);\n        } else {\n          stream = random().nextInt(NUM_STREAM);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"write stream=\" + stream);\n        }\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE) {\n            System.out.println(\"  init to \" + starts[stream]);\n          }\n        }\n\n        writer.init(uptos[stream]);\n        int numValue;\n        if (random().nextInt(10) == 3) {\n          numValue = random().nextInt(100);\n        } else if (random().nextInt(5) == 3) {\n          numValue = random().nextInt(3);\n        } else {\n          numValue = random().nextInt(20);\n        }\n\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE) {\n            System.out.println(\"    write \" + (counters[stream]+j));\n          }\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random().nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(10000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random().nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random().nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random().nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(3000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream;\n        if (random().nextBoolean()) {\n          stream = random().nextInt(3);\n        } else {\n          stream = random().nextInt(NUM_STREAM);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"write stream=\" + stream);\n        }\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE) {\n            System.out.println(\"  init to \" + starts[stream]);\n          }\n        }\n\n        writer.init(uptos[stream]);\n        int numValue;\n        if (random().nextInt(10) == 3) {\n          numValue = random().nextInt(100);\n        } else if (random().nextInt(5) == 3) {\n          numValue = random().nextInt(3);\n        } else {\n          numValue = random().nextInt(20);\n        }\n\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE) {\n            System.out.println(\"    write \" + (counters[stream]+j));\n          }\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random().nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(10000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random().nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random().nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random().nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30fd30bfbfa6b9e036bcd99c8339712e965d4a63","date":1351859294,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, random().nextInt(100)));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(3000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream;\n        if (random().nextBoolean()) {\n          stream = random().nextInt(3);\n        } else {\n          stream = random().nextInt(NUM_STREAM);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"write stream=\" + stream);\n        }\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE) {\n            System.out.println(\"  init to \" + starts[stream]);\n          }\n        }\n\n        writer.init(uptos[stream]);\n        int numValue;\n        if (random().nextInt(10) == 3) {\n          numValue = random().nextInt(100);\n        } else if (random().nextInt(5) == 3) {\n          numValue = random().nextInt(3);\n        } else {\n          numValue = random().nextInt(20);\n        }\n\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE) {\n            System.out.println(\"    write \" + (counters[stream]+j));\n          }\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random().nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(3000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream;\n        if (random().nextBoolean()) {\n          stream = random().nextInt(3);\n        } else {\n          stream = random().nextInt(NUM_STREAM);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"write stream=\" + stream);\n        }\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE) {\n            System.out.println(\"  init to \" + starts[stream]);\n          }\n        }\n\n        writer.init(uptos[stream]);\n        int numValue;\n        if (random().nextInt(10) == 3) {\n          numValue = random().nextInt(100);\n        } else if (random().nextInt(5) == 3) {\n          numValue = random().nextInt(3);\n        } else {\n          numValue = random().nextInt(20);\n        }\n\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE) {\n            System.out.println(\"    write \" + (counters[stream]+j));\n          }\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random().nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"617d6d4150e0fb2acef8980ce51e3b8e628fb200","date":1580326292,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    Random random = random();\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, random().nextInt(100)));\n\n    final int NUM_STREAM = atLeast(random, 100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(random, 3000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream;\n        if (random.nextBoolean()) {\n          stream = random.nextInt(3);\n        } else {\n          stream = random.nextInt(NUM_STREAM);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"write stream=\" + stream);\n        }\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE) {\n            System.out.println(\"  init to \" + starts[stream]);\n          }\n        }\n\n        writer.init(uptos[stream]);\n        int numValue;\n        if (random.nextInt(10) == 3) {\n          numValue = random.nextInt(100);\n        } else if (random.nextInt(5) == 3) {\n          numValue = random.nextInt(3);\n        } else {\n          numValue = random.nextInt(20);\n        }\n\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE) {\n            System.out.println(\"    write \" + (counters[stream]+j));\n          }\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, random().nextInt(100)));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(3000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream;\n        if (random().nextBoolean()) {\n          stream = random().nextInt(3);\n        } else {\n          stream = random().nextInt(NUM_STREAM);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"write stream=\" + stream);\n        }\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE) {\n            System.out.println(\"  init to \" + starts[stream]);\n          }\n        }\n\n        writer.init(uptos[stream]);\n        int numValue;\n        if (random().nextInt(10) == 3) {\n          numValue = random().nextInt(100);\n        } else if (random().nextInt(5) == 3) {\n          numValue = random().nextInt(3);\n        } else {\n          numValue = random().nextInt(20);\n        }\n\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE) {\n            System.out.println(\"    write \" + (counters[stream]+j));\n          }\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random().nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"30fd30bfbfa6b9e036bcd99c8339712e965d4a63":["7b90dce9d2510a4adffa447c4dbb85717693b5c3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7b90dce9d2510a4adffa447c4dbb85717693b5c3":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","7b90dce9d2510a4adffa447c4dbb85717693b5c3"],"617d6d4150e0fb2acef8980ce51e3b8e628fb200":["30fd30bfbfa6b9e036bcd99c8339712e965d4a63"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","7b90dce9d2510a4adffa447c4dbb85717693b5c3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["617d6d4150e0fb2acef8980ce51e3b8e628fb200"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"30fd30bfbfa6b9e036bcd99c8339712e965d4a63":["617d6d4150e0fb2acef8980ce51e3b8e628fb200"],"7b90dce9d2510a4adffa447c4dbb85717693b5c3":["30fd30bfbfa6b9e036bcd99c8339712e965d4a63","d6f074e73200c07d54f242d3880a8da5a35ff97b","8fd5be977c105554c6a7b68afcdbc511439723ab"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["7b90dce9d2510a4adffa447c4dbb85717693b5c3","d6f074e73200c07d54f242d3880a8da5a35ff97b","8fd5be977c105554c6a7b68afcdbc511439723ab"],"617d6d4150e0fb2acef8980ce51e3b8e628fb200":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d6f074e73200c07d54f242d3880a8da5a35ff97b","8fd5be977c105554c6a7b68afcdbc511439723ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}