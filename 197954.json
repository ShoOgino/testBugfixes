{"path":"lucene/core/src/test/org/apache/lucene/index/TestStressDeletes#test().mjava","commits":[{"id":"ecade4f318b63bd4b3abda59935530a40a4aa7a2","date":1406817633,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestStressDeletes#test().mjava","pathOld":"/dev/null","sourceNew":"  /** Make sure that order of adds/deletes across threads is respected as\n   *  long as each ID is only changed by one thread at a time. */\n  public void test() throws Exception {\n    final int numIDs = atLeast(100);\n    final Object[] locks = new Object[numIDs];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    final IndexWriter w = new IndexWriter(dir, iwc);\n    final int iters = atLeast(2000);\n    final Map<Integer,Boolean> exists = new ConcurrentHashMap<>();\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 6)];\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int iter=0;iter<iters;iter++) {\n                int id = random().nextInt(numIDs);\n                synchronized (locks[id]) {\n                  Boolean v = exists.get(id);\n                  if (v == null || v.booleanValue() == false) {\n                    Document doc = new Document();\n                    doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n                    w.addDocument(doc);\n                    exists.put(id, true);\n                  } else {\n                    w.deleteDocuments(new Term(\"id\", \"\"+id));\n                    exists.put(id, false);\n                  }\n                }\n                if (random().nextInt(500) == 2) {\n                  DirectoryReader.open(w, random().nextBoolean()).close();\n                }\n                if (random().nextInt(500) == 2) {\n                  w.commit();\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r);\n    for(Map.Entry<Integer,Boolean> ent : exists.entrySet()) {\n      int id = ent.getKey();\n      TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n      if (ent.getValue()) {\n        assertEquals(1, hits.totalHits);\n      } else {\n        assertEquals(0, hits.totalHits);\n      }\n    }\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestStressDeletes#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestStressDeletes#test().mjava","sourceNew":"  /** Make sure that order of adds/deletes across threads is respected as\n   *  long as each ID is only changed by one thread at a time. */\n  public void test() throws Exception {\n    final int numIDs = atLeast(100);\n    final Object[] locks = new Object[numIDs];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    final IndexWriter w = new IndexWriter(dir, iwc);\n    final int iters = atLeast(2000);\n    final Map<Integer,Boolean> exists = new ConcurrentHashMap<>();\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 6)];\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int iter=0;iter<iters;iter++) {\n                int id = random().nextInt(numIDs);\n                synchronized (locks[id]) {\n                  Boolean v = exists.get(id);\n                  if (v == null || v.booleanValue() == false) {\n                    Document doc = new Document();\n                    doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n                    w.addDocument(doc);\n                    exists.put(id, true);\n                  } else {\n                    w.deleteDocuments(new Term(\"id\", \"\"+id));\n                    exists.put(id, false);\n                  }\n                }\n                if (random().nextInt(500) == 2) {\n                  DirectoryReader.open(w, random().nextBoolean()).close();\n                }\n                if (random().nextInt(500) == 2) {\n                  w.commit();\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r);\n    for(Map.Entry<Integer,Boolean> ent : exists.entrySet()) {\n      int id = ent.getKey();\n      TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n      if (ent.getValue()) {\n        assertEquals(1, hits.totalHits);\n      } else {\n        assertEquals(0, hits.totalHits);\n      }\n    }\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** Make sure that order of adds/deletes across threads is respected as\n   *  long as each ID is only changed by one thread at a time. */\n  public void test() throws Exception {\n    final int numIDs = atLeast(100);\n    final Object[] locks = new Object[numIDs];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    final IndexWriter w = new IndexWriter(dir, iwc);\n    final int iters = atLeast(2000);\n    final Map<Integer,Boolean> exists = new ConcurrentHashMap<>();\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 6)];\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int iter=0;iter<iters;iter++) {\n                int id = random().nextInt(numIDs);\n                synchronized (locks[id]) {\n                  Boolean v = exists.get(id);\n                  if (v == null || v.booleanValue() == false) {\n                    Document doc = new Document();\n                    doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n                    w.addDocument(doc);\n                    exists.put(id, true);\n                  } else {\n                    w.deleteDocuments(new Term(\"id\", \"\"+id));\n                    exists.put(id, false);\n                  }\n                }\n                if (random().nextInt(500) == 2) {\n                  DirectoryReader.open(w, random().nextBoolean()).close();\n                }\n                if (random().nextInt(500) == 2) {\n                  w.commit();\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r);\n    for(Map.Entry<Integer,Boolean> ent : exists.entrySet()) {\n      int id = ent.getKey();\n      TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n      if (ent.getValue()) {\n        assertEquals(1, hits.totalHits);\n      } else {\n        assertEquals(0, hits.totalHits);\n      }\n    }\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e4c214a1f904dde76f5611b56d4081533055b3b","date":1421938451,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestStressDeletes#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestStressDeletes#test().mjava","sourceNew":"  /** Make sure that order of adds/deletes across threads is respected as\n   *  long as each ID is only changed by one thread at a time. */\n  public void test() throws Exception {\n    final int numIDs = atLeast(100);\n    final Object[] locks = new Object[numIDs];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    final IndexWriter w = new IndexWriter(dir, iwc);\n    final int iters = atLeast(2000);\n    final Map<Integer,Boolean> exists = new ConcurrentHashMap<>();\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 6)];\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final int deleteMode = random().nextInt(3);\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int iter=0;iter<iters;iter++) {\n                int id = random().nextInt(numIDs);\n                synchronized (locks[id]) {\n                  Boolean v = exists.get(id);\n                  if (v == null || v.booleanValue() == false) {\n                    Document doc = new Document();\n                    doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n                    w.addDocument(doc);\n                    exists.put(id, true);\n                  } else {\n                    if (deleteMode == 0) {\n                      // Always delete by term\n                      w.deleteDocuments(new Term(\"id\", \"\"+id));\n                    } else if (deleteMode == 1) {\n                      // Always delete by query\n                      w.deleteDocuments(new TermQuery(new Term(\"id\", \"\"+id)));\n                    } else {\n                      // Mixed\n                      if (random().nextBoolean()) {\n                        w.deleteDocuments(new Term(\"id\", \"\"+id));\n                      } else {\n                        w.deleteDocuments(new TermQuery(new Term(\"id\", \"\"+id)));\n                      }\n                    }\n                    exists.put(id, false);\n                  }\n                }\n                if (random().nextInt(500) == 2) {\n                  DirectoryReader.open(w, random().nextBoolean()).close();\n                }\n                if (random().nextInt(500) == 2) {\n                  w.commit();\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r);\n    for(Map.Entry<Integer,Boolean> ent : exists.entrySet()) {\n      int id = ent.getKey();\n      TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n      if (ent.getValue()) {\n        assertEquals(1, hits.totalHits);\n      } else {\n        assertEquals(0, hits.totalHits);\n      }\n    }\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** Make sure that order of adds/deletes across threads is respected as\n   *  long as each ID is only changed by one thread at a time. */\n  public void test() throws Exception {\n    final int numIDs = atLeast(100);\n    final Object[] locks = new Object[numIDs];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    final IndexWriter w = new IndexWriter(dir, iwc);\n    final int iters = atLeast(2000);\n    final Map<Integer,Boolean> exists = new ConcurrentHashMap<>();\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 6)];\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int iter=0;iter<iters;iter++) {\n                int id = random().nextInt(numIDs);\n                synchronized (locks[id]) {\n                  Boolean v = exists.get(id);\n                  if (v == null || v.booleanValue() == false) {\n                    Document doc = new Document();\n                    doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n                    w.addDocument(doc);\n                    exists.put(id, true);\n                  } else {\n                    w.deleteDocuments(new Term(\"id\", \"\"+id));\n                    exists.put(id, false);\n                  }\n                }\n                if (random().nextInt(500) == 2) {\n                  DirectoryReader.open(w, random().nextBoolean()).close();\n                }\n                if (random().nextInt(500) == 2) {\n                  w.commit();\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r);\n    for(Map.Entry<Integer,Boolean> ent : exists.entrySet()) {\n      int id = ent.getKey();\n      TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n      if (ent.getValue()) {\n        assertEquals(1, hits.totalHits);\n      } else {\n        assertEquals(0, hits.totalHits);\n      }\n    }\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":["ecade4f318b63bd4b3abda59935530a40a4aa7a2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestStressDeletes#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestStressDeletes#test().mjava","sourceNew":"  /** Make sure that order of adds/deletes across threads is respected as\n   *  long as each ID is only changed by one thread at a time. */\n  public void test() throws Exception {\n    final int numIDs = atLeast(100);\n    final Object[] locks = new Object[numIDs];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    final IndexWriter w = new IndexWriter(dir, iwc);\n    final int iters = atLeast(2000);\n    final Map<Integer,Boolean> exists = new ConcurrentHashMap<>();\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 6)];\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final int deleteMode = random().nextInt(3);\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int iter=0;iter<iters;iter++) {\n                int id = random().nextInt(numIDs);\n                synchronized (locks[id]) {\n                  Boolean v = exists.get(id);\n                  if (v == null || v.booleanValue() == false) {\n                    Document doc = new Document();\n                    doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n                    w.addDocument(doc);\n                    exists.put(id, true);\n                  } else {\n                    if (deleteMode == 0) {\n                      // Always delete by term\n                      w.deleteDocuments(new Term(\"id\", \"\"+id));\n                    } else if (deleteMode == 1) {\n                      // Always delete by query\n                      w.deleteDocuments(new TermQuery(new Term(\"id\", \"\"+id)));\n                    } else {\n                      // Mixed\n                      if (random().nextBoolean()) {\n                        w.deleteDocuments(new Term(\"id\", \"\"+id));\n                      } else {\n                        w.deleteDocuments(new TermQuery(new Term(\"id\", \"\"+id)));\n                      }\n                    }\n                    exists.put(id, false);\n                  }\n                }\n                if (random().nextInt(500) == 2) {\n                  DirectoryReader.open(w, random().nextBoolean(), false).close();\n                }\n                if (random().nextInt(500) == 2) {\n                  w.commit();\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r);\n    for(Map.Entry<Integer,Boolean> ent : exists.entrySet()) {\n      int id = ent.getKey();\n      TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n      if (ent.getValue()) {\n        assertEquals(1, hits.totalHits);\n      } else {\n        assertEquals(0, hits.totalHits);\n      }\n    }\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** Make sure that order of adds/deletes across threads is respected as\n   *  long as each ID is only changed by one thread at a time. */\n  public void test() throws Exception {\n    final int numIDs = atLeast(100);\n    final Object[] locks = new Object[numIDs];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    final IndexWriter w = new IndexWriter(dir, iwc);\n    final int iters = atLeast(2000);\n    final Map<Integer,Boolean> exists = new ConcurrentHashMap<>();\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 6)];\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final int deleteMode = random().nextInt(3);\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int iter=0;iter<iters;iter++) {\n                int id = random().nextInt(numIDs);\n                synchronized (locks[id]) {\n                  Boolean v = exists.get(id);\n                  if (v == null || v.booleanValue() == false) {\n                    Document doc = new Document();\n                    doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n                    w.addDocument(doc);\n                    exists.put(id, true);\n                  } else {\n                    if (deleteMode == 0) {\n                      // Always delete by term\n                      w.deleteDocuments(new Term(\"id\", \"\"+id));\n                    } else if (deleteMode == 1) {\n                      // Always delete by query\n                      w.deleteDocuments(new TermQuery(new Term(\"id\", \"\"+id)));\n                    } else {\n                      // Mixed\n                      if (random().nextBoolean()) {\n                        w.deleteDocuments(new Term(\"id\", \"\"+id));\n                      } else {\n                        w.deleteDocuments(new TermQuery(new Term(\"id\", \"\"+id)));\n                      }\n                    }\n                    exists.put(id, false);\n                  }\n                }\n                if (random().nextInt(500) == 2) {\n                  DirectoryReader.open(w, random().nextBoolean()).close();\n                }\n                if (random().nextInt(500) == 2) {\n                  w.commit();\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r);\n    for(Map.Entry<Integer,Boolean> ent : exists.entrySet()) {\n      int id = ent.getKey();\n      TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n      if (ent.getValue()) {\n        assertEquals(1, hits.totalHits);\n      } else {\n        assertEquals(0, hits.totalHits);\n      }\n    }\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestStressDeletes#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestStressDeletes#test().mjava","sourceNew":"  /** Make sure that order of adds/deletes across threads is respected as\n   *  long as each ID is only changed by one thread at a time. */\n  public void test() throws Exception {\n    final int numIDs = atLeast(100);\n    final Object[] locks = new Object[numIDs];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    final IndexWriter w = new IndexWriter(dir, iwc);\n    final int iters = atLeast(2000);\n    final Map<Integer,Boolean> exists = new ConcurrentHashMap<>();\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 6)];\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final int deleteMode = random().nextInt(3);\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int iter=0;iter<iters;iter++) {\n                int id = random().nextInt(numIDs);\n                synchronized (locks[id]) {\n                  Boolean v = exists.get(id);\n                  if (v == null || v.booleanValue() == false) {\n                    Document doc = new Document();\n                    doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n                    w.addDocument(doc);\n                    exists.put(id, true);\n                  } else {\n                    if (deleteMode == 0) {\n                      // Always delete by term\n                      w.deleteDocuments(new Term(\"id\", \"\"+id));\n                    } else if (deleteMode == 1) {\n                      // Always delete by query\n                      w.deleteDocuments(new TermQuery(new Term(\"id\", \"\"+id)));\n                    } else {\n                      // Mixed\n                      if (random().nextBoolean()) {\n                        w.deleteDocuments(new Term(\"id\", \"\"+id));\n                      } else {\n                        w.deleteDocuments(new TermQuery(new Term(\"id\", \"\"+id)));\n                      }\n                    }\n                    exists.put(id, false);\n                  }\n                }\n                if (random().nextInt(500) == 2) {\n                  DirectoryReader.open(w, random().nextBoolean(), false).close();\n                }\n                if (random().nextInt(500) == 2) {\n                  w.commit();\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r);\n    for(Map.Entry<Integer,Boolean> ent : exists.entrySet()) {\n      int id = ent.getKey();\n      TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n      if (ent.getValue()) {\n        assertEquals(1, hits.totalHits);\n      } else {\n        assertEquals(0, hits.totalHits);\n      }\n    }\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** Make sure that order of adds/deletes across threads is respected as\n   *  long as each ID is only changed by one thread at a time. */\n  public void test() throws Exception {\n    final int numIDs = atLeast(100);\n    final Object[] locks = new Object[numIDs];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    final IndexWriter w = new IndexWriter(dir, iwc);\n    final int iters = atLeast(2000);\n    final Map<Integer,Boolean> exists = new ConcurrentHashMap<>();\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 6)];\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final int deleteMode = random().nextInt(3);\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int iter=0;iter<iters;iter++) {\n                int id = random().nextInt(numIDs);\n                synchronized (locks[id]) {\n                  Boolean v = exists.get(id);\n                  if (v == null || v.booleanValue() == false) {\n                    Document doc = new Document();\n                    doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n                    w.addDocument(doc);\n                    exists.put(id, true);\n                  } else {\n                    if (deleteMode == 0) {\n                      // Always delete by term\n                      w.deleteDocuments(new Term(\"id\", \"\"+id));\n                    } else if (deleteMode == 1) {\n                      // Always delete by query\n                      w.deleteDocuments(new TermQuery(new Term(\"id\", \"\"+id)));\n                    } else {\n                      // Mixed\n                      if (random().nextBoolean()) {\n                        w.deleteDocuments(new Term(\"id\", \"\"+id));\n                      } else {\n                        w.deleteDocuments(new TermQuery(new Term(\"id\", \"\"+id)));\n                      }\n                    }\n                    exists.put(id, false);\n                  }\n                }\n                if (random().nextInt(500) == 2) {\n                  DirectoryReader.open(w, random().nextBoolean()).close();\n                }\n                if (random().nextInt(500) == 2) {\n                  w.commit();\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r);\n    for(Map.Entry<Integer,Boolean> ent : exists.entrySet()) {\n      int id = ent.getKey();\n      TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n      if (ent.getValue()) {\n        assertEquals(1, hits.totalHits);\n      } else {\n        assertEquals(0, hits.totalHits);\n      }\n    }\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestStressDeletes#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestStressDeletes#test().mjava","sourceNew":"  /** Make sure that order of adds/deletes across threads is respected as\n   *  long as each ID is only changed by one thread at a time. */\n  public void test() throws Exception {\n    final int numIDs = atLeast(100);\n    final Object[] locks = new Object[numIDs];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    final IndexWriter w = new IndexWriter(dir, iwc);\n    final int iters = atLeast(2000);\n    final Map<Integer,Boolean> exists = new ConcurrentHashMap<>();\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 6)];\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final int deleteMode = random().nextInt(3);\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int iter=0;iter<iters;iter++) {\n                int id = random().nextInt(numIDs);\n                synchronized (locks[id]) {\n                  Boolean v = exists.get(id);\n                  if (v == null || v.booleanValue() == false) {\n                    Document doc = new Document();\n                    doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n                    w.addDocument(doc);\n                    exists.put(id, true);\n                  } else {\n                    if (deleteMode == 0) {\n                      // Always delete by term\n                      w.deleteDocuments(new Term(\"id\", \"\"+id));\n                    } else if (deleteMode == 1) {\n                      // Always delete by query\n                      w.deleteDocuments(new TermQuery(new Term(\"id\", \"\"+id)));\n                    } else {\n                      // Mixed\n                      if (random().nextBoolean()) {\n                        w.deleteDocuments(new Term(\"id\", \"\"+id));\n                      } else {\n                        w.deleteDocuments(new TermQuery(new Term(\"id\", \"\"+id)));\n                      }\n                    }\n                    exists.put(id, false);\n                  }\n                }\n                if (random().nextInt(500) == 2) {\n                  DirectoryReader.open(w, random().nextBoolean(), false).close();\n                }\n                if (random().nextInt(500) == 2) {\n                  w.commit();\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r);\n    for(Map.Entry<Integer,Boolean> ent : exists.entrySet()) {\n      int id = ent.getKey();\n      TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n      if (ent.getValue()) {\n        assertEquals(1, hits.totalHits.value);\n      } else {\n        assertEquals(0, hits.totalHits.value);\n      }\n    }\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** Make sure that order of adds/deletes across threads is respected as\n   *  long as each ID is only changed by one thread at a time. */\n  public void test() throws Exception {\n    final int numIDs = atLeast(100);\n    final Object[] locks = new Object[numIDs];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    final IndexWriter w = new IndexWriter(dir, iwc);\n    final int iters = atLeast(2000);\n    final Map<Integer,Boolean> exists = new ConcurrentHashMap<>();\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 6)];\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final int deleteMode = random().nextInt(3);\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int iter=0;iter<iters;iter++) {\n                int id = random().nextInt(numIDs);\n                synchronized (locks[id]) {\n                  Boolean v = exists.get(id);\n                  if (v == null || v.booleanValue() == false) {\n                    Document doc = new Document();\n                    doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n                    w.addDocument(doc);\n                    exists.put(id, true);\n                  } else {\n                    if (deleteMode == 0) {\n                      // Always delete by term\n                      w.deleteDocuments(new Term(\"id\", \"\"+id));\n                    } else if (deleteMode == 1) {\n                      // Always delete by query\n                      w.deleteDocuments(new TermQuery(new Term(\"id\", \"\"+id)));\n                    } else {\n                      // Mixed\n                      if (random().nextBoolean()) {\n                        w.deleteDocuments(new Term(\"id\", \"\"+id));\n                      } else {\n                        w.deleteDocuments(new TermQuery(new Term(\"id\", \"\"+id)));\n                      }\n                    }\n                    exists.put(id, false);\n                  }\n                }\n                if (random().nextInt(500) == 2) {\n                  DirectoryReader.open(w, random().nextBoolean(), false).close();\n                }\n                if (random().nextInt(500) == 2) {\n                  w.commit();\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r);\n    for(Map.Entry<Integer,Boolean> ent : exists.entrySet()) {\n      int id = ent.getKey();\n      TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n      if (ent.getValue()) {\n        assertEquals(1, hits.totalHits);\n      } else {\n        assertEquals(0, hits.totalHits);\n      }\n    }\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["ecade4f318b63bd4b3abda59935530a40a4aa7a2"],"7e4c214a1f904dde76f5611b56d4081533055b3b":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"68496c2200e559fb7802f7575427b7a482659afb":["7e4c214a1f904dde76f5611b56d4081533055b3b","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["68496c2200e559fb7802f7575427b7a482659afb"],"ecade4f318b63bd4b3abda59935530a40a4aa7a2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["7e4c214a1f904dde76f5611b56d4081533055b3b"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ecade4f318b63bd4b3abda59935530a40a4aa7a2"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"7e4c214a1f904dde76f5611b56d4081533055b3b":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"68496c2200e559fb7802f7575427b7a482659afb":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ecade4f318b63bd4b3abda59935530a40a4aa7a2":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}