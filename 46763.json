{"path":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain.TermFacet#toJSONFacetParamValue().mjava","commits":[{"id":"b1b26212116cd764dfc34c7f93ecaa718ec27ef3","date":1493832602,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain.TermFacet#toJSONFacetParamValue().mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * recursively generates the <code>json.facet</code> param value to use for testing this facet\n     */\n    private CharSequence toJSONFacetParamValue() {\n      // NOTE: since refinement isn't supported, we have to use the max cardinality of the field as limit\n      StringBuilder sb = new StringBuilder(\"{ type:terms, field:\" + field + \", limit: \" + FACET_LIMIT);\n      if (! subFacets.isEmpty()) {\n        sb.append(\", facet:\");\n        sb.append(toJSONFacetParamValue(subFacets));\n      }\n      if (null != domain) {\n        CharSequence ds = domain.toJSONFacetParamValue();\n        if (null != ds) {\n          sb.append(\", \").append(ds);\n        }\n      }\n      sb.append(\"}\");\n      return sb;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain.TermFacet#toJSONFacetParamValue().mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * recursively generates the <code>json.facet</code> param value to use for testing this facet\n     */\n    private CharSequence toJSONFacetParamValue() {\n      // NOTE: since refinement isn't supported, we have to use the max cardinality of the field as limit\n      StringBuilder sb = new StringBuilder(\"{ type:terms, field:\" + field + \", limit: \" + FACET_LIMIT);\n      if (! subFacets.isEmpty()) {\n        sb.append(\", facet:\");\n        sb.append(toJSONFacetParamValue(subFacets));\n      }\n      if (null != domain) {\n        CharSequence ds = domain.toJSONFacetParamValue();\n        if (null != ds) {\n          sb.append(\", \").append(ds);\n        }\n      }\n      sb.append(\"}\");\n      return sb;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"494cdc6d3b60067f83082f0c19e18dc33dc2b375","date":1505902929,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain.TermFacet#toJSONFacetParamValue().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain.TermFacet#toJSONFacetParamValue().mjava","sourceNew":"    /**\n     * recursively generates the <code>json.facet</code> param value to use for testing this facet\n     */\n    private CharSequence toJSONFacetParamValue() {\n      int limit = random().nextInt(FACET_LIMIT*2);\n      String limitStr = \", limit:\" + limit;\n      if (limit >= FACET_LIMIT && random().nextBoolean()) {\n        limitStr = \", limit:-1\"; // unlimited\n      } else if (limit == 10 && random().nextBoolean()) {\n        limitStr=\"\"; // don't specify limit since it's the default\n      }\n\n      int overrequest = -1;\n      switch(random().nextInt(10)) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n          overrequest = 0; // 40% of the time, no overrequest to better stress refinement\n          break;\n        case 4:\n        case 5:\n          overrequest = random().nextInt(FACET_LIMIT);\n          break;\n        case 6:\n          overrequest = random().nextInt(Integer.MAX_VALUE);\n          break;\n        default: break;\n      }\n      String overrequestStr = overrequest==-1 ? \"\" : \", overrequest:\"+overrequest;\n\n      boolean refine = (overrequest >= 0 && (long)limit + overrequest < FACET_LIMIT)\n          || (overrequest < 0 && limit < FACET_LIMIT) // don't assume how much overrequest we do by default, just check the limit\n          || random().nextInt(10)==0; // once in a while, turn on refinement even when it isn't needed.\n\n      // refine = false; // NOTE: Uncomment this line to see if refinement testing is adequate (should get fails occasionally)\n      String refineStr=\", refine:\" + refine;\n      if (!refine) {\n        // if refine==false, don't specify it sometimes (it's the default)\n        if (random().nextBoolean()) refineStr=\"\";\n      }\n\n      StringBuilder sb = new StringBuilder(\"{ type:terms, field:\" + field + limitStr + overrequestStr + refineStr);\n      if (! subFacets.isEmpty()) {\n        sb.append(\", facet:\");\n        sb.append(toJSONFacetParamValue(subFacets));\n      }\n      if (null != domain) {\n        CharSequence ds = domain.toJSONFacetParamValue();\n        if (null != ds) {\n          sb.append(\", \").append(ds);\n        }\n      }\n      sb.append(\"}\");\n      return sb;\n    }\n\n","sourceOld":"    /**\n     * recursively generates the <code>json.facet</code> param value to use for testing this facet\n     */\n    private CharSequence toJSONFacetParamValue() {\n      // NOTE: since refinement isn't supported, we have to use the max cardinality of the field as limit\n      StringBuilder sb = new StringBuilder(\"{ type:terms, field:\" + field + \", limit: \" + FACET_LIMIT);\n      if (! subFacets.isEmpty()) {\n        sb.append(\", facet:\");\n        sb.append(toJSONFacetParamValue(subFacets));\n      }\n      if (null != domain) {\n        CharSequence ds = domain.toJSONFacetParamValue();\n        if (null != ds) {\n          sb.append(\", \").append(ds);\n        }\n      }\n      sb.append(\"}\");\n      return sb;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain.TermFacet#toJSONFacetParamValue().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain.TermFacet#toJSONFacetParamValue().mjava","sourceNew":"    /**\n     * recursively generates the <code>json.facet</code> param value to use for testing this facet\n     */\n    private CharSequence toJSONFacetParamValue() {\n      int limit = random().nextInt(FACET_LIMIT*2);\n      String limitStr = \", limit:\" + limit;\n      if (limit >= FACET_LIMIT && random().nextBoolean()) {\n        limitStr = \", limit:-1\"; // unlimited\n      } else if (limit == 10 && random().nextBoolean()) {\n        limitStr=\"\"; // don't specify limit since it's the default\n      }\n\n      int overrequest = -1;\n      switch(random().nextInt(10)) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n          overrequest = 0; // 40% of the time, no overrequest to better stress refinement\n          break;\n        case 4:\n        case 5:\n          overrequest = random().nextInt(FACET_LIMIT);\n          break;\n        case 6:\n          overrequest = random().nextInt(Integer.MAX_VALUE);\n          break;\n        default: break;\n      }\n      String overrequestStr = overrequest==-1 ? \"\" : \", overrequest:\"+overrequest;\n\n      boolean refine = (overrequest >= 0 && (long)limit + overrequest < FACET_LIMIT)\n          || (overrequest < 0 && limit < FACET_LIMIT) // don't assume how much overrequest we do by default, just check the limit\n          || random().nextInt(10)==0; // once in a while, turn on refinement even when it isn't needed.\n\n      // refine = false; // NOTE: Uncomment this line to see if refinement testing is adequate (should get fails occasionally)\n      String refineStr=\", refine:\" + refine;\n      if (!refine) {\n        // if refine==false, don't specify it sometimes (it's the default)\n        if (random().nextBoolean()) refineStr=\"\";\n      }\n\n      StringBuilder sb = new StringBuilder(\"{ type:terms, field:\" + field + limitStr + overrequestStr + refineStr);\n      if (! subFacets.isEmpty()) {\n        sb.append(\", facet:\");\n        sb.append(toJSONFacetParamValue(subFacets));\n      }\n      if (null != domain) {\n        CharSequence ds = domain.toJSONFacetParamValue();\n        if (null != ds) {\n          sb.append(\", \").append(ds);\n        }\n      }\n      sb.append(\"}\");\n      return sb;\n    }\n\n","sourceOld":"    /**\n     * recursively generates the <code>json.facet</code> param value to use for testing this facet\n     */\n    private CharSequence toJSONFacetParamValue() {\n      // NOTE: since refinement isn't supported, we have to use the max cardinality of the field as limit\n      StringBuilder sb = new StringBuilder(\"{ type:terms, field:\" + field + \", limit: \" + FACET_LIMIT);\n      if (! subFacets.isEmpty()) {\n        sb.append(\", facet:\");\n        sb.append(toJSONFacetParamValue(subFacets));\n      }\n      if (null != domain) {\n        CharSequence ds = domain.toJSONFacetParamValue();\n        if (null != ds) {\n          sb.append(\", \").append(ds);\n        }\n      }\n      sb.append(\"}\");\n      return sb;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"20e27469285c87fe39ba0fcaf9c290f18bb0f1cf","date":1507135648,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain.TermFacet#toJSONFacetParamValue().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain.TermFacet#toJSONFacetParamValue().mjava","sourceNew":"    /**\n     * recursively generates the <code>json.facet</code> param value to use for testing this facet\n     */\n    private CharSequence toJSONFacetParamValue() {\n      final String limitStr = (null == limit) ? \"\" : (\", limit:\" + limit);\n      final String overrequestStr = (null == overrequest) ? \"\" : (\", overrequest:\" + overrequest);\n      final String refineStr = (null == refine) ? \"\" : \", refine:\" + refine;\n      final StringBuilder sb = new StringBuilder(\"{ type:terms, field:\" + field + limitStr + overrequestStr + refineStr);\n      if (! subFacets.isEmpty()) {\n        sb.append(\", facet:\");\n        sb.append(toJSONFacetParamValue(subFacets));\n      }\n      if (null != domain) {\n        CharSequence ds = domain.toJSONFacetParamValue();\n        if (null != ds) {\n          sb.append(\", \").append(ds);\n        }\n      }\n      sb.append(\"}\");\n      return sb;\n    }\n\n","sourceOld":"    /**\n     * recursively generates the <code>json.facet</code> param value to use for testing this facet\n     */\n    private CharSequence toJSONFacetParamValue() {\n      int limit = random().nextInt(FACET_LIMIT*2);\n      String limitStr = \", limit:\" + limit;\n      if (limit >= FACET_LIMIT && random().nextBoolean()) {\n        limitStr = \", limit:-1\"; // unlimited\n      } else if (limit == 10 && random().nextBoolean()) {\n        limitStr=\"\"; // don't specify limit since it's the default\n      }\n\n      int overrequest = -1;\n      switch(random().nextInt(10)) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n          overrequest = 0; // 40% of the time, no overrequest to better stress refinement\n          break;\n        case 4:\n        case 5:\n          overrequest = random().nextInt(FACET_LIMIT);\n          break;\n        case 6:\n          overrequest = random().nextInt(Integer.MAX_VALUE);\n          break;\n        default: break;\n      }\n      String overrequestStr = overrequest==-1 ? \"\" : \", overrequest:\"+overrequest;\n\n      boolean refine = (overrequest >= 0 && (long)limit + overrequest < FACET_LIMIT)\n          || (overrequest < 0 && limit < FACET_LIMIT) // don't assume how much overrequest we do by default, just check the limit\n          || random().nextInt(10)==0; // once in a while, turn on refinement even when it isn't needed.\n\n      // refine = false; // NOTE: Uncomment this line to see if refinement testing is adequate (should get fails occasionally)\n      String refineStr=\", refine:\" + refine;\n      if (!refine) {\n        // if refine==false, don't specify it sometimes (it's the default)\n        if (random().nextBoolean()) refineStr=\"\";\n      }\n\n      StringBuilder sb = new StringBuilder(\"{ type:terms, field:\" + field + limitStr + overrequestStr + refineStr);\n      if (! subFacets.isEmpty()) {\n        sb.append(\", facet:\");\n        sb.append(toJSONFacetParamValue(subFacets));\n      }\n      if (null != domain) {\n        CharSequence ds = domain.toJSONFacetParamValue();\n        if (null != ds) {\n          sb.append(\", \").append(ds);\n        }\n      }\n      sb.append(\"}\");\n      return sb;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d7859b8e6a469429413db808a609e8468be14c03","date":1507222263,"type":3,"author":"tballison","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain.TermFacet#toJSONFacetParamValue().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain.TermFacet#toJSONFacetParamValue().mjava","sourceNew":"    /**\n     * recursively generates the <code>json.facet</code> param value to use for testing this facet\n     */\n    private CharSequence toJSONFacetParamValue() {\n      final String limitStr = (null == limit) ? \"\" : (\", limit:\" + limit);\n      final String overrequestStr = (null == overrequest) ? \"\" : (\", overrequest:\" + overrequest);\n      final String refineStr = (null == refine) ? \"\" : \", refine:\" + refine;\n      final StringBuilder sb = new StringBuilder(\"{ type:terms, field:\" + field + limitStr + overrequestStr + refineStr);\n      if (! subFacets.isEmpty()) {\n        sb.append(\", facet:\");\n        sb.append(toJSONFacetParamValue(subFacets));\n      }\n      if (null != domain) {\n        CharSequence ds = domain.toJSONFacetParamValue();\n        if (null != ds) {\n          sb.append(\", \").append(ds);\n        }\n      }\n      sb.append(\"}\");\n      return sb;\n    }\n\n","sourceOld":"    /**\n     * recursively generates the <code>json.facet</code> param value to use for testing this facet\n     */\n    private CharSequence toJSONFacetParamValue() {\n      int limit = random().nextInt(FACET_LIMIT*2);\n      String limitStr = \", limit:\" + limit;\n      if (limit >= FACET_LIMIT && random().nextBoolean()) {\n        limitStr = \", limit:-1\"; // unlimited\n      } else if (limit == 10 && random().nextBoolean()) {\n        limitStr=\"\"; // don't specify limit since it's the default\n      }\n\n      int overrequest = -1;\n      switch(random().nextInt(10)) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n          overrequest = 0; // 40% of the time, no overrequest to better stress refinement\n          break;\n        case 4:\n        case 5:\n          overrequest = random().nextInt(FACET_LIMIT);\n          break;\n        case 6:\n          overrequest = random().nextInt(Integer.MAX_VALUE);\n          break;\n        default: break;\n      }\n      String overrequestStr = overrequest==-1 ? \"\" : \", overrequest:\"+overrequest;\n\n      boolean refine = (overrequest >= 0 && (long)limit + overrequest < FACET_LIMIT)\n          || (overrequest < 0 && limit < FACET_LIMIT) // don't assume how much overrequest we do by default, just check the limit\n          || random().nextInt(10)==0; // once in a while, turn on refinement even when it isn't needed.\n\n      // refine = false; // NOTE: Uncomment this line to see if refinement testing is adequate (should get fails occasionally)\n      String refineStr=\", refine:\" + refine;\n      if (!refine) {\n        // if refine==false, don't specify it sometimes (it's the default)\n        if (random().nextBoolean()) refineStr=\"\";\n      }\n\n      StringBuilder sb = new StringBuilder(\"{ type:terms, field:\" + field + limitStr + overrequestStr + refineStr);\n      if (! subFacets.isEmpty()) {\n        sb.append(\", facet:\");\n        sb.append(toJSONFacetParamValue(subFacets));\n      }\n      if (null != domain) {\n        CharSequence ds = domain.toJSONFacetParamValue();\n        if (null != ds) {\n          sb.append(\", \").append(ds);\n        }\n      }\n      sb.append(\"}\");\n      return sb;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92910727264a23a47b7a6c94b0f75d655537b9ea","date":1540414655,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetJoinDomain.TermFacet#toJSONFacetParamValue().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain.TermFacet#toJSONFacetParamValue().mjava","sourceNew":"    /**\n     * recursively generates the <code>json.facet</code> param value to use for testing this facet\n     */\n    private CharSequence toJSONFacetParamValue() {\n      final String limitStr = (null == limit) ? \"\" : (\", limit:\" + limit);\n      final String overrequestStr = (null == overrequest) ? \"\" : (\", overrequest:\" + overrequest);\n      final String refineStr = (null == refine) ? \"\" : \", refine:\" + refine;\n      final StringBuilder sb = new StringBuilder(\"{ type:terms, field:\" + field + limitStr + overrequestStr + refineStr);\n      if (! subFacets.isEmpty()) {\n        sb.append(\", facet:\");\n        sb.append(toJSONFacetParamValue(subFacets));\n      }\n      if (null != domain) {\n        CharSequence ds = domain.toJSONFacetParamValue();\n        if (null != ds) {\n          sb.append(\", \").append(ds);\n        }\n      }\n      sb.append(\"}\");\n      return sb;\n    }\n\n","sourceOld":"    /**\n     * recursively generates the <code>json.facet</code> param value to use for testing this facet\n     */\n    private CharSequence toJSONFacetParamValue() {\n      final String limitStr = (null == limit) ? \"\" : (\", limit:\" + limit);\n      final String overrequestStr = (null == overrequest) ? \"\" : (\", overrequest:\" + overrequest);\n      final String refineStr = (null == refine) ? \"\" : \", refine:\" + refine;\n      final StringBuilder sb = new StringBuilder(\"{ type:terms, field:\" + field + limitStr + overrequestStr + refineStr);\n      if (! subFacets.isEmpty()) {\n        sb.append(\", facet:\");\n        sb.append(toJSONFacetParamValue(subFacets));\n      }\n      if (null != domain) {\n        CharSequence ds = domain.toJSONFacetParamValue();\n        if (null != ds) {\n          sb.append(\", \").append(ds);\n        }\n      }\n      sb.append(\"}\");\n      return sb;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b1b26212116cd764dfc34c7f93ecaa718ec27ef3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b1b26212116cd764dfc34c7f93ecaa718ec27ef3"],"494cdc6d3b60067f83082f0c19e18dc33dc2b375":["b1b26212116cd764dfc34c7f93ecaa718ec27ef3"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["e9017cf144952056066919f1ebc7897ff9bd71b1","494cdc6d3b60067f83082f0c19e18dc33dc2b375"],"d7859b8e6a469429413db808a609e8468be14c03":["494cdc6d3b60067f83082f0c19e18dc33dc2b375","20e27469285c87fe39ba0fcaf9c290f18bb0f1cf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"92910727264a23a47b7a6c94b0f75d655537b9ea":["20e27469285c87fe39ba0fcaf9c290f18bb0f1cf"],"20e27469285c87fe39ba0fcaf9c290f18bb0f1cf":["494cdc6d3b60067f83082f0c19e18dc33dc2b375"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["92910727264a23a47b7a6c94b0f75d655537b9ea"]},"commit2Childs":{"b1b26212116cd764dfc34c7f93ecaa718ec27ef3":["e9017cf144952056066919f1ebc7897ff9bd71b1","494cdc6d3b60067f83082f0c19e18dc33dc2b375"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["6240b74b884c5587f2a4062dd27d6c32bf228889"],"494cdc6d3b60067f83082f0c19e18dc33dc2b375":["6240b74b884c5587f2a4062dd27d6c32bf228889","d7859b8e6a469429413db808a609e8468be14c03","20e27469285c87fe39ba0fcaf9c290f18bb0f1cf"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"d7859b8e6a469429413db808a609e8468be14c03":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b1b26212116cd764dfc34c7f93ecaa718ec27ef3","e9017cf144952056066919f1ebc7897ff9bd71b1"],"92910727264a23a47b7a6c94b0f75d655537b9ea":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"20e27469285c87fe39ba0fcaf9c290f18bb0f1cf":["d7859b8e6a469429413db808a609e8468be14c03","92910727264a23a47b7a6c94b0f75d655537b9ea"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6240b74b884c5587f2a4062dd27d6c32bf228889","d7859b8e6a469429413db808a609e8468be14c03","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}