{"path":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = null;\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDir = getNewIndexDir();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        IndexReader newReader;\n        IndexReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = IndexReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e0bbfc7e96e0cf26b51dcefe3b2e4c93fe34e8c0","058801f8673d53a5abac8088204860ec29a40f0d","96e0d4494fe54b31c7f0151f3a632124ab806351","d0ce568448269aad19a317e537eefc0993934c9d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = null;\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDir = getNewIndexDir();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        IndexReader newReader;\n        IndexReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = IndexReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = null;\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDir = getNewIndexDir();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        IndexReader newReader;\n        IndexReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = IndexReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"106138013e106211a65b050fa67f96ed95384f07","date":1327636191,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        IndexReader newReader;\n        IndexReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = IndexReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = null;\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDir = getNewIndexDir();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        IndexReader newReader;\n        IndexReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = IndexReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"78a55f24d9b493c2a1cecf79f1d78279062b545b","date":1327688152,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        IndexReader newReader;\n        IndexReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = IndexReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = null;\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDir = getNewIndexDir();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        IndexReader newReader;\n        IndexReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = IndexReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        IndexReader newReader;\n        IndexReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = IndexReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = null;\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDir = getNewIndexDir();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        IndexReader newReader;\n        IndexReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = IndexReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96d207426bd26fa5c1014e26d21d87603aea68b7","date":1327944562,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = DirectoryReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        IndexReader newReader;\n        IndexReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = IndexReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = DirectoryReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        IndexReader newReader;\n        IndexReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = IndexReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a5469a71486c4c1e313c7fcb08188d7111195c2","date":1333407337,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = DirectoryReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = DirectoryReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08bcaef9e931052e4ca24133a89cc6aefaf61829","date":1342469326,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = DirectoryReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = DirectoryReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9767265f21f7d1246b13dd7e73e8a4ad88b4384","date":1342986300,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["d0ce568448269aad19a317e537eefc0993934c9d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          newReader = DirectoryReader.openIfChanged(currentReader, writer, true);\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6d3fca4763c45f22581927b942c808dbb2e2aec","date":1347304121,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method aquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n     \n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n     \n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = null;\n      File newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = new File(getIndexDir()).getCanonicalFile();\n        newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ce568448269aad19a317e537eefc0993934c9d","date":1361139215,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n     \n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n     \n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"bugIntro":["a114c79cee12feb72f81641925268f6e3e4f051e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09c8567c25c02eeeb3e719841606a1269f3538ca","date":1361155063,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n     \n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n     \n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a837c064b67fa63a9394136e31218b908cdcf783","date":1362186072,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n     \n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n     \n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a114c79cee12feb72f81641925268f6e3e4f051e","date":1364002322,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n     \n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n     \n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, schema, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":["d0ce568448269aad19a317e537eefc0993934c9d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"058801f8673d53a5abac8088204860ec29a40f0d","date":1364178882,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            newReader = DirectoryReader.openIfChanged(currentReader,\n                writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            \n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        if (updateHandlerReopens) {\n          // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          try {\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } finally {\n            writer.decref();\n          }\n\n        } else {\n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = DirectoryReader.openIfChanged(currentReader);\n     \n          // verbose(\"reopen result\", newReader);\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","d9405f486872f1e416304dfe389741f4ee2f8a4d","96d207426bd26fa5c1014e26d21d87603aea68b7","08bcaef9e931052e4ca24133a89cc6aefaf61829"],"bugIntro":["4bf9a95dde95952e0577d294ba4f9ab6b3d3343e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            newReader = DirectoryReader.openIfChanged(currentReader,\n                writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            \n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n            (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            newReader = DirectoryReader.openIfChanged(currentReader,\n                writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            \n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().indexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6ab99a2487a34179af579c58aee0f6954a54173b","date":1370025444,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            newReader = DirectoryReader.openIfChanged(currentReader,\n                writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            \n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n            (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            newReader = DirectoryReader.openIfChanged(currentReader,\n                writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            \n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n            (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["96e0d4494fe54b31c7f0151f3a632124ab806351"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"65974810aff303cdaecff3dd789ae9353c1d9134","date":1376496589,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            newReader = DirectoryReader.openIfChanged(currentReader,\n                writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            \n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n            (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.reopenReaders) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            newReader = DirectoryReader.openIfChanged(currentReader,\n                writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            \n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n            (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["4bf9a95dde95952e0577d294ba4f9ab6b3d3343e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            newReader = DirectoryReader.openIfChanged(currentReader,\n                writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            \n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n            (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.reopenReaders) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            newReader = DirectoryReader.openIfChanged(currentReader,\n                writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            \n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n            (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9f81a0a8d08cc36757b7be45a8c8dcd66ff0360","date":1378833548,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n            (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && solrConfig.reopenReaders\n          && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            newReader = DirectoryReader.openIfChanged(currentReader,\n                writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            \n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n            (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.reopenReaders) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"beea4d4bbebcfb6689ed31936553c5e98bce2871","date":1393882670,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n                                    getSolrConfig().indexConfig, newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) {\n          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.\n          if (realtime) {\n            newestSearcher.incref();\n            return newestSearcher;\n          }\n\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n            (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab499d210c848577f67d42fc12866e1e95273ebe","date":1394719295,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n                                    getSolrConfig().indexConfig, newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n                                    getSolrConfig().indexConfig, newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30b6ad849a21206db510322a3f583ca70ae20a2f","date":1399996150,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n                                    getSolrConfig().indexConfig, newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n                                    getSolrConfig().indexConfig, newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n                                    getSolrConfig().indexConfig, newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n                                    getSolrConfig().indexConfig, newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n                                    getSolrConfig().indexConfig, newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getIndexReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n                                    getSolrConfig().indexConfig, newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b906bdda81aff118473358c14c280e6f07feeda","date":1412632498,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n                                    getSolrConfig().indexConfig, newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n                                    getSolrConfig().indexConfig, newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig, \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with it's reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac2f1cdbdc54a889e88543cc1d939a931cb96883","date":1420554488,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n    boolean nrt = solrConfig.nrtMode && updateHandlerReopens;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!nrt) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (nrt || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null && solrConfig.nrtMode) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            // if not in NRT mode, just re-open the reader\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else if (solrConfig.nrtMode) {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n         // normal open that happens at startup\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), getSolrConfig().indexConfig,\n                                    \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9aea0485ecacb6734c17da2d02569816c23a69c1","date":1425707735,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n        \n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), \n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e0bbfc7e96e0cf26b51dcefe3b2e4c93fe34e8c0","date":1433439403,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4bf9a95dde95952e0577d294ba4f9ab6b3d3343e","date":1439906646,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState()\n            .getIndexWriter(null);\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":["058801f8673d53a5abac8088204860ec29a40f0d","65974810aff303cdaecff3dd789ae9353c1d9134"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b8ae9fd09e7ac7192f47c81a085ef2113c66f905","date":1463582752,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["96e0d4494fe54b31c7f0151f3a632124ab806351"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec6c8973bbd2cdccb14a19312531e17d30350349","date":1463618107,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7f0c8426396c925de8db3ed3f8ff40fd73670a5c","date":1474556641,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"126d6ad24eed13163ba0959435d5a80e5672837c","date":1474567302,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.info(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6ba9c6a7bb3418fae644fe4b821c94cf739338a","date":1482164091,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searchLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","date":1482251961,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searchLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searckLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96e0d4494fe54b31c7f0151f3a632124ab806351","date":1512410218,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searchLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searchLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":["b8ae9fd09e7ac7192f47c81a085ef2113c66f905","2c007e7c4cf8c55bc2a5884e315123afaaeec87f","6ab99a2487a34179af579c58aee0f6954a54173b"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"24792720c893049d53a1807bd0ae9b64d1cd7be5","date":1527536585,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searchLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: {}\", newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searchLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: \" + newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searchLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrCoreState.CoreIsClosedException();\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: {}\", newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searchLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: {}\", newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":["96e0d4494fe54b31c7f0151f3a632124ab806351"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /**\n   * Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   * <p>\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   * <p>\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   * <p>\n   * This method acquires openSearcherLock - do not call with searchLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrCoreState.CoreIsClosedException();\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: {}\", newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n            newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\" : \"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\" : \"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    } finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /** Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   *\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   *\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   *\n   * This method acquires openSearcherLock - do not call with searchLock held!\n   */\n  public RefCounted<SolrIndexSearcher>  openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrCoreState.CoreIsClosedException();\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: {}\", newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n                                    newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else  {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\":\"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    }\n    finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#openNewSearcher(boolean,boolean).mjava","sourceNew":"  /**\n   * Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   * <p>\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   * <p>\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   * <p>\n   * This method acquires openSearcherLock - do not call with searchLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrCoreState.CoreIsClosedException();\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            if (log.isDebugEnabled()) {\n              log.debug(\"SolrIndexSearcher has not changed - not re-opening: {}\", newestSearcher.get().getName());\n            }\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n            newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\" : \"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\" : \"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    } finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Opens a new searcher and returns a RefCounted&lt;SolrIndexSearcher&gt; with its reference incremented.\n   * <p>\n   * \"realtime\" means that we need to open quickly for a realtime view of the index, hence don't do any\n   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't\n   * be used for autowarming by a future normal searcher).  A \"realtime\" searcher will currently never\n   * become \"registered\" (since it currently lacks caching).\n   * <p>\n   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of \"realtime\".\n   * <p>\n   * This method acquires openSearcherLock - do not call with searchLock held!\n   */\n  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {\n    if (isClosed()) { // catch some errors quicker\n      throw new SolrCoreState.CoreIsClosedException();\n    }\n\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    openSearcherLock.lock();\n    try {\n      String newIndexDir = getNewIndexDir();\n      String indexDirFile = null;\n      String newIndexDirFile = null;\n\n      // if it's not a normal near-realtime update, check that paths haven't changed.\n      if (!updateHandlerReopens) {\n        indexDirFile = getDirectoryFactory().normalize(getIndexDir());\n        newIndexDirFile = getDirectoryFactory().normalize(newIndexDir);\n      }\n\n      synchronized (searcherLock) {\n        newestSearcher = realtimeSearcher;\n        if (newestSearcher != null) {\n          newestSearcher.incref();      // the matching decref is in the finally block\n        }\n      }\n\n      if (newestSearcher != null && (updateHandlerReopens || indexDirFile.equals(newIndexDirFile))) {\n\n        DirectoryReader newReader;\n        DirectoryReader currentReader = newestSearcher.get().getRawReader();\n\n        // SolrCore.verbose(\"start reopen from\",previousSearcher,\"writer=\",writer);\n\n        RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(null);\n\n        try {\n          if (writer != null) {\n            // if in NRT mode, open from the writer\n            newReader = DirectoryReader.openIfChanged(currentReader, writer.get(), true);\n          } else {\n            // verbose(\"start reopen without writer, reader=\", currentReader);\n            newReader = DirectoryReader.openIfChanged(currentReader);\n            // verbose(\"reopen result\", newReader);\n          }\n        } finally {\n          if (writer != null) {\n            writer.decref();\n          }\n        }\n\n        if (newReader == null) { // the underlying index has not changed at all\n\n          if (realtime) {\n            // if this is a request for a realtime searcher, just return the same searcher\n            newestSearcher.incref();\n            return newestSearcher;\n\n          } else if (newestSearcher.get().isCachingEnabled() && newestSearcher.get().getSchema() == getLatestSchema()) {\n            // absolutely nothing has changed, can use the same searcher\n            // but log a message about it to minimize confusion\n\n            newestSearcher.incref();\n            log.debug(\"SolrIndexSearcher has not changed - not re-opening: {}\", newestSearcher.get().getName());\n            return newestSearcher;\n\n          } // ELSE: open a new searcher against the old reader...\n          currentReader.incRef();\n          newReader = currentReader;\n        }\n\n        // for now, turn off caches if this is for a realtime reader \n        // (caches take a little while to instantiate)\n        final boolean useCaches = !realtime;\n        final String newName = realtime ? \"realtime\" : \"main\";\n        tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(), newName,\n            newReader, true, useCaches, true, directoryFactory);\n\n      } else {\n        // newestSearcher == null at this point\n\n        if (newReaderCreator != null) {\n          // this is set in the constructor if there is a currently open index writer\n          // so that we pick up any uncommitted changes and so we don't go backwards\n          // in time on a core reload\n          DirectoryReader newReader = newReaderCreator.call();\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\" : \"main\"), newReader, true, !realtime, true, directoryFactory);\n        } else {\n          RefCounted<IndexWriter> writer = getSolrCoreState().getIndexWriter(this);\n          DirectoryReader newReader = null;\n          try {\n            newReader = indexReaderFactory.newReader(writer.get(), this);\n          } finally {\n            writer.decref();\n          }\n          tmp = new SolrIndexSearcher(this, newIndexDir, getLatestSchema(),\n              (realtime ? \"realtime\" : \"main\"), newReader, true, !realtime, true, directoryFactory);\n        }\n      }\n\n      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;\n      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1\n\n      // Increment reference again for \"realtimeSearcher\" variable.  It should be at 2 after.\n      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,\n      // it will be closed.\n      newSearcher.incref();\n\n      synchronized (searcherLock) {\n        // Check if the core is closed again inside the lock in case this method is racing with a close. If the core is\n        // closed, clean up the new searcher and bail.\n        if (isClosed()) {\n          newSearcher.decref(); // once for caller since we're not returning it\n          newSearcher.decref(); // once for ourselves since it won't be \"replaced\"\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"openNewSearcher called on closed core\");\n        }\n\n        if (realtimeSearcher != null) {\n          realtimeSearcher.decref();\n        }\n        realtimeSearcher = newSearcher;\n        searcherList.add(realtimeSearcher);\n      }\n\n      return newSearcher;\n\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error opening new searcher\", e);\n    } finally {\n      openSearcherLock.unlock();\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"96e0d4494fe54b31c7f0151f3a632124ab806351":["c6ba9c6a7bb3418fae644fe4b821c94cf739338a"],"96d207426bd26fa5c1014e26d21d87603aea68b7":["fd92b8bcc88e969302510acf77bd6970da3994c4"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["a6d3fca4763c45f22581927b942c808dbb2e2aec"],"a6d3fca4763c45f22581927b942c808dbb2e2aec":["c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"106138013e106211a65b050fa67f96ed95384f07":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"e0bbfc7e96e0cf26b51dcefe3b2e4c93fe34e8c0":["9aea0485ecacb6734c17da2d02569816c23a69c1"],"aba371508186796cc6151d8223a5b4e16d02e26e":["4a5469a71486c4c1e313c7fcb08188d7111195c2","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c6ba9c6a7bb3418fae644fe4b821c94cf739338a"],"140be51d03394488536f4aacedace29f9b318347":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"ab499d210c848577f67d42fc12866e1e95273ebe":["beea4d4bbebcfb6689ed31936553c5e98bce2871"],"a114c79cee12feb72f81641925268f6e3e4f051e":["a837c064b67fa63a9394136e31218b908cdcf783"],"f2126b84bd093fa3d921582a109a0ee578c28126":["a6d3fca4763c45f22581927b942c808dbb2e2aec","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"c9f81a0a8d08cc36757b7be45a8c8dcd66ff0360":["65974810aff303cdaecff3dd789ae9353c1d9134"],"d0ce568448269aad19a317e537eefc0993934c9d":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"b8ae9fd09e7ac7192f47c81a085ef2113c66f905":["4bf9a95dde95952e0577d294ba4f9ab6b3d3343e"],"6b906bdda81aff118473358c14c280e6f07feeda":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c6ba9c6a7bb3418fae644fe4b821c94cf739338a":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"058801f8673d53a5abac8088204860ec29a40f0d":["a114c79cee12feb72f81641925268f6e3e4f051e"],"126d6ad24eed13163ba0959435d5a80e5672837c":["d470c8182e92b264680e34081b75e70a9f2b3c89","7f0c8426396c925de8db3ed3f8ff40fd73670a5c"],"4a5469a71486c4c1e313c7fcb08188d7111195c2":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4a5469a71486c4c1e313c7fcb08188d7111195c2","08bcaef9e931052e4ca24133a89cc6aefaf61829"],"6ab99a2487a34179af579c58aee0f6954a54173b":["08970e5b8411182a29412c177eff67ec1110095b"],"beea4d4bbebcfb6689ed31936553c5e98bce2871":["c9f81a0a8d08cc36757b7be45a8c8dcd66ff0360"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["24792720c893049d53a1807bd0ae9b64d1cd7be5"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["0d22ac6a4146774c1bc8400160fc0b6150294e92","106138013e106211a65b050fa67f96ed95384f07"],"56572ec06f1407c066d6b7399413178b33176cd8":["ab499d210c848577f67d42fc12866e1e95273ebe","93dd449115a9247533e44bab47e8429e5dccbc6d"],"ec6c8973bbd2cdccb14a19312531e17d30350349":["4bf9a95dde95952e0577d294ba4f9ab6b3d3343e","b8ae9fd09e7ac7192f47c81a085ef2113c66f905"],"7f0c8426396c925de8db3ed3f8ff40fd73670a5c":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"09c8567c25c02eeeb3e719841606a1269f3538ca":["d9405f486872f1e416304dfe389741f4ee2f8a4d","d0ce568448269aad19a317e537eefc0993934c9d"],"08970e5b8411182a29412c177eff67ec1110095b":["058801f8673d53a5abac8088204860ec29a40f0d"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4bf9a95dde95952e0577d294ba4f9ab6b3d3343e","ec6c8973bbd2cdccb14a19312531e17d30350349"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["ac2f1cdbdc54a889e88543cc1d939a931cb96883","9aea0485ecacb6734c17da2d02569816c23a69c1"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["6b906bdda81aff118473358c14c280e6f07feeda"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["d470c8182e92b264680e34081b75e70a9f2b3c89","126d6ad24eed13163ba0959435d5a80e5672837c"],"65974810aff303cdaecff3dd789ae9353c1d9134":["6ab99a2487a34179af579c58aee0f6954a54173b"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["fe33227f6805edab2036cbb80645cc4e2d1fa424","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"30b6ad849a21206db510322a3f583ca70ae20a2f":["ab499d210c848577f67d42fc12866e1e95273ebe"],"9aea0485ecacb6734c17da2d02569816c23a69c1":["ac2f1cdbdc54a889e88543cc1d939a931cb96883"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","106138013e106211a65b050fa67f96ed95384f07"],"55980207f1977bd1463465de1659b821347e2fa8":["93dd449115a9247533e44bab47e8429e5dccbc6d","6b906bdda81aff118473358c14c280e6f07feeda"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["6ab99a2487a34179af579c58aee0f6954a54173b","65974810aff303cdaecff3dd789ae9353c1d9134"],"24792720c893049d53a1807bd0ae9b64d1cd7be5":["96e0d4494fe54b31c7f0151f3a632124ab806351"],"4bf9a95dde95952e0577d294ba4f9ab6b3d3343e":["e0bbfc7e96e0cf26b51dcefe3b2e4c93fe34e8c0"],"ac2f1cdbdc54a889e88543cc1d939a931cb96883":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["106138013e106211a65b050fa67f96ed95384f07","96d207426bd26fa5c1014e26d21d87603aea68b7"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["4bf9a95dde95952e0577d294ba4f9ab6b3d3343e","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["ab499d210c848577f67d42fc12866e1e95273ebe","30b6ad849a21206db510322a3f583ca70ae20a2f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"08bcaef9e931052e4ca24133a89cc6aefaf61829":["4a5469a71486c4c1e313c7fcb08188d7111195c2"],"a837c064b67fa63a9394136e31218b908cdcf783":["d0ce568448269aad19a317e537eefc0993934c9d"],"c9767265f21f7d1246b13dd7e73e8a4ad88b4384":["08bcaef9e931052e4ca24133a89cc6aefaf61829"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["140be51d03394488536f4aacedace29f9b318347"]},"commit2Childs":{"96e0d4494fe54b31c7f0151f3a632124ab806351":["24792720c893049d53a1807bd0ae9b64d1cd7be5"],"96d207426bd26fa5c1014e26d21d87603aea68b7":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["f2126b84bd093fa3d921582a109a0ee578c28126","d0ce568448269aad19a317e537eefc0993934c9d","09c8567c25c02eeeb3e719841606a1269f3538ca"],"a6d3fca4763c45f22581927b942c808dbb2e2aec":["d9405f486872f1e416304dfe389741f4ee2f8a4d","f2126b84bd093fa3d921582a109a0ee578c28126"],"106138013e106211a65b050fa67f96ed95384f07":["fd92b8bcc88e969302510acf77bd6970da3994c4","78a55f24d9b493c2a1cecf79f1d78279062b545b","5cab9a86bd67202d20b6adc463008c8e982b070a"],"e0bbfc7e96e0cf26b51dcefe3b2e4c93fe34e8c0":["4bf9a95dde95952e0577d294ba4f9ab6b3d3343e"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":[],"140be51d03394488536f4aacedace29f9b318347":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ab499d210c848577f67d42fc12866e1e95273ebe":["56572ec06f1407c066d6b7399413178b33176cd8","30b6ad849a21206db510322a3f583ca70ae20a2f","93dd449115a9247533e44bab47e8429e5dccbc6d"],"a114c79cee12feb72f81641925268f6e3e4f051e":["058801f8673d53a5abac8088204860ec29a40f0d"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"c9f81a0a8d08cc36757b7be45a8c8dcd66ff0360":["beea4d4bbebcfb6689ed31936553c5e98bce2871"],"d0ce568448269aad19a317e537eefc0993934c9d":["09c8567c25c02eeeb3e719841606a1269f3538ca","a837c064b67fa63a9394136e31218b908cdcf783"],"b8ae9fd09e7ac7192f47c81a085ef2113c66f905":["ec6c8973bbd2cdccb14a19312531e17d30350349"],"6b906bdda81aff118473358c14c280e6f07feeda":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","55980207f1977bd1463465de1659b821347e2fa8"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["78a55f24d9b493c2a1cecf79f1d78279062b545b"],"c6ba9c6a7bb3418fae644fe4b821c94cf739338a":["96e0d4494fe54b31c7f0151f3a632124ab806351","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf"],"058801f8673d53a5abac8088204860ec29a40f0d":["08970e5b8411182a29412c177eff67ec1110095b"],"126d6ad24eed13163ba0959435d5a80e5672837c":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4a5469a71486c4c1e313c7fcb08188d7111195c2":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","08bcaef9e931052e4ca24133a89cc6aefaf61829"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"6ab99a2487a34179af579c58aee0f6954a54173b":["65974810aff303cdaecff3dd789ae9353c1d9134","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"beea4d4bbebcfb6689ed31936553c5e98bce2871":["ab499d210c848577f67d42fc12866e1e95273ebe"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["96d207426bd26fa5c1014e26d21d87603aea68b7"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"7f0c8426396c925de8db3ed3f8ff40fd73670a5c":["126d6ad24eed13163ba0959435d5a80e5672837c"],"ec6c8973bbd2cdccb14a19312531e17d30350349":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"09c8567c25c02eeeb3e719841606a1269f3538ca":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["126d6ad24eed13163ba0959435d5a80e5672837c","7f0c8426396c925de8db3ed3f8ff40fd73670a5c","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"08970e5b8411182a29412c177eff67ec1110095b":["6ab99a2487a34179af579c58aee0f6954a54173b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["fd92b8bcc88e969302510acf77bd6970da3994c4"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["ac2f1cdbdc54a889e88543cc1d939a931cb96883"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["140be51d03394488536f4aacedace29f9b318347"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["c6ba9c6a7bb3418fae644fe4b821c94cf739338a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"65974810aff303cdaecff3dd789ae9353c1d9134":["c9f81a0a8d08cc36757b7be45a8c8dcd66ff0360","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":[],"30b6ad849a21206db510322a3f583ca70ae20a2f":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"9aea0485ecacb6734c17da2d02569816c23a69c1":["e0bbfc7e96e0cf26b51dcefe3b2e4c93fe34e8c0","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":[],"55980207f1977bd1463465de1659b821347e2fa8":[],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"24792720c893049d53a1807bd0ae9b64d1cd7be5":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"4bf9a95dde95952e0577d294ba4f9ab6b3d3343e":["b8ae9fd09e7ac7192f47c81a085ef2113c66f905","ec6c8973bbd2cdccb14a19312531e17d30350349","d470c8182e92b264680e34081b75e70a9f2b3c89","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["4a5469a71486c4c1e313c7fcb08188d7111195c2"],"ac2f1cdbdc54a889e88543cc1d939a931cb96883":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","9aea0485ecacb6734c17da2d02569816c23a69c1"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["6b906bdda81aff118473358c14c280e6f07feeda","56572ec06f1407c066d6b7399413178b33176cd8","55980207f1977bd1463465de1659b821347e2fa8"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["106138013e106211a65b050fa67f96ed95384f07","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92"],"08bcaef9e931052e4ca24133a89cc6aefaf61829":["fe33227f6805edab2036cbb80645cc4e2d1fa424","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"c9767265f21f7d1246b13dd7e73e8a4ad88b4384":["a6d3fca4763c45f22581927b942c808dbb2e2aec","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"a837c064b67fa63a9394136e31218b908cdcf783":["a114c79cee12feb72f81641925268f6e3e4f051e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","f2126b84bd093fa3d921582a109a0ee578c28126","56572ec06f1407c066d6b7399413178b33176cd8","09c8567c25c02eeeb3e719841606a1269f3538ca","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","78a55f24d9b493c2a1cecf79f1d78279062b545b","55980207f1977bd1463465de1659b821347e2fa8","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}