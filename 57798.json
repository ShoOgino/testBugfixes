{"path":"src/java/org/apache/lucene/search/FieldSortedHitQueue#determineComparator(IndexReader,String).mjava","commits":[{"id":"c6691cb6747f9e850337c706c06b92e9ddf816e1","date":1077044431,"type":0,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#determineComparator(IndexReader,String).mjava","pathOld":"/dev/null","sourceNew":"\t/**\n\t * Looks at the actual values in the field and determines whether\n\t * they contain Integers, Floats or Strings.  Only the first term in the field\n\t * is looked at.\n\t * <p>The following patterns are used to determine the content of the terms:\n\t * <p><table border=\"1\" cellspacing=\"0\" cellpadding=\"3\">\n\t * <tr><th>Sequence</th><th>Pattern</th><th>Type</th></tr>\n\t * <tr><td>1</td><td>[0-9\\-]+</td><td>Integer</td></tr>\n\t * <tr><td>2</td><td>[0-9+\\-\\.eEfFdD]+</td><td>Float</td></tr>\n\t * <tr><td>3</td><td><i>(none - default)</i></td><td>String</td></tr>\n\t * </table>\n\t *\n\t * @param reader  Index to use.\n\t * @param field   Field to create comparator for.\n\t * @return  Comparator appropriate for the terms in the given field.\n\t * @throws IOException  If an error occurs reading the index.\n\t */\n\tprotected static ScoreDocComparator determineComparator (IndexReader reader, String field)\n\tthrows IOException {\n\n\t\tTermEnum enumerator = reader.terms (new Term (field, \"\"));\n\t\ttry {\n\t\t\tTerm term = enumerator.term();\n\t\t\tif (term == null) {\n\t\t\t\tthrow new RuntimeException (\"no terms in field \"+field);\n\t\t\t}\n\t\t\tif (term.field() == field) {\n\t\t\t\tString termtext = term.text().trim();\n\n\t\t\t\tif (pIntegers.matcher(termtext).matches())\n\t\t\t\t\treturn IntegerSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t\telse if (pFloats.matcher(termtext).matches())\n\t\t\t\t\treturn FloatSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t\treturn StringSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException (\"field \\\"\"+field+\"\\\" does not appear to be indexed\");\n\t\t\t}\n\t\t} finally {\n\t\t\tenumerator.close();\n\t\t}\n\t}\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d7f2f39556d99cecd24f152bdece2b6432458c3","date":1077651298,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#determineComparator(IndexReader,String).mjava","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#determineComparator(IndexReader,String).mjava","sourceNew":"\t/**\n\t * Looks at the actual values in the field and determines whether\n\t * they contain Integers, Floats or Strings.  Only the first term in the field\n\t * is looked at.\n\t * <p>The following patterns are used to determine the content of the terms:\n\t * <p><table border=\"1\" cellspacing=\"0\" cellpadding=\"3\">\n\t * <tr><th>Sequence</th><th>Pattern</th><th>Type</th></tr>\n\t * <tr><td>1</td><td>[0-9\\-]+</td><td>Integer</td></tr>\n\t * <tr><td>2</td><td>[0-9+\\-\\.eEfFdD]+</td><td>Float</td></tr>\n\t * <tr><td>3</td><td><i>(none - default)</i></td><td>String</td></tr>\n\t * </table>\n\t *\n\t * @param reader  Index to use.\n\t * @param field   Field to create comparator for.\n\t * @return  Comparator appropriate for the terms in the given field.\n\t * @throws IOException  If an error occurs reading the index.\n\t */\n\tprotected static ScoreDocComparator determineComparator (IndexReader reader, String field)\n\tthrows IOException {\n\t\tfield = field.intern();\n\t\tTermEnum enumerator = reader.terms (new Term (field, \"\"));\n\t\ttry {\n\t\t\tTerm term = enumerator.term();\n\t\t\tif (term == null) {\n\t\t\t\tthrow new RuntimeException (\"no terms in field \"+field);\n\t\t\t}\n\t\t\tif (term.field() == field) {\n\t\t\t\tString termtext = term.text().trim();\n\n\t\t\t\tif (pIntegers.matcher(termtext).matches())\n\t\t\t\t\treturn IntegerSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t\telse if (pFloats.matcher(termtext).matches())\n\t\t\t\t\treturn FloatSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t\treturn StringSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException (\"field \\\"\"+field+\"\\\" does not appear to be indexed\");\n\t\t\t}\n\t\t} finally {\n\t\t\tenumerator.close();\n\t\t}\n\t}\n\n","sourceOld":"\t/**\n\t * Looks at the actual values in the field and determines whether\n\t * they contain Integers, Floats or Strings.  Only the first term in the field\n\t * is looked at.\n\t * <p>The following patterns are used to determine the content of the terms:\n\t * <p><table border=\"1\" cellspacing=\"0\" cellpadding=\"3\">\n\t * <tr><th>Sequence</th><th>Pattern</th><th>Type</th></tr>\n\t * <tr><td>1</td><td>[0-9\\-]+</td><td>Integer</td></tr>\n\t * <tr><td>2</td><td>[0-9+\\-\\.eEfFdD]+</td><td>Float</td></tr>\n\t * <tr><td>3</td><td><i>(none - default)</i></td><td>String</td></tr>\n\t * </table>\n\t *\n\t * @param reader  Index to use.\n\t * @param field   Field to create comparator for.\n\t * @return  Comparator appropriate for the terms in the given field.\n\t * @throws IOException  If an error occurs reading the index.\n\t */\n\tprotected static ScoreDocComparator determineComparator (IndexReader reader, String field)\n\tthrows IOException {\n\n\t\tTermEnum enumerator = reader.terms (new Term (field, \"\"));\n\t\ttry {\n\t\t\tTerm term = enumerator.term();\n\t\t\tif (term == null) {\n\t\t\t\tthrow new RuntimeException (\"no terms in field \"+field);\n\t\t\t}\n\t\t\tif (term.field() == field) {\n\t\t\t\tString termtext = term.text().trim();\n\n\t\t\t\tif (pIntegers.matcher(termtext).matches())\n\t\t\t\t\treturn IntegerSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t\telse if (pFloats.matcher(termtext).matches())\n\t\t\t\t\treturn FloatSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t\treturn StringSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException (\"field \\\"\"+field+\"\\\" does not appear to be indexed\");\n\t\t\t}\n\t\t} finally {\n\t\t\tenumerator.close();\n\t\t}\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f17709119ee4a1f8a86177ef1440f70783a27958","date":1079547062,"type":3,"author":"Tim Jones","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#determineComparator(IndexReader,String).mjava","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#determineComparator(IndexReader,String).mjava","sourceNew":"\t/**\n\t * Looks at the actual values in the field and determines whether\n\t * they contain Integers, Floats or Strings.  Only the first term in the field\n\t * is looked at.\n\t * <p>The following patterns are used to determine the content of the terms:\n\t * <p><table border=\"1\" cellspacing=\"0\" cellpadding=\"3\">\n\t * <tr><th>Sequence</th><th>Pattern</th><th>Type</th></tr>\n\t * <tr><td>1</td><td>[0-9\\-]+</td><td>Integer</td></tr>\n\t * <tr><td>2</td><td>[0-9+\\-\\.eEfFdD]+</td><td>Float</td></tr>\n\t * <tr><td>3</td><td><i>(none - default)</i></td><td>String</td></tr>\n\t * </table>\n\t *\n\t * @param reader  Index to use.\n\t * @param field   Field to create comparator for.\n\t * @return  Comparator appropriate for the terms in the given field.\n\t * @throws IOException  If an error occurs reading the index.\n\t */\n\tprotected static ScoreDocComparator determineComparator (IndexReader reader, String field)\n\tthrows IOException {\n\t\tfield = field.intern();\n\t\tTermEnum enumerator = reader.terms (new Term (field, \"\"));\n\t\ttry {\n\t\t\tTerm term = enumerator.term();\n\t\t\tif (term == null) {\n\t\t\t\tthrow new RuntimeException (\"no terms in field \"+field);\n\t\t\t}\n\t\t\tif (term.field() == field) {\n\t\t\t\tString termtext = term.text().trim();\n\n\t\t\t\t/**\n\t\t\t\t * Java 1.4 level code:\n\n\t\t\t\tif (pIntegers.matcher(termtext).matches())\n\t\t\t\t\treturn IntegerSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t\telse if (pFloats.matcher(termtext).matches())\n\t\t\t\t\treturn FloatSortedHitQueue.comparator (reader, enumerator, field);\n\t\t\t\t */\n\n\t\t\t\t// Java 1.3 level code:\n\t\t\t\ttry {\n\t\t\t\t\tInteger.parseInt (termtext);\n\t\t\t\t\treturn IntegerSortedHitQueue.comparator (reader, enumerator, field);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t// nothing\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tFloat.parseFloat (termtext);\n\t\t\t\t\treturn FloatSortedHitQueue.comparator (reader, enumerator, field);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t// nothing\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn StringSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException (\"field \\\"\"+field+\"\\\" does not appear to be indexed\");\n\t\t\t}\n\t\t} finally {\n\t\t\tenumerator.close();\n\t\t}\n\t}\n\n","sourceOld":"\t/**\n\t * Looks at the actual values in the field and determines whether\n\t * they contain Integers, Floats or Strings.  Only the first term in the field\n\t * is looked at.\n\t * <p>The following patterns are used to determine the content of the terms:\n\t * <p><table border=\"1\" cellspacing=\"0\" cellpadding=\"3\">\n\t * <tr><th>Sequence</th><th>Pattern</th><th>Type</th></tr>\n\t * <tr><td>1</td><td>[0-9\\-]+</td><td>Integer</td></tr>\n\t * <tr><td>2</td><td>[0-9+\\-\\.eEfFdD]+</td><td>Float</td></tr>\n\t * <tr><td>3</td><td><i>(none - default)</i></td><td>String</td></tr>\n\t * </table>\n\t *\n\t * @param reader  Index to use.\n\t * @param field   Field to create comparator for.\n\t * @return  Comparator appropriate for the terms in the given field.\n\t * @throws IOException  If an error occurs reading the index.\n\t */\n\tprotected static ScoreDocComparator determineComparator (IndexReader reader, String field)\n\tthrows IOException {\n\t\tfield = field.intern();\n\t\tTermEnum enumerator = reader.terms (new Term (field, \"\"));\n\t\ttry {\n\t\t\tTerm term = enumerator.term();\n\t\t\tif (term == null) {\n\t\t\t\tthrow new RuntimeException (\"no terms in field \"+field);\n\t\t\t}\n\t\t\tif (term.field() == field) {\n\t\t\t\tString termtext = term.text().trim();\n\n\t\t\t\tif (pIntegers.matcher(termtext).matches())\n\t\t\t\t\treturn IntegerSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t\telse if (pFloats.matcher(termtext).matches())\n\t\t\t\t\treturn FloatSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t\treturn StringSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException (\"field \\\"\"+field+\"\\\" does not appear to be indexed\");\n\t\t\t}\n\t\t} finally {\n\t\t\tenumerator.close();\n\t\t}\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dba073cad85af8b853f4461a62b0a245480fcd7a","date":1080156191,"type":3,"author":"Tim Jones","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#determineComparator(IndexReader,String).mjava","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#determineComparator(IndexReader,String).mjava","sourceNew":"\t/**\n\t * Looks at the actual values in the field and determines whether\n\t * they contain Integers, Floats or Strings.  Only the first term in the field\n\t * is looked at.\n\t * <p>The following patterns are used to determine the content of the terms:\n\t * <p><table border=\"1\" cellspacing=\"0\" cellpadding=\"3\">\n\t * <tr><th>Sequence</th><th>Pattern</th><th>Type</th></tr>\n\t * <tr><td>1</td><td>[0-9\\-]+</td><td>Integer</td></tr>\n\t * <tr><td>2</td><td>[0-9+\\-\\.eEfFdD]+</td><td>Float</td></tr>\n\t * <tr><td>3</td><td><i>(none - default)</i></td><td>String</td></tr>\n\t * </table>\n\t *\n\t * @param reader  Index to use.\n\t * @param field   Field to create comparator for.\n\t * @return  Comparator appropriate for the terms in the given field.\n\t * @throws IOException  If an error occurs reading the index.\n\t */\n\tprotected static ScoreDocComparator determineComparator (IndexReader reader, String field)\n\tthrows IOException {\n\t\tfield = field.intern();\n\t\tTermEnum enumerator = reader.terms (new Term (field, \"\"));\n\t\ttry {\n\t\t\tTerm term = enumerator.term();\n\t\t\tif (term == null) {\n\t\t\t\tthrow new RuntimeException (\"no terms in field \"+field+\" - cannot determine sort type\");\n\t\t\t}\n\t\t\tif (term.field() == field) {\n\t\t\t\tString termtext = term.text().trim();\n\n\t\t\t\t/**\n\t\t\t\t * Java 1.4 level code:\n\n\t\t\t\tif (pIntegers.matcher(termtext).matches())\n\t\t\t\t\treturn IntegerSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t\telse if (pFloats.matcher(termtext).matches())\n\t\t\t\t\treturn FloatSortedHitQueue.comparator (reader, enumerator, field);\n\t\t\t\t */\n\n\t\t\t\t// Java 1.3 level code:\n\t\t\t\ttry {\n\t\t\t\t\tInteger.parseInt (termtext);\n\t\t\t\t\treturn IntegerSortedHitQueue.comparator (reader, enumerator, field);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t// nothing\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tFloat.parseFloat (termtext);\n\t\t\t\t\treturn FloatSortedHitQueue.comparator (reader, enumerator, field);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t// nothing\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn StringSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException (\"field \\\"\"+field+\"\\\" does not appear to be indexed\");\n\t\t\t}\n\t\t} finally {\n\t\t\tenumerator.close();\n\t\t}\n\t}\n\n","sourceOld":"\t/**\n\t * Looks at the actual values in the field and determines whether\n\t * they contain Integers, Floats or Strings.  Only the first term in the field\n\t * is looked at.\n\t * <p>The following patterns are used to determine the content of the terms:\n\t * <p><table border=\"1\" cellspacing=\"0\" cellpadding=\"3\">\n\t * <tr><th>Sequence</th><th>Pattern</th><th>Type</th></tr>\n\t * <tr><td>1</td><td>[0-9\\-]+</td><td>Integer</td></tr>\n\t * <tr><td>2</td><td>[0-9+\\-\\.eEfFdD]+</td><td>Float</td></tr>\n\t * <tr><td>3</td><td><i>(none - default)</i></td><td>String</td></tr>\n\t * </table>\n\t *\n\t * @param reader  Index to use.\n\t * @param field   Field to create comparator for.\n\t * @return  Comparator appropriate for the terms in the given field.\n\t * @throws IOException  If an error occurs reading the index.\n\t */\n\tprotected static ScoreDocComparator determineComparator (IndexReader reader, String field)\n\tthrows IOException {\n\t\tfield = field.intern();\n\t\tTermEnum enumerator = reader.terms (new Term (field, \"\"));\n\t\ttry {\n\t\t\tTerm term = enumerator.term();\n\t\t\tif (term == null) {\n\t\t\t\tthrow new RuntimeException (\"no terms in field \"+field);\n\t\t\t}\n\t\t\tif (term.field() == field) {\n\t\t\t\tString termtext = term.text().trim();\n\n\t\t\t\t/**\n\t\t\t\t * Java 1.4 level code:\n\n\t\t\t\tif (pIntegers.matcher(termtext).matches())\n\t\t\t\t\treturn IntegerSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t\telse if (pFloats.matcher(termtext).matches())\n\t\t\t\t\treturn FloatSortedHitQueue.comparator (reader, enumerator, field);\n\t\t\t\t */\n\n\t\t\t\t// Java 1.3 level code:\n\t\t\t\ttry {\n\t\t\t\t\tInteger.parseInt (termtext);\n\t\t\t\t\treturn IntegerSortedHitQueue.comparator (reader, enumerator, field);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t// nothing\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tFloat.parseFloat (termtext);\n\t\t\t\t\treturn FloatSortedHitQueue.comparator (reader, enumerator, field);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t// nothing\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn StringSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException (\"field \\\"\"+field+\"\\\" does not appear to be indexed\");\n\t\t\t}\n\t\t} finally {\n\t\t\tenumerator.close();\n\t\t}\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99ee715b9c02dd47d9e69a18607a5192c1ebd82b","date":1085007927,"type":4,"author":"Tim Jones","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#determineComparator(IndexReader,String).mjava","sourceNew":null,"sourceOld":"\t/**\n\t * Looks at the actual values in the field and determines whether\n\t * they contain Integers, Floats or Strings.  Only the first term in the field\n\t * is looked at.\n\t * <p>The following patterns are used to determine the content of the terms:\n\t * <p><table border=\"1\" cellspacing=\"0\" cellpadding=\"3\">\n\t * <tr><th>Sequence</th><th>Pattern</th><th>Type</th></tr>\n\t * <tr><td>1</td><td>[0-9\\-]+</td><td>Integer</td></tr>\n\t * <tr><td>2</td><td>[0-9+\\-\\.eEfFdD]+</td><td>Float</td></tr>\n\t * <tr><td>3</td><td><i>(none - default)</i></td><td>String</td></tr>\n\t * </table>\n\t *\n\t * @param reader  Index to use.\n\t * @param field   Field to create comparator for.\n\t * @return  Comparator appropriate for the terms in the given field.\n\t * @throws IOException  If an error occurs reading the index.\n\t */\n\tprotected static ScoreDocComparator determineComparator (IndexReader reader, String field)\n\tthrows IOException {\n\t\tfield = field.intern();\n\t\tTermEnum enumerator = reader.terms (new Term (field, \"\"));\n\t\ttry {\n\t\t\tTerm term = enumerator.term();\n\t\t\tif (term == null) {\n\t\t\t\tthrow new RuntimeException (\"no terms in field \"+field+\" - cannot determine sort type\");\n\t\t\t}\n\t\t\tif (term.field() == field) {\n\t\t\t\tString termtext = term.text().trim();\n\n\t\t\t\t/**\n\t\t\t\t * Java 1.4 level code:\n\n\t\t\t\tif (pIntegers.matcher(termtext).matches())\n\t\t\t\t\treturn IntegerSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t\telse if (pFloats.matcher(termtext).matches())\n\t\t\t\t\treturn FloatSortedHitQueue.comparator (reader, enumerator, field);\n\t\t\t\t */\n\n\t\t\t\t// Java 1.3 level code:\n\t\t\t\ttry {\n\t\t\t\t\tInteger.parseInt (termtext);\n\t\t\t\t\treturn IntegerSortedHitQueue.comparator (reader, enumerator, field);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t// nothing\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tFloat.parseFloat (termtext);\n\t\t\t\t\treturn FloatSortedHitQueue.comparator (reader, enumerator, field);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t// nothing\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn StringSortedHitQueue.comparator (reader, enumerator, field);\n\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException (\"field \\\"\"+field+\"\\\" does not appear to be indexed\");\n\t\t\t}\n\t\t} finally {\n\t\t\tenumerator.close();\n\t\t}\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f17709119ee4a1f8a86177ef1440f70783a27958":["9d7f2f39556d99cecd24f152bdece2b6432458c3"],"c6691cb6747f9e850337c706c06b92e9ddf816e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"99ee715b9c02dd47d9e69a18607a5192c1ebd82b":["dba073cad85af8b853f4461a62b0a245480fcd7a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9d7f2f39556d99cecd24f152bdece2b6432458c3":["c6691cb6747f9e850337c706c06b92e9ddf816e1"],"dba073cad85af8b853f4461a62b0a245480fcd7a":["f17709119ee4a1f8a86177ef1440f70783a27958"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["99ee715b9c02dd47d9e69a18607a5192c1ebd82b"]},"commit2Childs":{"f17709119ee4a1f8a86177ef1440f70783a27958":["dba073cad85af8b853f4461a62b0a245480fcd7a"],"c6691cb6747f9e850337c706c06b92e9ddf816e1":["9d7f2f39556d99cecd24f152bdece2b6432458c3"],"99ee715b9c02dd47d9e69a18607a5192c1ebd82b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c6691cb6747f9e850337c706c06b92e9ddf816e1"],"9d7f2f39556d99cecd24f152bdece2b6432458c3":["f17709119ee4a1f8a86177ef1440f70783a27958"],"dba073cad85af8b853f4461a62b0a245480fcd7a":["99ee715b9c02dd47d9e69a18607a5192c1ebd82b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}