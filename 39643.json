{"path":"lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","commits":[{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}