{"path":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testQueryJoinBooksAndPages().mjava","commits":[{"id":"487de3f55283f58d7e02a16993f8be55bbe32061","date":1502123368,"type":1,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testQueryJoinBooksAndPages().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testQureyJoinBooksAndPages().mjava","sourceNew":"  /**\n   * Similar to {@link #testBlockJoin} but uses query time joining.\n   * <p>\n   * (asserts are slightly diff because if a query matches multiple types of documents, blockJoin domain switches\n   * to parent/child domains preserve any existing parent/children from the original domain - eg: when q=*:*)\n   * </p>\n   */\n  public void testQueryJoinBooksAndPages() throws Exception {\n\n    final Client client = Client.localClient();\n\n    final SolrParams p = params(\"rows\",\"0\");\n\n    client.deleteByQuery(\"*:*\", null);\n\n\n    // build up a list of the docs we want to test with\n    List<SolrInputDocument> docsToAdd = new ArrayList<>(10);\n    docsToAdd.add(sdoc(\"id\", \"1\", \"type_s\",\"book\", \"book_s\",\"A\", \"v_t\",\"q\"));\n    \n    docsToAdd.add( sdoc(\"id\", \"2\", \"type_s\",\"book\", \"book_s\",\"B\", \"v_t\",\"q w\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\", \"2.1\", \"type_s\",\"page\", \"page_s\",\"a\", \"v_t\",\"x y z\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\", \"2.2\", \"type_s\",\"page\", \"page_s\",\"b\", \"v_t\",\"x y  \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\",\"2.3\", \"type_s\",\"page\", \"page_s\",\"c\", \"v_t\",\"  y z\" ) );\n\n    docsToAdd.add( sdoc(\"id\", \"3\", \"type_s\",\"book\", \"book_s\",\"C\", \"v_t\",\"q w e\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.1\", \"type_s\",\"page\", \"page_s\",\"d\", \"v_t\",\"x    \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.2\", \"type_s\",\"page\", \"page_s\",\"e\", \"v_t\",\"  y  \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.3\", \"type_s\",\"page\", \"page_s\",\"f\", \"v_t\",\"    z\") );\n\n    docsToAdd.add( sdoc(\"id\", \"4\", \"type_s\",\"book\", \"book_s\",\"D\", \"v_t\",\"e\") );\n    \n    // shuffle the docs since order shouldn't matter\n    Collections.shuffle(docsToAdd, random());\n    for (SolrInputDocument doc : docsToAdd) {\n      client.add(doc, null);\n    }\n    client.commit();\n\n    // the domains we'll be testing, initially setup for block join\n    final String toChildren = \"join: { from:'id', to:'book_id_s' }\";\n    final String toParents = \"join: { from:'book_id_s', to:'id' }\";\n    final String toBogusChildren = \"join: { from:'id', to:'does_not_exist_s' }\";\n    final String toBogusParents = \"join: { from:'book_id_s', to:'does_not_exist_s' }\";\n\n    client.testJQ(params(p, \"q\", \"*:*\"\n            , \"json.facet\", \"{ \" +\n                \"pages:{ type:query, domain:{\"+toChildren+\"} , facet:{ x:{field:v_t} } }\" +\n                \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\"} }\" +\n                \",books:{ type:query, domain:{\"+toParents+\"}  , facet:{ x:{field:v_t} } }\" +\n                \",books2:{type:terms, field:v_t, domain:{\"+toParents+\"} }\" +\n                \",pageof3:{ type:query, q:'id:3', facet : { x : { type:terms, field:page_s, domain:{\"+toChildren+\"}}} }\" +\n                \",bookof22:{ type:query, q:'id:2.2', facet : { x : { type:terms, field:book_s, domain:{\"+toParents+\"}}} }\" +\n                \",missing_Parents:{ type:query, domain:{\"+toBogusParents+\"} }\" +\n                \",missing_Children:{ type:query, domain:{\"+toBogusChildren+\"} }\" +\n                \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages:{count:6 , x:{buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ]}  }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", books:{count:2 , x:{buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ]}  }\" +\n            \", books2:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", pageof3:{count:1 , x:{buckets:[ {val:d,count:1},{val:e,count:1},{val:f,count:1} ]}  }\" +\n            \", bookof22:{count:1 , x:{buckets:[ {val:B,count:1} ]}  }\" +\n            \", missing_Parents:{count:0}\" + \n            \", missing_Children:{count:0}\" +\n            \"}\"\n    );\n\n    // no matches in base query\n    client.testJQ(params(\"q\", \"no_match_s:NO_MATCHES\"\n            , \"json.facet\", \"{ processEmpty:true,\" +\n                \"pages:{ type:query, domain:{\"+toChildren+\"} }\" +\n                \",books:{ type:query, domain:{\"+toParents+\"} }\" +\n                \"}\"\n        )\n        , \"facets=={ count:0\" +\n            \", pages:{count:0}\" +\n            \", books:{count:0}\" +\n            \"}\"\n    );\n\n\n    // test facet on children nested under terms facet on parents\n    client.testJQ(params(\"q\", \"*:*\"\n            , \"json.facet\", \"{\" +\n                \"books:{ type:terms, field:book_s, facet:{ pages:{type:terms, field:v_t, domain:{\"+toChildren+\"}} } }\" +\n                \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", books:{buckets:[{val:A,count:1,pages:{buckets:[]}}\" +\n            \"                 ,{val:B,count:1,pages:{buckets:[{val:y,count:3},{val:x,count:2},{val:z,count:2}]}}\" +\n            \"                 ,{val:C,count:1,pages:{buckets:[{val:x,count:1},{val:y,count:1},{val:z,count:1}]}}\" +\n            \"                 ,{val:D,count:1,pages:{buckets:[]}}\"+\n            \"] }\" +\n            \"}\"\n    );\n\n    // test filter after join\n    client.testJQ(params(p, \"q\", \"*:*\"\n        , \"json.facet\", \"{ \" +\n            \"pages1:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:'*:*'} }\" +\n            \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:'-id:3.1'} }\" +\n            \",books:{type:terms, field:v_t, domain:{\"+toParents+\", filter:'*:*'} }\" +\n            \",books2:{type:terms, field:v_t, domain:{\"+toParents+\", filter:'id:2'} }\" +\n            \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages1:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:z,count:3},{val:x,count:2} ] }\" +\n            \", books:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", books2:{ buckets:[ {val:q,count:1}, {val:w,count:1} ] }\" +\n            \"}\"\n    );\n\n\n    // test other various ways to get filters\n    client.testJQ(params(p, \"q\", \"*:*\", \"f1\",\"-id:3.1\", \"f2\",\"id:2\"\n        , \"json.facet\", \"{ \" +\n            \"pages1:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:[]} }\" +\n            \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:{param:f1} } }\" +\n            \",books:{type:terms, field:v_t, domain:{\"+toParents+\", filter:[{param:q},{param:missing_param}]} }\" +\n            \",books2:{type:terms, field:v_t, domain:{\"+toParents+\", filter:[{param:f2}] } }\" +\n            \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages1:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:z,count:3},{val:x,count:2} ] }\" +\n            \", books:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", books2:{ buckets:[ {val:q,count:1}, {val:w,count:1} ] }\" +\n            \"}\"\n    );\n\n  }\n\n","sourceOld":"  /**\n   * Similar to {@link #testBlockJoin} but uses query time joining.\n   * <p>\n   * (asserts are slightly diff because if a query matches multiple types of documents, blockJoin domain switches\n   * to parent/child domains preserve any existing parent/children from the original domain - eg: when q=*:*)\n   * </p>\n   */\n  public void testQureyJoinBooksAndPages() throws Exception {\n\n    final Client client = Client.localClient();\n\n    final SolrParams p = params(\"rows\",\"0\");\n\n    client.deleteByQuery(\"*:*\", null);\n\n\n    // build up a list of the docs we want to test with\n    List<SolrInputDocument> docsToAdd = new ArrayList<>(10);\n    docsToAdd.add(sdoc(\"id\", \"1\", \"type_s\",\"book\", \"book_s\",\"A\", \"v_t\",\"q\"));\n    \n    docsToAdd.add( sdoc(\"id\", \"2\", \"type_s\",\"book\", \"book_s\",\"B\", \"v_t\",\"q w\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\", \"2.1\", \"type_s\",\"page\", \"page_s\",\"a\", \"v_t\",\"x y z\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\", \"2.2\", \"type_s\",\"page\", \"page_s\",\"b\", \"v_t\",\"x y  \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\",\"2.3\", \"type_s\",\"page\", \"page_s\",\"c\", \"v_t\",\"  y z\" ) );\n\n    docsToAdd.add( sdoc(\"id\", \"3\", \"type_s\",\"book\", \"book_s\",\"C\", \"v_t\",\"q w e\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.1\", \"type_s\",\"page\", \"page_s\",\"d\", \"v_t\",\"x    \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.2\", \"type_s\",\"page\", \"page_s\",\"e\", \"v_t\",\"  y  \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.3\", \"type_s\",\"page\", \"page_s\",\"f\", \"v_t\",\"    z\") );\n\n    docsToAdd.add( sdoc(\"id\", \"4\", \"type_s\",\"book\", \"book_s\",\"D\", \"v_t\",\"e\") );\n    \n    // shuffle the docs since order shouldn't matter\n    Collections.shuffle(docsToAdd, random());\n    for (SolrInputDocument doc : docsToAdd) {\n      client.add(doc, null);\n    }\n    client.commit();\n\n    // the domains we'll be testing, initially setup for block join\n    final String toChildren = \"join: { from:'id', to:'book_id_s' }\";\n    final String toParents = \"join: { from:'book_id_s', to:'id' }\";\n    final String toBogusChildren = \"join: { from:'id', to:'does_not_exist' }\";\n    final String toBogusParents = \"join: { from:'book_id_s', to:'does_not_exist' }\";\n\n    client.testJQ(params(p, \"q\", \"*:*\"\n            , \"json.facet\", \"{ \" +\n                \"pages:{ type:query, domain:{\"+toChildren+\"} , facet:{ x:{field:v_t} } }\" +\n                \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\"} }\" +\n                \",books:{ type:query, domain:{\"+toParents+\"}  , facet:{ x:{field:v_t} } }\" +\n                \",books2:{type:terms, field:v_t, domain:{\"+toParents+\"} }\" +\n                \",pageof3:{ type:query, q:'id:3', facet : { x : { type:terms, field:page_s, domain:{\"+toChildren+\"}}} }\" +\n                \",bookof22:{ type:query, q:'id:2.2', facet : { x : { type:terms, field:book_s, domain:{\"+toParents+\"}}} }\" +\n                \",missing_Parents:{ type:query, domain:{\"+toBogusParents+\"} }\" +\n                \",missing_Children:{ type:query, domain:{\"+toBogusChildren+\"} }\" +\n                \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages:{count:6 , x:{buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ]}  }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", books:{count:2 , x:{buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ]}  }\" +\n            \", books2:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", pageof3:{count:1 , x:{buckets:[ {val:d,count:1},{val:e,count:1},{val:f,count:1} ]}  }\" +\n            \", bookof22:{count:1 , x:{buckets:[ {val:B,count:1} ]}  }\" +\n            \", missing_Parents:{count:0}\" + \n            \", missing_Children:{count:0}\" +\n            \"}\"\n    );\n\n    // no matches in base query\n    client.testJQ(params(\"q\", \"no_match_s:NO_MATCHES\"\n            , \"json.facet\", \"{ processEmpty:true,\" +\n                \"pages:{ type:query, domain:{\"+toChildren+\"} }\" +\n                \",books:{ type:query, domain:{\"+toParents+\"} }\" +\n                \"}\"\n        )\n        , \"facets=={ count:0\" +\n            \", pages:{count:0}\" +\n            \", books:{count:0}\" +\n            \"}\"\n    );\n\n\n    // test facet on children nested under terms facet on parents\n    client.testJQ(params(\"q\", \"*:*\"\n            , \"json.facet\", \"{\" +\n                \"books:{ type:terms, field:book_s, facet:{ pages:{type:terms, field:v_t, domain:{\"+toChildren+\"}} } }\" +\n                \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", books:{buckets:[{val:A,count:1,pages:{buckets:[]}}\" +\n            \"                 ,{val:B,count:1,pages:{buckets:[{val:y,count:3},{val:x,count:2},{val:z,count:2}]}}\" +\n            \"                 ,{val:C,count:1,pages:{buckets:[{val:x,count:1},{val:y,count:1},{val:z,count:1}]}}\" +\n            \"                 ,{val:D,count:1,pages:{buckets:[]}}\"+\n            \"] }\" +\n            \"}\"\n    );\n\n    // test filter after join\n    client.testJQ(params(p, \"q\", \"*:*\"\n        , \"json.facet\", \"{ \" +\n            \"pages1:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:'*:*'} }\" +\n            \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:'-id:3.1'} }\" +\n            \",books:{type:terms, field:v_t, domain:{\"+toParents+\", filter:'*:*'} }\" +\n            \",books2:{type:terms, field:v_t, domain:{\"+toParents+\", filter:'id:2'} }\" +\n            \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages1:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:z,count:3},{val:x,count:2} ] }\" +\n            \", books:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", books2:{ buckets:[ {val:q,count:1}, {val:w,count:1} ] }\" +\n            \"}\"\n    );\n\n\n    // test other various ways to get filters\n    client.testJQ(params(p, \"q\", \"*:*\", \"f1\",\"-id:3.1\", \"f2\",\"id:2\"\n        , \"json.facet\", \"{ \" +\n            \"pages1:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:[]} }\" +\n            \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:{param:f1} } }\" +\n            \",books:{type:terms, field:v_t, domain:{\"+toParents+\", filter:[{param:q},{param:missing_param}]} }\" +\n            \",books2:{type:terms, field:v_t, domain:{\"+toParents+\", filter:[{param:f2}] } }\" +\n            \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages1:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:z,count:3},{val:x,count:2} ] }\" +\n            \", books:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", books2:{ buckets:[ {val:q,count:1}, {val:w,count:1} ] }\" +\n            \"}\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":1,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testQueryJoinBooksAndPages().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testQureyJoinBooksAndPages().mjava","sourceNew":"  /**\n   * Similar to {@link #testBlockJoin} but uses query time joining.\n   * <p>\n   * (asserts are slightly diff because if a query matches multiple types of documents, blockJoin domain switches\n   * to parent/child domains preserve any existing parent/children from the original domain - eg: when q=*:*)\n   * </p>\n   */\n  public void testQueryJoinBooksAndPages() throws Exception {\n\n    final Client client = Client.localClient();\n\n    final SolrParams p = params(\"rows\",\"0\");\n\n    client.deleteByQuery(\"*:*\", null);\n\n\n    // build up a list of the docs we want to test with\n    List<SolrInputDocument> docsToAdd = new ArrayList<>(10);\n    docsToAdd.add(sdoc(\"id\", \"1\", \"type_s\",\"book\", \"book_s\",\"A\", \"v_t\",\"q\"));\n    \n    docsToAdd.add( sdoc(\"id\", \"2\", \"type_s\",\"book\", \"book_s\",\"B\", \"v_t\",\"q w\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\", \"2.1\", \"type_s\",\"page\", \"page_s\",\"a\", \"v_t\",\"x y z\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\", \"2.2\", \"type_s\",\"page\", \"page_s\",\"b\", \"v_t\",\"x y  \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\",\"2.3\", \"type_s\",\"page\", \"page_s\",\"c\", \"v_t\",\"  y z\" ) );\n\n    docsToAdd.add( sdoc(\"id\", \"3\", \"type_s\",\"book\", \"book_s\",\"C\", \"v_t\",\"q w e\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.1\", \"type_s\",\"page\", \"page_s\",\"d\", \"v_t\",\"x    \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.2\", \"type_s\",\"page\", \"page_s\",\"e\", \"v_t\",\"  y  \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.3\", \"type_s\",\"page\", \"page_s\",\"f\", \"v_t\",\"    z\") );\n\n    docsToAdd.add( sdoc(\"id\", \"4\", \"type_s\",\"book\", \"book_s\",\"D\", \"v_t\",\"e\") );\n    \n    // shuffle the docs since order shouldn't matter\n    Collections.shuffle(docsToAdd, random());\n    for (SolrInputDocument doc : docsToAdd) {\n      client.add(doc, null);\n    }\n    client.commit();\n\n    // the domains we'll be testing, initially setup for block join\n    final String toChildren = \"join: { from:'id', to:'book_id_s' }\";\n    final String toParents = \"join: { from:'book_id_s', to:'id' }\";\n    final String toBogusChildren = \"join: { from:'id', to:'does_not_exist_s' }\";\n    final String toBogusParents = \"join: { from:'book_id_s', to:'does_not_exist_s' }\";\n\n    client.testJQ(params(p, \"q\", \"*:*\"\n            , \"json.facet\", \"{ \" +\n                \"pages:{ type:query, domain:{\"+toChildren+\"} , facet:{ x:{field:v_t} } }\" +\n                \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\"} }\" +\n                \",books:{ type:query, domain:{\"+toParents+\"}  , facet:{ x:{field:v_t} } }\" +\n                \",books2:{type:terms, field:v_t, domain:{\"+toParents+\"} }\" +\n                \",pageof3:{ type:query, q:'id:3', facet : { x : { type:terms, field:page_s, domain:{\"+toChildren+\"}}} }\" +\n                \",bookof22:{ type:query, q:'id:2.2', facet : { x : { type:terms, field:book_s, domain:{\"+toParents+\"}}} }\" +\n                \",missing_Parents:{ type:query, domain:{\"+toBogusParents+\"} }\" +\n                \",missing_Children:{ type:query, domain:{\"+toBogusChildren+\"} }\" +\n                \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages:{count:6 , x:{buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ]}  }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", books:{count:2 , x:{buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ]}  }\" +\n            \", books2:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", pageof3:{count:1 , x:{buckets:[ {val:d,count:1},{val:e,count:1},{val:f,count:1} ]}  }\" +\n            \", bookof22:{count:1 , x:{buckets:[ {val:B,count:1} ]}  }\" +\n            \", missing_Parents:{count:0}\" + \n            \", missing_Children:{count:0}\" +\n            \"}\"\n    );\n\n    // no matches in base query\n    client.testJQ(params(\"q\", \"no_match_s:NO_MATCHES\"\n            , \"json.facet\", \"{ processEmpty:true,\" +\n                \"pages:{ type:query, domain:{\"+toChildren+\"} }\" +\n                \",books:{ type:query, domain:{\"+toParents+\"} }\" +\n                \"}\"\n        )\n        , \"facets=={ count:0\" +\n            \", pages:{count:0}\" +\n            \", books:{count:0}\" +\n            \"}\"\n    );\n\n\n    // test facet on children nested under terms facet on parents\n    client.testJQ(params(\"q\", \"*:*\"\n            , \"json.facet\", \"{\" +\n                \"books:{ type:terms, field:book_s, facet:{ pages:{type:terms, field:v_t, domain:{\"+toChildren+\"}} } }\" +\n                \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", books:{buckets:[{val:A,count:1,pages:{buckets:[]}}\" +\n            \"                 ,{val:B,count:1,pages:{buckets:[{val:y,count:3},{val:x,count:2},{val:z,count:2}]}}\" +\n            \"                 ,{val:C,count:1,pages:{buckets:[{val:x,count:1},{val:y,count:1},{val:z,count:1}]}}\" +\n            \"                 ,{val:D,count:1,pages:{buckets:[]}}\"+\n            \"] }\" +\n            \"}\"\n    );\n\n    // test filter after join\n    client.testJQ(params(p, \"q\", \"*:*\"\n        , \"json.facet\", \"{ \" +\n            \"pages1:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:'*:*'} }\" +\n            \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:'-id:3.1'} }\" +\n            \",books:{type:terms, field:v_t, domain:{\"+toParents+\", filter:'*:*'} }\" +\n            \",books2:{type:terms, field:v_t, domain:{\"+toParents+\", filter:'id:2'} }\" +\n            \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages1:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:z,count:3},{val:x,count:2} ] }\" +\n            \", books:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", books2:{ buckets:[ {val:q,count:1}, {val:w,count:1} ] }\" +\n            \"}\"\n    );\n\n\n    // test other various ways to get filters\n    client.testJQ(params(p, \"q\", \"*:*\", \"f1\",\"-id:3.1\", \"f2\",\"id:2\"\n        , \"json.facet\", \"{ \" +\n            \"pages1:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:[]} }\" +\n            \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:{param:f1} } }\" +\n            \",books:{type:terms, field:v_t, domain:{\"+toParents+\", filter:[{param:q},{param:missing_param}]} }\" +\n            \",books2:{type:terms, field:v_t, domain:{\"+toParents+\", filter:[{param:f2}] } }\" +\n            \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages1:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:z,count:3},{val:x,count:2} ] }\" +\n            \", books:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", books2:{ buckets:[ {val:q,count:1}, {val:w,count:1} ] }\" +\n            \"}\"\n    );\n\n  }\n\n","sourceOld":"  /**\n   * Similar to {@link #testBlockJoin} but uses query time joining.\n   * <p>\n   * (asserts are slightly diff because if a query matches multiple types of documents, blockJoin domain switches\n   * to parent/child domains preserve any existing parent/children from the original domain - eg: when q=*:*)\n   * </p>\n   */\n  public void testQureyJoinBooksAndPages() throws Exception {\n\n    final Client client = Client.localClient();\n\n    final SolrParams p = params(\"rows\",\"0\");\n\n    client.deleteByQuery(\"*:*\", null);\n\n\n    // build up a list of the docs we want to test with\n    List<SolrInputDocument> docsToAdd = new ArrayList<>(10);\n    docsToAdd.add(sdoc(\"id\", \"1\", \"type_s\",\"book\", \"book_s\",\"A\", \"v_t\",\"q\"));\n    \n    docsToAdd.add( sdoc(\"id\", \"2\", \"type_s\",\"book\", \"book_s\",\"B\", \"v_t\",\"q w\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\", \"2.1\", \"type_s\",\"page\", \"page_s\",\"a\", \"v_t\",\"x y z\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\", \"2.2\", \"type_s\",\"page\", \"page_s\",\"b\", \"v_t\",\"x y  \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\",\"2.3\", \"type_s\",\"page\", \"page_s\",\"c\", \"v_t\",\"  y z\" ) );\n\n    docsToAdd.add( sdoc(\"id\", \"3\", \"type_s\",\"book\", \"book_s\",\"C\", \"v_t\",\"q w e\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.1\", \"type_s\",\"page\", \"page_s\",\"d\", \"v_t\",\"x    \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.2\", \"type_s\",\"page\", \"page_s\",\"e\", \"v_t\",\"  y  \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.3\", \"type_s\",\"page\", \"page_s\",\"f\", \"v_t\",\"    z\") );\n\n    docsToAdd.add( sdoc(\"id\", \"4\", \"type_s\",\"book\", \"book_s\",\"D\", \"v_t\",\"e\") );\n    \n    // shuffle the docs since order shouldn't matter\n    Collections.shuffle(docsToAdd, random());\n    for (SolrInputDocument doc : docsToAdd) {\n      client.add(doc, null);\n    }\n    client.commit();\n\n    // the domains we'll be testing, initially setup for block join\n    final String toChildren = \"join: { from:'id', to:'book_id_s' }\";\n    final String toParents = \"join: { from:'book_id_s', to:'id' }\";\n    final String toBogusChildren = \"join: { from:'id', to:'does_not_exist' }\";\n    final String toBogusParents = \"join: { from:'book_id_s', to:'does_not_exist' }\";\n\n    client.testJQ(params(p, \"q\", \"*:*\"\n            , \"json.facet\", \"{ \" +\n                \"pages:{ type:query, domain:{\"+toChildren+\"} , facet:{ x:{field:v_t} } }\" +\n                \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\"} }\" +\n                \",books:{ type:query, domain:{\"+toParents+\"}  , facet:{ x:{field:v_t} } }\" +\n                \",books2:{type:terms, field:v_t, domain:{\"+toParents+\"} }\" +\n                \",pageof3:{ type:query, q:'id:3', facet : { x : { type:terms, field:page_s, domain:{\"+toChildren+\"}}} }\" +\n                \",bookof22:{ type:query, q:'id:2.2', facet : { x : { type:terms, field:book_s, domain:{\"+toParents+\"}}} }\" +\n                \",missing_Parents:{ type:query, domain:{\"+toBogusParents+\"} }\" +\n                \",missing_Children:{ type:query, domain:{\"+toBogusChildren+\"} }\" +\n                \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages:{count:6 , x:{buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ]}  }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", books:{count:2 , x:{buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ]}  }\" +\n            \", books2:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", pageof3:{count:1 , x:{buckets:[ {val:d,count:1},{val:e,count:1},{val:f,count:1} ]}  }\" +\n            \", bookof22:{count:1 , x:{buckets:[ {val:B,count:1} ]}  }\" +\n            \", missing_Parents:{count:0}\" + \n            \", missing_Children:{count:0}\" +\n            \"}\"\n    );\n\n    // no matches in base query\n    client.testJQ(params(\"q\", \"no_match_s:NO_MATCHES\"\n            , \"json.facet\", \"{ processEmpty:true,\" +\n                \"pages:{ type:query, domain:{\"+toChildren+\"} }\" +\n                \",books:{ type:query, domain:{\"+toParents+\"} }\" +\n                \"}\"\n        )\n        , \"facets=={ count:0\" +\n            \", pages:{count:0}\" +\n            \", books:{count:0}\" +\n            \"}\"\n    );\n\n\n    // test facet on children nested under terms facet on parents\n    client.testJQ(params(\"q\", \"*:*\"\n            , \"json.facet\", \"{\" +\n                \"books:{ type:terms, field:book_s, facet:{ pages:{type:terms, field:v_t, domain:{\"+toChildren+\"}} } }\" +\n                \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", books:{buckets:[{val:A,count:1,pages:{buckets:[]}}\" +\n            \"                 ,{val:B,count:1,pages:{buckets:[{val:y,count:3},{val:x,count:2},{val:z,count:2}]}}\" +\n            \"                 ,{val:C,count:1,pages:{buckets:[{val:x,count:1},{val:y,count:1},{val:z,count:1}]}}\" +\n            \"                 ,{val:D,count:1,pages:{buckets:[]}}\"+\n            \"] }\" +\n            \"}\"\n    );\n\n    // test filter after join\n    client.testJQ(params(p, \"q\", \"*:*\"\n        , \"json.facet\", \"{ \" +\n            \"pages1:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:'*:*'} }\" +\n            \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:'-id:3.1'} }\" +\n            \",books:{type:terms, field:v_t, domain:{\"+toParents+\", filter:'*:*'} }\" +\n            \",books2:{type:terms, field:v_t, domain:{\"+toParents+\", filter:'id:2'} }\" +\n            \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages1:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:z,count:3},{val:x,count:2} ] }\" +\n            \", books:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", books2:{ buckets:[ {val:q,count:1}, {val:w,count:1} ] }\" +\n            \"}\"\n    );\n\n\n    // test other various ways to get filters\n    client.testJQ(params(p, \"q\", \"*:*\", \"f1\",\"-id:3.1\", \"f2\",\"id:2\"\n        , \"json.facet\", \"{ \" +\n            \"pages1:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:[]} }\" +\n            \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:{param:f1} } }\" +\n            \",books:{type:terms, field:v_t, domain:{\"+toParents+\", filter:[{param:q},{param:missing_param}]} }\" +\n            \",books2:{type:terms, field:v_t, domain:{\"+toParents+\", filter:[{param:f2}] } }\" +\n            \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages1:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:z,count:3},{val:x,count:2} ] }\" +\n            \", books:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", books2:{ buckets:[ {val:q,count:1}, {val:w,count:1} ] }\" +\n            \"}\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58884af1f68e9d61c217c753fbd6266d86a63b14","date":1502363401,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testQueryJoinBooksAndPages().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testQureyJoinBooksAndPages().mjava","sourceNew":"  /**\n   * Similar to {@link #testBlockJoin} but uses query time joining.\n   * <p>\n   * (asserts are slightly diff because if a query matches multiple types of documents, blockJoin domain switches\n   * to parent/child domains preserve any existing parent/children from the original domain - eg: when q=*:*)\n   * </p>\n   */\n  public void testQueryJoinBooksAndPages() throws Exception {\n\n    final Client client = Client.localClient();\n\n    final SolrParams p = params(\"rows\",\"0\");\n\n    client.deleteByQuery(\"*:*\", null);\n\n\n    // build up a list of the docs we want to test with\n    List<SolrInputDocument> docsToAdd = new ArrayList<>(10);\n    docsToAdd.add(sdoc(\"id\", \"1\", \"type_s\",\"book\", \"book_s\",\"A\", \"v_t\",\"q\"));\n    \n    docsToAdd.add( sdoc(\"id\", \"2\", \"type_s\",\"book\", \"book_s\",\"B\", \"v_t\",\"q w\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\", \"2.1\", \"type_s\",\"page\", \"page_s\",\"a\", \"v_t\",\"x y z\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\", \"2.2\", \"type_s\",\"page\", \"page_s\",\"b\", \"v_t\",\"x y  \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\",\"2.3\", \"type_s\",\"page\", \"page_s\",\"c\", \"v_t\",\"  y z\" ) );\n\n    docsToAdd.add( sdoc(\"id\", \"3\", \"type_s\",\"book\", \"book_s\",\"C\", \"v_t\",\"q w e\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.1\", \"type_s\",\"page\", \"page_s\",\"d\", \"v_t\",\"x    \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.2\", \"type_s\",\"page\", \"page_s\",\"e\", \"v_t\",\"  y  \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.3\", \"type_s\",\"page\", \"page_s\",\"f\", \"v_t\",\"    z\") );\n\n    docsToAdd.add( sdoc(\"id\", \"4\", \"type_s\",\"book\", \"book_s\",\"D\", \"v_t\",\"e\") );\n    \n    // shuffle the docs since order shouldn't matter\n    Collections.shuffle(docsToAdd, random());\n    for (SolrInputDocument doc : docsToAdd) {\n      client.add(doc, null);\n    }\n    client.commit();\n\n    // the domains we'll be testing, initially setup for block join\n    final String toChildren = \"join: { from:'id', to:'book_id_s' }\";\n    final String toParents = \"join: { from:'book_id_s', to:'id' }\";\n    final String toBogusChildren = \"join: { from:'id', to:'does_not_exist_s' }\";\n    final String toBogusParents = \"join: { from:'book_id_s', to:'does_not_exist_s' }\";\n\n    client.testJQ(params(p, \"q\", \"*:*\"\n            , \"json.facet\", \"{ \" +\n                \"pages:{ type:query, domain:{\"+toChildren+\"} , facet:{ x:{field:v_t} } }\" +\n                \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\"} }\" +\n                \",books:{ type:query, domain:{\"+toParents+\"}  , facet:{ x:{field:v_t} } }\" +\n                \",books2:{type:terms, field:v_t, domain:{\"+toParents+\"} }\" +\n                \",pageof3:{ type:query, q:'id:3', facet : { x : { type:terms, field:page_s, domain:{\"+toChildren+\"}}} }\" +\n                \",bookof22:{ type:query, q:'id:2.2', facet : { x : { type:terms, field:book_s, domain:{\"+toParents+\"}}} }\" +\n                \",missing_Parents:{ type:query, domain:{\"+toBogusParents+\"} }\" +\n                \",missing_Children:{ type:query, domain:{\"+toBogusChildren+\"} }\" +\n                \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages:{count:6 , x:{buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ]}  }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", books:{count:2 , x:{buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ]}  }\" +\n            \", books2:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", pageof3:{count:1 , x:{buckets:[ {val:d,count:1},{val:e,count:1},{val:f,count:1} ]}  }\" +\n            \", bookof22:{count:1 , x:{buckets:[ {val:B,count:1} ]}  }\" +\n            \", missing_Parents:{count:0}\" + \n            \", missing_Children:{count:0}\" +\n            \"}\"\n    );\n\n    // no matches in base query\n    client.testJQ(params(\"q\", \"no_match_s:NO_MATCHES\"\n            , \"json.facet\", \"{ processEmpty:true,\" +\n                \"pages:{ type:query, domain:{\"+toChildren+\"} }\" +\n                \",books:{ type:query, domain:{\"+toParents+\"} }\" +\n                \"}\"\n        )\n        , \"facets=={ count:0\" +\n            \", pages:{count:0}\" +\n            \", books:{count:0}\" +\n            \"}\"\n    );\n\n\n    // test facet on children nested under terms facet on parents\n    client.testJQ(params(\"q\", \"*:*\"\n            , \"json.facet\", \"{\" +\n                \"books:{ type:terms, field:book_s, facet:{ pages:{type:terms, field:v_t, domain:{\"+toChildren+\"}} } }\" +\n                \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", books:{buckets:[{val:A,count:1,pages:{buckets:[]}}\" +\n            \"                 ,{val:B,count:1,pages:{buckets:[{val:y,count:3},{val:x,count:2},{val:z,count:2}]}}\" +\n            \"                 ,{val:C,count:1,pages:{buckets:[{val:x,count:1},{val:y,count:1},{val:z,count:1}]}}\" +\n            \"                 ,{val:D,count:1,pages:{buckets:[]}}\"+\n            \"] }\" +\n            \"}\"\n    );\n\n    // test filter after join\n    client.testJQ(params(p, \"q\", \"*:*\"\n        , \"json.facet\", \"{ \" +\n            \"pages1:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:'*:*'} }\" +\n            \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:'-id:3.1'} }\" +\n            \",books:{type:terms, field:v_t, domain:{\"+toParents+\", filter:'*:*'} }\" +\n            \",books2:{type:terms, field:v_t, domain:{\"+toParents+\", filter:'id:2'} }\" +\n            \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages1:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:z,count:3},{val:x,count:2} ] }\" +\n            \", books:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", books2:{ buckets:[ {val:q,count:1}, {val:w,count:1} ] }\" +\n            \"}\"\n    );\n\n\n    // test other various ways to get filters\n    client.testJQ(params(p, \"q\", \"*:*\", \"f1\",\"-id:3.1\", \"f2\",\"id:2\"\n        , \"json.facet\", \"{ \" +\n            \"pages1:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:[]} }\" +\n            \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:{param:f1} } }\" +\n            \",books:{type:terms, field:v_t, domain:{\"+toParents+\", filter:[{param:q},{param:missing_param}]} }\" +\n            \",books2:{type:terms, field:v_t, domain:{\"+toParents+\", filter:[{param:f2}] } }\" +\n            \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages1:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:z,count:3},{val:x,count:2} ] }\" +\n            \", books:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", books2:{ buckets:[ {val:q,count:1}, {val:w,count:1} ] }\" +\n            \"}\"\n    );\n\n  }\n\n","sourceOld":"  /**\n   * Similar to {@link #testBlockJoin} but uses query time joining.\n   * <p>\n   * (asserts are slightly diff because if a query matches multiple types of documents, blockJoin domain switches\n   * to parent/child domains preserve any existing parent/children from the original domain - eg: when q=*:*)\n   * </p>\n   */\n  public void testQureyJoinBooksAndPages() throws Exception {\n\n    final Client client = Client.localClient();\n\n    final SolrParams p = params(\"rows\",\"0\");\n\n    client.deleteByQuery(\"*:*\", null);\n\n\n    // build up a list of the docs we want to test with\n    List<SolrInputDocument> docsToAdd = new ArrayList<>(10);\n    docsToAdd.add(sdoc(\"id\", \"1\", \"type_s\",\"book\", \"book_s\",\"A\", \"v_t\",\"q\"));\n    \n    docsToAdd.add( sdoc(\"id\", \"2\", \"type_s\",\"book\", \"book_s\",\"B\", \"v_t\",\"q w\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\", \"2.1\", \"type_s\",\"page\", \"page_s\",\"a\", \"v_t\",\"x y z\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\", \"2.2\", \"type_s\",\"page\", \"page_s\",\"b\", \"v_t\",\"x y  \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"2\", \"id\",\"2.3\", \"type_s\",\"page\", \"page_s\",\"c\", \"v_t\",\"  y z\" ) );\n\n    docsToAdd.add( sdoc(\"id\", \"3\", \"type_s\",\"book\", \"book_s\",\"C\", \"v_t\",\"q w e\") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.1\", \"type_s\",\"page\", \"page_s\",\"d\", \"v_t\",\"x    \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.2\", \"type_s\",\"page\", \"page_s\",\"e\", \"v_t\",\"  y  \") );\n    docsToAdd.add( sdoc(\"book_id_s\", \"3\", \"id\",\"3.3\", \"type_s\",\"page\", \"page_s\",\"f\", \"v_t\",\"    z\") );\n\n    docsToAdd.add( sdoc(\"id\", \"4\", \"type_s\",\"book\", \"book_s\",\"D\", \"v_t\",\"e\") );\n    \n    // shuffle the docs since order shouldn't matter\n    Collections.shuffle(docsToAdd, random());\n    for (SolrInputDocument doc : docsToAdd) {\n      client.add(doc, null);\n    }\n    client.commit();\n\n    // the domains we'll be testing, initially setup for block join\n    final String toChildren = \"join: { from:'id', to:'book_id_s' }\";\n    final String toParents = \"join: { from:'book_id_s', to:'id' }\";\n    final String toBogusChildren = \"join: { from:'id', to:'does_not_exist' }\";\n    final String toBogusParents = \"join: { from:'book_id_s', to:'does_not_exist' }\";\n\n    client.testJQ(params(p, \"q\", \"*:*\"\n            , \"json.facet\", \"{ \" +\n                \"pages:{ type:query, domain:{\"+toChildren+\"} , facet:{ x:{field:v_t} } }\" +\n                \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\"} }\" +\n                \",books:{ type:query, domain:{\"+toParents+\"}  , facet:{ x:{field:v_t} } }\" +\n                \",books2:{type:terms, field:v_t, domain:{\"+toParents+\"} }\" +\n                \",pageof3:{ type:query, q:'id:3', facet : { x : { type:terms, field:page_s, domain:{\"+toChildren+\"}}} }\" +\n                \",bookof22:{ type:query, q:'id:2.2', facet : { x : { type:terms, field:book_s, domain:{\"+toParents+\"}}} }\" +\n                \",missing_Parents:{ type:query, domain:{\"+toBogusParents+\"} }\" +\n                \",missing_Children:{ type:query, domain:{\"+toBogusChildren+\"} }\" +\n                \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages:{count:6 , x:{buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ]}  }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", books:{count:2 , x:{buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ]}  }\" +\n            \", books2:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", pageof3:{count:1 , x:{buckets:[ {val:d,count:1},{val:e,count:1},{val:f,count:1} ]}  }\" +\n            \", bookof22:{count:1 , x:{buckets:[ {val:B,count:1} ]}  }\" +\n            \", missing_Parents:{count:0}\" + \n            \", missing_Children:{count:0}\" +\n            \"}\"\n    );\n\n    // no matches in base query\n    client.testJQ(params(\"q\", \"no_match_s:NO_MATCHES\"\n            , \"json.facet\", \"{ processEmpty:true,\" +\n                \"pages:{ type:query, domain:{\"+toChildren+\"} }\" +\n                \",books:{ type:query, domain:{\"+toParents+\"} }\" +\n                \"}\"\n        )\n        , \"facets=={ count:0\" +\n            \", pages:{count:0}\" +\n            \", books:{count:0}\" +\n            \"}\"\n    );\n\n\n    // test facet on children nested under terms facet on parents\n    client.testJQ(params(\"q\", \"*:*\"\n            , \"json.facet\", \"{\" +\n                \"books:{ type:terms, field:book_s, facet:{ pages:{type:terms, field:v_t, domain:{\"+toChildren+\"}} } }\" +\n                \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", books:{buckets:[{val:A,count:1,pages:{buckets:[]}}\" +\n            \"                 ,{val:B,count:1,pages:{buckets:[{val:y,count:3},{val:x,count:2},{val:z,count:2}]}}\" +\n            \"                 ,{val:C,count:1,pages:{buckets:[{val:x,count:1},{val:y,count:1},{val:z,count:1}]}}\" +\n            \"                 ,{val:D,count:1,pages:{buckets:[]}}\"+\n            \"] }\" +\n            \"}\"\n    );\n\n    // test filter after join\n    client.testJQ(params(p, \"q\", \"*:*\"\n        , \"json.facet\", \"{ \" +\n            \"pages1:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:'*:*'} }\" +\n            \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:'-id:3.1'} }\" +\n            \",books:{type:terms, field:v_t, domain:{\"+toParents+\", filter:'*:*'} }\" +\n            \",books2:{type:terms, field:v_t, domain:{\"+toParents+\", filter:'id:2'} }\" +\n            \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages1:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:z,count:3},{val:x,count:2} ] }\" +\n            \", books:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", books2:{ buckets:[ {val:q,count:1}, {val:w,count:1} ] }\" +\n            \"}\"\n    );\n\n\n    // test other various ways to get filters\n    client.testJQ(params(p, \"q\", \"*:*\", \"f1\",\"-id:3.1\", \"f2\",\"id:2\"\n        , \"json.facet\", \"{ \" +\n            \"pages1:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:[]} }\" +\n            \",pages2:{type:terms, field:v_t, domain:{\"+toChildren+\", filter:{param:f1} } }\" +\n            \",books:{type:terms, field:v_t, domain:{\"+toParents+\", filter:[{param:q},{param:missing_param}]} }\" +\n            \",books2:{type:terms, field:v_t, domain:{\"+toParents+\", filter:[{param:f2}] } }\" +\n            \"}\"\n        )\n        , \"facets=={ count:10\" +\n            \", pages1:{ buckets:[ {val:y,count:4},{val:x,count:3},{val:z,count:3} ] }\" +\n            \", pages2:{ buckets:[ {val:y,count:4},{val:z,count:3},{val:x,count:2} ] }\" +\n            \", books:{ buckets:[ {val:q,count:2},{val:w,count:2},{val:e,count:1} ] }\" +\n            \", books2:{ buckets:[ {val:q,count:1}, {val:w,count:1} ] }\" +\n            \"}\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"58884af1f68e9d61c217c753fbd6266d86a63b14":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","487de3f55283f58d7e02a16993f8be55bbe32061"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","487de3f55283f58d7e02a16993f8be55bbe32061"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"487de3f55283f58d7e02a16993f8be55bbe32061":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["487de3f55283f58d7e02a16993f8be55bbe32061"]},"commit2Childs":{"58884af1f68e9d61c217c753fbd6266d86a63b14":[],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["58884af1f68e9d61c217c753fbd6266d86a63b14","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","487de3f55283f58d7e02a16993f8be55bbe32061"],"487de3f55283f58d7e02a16993f8be55bbe32061":["58884af1f68e9d61c217c753fbd6266d86a63b14","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["58884af1f68e9d61c217c753fbd6266d86a63b14","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}