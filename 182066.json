{"path":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#internalCompile(ParseTree).mjava","commits":[{"id":"d23d4828afa583ebf35b4a541763af6206133458","date":1438931440,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#internalCompile(ParseTree).mjava","pathOld":"/dev/null","sourceNew":"  // internalCompile is used to create an anonymous inner class around the ANTLR listener\n  // to completely hide the implementation details of expression compilation\n  private void internalCompile(ParseTree parseTree) {\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throw new IllegalArgumentException(\n                \"Expected (\" + arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\");\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalArgumentException(\"Unrecognized function call (\" + text + \").\");\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    }.visit(parseTree);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c46fed43ef19dd63a005bf3a81d5e0d0f884268","date":1439122230,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#internalCompile(ParseTree).mjava","sourceNew":"  private void generateClass(ParseTree parseTree, ClassWriter classWriter, Map<String, Integer> externalsMap) {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL | Opcodes.ACC_SYNTHETIC,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EVALUATE_METHOD, null, null, classWriter);\n\n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throw new IllegalArgumentException(\n                \"Expected (\" + arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\");\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalArgumentException(\"Unrecognized function call (\" + text + \").\");\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","sourceOld":"  // internalCompile is used to create an anonymous inner class around the ANTLR listener\n  // to completely hide the implementation details of expression compilation\n  private void internalCompile(ParseTree parseTree) {\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throw new IllegalArgumentException(\n                \"Expected (\" + arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\");\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalArgumentException(\"Unrecognized function call (\" + text + \").\");\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    }.visit(parseTree);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d23d4828afa583ebf35b4a541763af6206133458":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2c46fed43ef19dd63a005bf3a81d5e0d0f884268":["d23d4828afa583ebf35b4a541763af6206133458"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2c46fed43ef19dd63a005bf3a81d5e0d0f884268"]},"commit2Childs":{"d23d4828afa583ebf35b4a541763af6206133458":["2c46fed43ef19dd63a005bf3a81d5e0d0f884268"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d23d4828afa583ebf35b4a541763af6206133458"],"2c46fed43ef19dd63a005bf3a81d5e0d0f884268":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}