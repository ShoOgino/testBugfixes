{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","commits":[{"id":"2d3b450958a83a29a16e492fbff9d094a9a571b6","date":1421525067,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"/dev/null","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0932eb10135843758b2ca508d5aa2b4798aa07f9","date":1426947197,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef","date":1458928975,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06e38ae84477e7a7eacea808dc3de9950fce5ccf","date":1470634560,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5937684381598deda2e4ef4f6f0a55678e5090ee","date":1472586582,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc8f206328a706450934717bec7ccc22ad166fc0","date":1473142172,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      onlyLeaderIndexes = coll.getRealtimeReplicas() == 1;\n    } else {\n      collection = null;\n      onlyLeaderIndexes = false;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      onlyLeaderIndexes = coll.getRealtimeReplicas() == 1;\n    } else {\n      collection = null;\n      onlyLeaderIndexes = false;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      onlyLeaderIndexes = coll.getRealtimeReplicas() == 1;\n    } else {\n      collection = null;\n      onlyLeaderIndexes = false;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n    } else {\n      collection = null;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      onlyLeaderIndexes = coll.getRealtimeReplicas() == 1;\n    } else {\n      collection = null;\n      onlyLeaderIndexes = false;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      onlyLeaderIndexes = coll.getRealtimeReplicas() == 1;\n    } else {\n      collection = null;\n      onlyLeaderIndexes = false;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      onlyLeaderIndexes = coll.getRealtimeReplicas() == 1;\n    } else {\n      collection = null;\n      onlyLeaderIndexes = false;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      onlyLeaderIndexes = coll.getRealtimeReplicas() == 1;\n    } else {\n      collection = null;\n      onlyLeaderIndexes = false;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      onlyLeaderIndexes = coll.getRealtimeReplicas() == 1;\n    } else {\n      collection = null;\n      onlyLeaderIndexes = false;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      onlyLeaderIndexes = coll.getRealtimeReplicas() == 1;\n    } else {\n      collection = null;\n      onlyLeaderIndexes = false;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      onlyLeaderIndexes = coll.getRealtimeReplicas() == 1;\n    } else {\n      collection = null;\n      onlyLeaderIndexes = false;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n    \n    CoreDescriptor coreDesc = req.getCore().getCoreDescriptor();\n    \n    this.zkEnabled  = coreDesc.getCoreContainer().isZooKeeperAware();\n    zkController = req.getCore().getCoreDescriptor().getCoreContainer().getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n\n    cloudDesc = coreDesc.getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      onlyLeaderIndexes = coll.getRealtimeReplicas() == 1;\n    } else {\n      collection = null;\n      onlyLeaderIndexes = false;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      replicaType = cloudDesc.getReplicaType();\n    } else {\n      collection = null;\n      replicaType = Replica.Type.NRT;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      onlyLeaderIndexes = coll.getRealtimeReplicas() == 1;\n    } else {\n      collection = null;\n      onlyLeaderIndexes = false;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      replicaType = cloudDesc.getReplicaType();\n    } else {\n      collection = null;\n      replicaType = Replica.Type.NRT;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      onlyLeaderIndexes = coll.getRealtimeReplicas() == 1;\n    } else {\n      collection = null;\n      onlyLeaderIndexes = false;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"601f914e4448cab7640fecfb5d15f8f2e2af0bf6","date":1508947828,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      replicaType = cloudDesc.getReplicaType();\n    } else {\n      collection = null;\n      replicaType = Replica.Type.NRT;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.updateHandler = req.getCore().getUpdateHandler();\n    this.ulog = updateHandler.getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      replicaType = cloudDesc.getReplicaType();\n    } else {\n      collection = null;\n      replicaType = Replica.Type.NRT;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    this.isOldLIRMode = !\"new\".equals(req.getCore().getCoreDescriptor().getCoreProperty(\"lirVersion\", \"new\"));\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      replicaType = cloudDesc.getReplicaType();\n    } else {\n      collection = null;\n      replicaType = Replica.Type.NRT;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      replicaType = cloudDesc.getReplicaType();\n    } else {\n      collection = null;\n      replicaType = Replica.Type.NRT;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180","date":1539076849,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      replicaType = cloudDesc.getReplicaType();\n    } else {\n      collection = null;\n      replicaType = Replica.Type.NRT;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    this.isOldLIRMode = !\"new\".equals(req.getCore().getCoreDescriptor().getCoreProperty(\"lirVersion\", \"new\"));\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      replicaType = cloudDesc.getReplicaType();\n    } else {\n      collection = null;\n      replicaType = Replica.Type.NRT;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n\n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n\n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      replicaType = cloudDesc.getReplicaType();\n    } else {\n      collection = null;\n      replicaType = Replica.Type.NRT;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n    \n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    \n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      replicaType = cloudDesc.getReplicaType();\n    } else {\n      collection = null;\n      replicaType = Replica.Type.NRT;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7cac1f2920f8057198f04505797cbabf74dd9a97","date":1546884894,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n\n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD,\n          UpdateParams.EXPUNGE_DELETES, UpdateParams.OPTIMIZE, UpdateParams.MAX_OPTIMIZE_SEGMENTS);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n\n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      replicaType = cloudDesc.getReplicaType();\n    } else {\n      collection = null;\n      replicaType = Replica.Type.NRT;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n\n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n\n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      replicaType = cloudDesc.getReplicaType();\n    } else {\n      collection = null;\n      replicaType = Replica.Type.NRT;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e","date":1551802585,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n\n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD,\n          UpdateParams.EXPUNGE_DELETES, UpdateParams.OPTIMIZE, UpdateParams.MAX_OPTIMIZE_SEGMENTS);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n\n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      replicaType = cloudDesc.getReplicaType();\n      DocCollection coll = zkController.getClusterState().getCollectionOrNull(collection);\n      if (coll != null) {\n        // check readOnly property in coll state\n        readOnlyCollection = coll.isReadOnly();\n      }\n    } else {\n      collection = null;\n      replicaType = Replica.Type.NRT;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n\n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD,\n          UpdateParams.EXPUNGE_DELETES, UpdateParams.OPTIMIZE, UpdateParams.MAX_OPTIMIZE_SEGMENTS);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n\n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      replicaType = cloudDesc.getReplicaType();\n    } else {\n      collection = null;\n      replicaType = Replica.Type.NRT;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d70e774cb25c8a8d2c3e5e84200f235f9168d87","date":1553016391,"type":3,"author":"Bar Rotstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger,\n      UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    this.req = req;\n    this.replicaType = computeReplicaType();\n    // version init\n\n    this.ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD,\n          UpdateParams.EXPUNGE_DELETES, UpdateParams.OPTIMIZE, UpdateParams.MAX_OPTIMIZE_SEGMENTS);\n\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger, UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.next = next;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    // version init\n\n    this.ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    this.req = req;\n\n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD,\n          UpdateParams.EXPUNGE_DELETES, UpdateParams.OPTIMIZE, UpdateParams.MAX_OPTIMIZE_SEGMENTS);\n\n    CoreContainer cc = req.getCore().getCoreContainer();\n\n    this.zkEnabled  = cc.isZooKeeperAware();\n    zkController = cc.getZkController();\n    if (zkEnabled) {\n      cmdDistrib = new SolrCmdDistributor(cc.getUpdateShardHandler());\n    }\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n    cloudDesc = req.getCore().getCoreDescriptor().getCloudDescriptor();\n\n    if (cloudDesc != null) {\n      collection = cloudDesc.getCollectionName();\n      replicaType = cloudDesc.getReplicaType();\n      DocCollection coll = zkController.getClusterState().getCollectionOrNull(collection);\n      if (coll != null) {\n        // check readOnly property in coll state\n        readOnlyCollection = coll.isReadOnly();\n      }\n    } else {\n      collection = null;\n      replicaType = Replica.Type.NRT;\n    }\n\n    boolean shouldClone = false;\n    UpdateRequestProcessor nextInChain = next;\n    while (nextInChain != null)  {\n      Class<? extends UpdateRequestProcessor> klass = nextInChain.getClass();\n      if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class\n          && klass != RunUpdateProcessor.class\n          && klass != TolerantUpdateProcessor.class)  {\n        shouldClone = true;\n        break;\n      }\n      nextInChain = nextInChain.next;\n    }\n    cloneRequiredOnLeader = shouldClone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07749612bed4eb54dd05255c1434c301133310c1","date":1554879779,"type":3,"author":"Moshe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#DistributedUpdateProcessor(SolrQueryRequest,SolrQueryResponse,AtomicUpdateDocumentMerger,UpdateRequestProcessor).mjava","sourceNew":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger,\n      UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    this.req = req;\n    this.replicaType = computeReplicaType();\n    // version init\n\n    this.ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD,\n          UpdateParams.EXPUNGE_DELETES, UpdateParams.OPTIMIZE, UpdateParams.MAX_OPTIMIZE_SEGMENTS, ShardParams._ROUTE_);\n\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n  }\n\n","sourceOld":"  /** Specification of AtomicUpdateDocumentMerger is currently experimental.\n   * @lucene.experimental\n   */\n  public DistributedUpdateProcessor(SolrQueryRequest req,\n      SolrQueryResponse rsp, AtomicUpdateDocumentMerger docMerger,\n      UpdateRequestProcessor next) {\n    super(next);\n    this.rsp = rsp;\n    this.docMerger = docMerger;\n    this.idField = req.getSchema().getUniqueKeyField();\n    this.req = req;\n    this.replicaType = computeReplicaType();\n    // version init\n\n    this.ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    this.vinfo = ulog == null ? null : ulog.getVersionInfo();\n    versionsStored = this.vinfo != null && this.vinfo.getVersionField() != null;\n    returnVersions = req.getParams().getBool(UpdateParams.VERSIONS ,false);\n\n    // TODO: better way to get the response, or pass back info to it?\n    // SolrRequestInfo reqInfo = returnVersions ? SolrRequestInfo.getRequestInfo() : null;\n\n    // this should always be used - see filterParams\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist\n      (this.req, UpdateParams.UPDATE_CHAIN, TEST_DISTRIB_SKIP_SERVERS, CommonParams.VERSION_FIELD,\n          UpdateParams.EXPUNGE_DELETES, UpdateParams.OPTIMIZE, UpdateParams.MAX_OPTIMIZE_SEGMENTS);\n\n    //this.rsp = reqInfo != null ? reqInfo.getRsp() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e5fa6615014cd2288fe930f8c8bb726f9504961d"],"84f20f331d8001864545c7021812d8c6509c7593":["601f914e4448cab7640fecfb5d15f8f2e2af0bf6"],"5937684381598deda2e4ef4f6f0a55678e5090ee":["06e38ae84477e7a7eacea808dc3de9950fce5ccf"],"bc8f206328a706450934717bec7ccc22ad166fc0":["06e38ae84477e7a7eacea808dc3de9950fce5ccf","5937684381598deda2e4ef4f6f0a55678e5090ee"],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["84f20f331d8001864545c7021812d8c6509c7593"],"07749612bed4eb54dd05255c1434c301133310c1":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","61c45e99cf6676da48f19d7511c73712ad39402b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["2d3b450958a83a29a16e492fbff9d094a9a571b6","0932eb10135843758b2ca508d5aa2b4798aa07f9"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"],"601f914e4448cab7640fecfb5d15f8f2e2af0bf6":["61c45e99cf6676da48f19d7511c73712ad39402b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["06e38ae84477e7a7eacea808dc3de9950fce5ccf","5937684381598deda2e4ef4f6f0a55678e5090ee"],"0932eb10135843758b2ca508d5aa2b4798aa07f9":["2d3b450958a83a29a16e492fbff9d094a9a571b6"],"be320990bdc77e643388fa801e75017f19289c42":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"ab68488225b6a6c357dda72ed11dedca9914a192":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"7cac1f2920f8057198f04505797cbabf74dd9a97":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"61c45e99cf6676da48f19d7511c73712ad39402b":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["be320990bdc77e643388fa801e75017f19289c42"],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["0932eb10135843758b2ca508d5aa2b4798aa07f9"],"06e38ae84477e7a7eacea808dc3de9950fce5ccf":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["ab68488225b6a6c357dda72ed11dedca9914a192"],"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e":["7cac1f2920f8057198f04505797cbabf74dd9a97"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"2d3b450958a83a29a16e492fbff9d094a9a571b6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef","06e38ae84477e7a7eacea808dc3de9950fce5ccf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["07749612bed4eb54dd05255c1434c301133310c1"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"84f20f331d8001864545c7021812d8c6509c7593":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"],"5937684381598deda2e4ef4f6f0a55678e5090ee":["bc8f206328a706450934717bec7ccc22ad166fc0","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"bc8f206328a706450934717bec7ccc22ad166fc0":[],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"07749612bed4eb54dd05255c1434c301133310c1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["7cac1f2920f8057198f04505797cbabf74dd9a97"],"601f914e4448cab7640fecfb5d15f8f2e2af0bf6":["84f20f331d8001864545c7021812d8c6509c7593"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2d3b450958a83a29a16e492fbff9d094a9a571b6"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"0932eb10135843758b2ca508d5aa2b4798aa07f9":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"be320990bdc77e643388fa801e75017f19289c42":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e5fa6615014cd2288fe930f8c8bb726f9504961d"],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","601f914e4448cab7640fecfb5d15f8f2e2af0bf6"],"7cac1f2920f8057198f04505797cbabf74dd9a97":["fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["06e38ae84477e7a7eacea808dc3de9950fce5ccf","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"06e38ae84477e7a7eacea808dc3de9950fce5ccf":["5937684381598deda2e4ef4f6f0a55678e5090ee","bc8f206328a706450934717bec7ccc22ad166fc0","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["61c45e99cf6676da48f19d7511c73712ad39402b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"2d3b450958a83a29a16e492fbff9d094a9a571b6":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0932eb10135843758b2ca508d5aa2b4798aa07f9"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["07749612bed4eb54dd05255c1434c301133310c1"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["bc8f206328a706450934717bec7ccc22ad166fc0","e9017cf144952056066919f1ebc7897ff9bd71b1","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}