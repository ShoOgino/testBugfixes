{"path":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","commits":[{"id":"163fe85a71d778fd2b7747f65ca27b54829e2e57","date":1279898785,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","pathOld":"/dev/null","sourceNew":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similary,we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != fieldInfo.name) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b103252dee6afa1b6d7a622c773d178788eb85a","date":1280180143,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","pathOld":"/dev/null","sourceNew":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similary,we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != fieldInfo.name) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","pathOld":"/dev/null","sourceNew":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similary,we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != fieldInfo.name) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7235f072992928845d8cfd2dfc1c90362360e1e","date":1296426876,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","sourceNew":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similarly, we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != fieldInfo.name) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","sourceOld":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similary,we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != fieldInfo.name) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","sourceNew":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similarly, we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != fieldInfo.name) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","sourceOld":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similary,we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != fieldInfo.name) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","sourceNew":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similarly, we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != fieldInfo.name) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","sourceOld":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similary,we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != fieldInfo.name) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","date":1308670974,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","sourceNew":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similarly, we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != internedFieldName) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","sourceOld":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similarly, we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != fieldInfo.name) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","sourceNew":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similarly, we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != internedFieldName) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","sourceOld":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similarly, we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != fieldInfo.name) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","sourceNew":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similarly, we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != internedFieldName) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","sourceOld":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similarly, we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != fieldInfo.name) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#surrogateDance().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#surrogateDance().mjava","sourceNew":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similarly, we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != internedFieldName) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","sourceOld":"    private void surrogateDance() throws IOException {\n\n      if (!unicodeSortOrder) {\n        return;\n      }\n\n      // We are invoked after TIS.next() (by UTF16 order) to\n      // possibly seek to a different \"next\" (by unicode\n      // order) term.\n\n      // We scan only the \"delta\" from the last term to the\n      // current term, in UTF8 bytes.  We look at 1) the bytes\n      // stripped from the prior term, and then 2) the bytes\n      // appended to that prior term's prefix.\n    \n      // We don't care about specific UTF8 sequences, just\n      // the \"category\" of the UTF16 character.  Category S\n      // is a high/low surrogate pair (it non-BMP).\n      // Category E is any BMP char > UNI_SUR_LOW_END (and <\n      // U+FFFF). Category A is the rest (any unicode char\n      // <= UNI_SUR_HIGH_START).\n\n      // The core issue is that pre-flex indices sort the\n      // characters as ASE, while flex must sort as AES.  So\n      // when scanning, when we hit S, we must 1) seek\n      // forward to E and enum the terms there, then 2) seek\n      // back to S and enum all terms there, then 3) seek to\n      // after E.  Three different seek points (1, 2, 3).\n    \n      // We can easily detect S in UTF8: if a byte has\n      // prefix 11110 (0xf0), then that byte and the\n      // following 3 bytes encode a single unicode codepoint\n      // in S.  Similarly, we can detect E: if a byte has\n      // prefix 1110111 (0xee), then that byte and the\n      // following 2 bytes encode a single unicode codepoint\n      // in E.\n\n      // Note that this is really a recursive process --\n      // maybe the char at pos 2 needs to dance, but any\n      // point in its dance, suddenly pos 4 needs to dance\n      // so you must finish pos 4 before returning to pos\n      // 2.  But then during pos 4's dance maybe pos 7 needs\n      // to dance, etc.  However, despite being recursive,\n      // we don't need to hold any state because the state\n      // can always be derived by looking at prior term &\n      // current term.\n\n      // TODO: can we avoid this copy?\n      if (termEnum.term() == null || termEnum.term().field() != internedFieldName) {\n        scratchTerm.length = 0;\n      } else {\n        scratchTerm.copy(termEnum.term().bytes());\n      }\n      \n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  dance\");\n        System.out.println(\"    prev=\" + UnicodeUtil.toHexString(prevTerm.utf8ToString()));\n        System.out.println(\"         \" + prevTerm.toString());\n        System.out.println(\"    term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()));\n        System.out.println(\"         \" + scratchTerm.toString());\n      }\n\n      // This code assumes TermInfosReader/SegmentTermEnum\n      // always use BytesRef.offset == 0\n      assert prevTerm.offset == 0;\n      assert scratchTerm.offset == 0;\n\n      // Need to loop here because we may need to do multiple\n      // pops, and possibly a continue in the end, ie:\n      //\n      //  cont\n      //  pop, cont\n      //  pop, pop, cont\n      //  <nothing>\n      //\n\n      while(true) {\n        if (doContinue()) {\n          break;\n        } else {\n          if (!doPop()) {\n            break;\n          }\n        }\n      }\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  finish bmp ends\");\n      }\n\n      doPushes();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4b103252dee6afa1b6d7a622c773d178788eb85a"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","163fe85a71d778fd2b7747f65ca27b54829e2e57"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["c7235f072992928845d8cfd2dfc1c90362360e1e"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["4b103252dee6afa1b6d7a622c773d178788eb85a","c7235f072992928845d8cfd2dfc1c90362360e1e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c7235f072992928845d8cfd2dfc1c90362360e1e":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"2553b00f699380c64959ccb27991289aae87be2e":["c7235f072992928845d8cfd2dfc1c90362360e1e","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["c7235f072992928845d8cfd2dfc1c90362360e1e","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["3242a09f703274d3b9283f2064a1a33064b53a1b","c7235f072992928845d8cfd2dfc1c90362360e1e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b91922b55d15444d554721b352861d028eb8278"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["3242a09f703274d3b9283f2064a1a33064b53a1b","29ef99d61cda9641b6250bf9567329a6e65f901d","c7235f072992928845d8cfd2dfc1c90362360e1e"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["7b91922b55d15444d554721b352861d028eb8278","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3242a09f703274d3b9283f2064a1a33064b53a1b","4b103252dee6afa1b6d7a622c773d178788eb85a","163fe85a71d778fd2b7747f65ca27b54829e2e57"],"c7235f072992928845d8cfd2dfc1c90362360e1e":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","29ef99d61cda9641b6250bf9567329a6e65f901d","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"2553b00f699380c64959ccb27991289aae87be2e":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}