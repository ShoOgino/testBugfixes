{"path":"src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","commits":[{"id":"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76","date":1204055227,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"/dev/null","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.rsp.getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.rsp.getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.shard);\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.shard;\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insert(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0e69935771ba8cb2303a86bf8a42be7861eaf1da","ae56db85dd1cd5b93e54f4caddb9f443b19da009","ae56db85dd1cd5b93e54f4caddb9f443b19da009","ae56db85dd1cd5b93e54f4caddb9f443b19da009"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"db25c1f61b5ae826f10777da6551a832703967d5","date":1215306972,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.rsp.getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.rsp.getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.shard);\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.shard;\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insert(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.rsp.getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.rsp.getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.shard);\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.shard;\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insert(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e69935771ba8cb2303a86bf8a42be7861eaf1da","date":1216694040,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insert(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.rsp.getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.rsp.getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.shard);\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.shard;\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insert(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef28ac95f5f85bbf872801277448c0924b0a6827","date":1268600312,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insert(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ef28ac95f5f85bbf872801277448c0924b0a6827":["0e69935771ba8cb2303a86bf8a42be7861eaf1da"],"0e69935771ba8cb2303a86bf8a42be7861eaf1da":["db25c1f61b5ae826f10777da6551a832703967d5"],"db25c1f61b5ae826f10777da6551a832703967d5":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"ad94625fb8d088209f46650c8097196fec67f00c":["ef28ac95f5f85bbf872801277448c0924b0a6827"],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"ef28ac95f5f85bbf872801277448c0924b0a6827":["ad94625fb8d088209f46650c8097196fec67f00c"],"0e69935771ba8cb2303a86bf8a42be7861eaf1da":["ef28ac95f5f85bbf872801277448c0924b0a6827"],"db25c1f61b5ae826f10777da6551a832703967d5":["0e69935771ba8cb2303a86bf8a42be7861eaf1da"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":["db25c1f61b5ae826f10777da6551a832703967d5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}