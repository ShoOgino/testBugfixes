{"path":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","commits":[{"id":"c5cc22ce99f9ec86f1d1e55d36aaefac498ada97","date":1458507332,"type":0,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable)) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/int[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a69ac62082cc10ebd9c5d0ffda17b4de2c248408"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5","date":1465691899,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","sourceNew":"  @Test\n  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable)) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/int[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","sourceOld":"  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable)) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/int[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","sourceNew":"  @Test\n  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable)) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/int[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","sourceOld":"  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable)) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/int[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a71f63026529f3c1f03cfdd664910873ab2369ae","date":1497543264,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","sourceNew":"  @Test\n  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable)) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/str[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id_i asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable)) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/int[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","sourceNew":"  @Test\n  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable)) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/str[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id_i asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable)) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/int[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","sourceNew":"  @Test\n  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable)) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/str[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id_i asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable)) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/int[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a69ac62082cc10ebd9c5d0ffda17b4de2c248408","date":1501113998,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","sourceNew":"  @Test\n  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable || (min.equals(\"*\") && val == negativeInfinity[i])) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable || (max.equals(\"*\") && val == positiveInfinity[i]))) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/str[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id_i asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable)) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/str[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id_i asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","bugFix":["c5cc22ce99f9ec86f1d1e55d36aaefac498ada97"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","sourceNew":"  @Test\n  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable || (min.equals(\"*\") && val == negativeInfinity[i])) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable || (max.equals(\"*\") && val == positiveInfinity[i]))) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/str[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id_i asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable)) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/str[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id_i asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/DocValuesTest#testFloatAndDoubleRangeQueryRandom().mjava","sourceNew":"  @Test\n  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: {}\", values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable || (min.equals(\"*\") && val == negativeInfinity[i])) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable || (max.equals(\"*\") && val == positiveInfinity[i]))) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/str[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: {}\", tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id_i asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testFloatAndDoubleRangeQueryRandom() throws Exception {\n\n    String fieldName[] = new String[] {\"floatdv\", \"doubledv\"};\n    \n    Number largestNegative[] = new Number[] {0f-Float.MIN_NORMAL, 0f-Double.MIN_NORMAL};\n    Number smallestPositive[] = new Number[] {Float.MIN_NORMAL, Double.MIN_NORMAL};\n    Number positiveInfinity[] = new Number[] {Float.POSITIVE_INFINITY, Double.POSITIVE_INFINITY};\n    Number negativeInfinity[] = new Number[] {Float.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY};\n    Number largestValue[] = new Number[] {Float.MAX_VALUE, Double.MAX_VALUE};\n    Number zero[] = new Number[] {0f, 0d};\n    Function<Supplier<Number>,Number> noNaN = (next)\n        -> { Number num; while (String.valueOf(num = next.get()).equals(\"NaN\")); return num; };\n    List<Supplier<Number>> nextRandNoNaN = Arrays.asList(\n        () -> noNaN.apply(() -> Float.intBitsToFloat(random().nextInt())),\n        () -> noNaN.apply(() -> Double.longBitsToDouble(random().nextLong())));\n    List<Function<Number,Long>> toSortableLong = Arrays.asList(\n        (num) -> (long)NumericUtils.floatToSortableInt(num.floatValue()),\n        (num) -> NumericUtils.doubleToSortableLong(num.doubleValue()));\n\n    // Number minusZero[] = new Number[] {-0f, -0d}; // -0 == 0, so we should not treat them differently (and we should not guarantee that sign is preserved... we should be able to index both as 0)\n\n    for (int i=0; i<fieldName.length; i++) {\n      assertU(delQ(\"*:*\"));\n      commit();\n\n      Number specialValues[] = new Number[] {largestNegative[i], smallestPositive[i], negativeInfinity[i], \n          largestValue[i], positiveInfinity[i], zero[i]};\n\n      List<Number> values = new ArrayList<>();\n      int numDocs = 1 + random().nextInt(10);\n      for (int j=0; j<numDocs; j++) {\n        \n        if (random().nextInt(100) < 5) { // Add a boundary value with 5% probability\n          values.add(specialValues[random().nextInt(specialValues.length)]);\n        } else \n        {\n          if (fieldName[i].equals(\"floatdv\")) { // Add random values with 95% probability\n            values.add(Float.intBitsToFloat(random().nextInt()));\n          } else {\n            values.add(Double.longBitsToDouble(random().nextLong()));\n          }\n        }\n      }\n      // Indexing\n      for (int j=0; j<values.size(); j++) {\n        assertU(adoc(\"id\", String.valueOf(j+1), fieldName[i], String.valueOf(values.get(j))));\n      }\n      assertU(commit());\n\n      log.info(\"Indexed values: \"+values);\n      // Querying\n      int numQueries = 10000;\n      for (int j=0; j<numQueries; j++) {\n        boolean minInclusive = random().nextBoolean();\n        boolean maxInclusive = random().nextBoolean();\n\n        Number minVal, maxVal;\n        String min = String.valueOf(minVal = nextRandNoNaN.get(i).get());\n        String max = String.valueOf(maxVal = nextRandNoNaN.get(i).get());\n\n        // randomly use boundary values for min, 15% of the time\n        int r = random().nextInt(100);\n        if (r<5) {\n          minVal = negativeInfinity[i]; min = \"*\";\n        } else if (r<10) {\n          minVal = specialValues[random().nextInt(specialValues.length)]; min = String.valueOf(minVal);\n        } else if (r<15) {\n          minVal = values.get(random().nextInt(values.size())); min = String.valueOf(minVal);\n        }\n\n        // randomly use boundary values for max, 15% of the time\n        r = random().nextInt(100);\n        if (r<5) {\n          maxVal = positiveInfinity[i]; max = \"*\";\n        } else if (r<10) {\n            maxVal = specialValues[random().nextInt(specialValues.length)]; max = String.valueOf(maxVal);\n        } else if (r<15) {\n          // Don't pick a NaN for the range query\n          Number tmp = values.get(random().nextInt(values.size()));\n          if (!Double.isNaN(tmp.doubleValue()) && !Float.isNaN(tmp.floatValue())) {\n            maxVal = tmp; max = String.valueOf(maxVal);\n          }\n        }\n\n        List<String> tests = new ArrayList<>();\n        int counter = 0;\n        \n        for (int k=0; k<values.size(); k++) {\n          Number val = values.get(k);\n          long valSortable = toSortableLong.get(i).apply(val);\n          long minSortable = toSortableLong.get(i).apply(minVal);\n          long maxSortable = toSortableLong.get(i).apply(maxVal);\n          \n          if((minInclusive && minSortable<=valSortable || !minInclusive && minSortable<valSortable || (min.equals(\"*\") && val == negativeInfinity[i])) &&\n              (maxInclusive && maxSortable>=valSortable || !maxInclusive && maxSortable>valSortable || (max.equals(\"*\") && val == positiveInfinity[i]))) {\n            counter++;\n            tests.add(\"//result/doc[\"+counter+\"]/str[@name='id'][.=\"+(k+1)+\"]\");\n            tests.add(\"//result/doc[\"+counter+\"]/float[@name='score'][.=1.0]\");\n          }\n        }\n\n        tests.add(0, \"//*[@numFound='\"+counter+\"']\");\n\n        String testsArr[] = new String[tests.size()];\n        for (int k=0; k<tests.size(); k++) {\n          testsArr[k] = tests.get(k);\n        }\n        log.info(\"Expected: \"+tests);\n        assertQ(req(\"q\", fieldName[i] + \":\" + (minInclusive? '[': '{') + min + \" TO \" + max + (maxInclusive? ']': '}'),\n                         \"sort\", \"id_i asc\", \"fl\", \"id,\"+fieldName[i]+\",score\"),\n            testsArr);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","a69ac62082cc10ebd9c5d0ffda17b4de2c248408"],"7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5":["c5cc22ce99f9ec86f1d1e55d36aaefac498ada97"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a71f63026529f3c1f03cfdd664910873ab2369ae":["7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5"],"a69ac62082cc10ebd9c5d0ffda17b4de2c248408":["28288370235ed02234a64753cdbf0c6ec096304a"],"c5cc22ce99f9ec86f1d1e55d36aaefac498ada97":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["a69ac62082cc10ebd9c5d0ffda17b4de2c248408"],"28288370235ed02234a64753cdbf0c6ec096304a":["7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5","a71f63026529f3c1f03cfdd664910873ab2369ae"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5","a71f63026529f3c1f03cfdd664910873ab2369ae"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["c5cc22ce99f9ec86f1d1e55d36aaefac498ada97","7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5":["a71f63026529f3c1f03cfdd664910873ab2369ae","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c5cc22ce99f9ec86f1d1e55d36aaefac498ada97"],"a71f63026529f3c1f03cfdd664910873ab2369ae":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"a69ac62082cc10ebd9c5d0ffda17b4de2c248408":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","a966532d92cf9ba2856f15a8140151bb6b518e4b"],"c5cc22ce99f9ec86f1d1e55d36aaefac498ada97":["7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"28288370235ed02234a64753cdbf0c6ec096304a":["a69ac62082cc10ebd9c5d0ffda17b4de2c248408"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}