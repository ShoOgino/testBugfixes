{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.PathSegment#pathLinearDistance(GeoPoint).mjava","commits":[{"id":"851e4197476b684154a7b65f996f535522e67400","date":1428926498,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.PathSegment#pathLinearDistance(GeoPoint).mjava","pathOld":"/dev/null","sourceNew":"        public double pathLinearDistance(GeoPoint point)\n        {\n            if (!isWithin(point))\n                return Double.MAX_VALUE;\n\n            // We have a normalized connecting plane.\n            // First, compute the perpendicular plane.\n            // Want no allocations or expensive operations!  so we do this the hard way\n            double perpX = normalizedConnectingPlane.y * point.z - normalizedConnectingPlane.z * point.y;\n            double perpY = normalizedConnectingPlane.z * point.x - normalizedConnectingPlane.x * point.z;\n            double perpZ = normalizedConnectingPlane.x * point.y - normalizedConnectingPlane.y * point.x;\n\n            // If we have a degenerate line, then just compute the normal distance from point x to the start\n            if (Math.abs(perpX) < 1e-10 && Math.abs(perpY) < 1e-10 && Math.abs(perpZ) < 1e-10)\n                return point.linearDistance(start);\n\n            // Next, we need the vector of the line, which is the cross product of the normalized connecting plane\n            // and the perpendicular plane that we just calculated.\n            double lineX = normalizedConnectingPlane.y * perpZ - normalizedConnectingPlane.z * perpY;\n            double lineY = normalizedConnectingPlane.z * perpX - normalizedConnectingPlane.x * perpZ;\n            double lineZ = normalizedConnectingPlane.x * perpY - normalizedConnectingPlane.y * perpX;\n            \n            // Now, compute a normalization factor\n            double normalizer = 1.0/Math.sqrt(lineX * lineX + lineY * lineY + lineZ * lineZ);\n            \n            // Pick which point by using bounding planes\n            double normLineX = lineX * normalizer;\n            double normLineY = lineY * normalizer;\n            double normLineZ = lineZ * normalizer;\n            if (!startCutoffPlane.isWithin(normLineX,normLineY,normLineZ) ||\n              !endCutoffPlane.isWithin(normLineX,normLineY,normLineZ))\n            {\n                normLineX = -normLineX;\n                normLineY = -normLineY;\n                normLineZ = -normLineZ;\n            }\n            \n            // Compute linear distance for the two points\n            return point.linearDistance(normLineX,normLineY,normLineZ) + start.linearDistance(normLineX,normLineY,normLineZ);\n        }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0fb9dbed1415914caa27460f8abb7afadaa61451","date":1429504289,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.PathSegment#pathLinearDistance(GeoPoint).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.PathSegment#pathLinearDistance(GeoPoint).mjava","sourceNew":"        public double pathLinearDistance(final GeoPoint point)\n        {\n            if (!isWithin(point))\n                return Double.MAX_VALUE;\n\n            // We have a normalized connecting plane.\n            // First, compute the perpendicular plane.\n            // Want no allocations or expensive operations!  so we do this the hard way\n            final double perpX = normalizedConnectingPlane.y * point.z - normalizedConnectingPlane.z * point.y;\n            final double perpY = normalizedConnectingPlane.z * point.x - normalizedConnectingPlane.x * point.z;\n            final double perpZ = normalizedConnectingPlane.x * point.y - normalizedConnectingPlane.y * point.x;\n\n            // If we have a degenerate line, then just compute the normal distance from point x to the start\n            if (Math.abs(perpX) < 1e-10 && Math.abs(perpY) < 1e-10 && Math.abs(perpZ) < 1e-10)\n                return point.linearDistance(start);\n\n            // Next, we need the vector of the line, which is the cross product of the normalized connecting plane\n            // and the perpendicular plane that we just calculated.\n            final double lineX = normalizedConnectingPlane.y * perpZ - normalizedConnectingPlane.z * perpY;\n            final double lineY = normalizedConnectingPlane.z * perpX - normalizedConnectingPlane.x * perpZ;\n            final double lineZ = normalizedConnectingPlane.x * perpY - normalizedConnectingPlane.y * perpX;\n            \n            // Now, compute a normalization factor\n            final double normalizer = 1.0/Math.sqrt(lineX * lineX + lineY * lineY + lineZ * lineZ);\n            \n            // Pick which point by using bounding planes\n            double normLineX = lineX * normalizer;\n            double normLineY = lineY * normalizer;\n            double normLineZ = lineZ * normalizer;\n            if (!startCutoffPlane.isWithin(normLineX,normLineY,normLineZ) ||\n              !endCutoffPlane.isWithin(normLineX,normLineY,normLineZ))\n            {\n                normLineX = -normLineX;\n                normLineY = -normLineY;\n                normLineZ = -normLineZ;\n            }\n            \n            // Compute linear distance for the two points\n            return point.linearDistance(normLineX,normLineY,normLineZ) + start.linearDistance(normLineX,normLineY,normLineZ);\n        }\n\n","sourceOld":"        public double pathLinearDistance(GeoPoint point)\n        {\n            if (!isWithin(point))\n                return Double.MAX_VALUE;\n\n            // We have a normalized connecting plane.\n            // First, compute the perpendicular plane.\n            // Want no allocations or expensive operations!  so we do this the hard way\n            double perpX = normalizedConnectingPlane.y * point.z - normalizedConnectingPlane.z * point.y;\n            double perpY = normalizedConnectingPlane.z * point.x - normalizedConnectingPlane.x * point.z;\n            double perpZ = normalizedConnectingPlane.x * point.y - normalizedConnectingPlane.y * point.x;\n\n            // If we have a degenerate line, then just compute the normal distance from point x to the start\n            if (Math.abs(perpX) < 1e-10 && Math.abs(perpY) < 1e-10 && Math.abs(perpZ) < 1e-10)\n                return point.linearDistance(start);\n\n            // Next, we need the vector of the line, which is the cross product of the normalized connecting plane\n            // and the perpendicular plane that we just calculated.\n            double lineX = normalizedConnectingPlane.y * perpZ - normalizedConnectingPlane.z * perpY;\n            double lineY = normalizedConnectingPlane.z * perpX - normalizedConnectingPlane.x * perpZ;\n            double lineZ = normalizedConnectingPlane.x * perpY - normalizedConnectingPlane.y * perpX;\n            \n            // Now, compute a normalization factor\n            double normalizer = 1.0/Math.sqrt(lineX * lineX + lineY * lineY + lineZ * lineZ);\n            \n            // Pick which point by using bounding planes\n            double normLineX = lineX * normalizer;\n            double normLineY = lineY * normalizer;\n            double normLineZ = lineZ * normalizer;\n            if (!startCutoffPlane.isWithin(normLineX,normLineY,normLineZ) ||\n              !endCutoffPlane.isWithin(normLineX,normLineY,normLineZ))\n            {\n                normLineX = -normLineX;\n                normLineY = -normLineY;\n                normLineZ = -normLineZ;\n            }\n            \n            // Compute linear distance for the two points\n            return point.linearDistance(normLineX,normLineY,normLineZ) + start.linearDistance(normLineX,normLineY,normLineZ);\n        }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7aca5c321bc9760dbfc9cefcc9d648e946b4615e","date":1429714020,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.PathSegment#pathLinearDistance(GeoPoint).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.PathSegment#pathLinearDistance(GeoPoint).mjava","sourceNew":"        public double pathLinearDistance(final GeoPoint point)\n        {\n            if (!isWithin(point))\n                return Double.MAX_VALUE;\n\n            // We have a normalized connecting plane.\n            // First, compute the perpendicular plane.\n            // Want no allocations or expensive operations!  so we do this the hard way\n            final double perpX = normalizedConnectingPlane.y * point.z - normalizedConnectingPlane.z * point.y;\n            final double perpY = normalizedConnectingPlane.z * point.x - normalizedConnectingPlane.x * point.z;\n            final double perpZ = normalizedConnectingPlane.x * point.y - normalizedConnectingPlane.y * point.x;\n\n            // If we have a degenerate line, then just compute the normal distance from point x to the start\n            if (Math.abs(perpX) < Vector.MINIMUM_RESOLUTION && Math.abs(perpY) < Vector.MINIMUM_RESOLUTION && Math.abs(perpZ) < Vector.MINIMUM_RESOLUTION)\n                return point.linearDistance(start);\n\n            // Next, we need the vector of the line, which is the cross product of the normalized connecting plane\n            // and the perpendicular plane that we just calculated.\n            final double lineX = normalizedConnectingPlane.y * perpZ - normalizedConnectingPlane.z * perpY;\n            final double lineY = normalizedConnectingPlane.z * perpX - normalizedConnectingPlane.x * perpZ;\n            final double lineZ = normalizedConnectingPlane.x * perpY - normalizedConnectingPlane.y * perpX;\n            \n            // Now, compute a normalization factor\n            final double normalizer = 1.0/Math.sqrt(lineX * lineX + lineY * lineY + lineZ * lineZ);\n            \n            // Pick which point by using bounding planes\n            double normLineX = lineX * normalizer;\n            double normLineY = lineY * normalizer;\n            double normLineZ = lineZ * normalizer;\n            if (!startCutoffPlane.isWithin(normLineX,normLineY,normLineZ) ||\n              !endCutoffPlane.isWithin(normLineX,normLineY,normLineZ))\n            {\n                normLineX = -normLineX;\n                normLineY = -normLineY;\n                normLineZ = -normLineZ;\n            }\n            \n            // Compute linear distance for the two points\n            return point.linearDistance(normLineX,normLineY,normLineZ) + start.linearDistance(normLineX,normLineY,normLineZ);\n        }\n\n","sourceOld":"        public double pathLinearDistance(final GeoPoint point)\n        {\n            if (!isWithin(point))\n                return Double.MAX_VALUE;\n\n            // We have a normalized connecting plane.\n            // First, compute the perpendicular plane.\n            // Want no allocations or expensive operations!  so we do this the hard way\n            final double perpX = normalizedConnectingPlane.y * point.z - normalizedConnectingPlane.z * point.y;\n            final double perpY = normalizedConnectingPlane.z * point.x - normalizedConnectingPlane.x * point.z;\n            final double perpZ = normalizedConnectingPlane.x * point.y - normalizedConnectingPlane.y * point.x;\n\n            // If we have a degenerate line, then just compute the normal distance from point x to the start\n            if (Math.abs(perpX) < 1e-10 && Math.abs(perpY) < 1e-10 && Math.abs(perpZ) < 1e-10)\n                return point.linearDistance(start);\n\n            // Next, we need the vector of the line, which is the cross product of the normalized connecting plane\n            // and the perpendicular plane that we just calculated.\n            final double lineX = normalizedConnectingPlane.y * perpZ - normalizedConnectingPlane.z * perpY;\n            final double lineY = normalizedConnectingPlane.z * perpX - normalizedConnectingPlane.x * perpZ;\n            final double lineZ = normalizedConnectingPlane.x * perpY - normalizedConnectingPlane.y * perpX;\n            \n            // Now, compute a normalization factor\n            final double normalizer = 1.0/Math.sqrt(lineX * lineX + lineY * lineY + lineZ * lineZ);\n            \n            // Pick which point by using bounding planes\n            double normLineX = lineX * normalizer;\n            double normLineY = lineY * normalizer;\n            double normLineZ = lineZ * normalizer;\n            if (!startCutoffPlane.isWithin(normLineX,normLineY,normLineZ) ||\n              !endCutoffPlane.isWithin(normLineX,normLineY,normLineZ))\n            {\n                normLineX = -normLineX;\n                normLineY = -normLineY;\n                normLineZ = -normLineZ;\n            }\n            \n            // Compute linear distance for the two points\n            return point.linearDistance(normLineX,normLineY,normLineZ) + start.linearDistance(normLineX,normLineY,normLineZ);\n        }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2997acf74723385bd84aff1ea0b12af4aefde77","date":1430745542,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.PathSegment#pathLinearDistance(GeoPoint).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.PathSegment#pathLinearDistance(GeoPoint).mjava","sourceNew":"    public double pathLinearDistance(final GeoPoint point) {\n      if (!isWithin(point))\n        return Double.MAX_VALUE;\n\n      // We have a normalized connecting plane.\n      // First, compute the perpendicular plane.\n      // Want no allocations or expensive operations!  so we do this the hard way\n      final double perpX = normalizedConnectingPlane.y * point.z - normalizedConnectingPlane.z * point.y;\n      final double perpY = normalizedConnectingPlane.z * point.x - normalizedConnectingPlane.x * point.z;\n      final double perpZ = normalizedConnectingPlane.x * point.y - normalizedConnectingPlane.y * point.x;\n\n      // If we have a degenerate line, then just compute the normal distance from point x to the start\n      if (Math.abs(perpX) < Vector.MINIMUM_RESOLUTION && Math.abs(perpY) < Vector.MINIMUM_RESOLUTION && Math.abs(perpZ) < Vector.MINIMUM_RESOLUTION)\n        return point.linearDistance(start);\n\n      // Next, we need the vector of the line, which is the cross product of the normalized connecting plane\n      // and the perpendicular plane that we just calculated.\n      final double lineX = normalizedConnectingPlane.y * perpZ - normalizedConnectingPlane.z * perpY;\n      final double lineY = normalizedConnectingPlane.z * perpX - normalizedConnectingPlane.x * perpZ;\n      final double lineZ = normalizedConnectingPlane.x * perpY - normalizedConnectingPlane.y * perpX;\n\n      // Now, compute a normalization factor\n      final double normalizer = 1.0 / Math.sqrt(lineX * lineX + lineY * lineY + lineZ * lineZ);\n\n      // Pick which point by using bounding planes\n      double normLineX = lineX * normalizer;\n      double normLineY = lineY * normalizer;\n      double normLineZ = lineZ * normalizer;\n      if (!startCutoffPlane.isWithin(normLineX, normLineY, normLineZ) ||\n          !endCutoffPlane.isWithin(normLineX, normLineY, normLineZ)) {\n        normLineX = -normLineX;\n        normLineY = -normLineY;\n        normLineZ = -normLineZ;\n      }\n\n      // Compute linear distance for the two points\n      return point.linearDistance(normLineX, normLineY, normLineZ) + start.linearDistance(normLineX, normLineY, normLineZ);\n    }\n\n","sourceOld":"        public double pathLinearDistance(final GeoPoint point)\n        {\n            if (!isWithin(point))\n                return Double.MAX_VALUE;\n\n            // We have a normalized connecting plane.\n            // First, compute the perpendicular plane.\n            // Want no allocations or expensive operations!  so we do this the hard way\n            final double perpX = normalizedConnectingPlane.y * point.z - normalizedConnectingPlane.z * point.y;\n            final double perpY = normalizedConnectingPlane.z * point.x - normalizedConnectingPlane.x * point.z;\n            final double perpZ = normalizedConnectingPlane.x * point.y - normalizedConnectingPlane.y * point.x;\n\n            // If we have a degenerate line, then just compute the normal distance from point x to the start\n            if (Math.abs(perpX) < Vector.MINIMUM_RESOLUTION && Math.abs(perpY) < Vector.MINIMUM_RESOLUTION && Math.abs(perpZ) < Vector.MINIMUM_RESOLUTION)\n                return point.linearDistance(start);\n\n            // Next, we need the vector of the line, which is the cross product of the normalized connecting plane\n            // and the perpendicular plane that we just calculated.\n            final double lineX = normalizedConnectingPlane.y * perpZ - normalizedConnectingPlane.z * perpY;\n            final double lineY = normalizedConnectingPlane.z * perpX - normalizedConnectingPlane.x * perpZ;\n            final double lineZ = normalizedConnectingPlane.x * perpY - normalizedConnectingPlane.y * perpX;\n            \n            // Now, compute a normalization factor\n            final double normalizer = 1.0/Math.sqrt(lineX * lineX + lineY * lineY + lineZ * lineZ);\n            \n            // Pick which point by using bounding planes\n            double normLineX = lineX * normalizer;\n            double normLineY = lineY * normalizer;\n            double normLineZ = lineZ * normalizer;\n            if (!startCutoffPlane.isWithin(normLineX,normLineY,normLineZ) ||\n              !endCutoffPlane.isWithin(normLineX,normLineY,normLineZ))\n            {\n                normLineX = -normLineX;\n                normLineY = -normLineY;\n                normLineZ = -normLineZ;\n            }\n            \n            // Compute linear distance for the two points\n            return point.linearDistance(normLineX,normLineY,normLineZ) + start.linearDistance(normLineX,normLineY,normLineZ);\n        }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c921d81476f94b6686d3f216daa1f6b076b4a6c0","date":1430922284,"type":0,"author":"David Wayne Smiley","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.PathSegment#pathLinearDistance(GeoPoint).mjava","pathOld":"/dev/null","sourceNew":"    public double pathLinearDistance(final GeoPoint point) {\n      if (!isWithin(point))\n        return Double.MAX_VALUE;\n\n      // We have a normalized connecting plane.\n      // First, compute the perpendicular plane.\n      // Want no allocations or expensive operations!  so we do this the hard way\n      final double perpX = normalizedConnectingPlane.y * point.z - normalizedConnectingPlane.z * point.y;\n      final double perpY = normalizedConnectingPlane.z * point.x - normalizedConnectingPlane.x * point.z;\n      final double perpZ = normalizedConnectingPlane.x * point.y - normalizedConnectingPlane.y * point.x;\n\n      // If we have a degenerate line, then just compute the normal distance from point x to the start\n      if (Math.abs(perpX) < Vector.MINIMUM_RESOLUTION && Math.abs(perpY) < Vector.MINIMUM_RESOLUTION && Math.abs(perpZ) < Vector.MINIMUM_RESOLUTION)\n        return point.linearDistance(start);\n\n      // Next, we need the vector of the line, which is the cross product of the normalized connecting plane\n      // and the perpendicular plane that we just calculated.\n      final double lineX = normalizedConnectingPlane.y * perpZ - normalizedConnectingPlane.z * perpY;\n      final double lineY = normalizedConnectingPlane.z * perpX - normalizedConnectingPlane.x * perpZ;\n      final double lineZ = normalizedConnectingPlane.x * perpY - normalizedConnectingPlane.y * perpX;\n\n      // Now, compute a normalization factor\n      final double normalizer = 1.0 / Math.sqrt(lineX * lineX + lineY * lineY + lineZ * lineZ);\n\n      // Pick which point by using bounding planes\n      double normLineX = lineX * normalizer;\n      double normLineY = lineY * normalizer;\n      double normLineZ = lineZ * normalizer;\n      if (!startCutoffPlane.isWithin(normLineX, normLineY, normLineZ) ||\n          !endCutoffPlane.isWithin(normLineX, normLineY, normLineZ)) {\n        normLineX = -normLineX;\n        normLineY = -normLineY;\n        normLineZ = -normLineZ;\n      }\n\n      // Compute linear distance for the two points\n      return point.linearDistance(normLineX, normLineY, normLineZ) + start.linearDistance(normLineX, normLineY, normLineZ);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9908748d960ccb7706a20e81289a656237780b6c","date":1435716223,"type":4,"author":"David Wayne Smiley","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.PathSegment#pathLinearDistance(GeoPoint).mjava","sourceNew":null,"sourceOld":"    public double pathLinearDistance(final GeoPoint point) {\n      if (!isWithin(point))\n        return Double.MAX_VALUE;\n\n      // We have a normalized connecting plane.\n      // First, compute the perpendicular plane.\n      // Want no allocations or expensive operations!  so we do this the hard way\n      final double perpX = normalizedConnectingPlane.y * point.z - normalizedConnectingPlane.z * point.y;\n      final double perpY = normalizedConnectingPlane.z * point.x - normalizedConnectingPlane.x * point.z;\n      final double perpZ = normalizedConnectingPlane.x * point.y - normalizedConnectingPlane.y * point.x;\n\n      // If we have a degenerate line, then just compute the normal distance from point x to the start\n      if (Math.abs(perpX) < Vector.MINIMUM_RESOLUTION && Math.abs(perpY) < Vector.MINIMUM_RESOLUTION && Math.abs(perpZ) < Vector.MINIMUM_RESOLUTION)\n        return point.linearDistance(start);\n\n      // Next, we need the vector of the line, which is the cross product of the normalized connecting plane\n      // and the perpendicular plane that we just calculated.\n      final double lineX = normalizedConnectingPlane.y * perpZ - normalizedConnectingPlane.z * perpY;\n      final double lineY = normalizedConnectingPlane.z * perpX - normalizedConnectingPlane.x * perpZ;\n      final double lineZ = normalizedConnectingPlane.x * perpY - normalizedConnectingPlane.y * perpX;\n\n      // Now, compute a normalization factor\n      final double normalizer = 1.0 / Math.sqrt(lineX * lineX + lineY * lineY + lineZ * lineZ);\n\n      // Pick which point by using bounding planes\n      double normLineX = lineX * normalizer;\n      double normLineY = lineY * normalizer;\n      double normLineZ = lineZ * normalizer;\n      if (!startCutoffPlane.isWithin(normLineX, normLineY, normLineZ) ||\n          !endCutoffPlane.isWithin(normLineX, normLineY, normLineZ)) {\n        normLineX = -normLineX;\n        normLineY = -normLineY;\n        normLineZ = -normLineZ;\n      }\n\n      // Compute linear distance for the two points\n      return point.linearDistance(normLineX, normLineY, normLineZ) + start.linearDistance(normLineX, normLineY, normLineZ);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0fb9dbed1415914caa27460f8abb7afadaa61451":["851e4197476b684154a7b65f996f535522e67400"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e2997acf74723385bd84aff1ea0b12af4aefde77":["7aca5c321bc9760dbfc9cefcc9d648e946b4615e"],"c921d81476f94b6686d3f216daa1f6b076b4a6c0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e2997acf74723385bd84aff1ea0b12af4aefde77"],"851e4197476b684154a7b65f996f535522e67400":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7aca5c321bc9760dbfc9cefcc9d648e946b4615e":["0fb9dbed1415914caa27460f8abb7afadaa61451"],"9908748d960ccb7706a20e81289a656237780b6c":["c921d81476f94b6686d3f216daa1f6b076b4a6c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9908748d960ccb7706a20e81289a656237780b6c"]},"commit2Childs":{"0fb9dbed1415914caa27460f8abb7afadaa61451":["7aca5c321bc9760dbfc9cefcc9d648e946b4615e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c921d81476f94b6686d3f216daa1f6b076b4a6c0","851e4197476b684154a7b65f996f535522e67400"],"e2997acf74723385bd84aff1ea0b12af4aefde77":["c921d81476f94b6686d3f216daa1f6b076b4a6c0"],"851e4197476b684154a7b65f996f535522e67400":["0fb9dbed1415914caa27460f8abb7afadaa61451"],"c921d81476f94b6686d3f216daa1f6b076b4a6c0":["9908748d960ccb7706a20e81289a656237780b6c"],"7aca5c321bc9760dbfc9cefcc9d648e946b4615e":["e2997acf74723385bd84aff1ea0b12af4aefde77"],"9908748d960ccb7706a20e81289a656237780b6c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}