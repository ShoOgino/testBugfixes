{"path":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","commits":[{"id":"8af96162d6e24bbd73a74cf381037e6aea675cd8","date":1422142293,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  public static IndexReader wrapReader(IndexReader r) throws IOException {\n    Random random = random();\n      \n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof LeafReader;\n    for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n      switch(random.nextInt(6)) {\n      case 0:\n        r = SlowCompositeReaderWrapper.wrap(r);\n        break;\n      case 1:\n        // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n        r = (r instanceof LeafReader) ?\n          new ParallelLeafReader((LeafReader) r) :\n        new ParallelCompositeReader((CompositeReader) r);\n        break;\n      case 2:\n        // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        r = new FCInvisibleMultiReader(r);\n        break;\n      case 3:\n        final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n        final List<String> allFields = new ArrayList<>();\n        for (FieldInfo fi : ar.getFieldInfos()) {\n          allFields.add(fi.name);\n        }\n        Collections.shuffle(allFields, random);\n        final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n        final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n        // will create no FC insanity as ParallelLeafReader has own cache key:\n        r = new ParallelLeafReader(\n                                   new FieldFilterLeafReader(ar, fields, false),\n                                   new FieldFilterLeafReader(ar, fields, true)\n                                   );\n        break;\n      case 4:\n        // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (r instanceof LeafReader) {\n          r = new AssertingLeafReader((LeafReader)r);\n        } else if (r instanceof DirectoryReader) {\n          r = new AssertingDirectoryReader((DirectoryReader)r);\n        }\n        break;\n      case 5:\n        if (r instanceof LeafReader) {\n          r = new MismatchedLeafReader((LeafReader)r, random);\n        } else if (r instanceof DirectoryReader) {\n          r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n        }\n        break;\n      default:\n        fail(\"should not get here\");\n      }\n    }\n    if (wasOriginallyAtomic) {\n      r = SlowCompositeReaderWrapper.wrap(r);\n    } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n      // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n      r = new FCInvisibleMultiReader(r);\n    }\n    if (VERBOSE) {\n      System.out.println(\"wrapReader wrapped: \" +r);\n    }\n\n    return r;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c18695b5c27b72d1fdc966eee5e01d07a81b5c52","date":1456532984,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","sourceNew":"  public static IndexReader wrapReader(IndexReader r) throws IOException {\n    Random random = random();\n      \n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof LeafReader;\n    for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n      switch(random.nextInt(6)) {\n      case 0:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with SlowCompositeReaderWrapper.wrap\");\n        }\n        r = SlowCompositeReaderWrapper.wrap(r);\n        break;\n      case 1:\n        // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeaf/CompositeReader\");\n        }\n        r = (r instanceof LeafReader) ?\n          new ParallelLeafReader((LeafReader) r) :\n        new ParallelCompositeReader((CompositeReader) r);\n        break;\n      case 2:\n        // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with FCInvisibleMultiReader\");\n        }\n        r = new FCInvisibleMultiReader(r);\n        break;\n      case 3:\n        final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n        final List<String> allFields = new ArrayList<>();\n        for (FieldInfo fi : ar.getFieldInfos()) {\n          allFields.add(fi.name);\n        }\n        Collections.shuffle(allFields, random);\n        final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n        final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n        // will create no FC insanity as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeafReader(SlowCompositeReaderWapper)\");\n        }\n        r = new ParallelLeafReader(\n                                   new FieldFilterLeafReader(ar, fields, false),\n                                   new FieldFilterLeafReader(ar, fields, true)\n                                   );\n        break;\n      case 4:\n        // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with AssertingLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new AssertingLeafReader((LeafReader)r);\n        } else if (r instanceof DirectoryReader) {\n          r = new AssertingDirectoryReader((DirectoryReader)r);\n        }\n        break;\n      case 5:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with MismatchedLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new MismatchedLeafReader((LeafReader)r, random);\n        } else if (r instanceof DirectoryReader) {\n          r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n        }\n        break;\n      default:\n        fail(\"should not get here\");\n      }\n    }\n    if (wasOriginallyAtomic) {\n      r = SlowCompositeReaderWrapper.wrap(r);\n    } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n      // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n      r = new FCInvisibleMultiReader(r);\n    }\n    if (VERBOSE) {\n      System.out.println(\"wrapReader wrapped: \" +r);\n    }\n\n    return r;\n  }\n\n","sourceOld":"  public static IndexReader wrapReader(IndexReader r) throws IOException {\n    Random random = random();\n      \n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof LeafReader;\n    for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n      switch(random.nextInt(6)) {\n      case 0:\n        r = SlowCompositeReaderWrapper.wrap(r);\n        break;\n      case 1:\n        // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n        r = (r instanceof LeafReader) ?\n          new ParallelLeafReader((LeafReader) r) :\n        new ParallelCompositeReader((CompositeReader) r);\n        break;\n      case 2:\n        // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        r = new FCInvisibleMultiReader(r);\n        break;\n      case 3:\n        final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n        final List<String> allFields = new ArrayList<>();\n        for (FieldInfo fi : ar.getFieldInfos()) {\n          allFields.add(fi.name);\n        }\n        Collections.shuffle(allFields, random);\n        final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n        final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n        // will create no FC insanity as ParallelLeafReader has own cache key:\n        r = new ParallelLeafReader(\n                                   new FieldFilterLeafReader(ar, fields, false),\n                                   new FieldFilterLeafReader(ar, fields, true)\n                                   );\n        break;\n      case 4:\n        // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (r instanceof LeafReader) {\n          r = new AssertingLeafReader((LeafReader)r);\n        } else if (r instanceof DirectoryReader) {\n          r = new AssertingDirectoryReader((DirectoryReader)r);\n        }\n        break;\n      case 5:\n        if (r instanceof LeafReader) {\n          r = new MismatchedLeafReader((LeafReader)r, random);\n        } else if (r instanceof DirectoryReader) {\n          r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n        }\n        break;\n      default:\n        fail(\"should not get here\");\n      }\n    }\n    if (wasOriginallyAtomic) {\n      r = SlowCompositeReaderWrapper.wrap(r);\n    } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n      // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n      r = new FCInvisibleMultiReader(r);\n    }\n    if (VERBOSE) {\n      System.out.println(\"wrapReader wrapped: \" +r);\n    }\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","sourceNew":"  public static IndexReader wrapReader(IndexReader r) throws IOException {\n    Random random = random();\n      \n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof LeafReader;\n    for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n      switch(random.nextInt(6)) {\n      case 0:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with SlowCompositeReaderWrapper.wrap\");\n        }\n        r = SlowCompositeReaderWrapper.wrap(r);\n        break;\n      case 1:\n        // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeaf/CompositeReader\");\n        }\n        r = (r instanceof LeafReader) ?\n          new ParallelLeafReader((LeafReader) r) :\n        new ParallelCompositeReader((CompositeReader) r);\n        break;\n      case 2:\n        // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with FCInvisibleMultiReader\");\n        }\n        r = new FCInvisibleMultiReader(r);\n        break;\n      case 3:\n        final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n        final List<String> allFields = new ArrayList<>();\n        for (FieldInfo fi : ar.getFieldInfos()) {\n          allFields.add(fi.name);\n        }\n        Collections.shuffle(allFields, random);\n        final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n        final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n        // will create no FC insanity as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeafReader(SlowCompositeReaderWapper)\");\n        }\n        r = new ParallelLeafReader(\n                                   new FieldFilterLeafReader(ar, fields, false),\n                                   new FieldFilterLeafReader(ar, fields, true)\n                                   );\n        break;\n      case 4:\n        // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with AssertingLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new AssertingLeafReader((LeafReader)r);\n        } else if (r instanceof DirectoryReader) {\n          r = new AssertingDirectoryReader((DirectoryReader)r);\n        }\n        break;\n      case 5:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with MismatchedLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new MismatchedLeafReader((LeafReader)r, random);\n        } else if (r instanceof DirectoryReader) {\n          r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n        }\n        break;\n      default:\n        fail(\"should not get here\");\n      }\n    }\n    if (wasOriginallyAtomic) {\n      r = SlowCompositeReaderWrapper.wrap(r);\n    } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n      // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n      r = new FCInvisibleMultiReader(r);\n    }\n    if (VERBOSE) {\n      System.out.println(\"wrapReader wrapped: \" +r);\n    }\n\n    return r;\n  }\n\n","sourceOld":"  public static IndexReader wrapReader(IndexReader r) throws IOException {\n    Random random = random();\n      \n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof LeafReader;\n    for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n      switch(random.nextInt(6)) {\n      case 0:\n        r = SlowCompositeReaderWrapper.wrap(r);\n        break;\n      case 1:\n        // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n        r = (r instanceof LeafReader) ?\n          new ParallelLeafReader((LeafReader) r) :\n        new ParallelCompositeReader((CompositeReader) r);\n        break;\n      case 2:\n        // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        r = new FCInvisibleMultiReader(r);\n        break;\n      case 3:\n        final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n        final List<String> allFields = new ArrayList<>();\n        for (FieldInfo fi : ar.getFieldInfos()) {\n          allFields.add(fi.name);\n        }\n        Collections.shuffle(allFields, random);\n        final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n        final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n        // will create no FC insanity as ParallelLeafReader has own cache key:\n        r = new ParallelLeafReader(\n                                   new FieldFilterLeafReader(ar, fields, false),\n                                   new FieldFilterLeafReader(ar, fields, true)\n                                   );\n        break;\n      case 4:\n        // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (r instanceof LeafReader) {\n          r = new AssertingLeafReader((LeafReader)r);\n        } else if (r instanceof DirectoryReader) {\n          r = new AssertingDirectoryReader((DirectoryReader)r);\n        }\n        break;\n      case 5:\n        if (r instanceof LeafReader) {\n          r = new MismatchedLeafReader((LeafReader)r, random);\n        } else if (r instanceof DirectoryReader) {\n          r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n        }\n        break;\n      default:\n        fail(\"should not get here\");\n      }\n    }\n    if (wasOriginallyAtomic) {\n      r = SlowCompositeReaderWrapper.wrap(r);\n    } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n      // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n      r = new FCInvisibleMultiReader(r);\n    }\n    if (VERBOSE) {\n      System.out.println(\"wrapReader wrapped: \" +r);\n    }\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f","date":1456936072,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","sourceNew":"  public static IndexReader wrapReader(IndexReader r) throws IOException {\n    return wrapReader(r, true);\n  }\n\n","sourceOld":"  public static IndexReader wrapReader(IndexReader r) throws IOException {\n    Random random = random();\n      \n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof LeafReader;\n    for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n      switch(random.nextInt(6)) {\n      case 0:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with SlowCompositeReaderWrapper.wrap\");\n        }\n        r = SlowCompositeReaderWrapper.wrap(r);\n        break;\n      case 1:\n        // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeaf/CompositeReader\");\n        }\n        r = (r instanceof LeafReader) ?\n          new ParallelLeafReader((LeafReader) r) :\n        new ParallelCompositeReader((CompositeReader) r);\n        break;\n      case 2:\n        // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with FCInvisibleMultiReader\");\n        }\n        r = new FCInvisibleMultiReader(r);\n        break;\n      case 3:\n        final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n        final List<String> allFields = new ArrayList<>();\n        for (FieldInfo fi : ar.getFieldInfos()) {\n          allFields.add(fi.name);\n        }\n        Collections.shuffle(allFields, random);\n        final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n        final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n        // will create no FC insanity as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeafReader(SlowCompositeReaderWapper)\");\n        }\n        r = new ParallelLeafReader(\n                                   new FieldFilterLeafReader(ar, fields, false),\n                                   new FieldFilterLeafReader(ar, fields, true)\n                                   );\n        break;\n      case 4:\n        // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with AssertingLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new AssertingLeafReader((LeafReader)r);\n        } else if (r instanceof DirectoryReader) {\n          r = new AssertingDirectoryReader((DirectoryReader)r);\n        }\n        break;\n      case 5:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with MismatchedLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new MismatchedLeafReader((LeafReader)r, random);\n        } else if (r instanceof DirectoryReader) {\n          r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n        }\n        break;\n      default:\n        fail(\"should not get here\");\n      }\n    }\n    if (wasOriginallyAtomic) {\n      r = SlowCompositeReaderWrapper.wrap(r);\n    } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n      // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n      r = new FCInvisibleMultiReader(r);\n    }\n    if (VERBOSE) {\n      System.out.println(\"wrapReader wrapped: \" +r);\n    }\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","sourceNew":"  public static IndexReader wrapReader(IndexReader r) throws IOException {\n    return wrapReader(r, true);\n  }\n\n","sourceOld":"  public static IndexReader wrapReader(IndexReader r) throws IOException {\n    Random random = random();\n      \n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof LeafReader;\n    for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n      switch(random.nextInt(6)) {\n      case 0:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with SlowCompositeReaderWrapper.wrap\");\n        }\n        r = SlowCompositeReaderWrapper.wrap(r);\n        break;\n      case 1:\n        // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeaf/CompositeReader\");\n        }\n        r = (r instanceof LeafReader) ?\n          new ParallelLeafReader((LeafReader) r) :\n        new ParallelCompositeReader((CompositeReader) r);\n        break;\n      case 2:\n        // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with FCInvisibleMultiReader\");\n        }\n        r = new FCInvisibleMultiReader(r);\n        break;\n      case 3:\n        final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n        final List<String> allFields = new ArrayList<>();\n        for (FieldInfo fi : ar.getFieldInfos()) {\n          allFields.add(fi.name);\n        }\n        Collections.shuffle(allFields, random);\n        final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n        final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n        // will create no FC insanity as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeafReader(SlowCompositeReaderWapper)\");\n        }\n        r = new ParallelLeafReader(\n                                   new FieldFilterLeafReader(ar, fields, false),\n                                   new FieldFilterLeafReader(ar, fields, true)\n                                   );\n        break;\n      case 4:\n        // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with AssertingLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new AssertingLeafReader((LeafReader)r);\n        } else if (r instanceof DirectoryReader) {\n          r = new AssertingDirectoryReader((DirectoryReader)r);\n        }\n        break;\n      case 5:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with MismatchedLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new MismatchedLeafReader((LeafReader)r, random);\n        } else if (r instanceof DirectoryReader) {\n          r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n        }\n        break;\n      default:\n        fail(\"should not get here\");\n      }\n    }\n    if (wasOriginallyAtomic) {\n      r = SlowCompositeReaderWrapper.wrap(r);\n    } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n      // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n      r = new FCInvisibleMultiReader(r);\n    }\n    if (VERBOSE) {\n      System.out.println(\"wrapReader wrapped: \" +r);\n    }\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","date":1457644139,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","sourceNew":"  public static IndexReader wrapReader(IndexReader r) throws IOException {\n    Random random = random();\n      \n    for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n      switch(random.nextInt(5)) {\n      case 0:\n        // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeaf/CompositeReader\");\n        }\n        r = (r instanceof LeafReader) ?\n          new ParallelLeafReader((LeafReader) r) :\n        new ParallelCompositeReader((CompositeReader) r);\n        break;\n      case 1:\n        // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with FCInvisibleMultiReader\");\n        }\n        r = new FCInvisibleMultiReader(r);\n        break;\n      case 2:\n        if (r instanceof LeafReader) {\n          final LeafReader ar = (LeafReader) r;\n          final List<String> allFields = new ArrayList<>();\n          for (FieldInfo fi : ar.getFieldInfos()) {\n            allFields.add(fi.name);\n          }\n          Collections.shuffle(allFields, random);\n          final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n          final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n          // will create no FC insanity as ParallelLeafReader has own cache key:\n          if (VERBOSE) {\n            System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeafReader\");\n          }\n          r = new ParallelLeafReader(\n                                     new FieldFilterLeafReader(ar, fields, false),\n                                     new FieldFilterLeafReader(ar, fields, true)\n                                     );\n        }\n        break;\n      case 3:\n        // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with AssertingLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new AssertingLeafReader((LeafReader)r);\n        } else if (r instanceof DirectoryReader) {\n          r = new AssertingDirectoryReader((DirectoryReader)r);\n        }\n        break;\n      case 4:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with MismatchedLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new MismatchedLeafReader((LeafReader)r, random);\n        } else if (r instanceof DirectoryReader) {\n          r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n        }\n        break;\n      default:\n        fail(\"should not get here\");\n      }\n    }\n\n    if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n      // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n      r = new FCInvisibleMultiReader(r);\n    }\n    if (VERBOSE) {\n      System.out.println(\"wrapReader wrapped: \" +r);\n    }\n\n    return r;\n  }\n\n","sourceOld":"  public static IndexReader wrapReader(IndexReader r) throws IOException {\n    return wrapReader(r, true);\n  }\n\n","bugFix":["adc9dc8ef0ce617b940a039fd12f79e8b098cc7f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d211216c83f01894810543d1c107160a9ae3650b","date":1488289605,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","sourceNew":"  public static IndexReader wrapReader(IndexReader r) throws IOException {\n    Random random = random();\n      \n    for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n      switch(random.nextInt(4)) {\n      case 0:\n        // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeaf/CompositeReader\");\n        }\n        r = (r instanceof LeafReader) ?\n          new ParallelLeafReader((LeafReader) r) :\n        new ParallelCompositeReader((CompositeReader) r);\n        break;\n      case 1:\n        if (r instanceof LeafReader) {\n          final LeafReader ar = (LeafReader) r;\n          final List<String> allFields = new ArrayList<>();\n          for (FieldInfo fi : ar.getFieldInfos()) {\n            allFields.add(fi.name);\n          }\n          Collections.shuffle(allFields, random);\n          final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n          final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n          // will create no FC insanity as ParallelLeafReader has own cache key:\n          if (VERBOSE) {\n            System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeafReader\");\n          }\n          r = new ParallelLeafReader(\n                                     new FieldFilterLeafReader(ar, fields, false),\n                                     new FieldFilterLeafReader(ar, fields, true)\n                                     );\n        }\n        break;\n      case 2:\n        // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with AssertingLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new AssertingLeafReader((LeafReader)r);\n        } else if (r instanceof DirectoryReader) {\n          r = new AssertingDirectoryReader((DirectoryReader)r);\n        }\n        break;\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with MismatchedLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new MismatchedLeafReader((LeafReader)r, random);\n        } else if (r instanceof DirectoryReader) {\n          r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n        }\n        break;\n      default:\n        fail(\"should not get here\");\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"wrapReader wrapped: \" +r);\n    }\n\n    return r;\n  }\n\n","sourceOld":"  public static IndexReader wrapReader(IndexReader r) throws IOException {\n    Random random = random();\n      \n    for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n      switch(random.nextInt(5)) {\n      case 0:\n        // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeaf/CompositeReader\");\n        }\n        r = (r instanceof LeafReader) ?\n          new ParallelLeafReader((LeafReader) r) :\n        new ParallelCompositeReader((CompositeReader) r);\n        break;\n      case 1:\n        // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with FCInvisibleMultiReader\");\n        }\n        r = new FCInvisibleMultiReader(r);\n        break;\n      case 2:\n        if (r instanceof LeafReader) {\n          final LeafReader ar = (LeafReader) r;\n          final List<String> allFields = new ArrayList<>();\n          for (FieldInfo fi : ar.getFieldInfos()) {\n            allFields.add(fi.name);\n          }\n          Collections.shuffle(allFields, random);\n          final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n          final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n          // will create no FC insanity as ParallelLeafReader has own cache key:\n          if (VERBOSE) {\n            System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeafReader\");\n          }\n          r = new ParallelLeafReader(\n                                     new FieldFilterLeafReader(ar, fields, false),\n                                     new FieldFilterLeafReader(ar, fields, true)\n                                     );\n        }\n        break;\n      case 3:\n        // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with AssertingLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new AssertingLeafReader((LeafReader)r);\n        } else if (r instanceof DirectoryReader) {\n          r = new AssertingDirectoryReader((DirectoryReader)r);\n        }\n        break;\n      case 4:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with MismatchedLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new MismatchedLeafReader((LeafReader)r, random);\n        } else if (r instanceof DirectoryReader) {\n          r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n        }\n        break;\n      default:\n        fail(\"should not get here\");\n      }\n    }\n\n    if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n      // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n      r = new FCInvisibleMultiReader(r);\n    }\n    if (VERBOSE) {\n      System.out.println(\"wrapReader wrapped: \" +r);\n    }\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dbc046116d49cd3d0c50f7169cabaa295bc23a4a","date":1552989114,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#wrapReader(IndexReader).mjava","sourceNew":"  public static IndexReader wrapReader(IndexReader r) throws IOException {\n    Random random = random();\n      \n    for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n      switch(random.nextInt(5)) {\n      case 0:\n        // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeaf/CompositeReader\");\n        }\n        r = (r instanceof LeafReader) ?\n          new ParallelLeafReader((LeafReader) r) :\n        new ParallelCompositeReader((CompositeReader) r);\n        break;\n      case 1:\n        if (r instanceof LeafReader) {\n          final LeafReader ar = (LeafReader) r;\n          final List<String> allFields = new ArrayList<>();\n          for (FieldInfo fi : ar.getFieldInfos()) {\n            allFields.add(fi.name);\n          }\n          Collections.shuffle(allFields, random);\n          final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n          final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n          // will create no FC insanity as ParallelLeafReader has own cache key:\n          if (VERBOSE) {\n            System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeafReader\");\n          }\n          r = new ParallelLeafReader(\n                                     new FieldFilterLeafReader(ar, fields, false),\n                                     new FieldFilterLeafReader(ar, fields, true)\n                                     );\n        }\n        break;\n      case 2:\n        // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with AssertingLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new AssertingLeafReader((LeafReader)r);\n        } else if (r instanceof DirectoryReader) {\n          r = new AssertingDirectoryReader((DirectoryReader)r);\n        }\n        break;\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with MismatchedLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new MismatchedLeafReader((LeafReader)r, random);\n        } else if (r instanceof DirectoryReader) {\n          r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n        }\n        break;\n      case 4:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with MergingCodecReader\");\n        }\n        if (r instanceof CodecReader) {\n          r = new MergingCodecReader((CodecReader) r);\n        } else if (r instanceof DirectoryReader) {\n          boolean allLeavesAreCodecReaders = true;\n          for (LeafReaderContext ctx : r.leaves()) {\n            if (ctx.reader() instanceof CodecReader == false) {\n              allLeavesAreCodecReaders = false;\n              break;\n            }\n          }\n          if (allLeavesAreCodecReaders) {\n            r = new MergingDirectoryReaderWrapper((DirectoryReader) r);\n          }\n        }\n        break;\n      default:\n        fail(\"should not get here\");\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"wrapReader wrapped: \" +r);\n    }\n\n    return r;\n  }\n\n","sourceOld":"  public static IndexReader wrapReader(IndexReader r) throws IOException {\n    Random random = random();\n      \n    for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n      switch(random.nextInt(4)) {\n      case 0:\n        // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeaf/CompositeReader\");\n        }\n        r = (r instanceof LeafReader) ?\n          new ParallelLeafReader((LeafReader) r) :\n        new ParallelCompositeReader((CompositeReader) r);\n        break;\n      case 1:\n        if (r instanceof LeafReader) {\n          final LeafReader ar = (LeafReader) r;\n          final List<String> allFields = new ArrayList<>();\n          for (FieldInfo fi : ar.getFieldInfos()) {\n            allFields.add(fi.name);\n          }\n          Collections.shuffle(allFields, random);\n          final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n          final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n          // will create no FC insanity as ParallelLeafReader has own cache key:\n          if (VERBOSE) {\n            System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with ParallelLeafReader\");\n          }\n          r = new ParallelLeafReader(\n                                     new FieldFilterLeafReader(ar, fields, false),\n                                     new FieldFilterLeafReader(ar, fields, true)\n                                     );\n        }\n        break;\n      case 2:\n        // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n        // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n        // along our reader:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with AssertingLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new AssertingLeafReader((LeafReader)r);\n        } else if (r instanceof DirectoryReader) {\n          r = new AssertingDirectoryReader((DirectoryReader)r);\n        }\n        break;\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase.wrapReader: wrapping previous reader=\" + r + \" with MismatchedLeaf/DirectoryReader\");\n        }\n        if (r instanceof LeafReader) {\n          r = new MismatchedLeafReader((LeafReader)r, random);\n        } else if (r instanceof DirectoryReader) {\n          r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n        }\n        break;\n      default:\n        fail(\"should not get here\");\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"wrapReader wrapped: \" +r);\n    }\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"af2638813028b254a88b418ebeafb541afb49653":["8af96162d6e24bbd73a74cf381037e6aea675cd8","c18695b5c27b72d1fdc966eee5e01d07a81b5c52"],"d211216c83f01894810543d1c107160a9ae3650b":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"8af96162d6e24bbd73a74cf381037e6aea675cd8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dbc046116d49cd3d0c50f7169cabaa295bc23a4a":["d211216c83f01894810543d1c107160a9ae3650b"],"c18695b5c27b72d1fdc966eee5e01d07a81b5c52":["8af96162d6e24bbd73a74cf381037e6aea675cd8"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["af2638813028b254a88b418ebeafb541afb49653","adc9dc8ef0ce617b940a039fd12f79e8b098cc7f"],"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f":["c18695b5c27b72d1fdc966eee5e01d07a81b5c52"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dbc046116d49cd3d0c50f7169cabaa295bc23a4a"]},"commit2Childs":{"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["d211216c83f01894810543d1c107160a9ae3650b"],"af2638813028b254a88b418ebeafb541afb49653":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"8af96162d6e24bbd73a74cf381037e6aea675cd8":["af2638813028b254a88b418ebeafb541afb49653","c18695b5c27b72d1fdc966eee5e01d07a81b5c52"],"d211216c83f01894810543d1c107160a9ae3650b":["dbc046116d49cd3d0c50f7169cabaa295bc23a4a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8af96162d6e24bbd73a74cf381037e6aea675cd8"],"dbc046116d49cd3d0c50f7169cabaa295bc23a4a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"c18695b5c27b72d1fdc966eee5e01d07a81b5c52":["af2638813028b254a88b418ebeafb541afb49653","adc9dc8ef0ce617b940a039fd12f79e8b098cc7f"],"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}