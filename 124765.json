{"path":"src/java/org/apache/lucene/search/FieldSortedHitQueue#initializeSort(IndexReader,String).mjava","commits":[{"id":"6decf4a21b049e524a98231b4df27f61c84f7b65","date":1075479753,"type":0,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#initializeSort(IndexReader,String).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Initializes the cache of sort information.  <code>fieldCache</code> is queried\n     * to see if it has the term information for the given field.\n     * If so, and if the reader still has the same value for maxDoc()\n     * (note that we assume new IndexReaders are caught during the\n     * constructor), the existing data is used.  If not, all the term values\n     * for the given field are fetched.  The value of the term is assumed\n     * to be the sort index for any documents containing the term.  Documents\n     * should only have one term in the given field. Multiple documents\n     * can share the same term if desired (documents with the same term will\n     * be sorted relative to each other by the order they were placed in\n     * the index).\n     * @param reader  The document index.\n     * @param field   The field to sort by.\n     * @throws IOException  If the term enumerator fails.\n     */\n    protected final void initializeSort (IndexReader reader, String field)\n    throws IOException {\n\n        fieldOrder = (int[]) fieldCache.get (field);\n        if (fieldOrder == null || fieldOrder.length != reader.maxDoc()) {\n            fieldOrder = new int [reader.maxDoc()];\n\n            TermEnum enumerator = reader.terms (new Term (field, \"\"));\n            TermDocs termDocs = reader.termDocs();\n            if (enumerator.term() == null) {\n                throw new RuntimeException (\"no terms in field \"+field);\n            }\n\n            try {\n                Term term = enumerator.term();\n                while (term.field() == field) {\n                    termDocs.seek (term);\n                    if (termDocs.next()) {\n                        fieldOrder[termDocs.doc()] = Integer.parseInt (term.text());\n                    } else {\n                        throw new RuntimeException (\"termDocs.next() failed!\");\n                    }\n                    if (!enumerator.next()) {\n                        break;\n                    }\n                    term = enumerator.term();\n                }\n            } finally {\n                enumerator.close();\n                termDocs.close();\n            }\n\n            // be careful how the cache is updated so we\n            // don't have synchronization problems.  we do\n            // it this way because we assume updates will be\n            // few compared to the number of reads.\n            HashMap newCache = (HashMap) fieldCache.clone();\n            newCache.put (field, fieldOrder);\n            fieldCache = newCache;\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6691cb6747f9e850337c706c06b92e9ddf816e1","date":1077044431,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#initializeSort(IndexReader,String).mjava","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#initializeSort(IndexReader,String).mjava","sourceNew":"    /**\n     * Initializes the cache of sort information.  <code>fieldCache</code> is queried\n     * to see if it has the term information for the given field.\n     * If so, and if the reader still has the same value for maxDoc()\n     * (note that we assume new IndexReaders are caught during the\n     * constructor), the existing data is used.  If not, all the term values\n     * for the given field are fetched.  The value of the term is assumed\n     * to indicate the sort order for any documents containing the term.  Documents\n     * should only have one term in the given field.  Multiple documents\n     * can share the same term if desired, in which case they will be\n\t * considered equal during the sort.\n     * @param reader  The document index.\n     * @param field   The field to sort by.\n     * @throws IOException  If createComparator(IndexReader,String) fails - usually caused by the term enumerator failing.\n     */\n    protected final ScoreDocComparator initializeSort (IndexReader reader, String field)\n    throws IOException {\n\n\t\tScoreDocLookupComparator comparer = (ScoreDocLookupComparator) fieldCache.get (field);\n\t\tif (comparer == null || !comparer.sizeMatches(reader.maxDoc())) {\n\t\t\tcomparer = createComparator (reader, field);\n            fieldCache.put (field, comparer);\n\t\t}\n\t\treturn comparer;\n    }\n\n","sourceOld":"    /**\n     * Initializes the cache of sort information.  <code>fieldCache</code> is queried\n     * to see if it has the term information for the given field.\n     * If so, and if the reader still has the same value for maxDoc()\n     * (note that we assume new IndexReaders are caught during the\n     * constructor), the existing data is used.  If not, all the term values\n     * for the given field are fetched.  The value of the term is assumed\n     * to be the sort index for any documents containing the term.  Documents\n     * should only have one term in the given field. Multiple documents\n     * can share the same term if desired (documents with the same term will\n     * be sorted relative to each other by the order they were placed in\n     * the index).\n     * @param reader  The document index.\n     * @param field   The field to sort by.\n     * @throws IOException  If the term enumerator fails.\n     */\n    protected final void initializeSort (IndexReader reader, String field)\n    throws IOException {\n\n        fieldOrder = (int[]) fieldCache.get (field);\n        if (fieldOrder == null || fieldOrder.length != reader.maxDoc()) {\n            fieldOrder = new int [reader.maxDoc()];\n\n            TermEnum enumerator = reader.terms (new Term (field, \"\"));\n            TermDocs termDocs = reader.termDocs();\n            if (enumerator.term() == null) {\n                throw new RuntimeException (\"no terms in field \"+field);\n            }\n\n            try {\n                Term term = enumerator.term();\n                while (term.field() == field) {\n                    termDocs.seek (term);\n                    if (termDocs.next()) {\n                        fieldOrder[termDocs.doc()] = Integer.parseInt (term.text());\n                    } else {\n                        throw new RuntimeException (\"termDocs.next() failed!\");\n                    }\n                    if (!enumerator.next()) {\n                        break;\n                    }\n                    term = enumerator.term();\n                }\n            } finally {\n                enumerator.close();\n                termDocs.close();\n            }\n\n            // be careful how the cache is updated so we\n            // don't have synchronization problems.  we do\n            // it this way because we assume updates will be\n            // few compared to the number of reads.\n            HashMap newCache = (HashMap) fieldCache.clone();\n            newCache.put (field, fieldOrder);\n            fieldCache = newCache;\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99ee715b9c02dd47d9e69a18607a5192c1ebd82b","date":1085007927,"type":4,"author":"Tim Jones","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#initializeSort(IndexReader,String).mjava","sourceNew":null,"sourceOld":"    /**\n     * Initializes the cache of sort information.  <code>fieldCache</code> is queried\n     * to see if it has the term information for the given field.\n     * If so, and if the reader still has the same value for maxDoc()\n     * (note that we assume new IndexReaders are caught during the\n     * constructor), the existing data is used.  If not, all the term values\n     * for the given field are fetched.  The value of the term is assumed\n     * to indicate the sort order for any documents containing the term.  Documents\n     * should only have one term in the given field.  Multiple documents\n     * can share the same term if desired, in which case they will be\n\t * considered equal during the sort.\n     * @param reader  The document index.\n     * @param field   The field to sort by.\n     * @throws IOException  If createComparator(IndexReader,String) fails - usually caused by the term enumerator failing.\n     */\n    protected final ScoreDocComparator initializeSort (IndexReader reader, String field)\n    throws IOException {\n\n\t\tScoreDocLookupComparator comparer = (ScoreDocLookupComparator) fieldCache.get (field);\n\t\tif (comparer == null || !comparer.sizeMatches(reader.maxDoc())) {\n\t\t\tcomparer = createComparator (reader, field);\n            fieldCache.put (field, comparer);\n\t\t}\n\t\treturn comparer;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c6691cb6747f9e850337c706c06b92e9ddf816e1":["6decf4a21b049e524a98231b4df27f61c84f7b65"],"99ee715b9c02dd47d9e69a18607a5192c1ebd82b":["c6691cb6747f9e850337c706c06b92e9ddf816e1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6decf4a21b049e524a98231b4df27f61c84f7b65":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["99ee715b9c02dd47d9e69a18607a5192c1ebd82b"]},"commit2Childs":{"c6691cb6747f9e850337c706c06b92e9ddf816e1":["99ee715b9c02dd47d9e69a18607a5192c1ebd82b"],"99ee715b9c02dd47d9e69a18607a5192c1ebd82b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6decf4a21b049e524a98231b4df27f61c84f7b65"],"6decf4a21b049e524a98231b4df27f61c84f7b65":["c6691cb6747f9e850337c706c06b92e9ddf816e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}