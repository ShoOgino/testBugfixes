{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetRequest.FacetFieldParser#parseAndValidateSort(FacetField,Map[String,Object],String).mjava","commits":[{"id":"248f6ecc900c3a5633fd5ca6f564ea8b717720da","date":1588863846,"type":0,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequest.FacetFieldParser#parseAndValidateSort(FacetField,Map[String,Object],String).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Parses, validates and returns the {@link FacetSort} for given sortParam\n     * and facet field\n     * <p>\n     *   Currently, supported sort specifications are 'mystat desc' OR {mystat: 'desc'}\n     *   index - This is equivalent to 'index asc'\n     *   count - This is equivalent to 'count desc'\n     * </p>\n     *\n     * @param facet {@link FacetField} for which sort needs to be parsed and validated\n     * @param args map containing the sortVal for given sortParam\n     * @param sortParam parameter for which sort needs to parsed and validated\n     * @return parsed facet sort\n     */\n    private static FacetSort parseAndValidateSort(FacetField facet, Map<String, Object> args, String sortParam) {\n      Object sort = args.get(sortParam);\n      if (sort == null) {\n        return null;\n      }\n\n      FacetSort facetSort = null;\n\n      if (sort instanceof String) {\n        String sortStr = (String)sort;\n        if (sortStr.endsWith(\" asc\")) {\n          facetSort =  new FacetSort(sortStr.substring(0, sortStr.length()-\" asc\".length()),\n              SortDirection.asc);\n        } else if (sortStr.endsWith(\" desc\")) {\n          facetSort =  new FacetSort(sortStr.substring(0, sortStr.length()-\" desc\".length()),\n              SortDirection.desc);\n        } else {\n          facetSort =  new FacetSort(sortStr,\n              // default direction for \"index\" is ascending\n              (\"index\".equals(sortStr)\n                  ? SortDirection.asc\n                  : SortDirection.desc));\n        }\n      } else if (sort instanceof Map) {\n        // { myvar : 'desc' }\n        Optional<Map.Entry<String,Object>> optional = ((Map<String,Object>)sort).entrySet().stream().findFirst();\n        if (optional.isPresent()) {\n          Map.Entry<String, Object> entry = optional.get();\n          facetSort = new FacetSort(entry.getKey(), SortDirection.fromObj(entry.getValue()));\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Expected string/map for '\" + sortParam +\"', received \"+ sort.getClass().getSimpleName() + \"=\" + sort);\n      }\n\n      Map<String, AggValueSource> facetStats = facet.facetStats;\n      // validate facet sort\n      boolean isValidSort = facetSort == null ||\n          \"index\".equals(facetSort.sortVariable) ||\n          \"count\".equals(facetSort.sortVariable) ||\n          (facetStats != null && facetStats.containsKey(facetSort.sortVariable));\n\n      if (!isValidSort) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Invalid \" + sortParam + \" option '\" + sort + \"' for field '\" + facet.field + \"'\");\n      }\n      return facetSort;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a56a9893014b284af4d1af451e6c02e7ffdf5b6e","date":1590065972,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequest.FacetFieldParser#parseAndValidateSort(FacetField,Map[String,Object],String).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRequest.FacetFieldParser#parseAndValidateSort(FacetField,Map[String,Object],String).mjava","sourceNew":"    /**\n     * Parses, validates and returns the {@link FacetSort} for given sortParam\n     * and facet field\n     * <p>\n     *   Currently, supported sort specifications are 'mystat desc' OR {mystat: 'desc'}\n     *   index - This is equivalent to 'index asc'\n     *   count - This is equivalent to 'count desc'\n     * </p>\n     *\n     * @param facet {@link FacetField} for which sort needs to be parsed and validated\n     * @param args map containing the sortVal for given sortParam\n     * @param sortParam parameter for which sort needs to parsed and validated\n     * @return parsed facet sort\n     */\n    private static FacetSort parseAndValidateSort(FacetField facet, Map<String, Object> args, String sortParam) {\n      Object sort = args.get(sortParam);\n      if (sort == null) {\n        return null;\n      }\n\n      FacetSort facetSort = null;\n\n      if (sort instanceof String) {\n        String sortStr = (String)sort;\n        if (sortStr.endsWith(\" asc\")) {\n          facetSort =  new FacetSort(sortStr.substring(0, sortStr.length()-\" asc\".length()),\n              SortDirection.asc);\n        } else if (sortStr.endsWith(\" desc\")) {\n          facetSort =  new FacetSort(sortStr.substring(0, sortStr.length()-\" desc\".length()),\n              SortDirection.desc);\n        } else {\n          facetSort =  new FacetSort(sortStr,\n              // default direction for \"index\" is ascending\n              (\"index\".equals(sortStr)\n                  ? SortDirection.asc\n                  : SortDirection.desc));\n        }\n      } else if (sort instanceof Map) {\n        // { myvar : 'desc' }\n        @SuppressWarnings(\"unchecked\")\n        Optional<Map.Entry<String,Object>> optional = ((Map<String,Object>)sort).entrySet().stream().findFirst();\n        if (optional.isPresent()) {\n          Map.Entry<String, Object> entry = optional.get();\n          facetSort = new FacetSort(entry.getKey(), SortDirection.fromObj(entry.getValue()));\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Expected string/map for '\" + sortParam +\"', received \"+ sort.getClass().getSimpleName() + \"=\" + sort);\n      }\n\n      Map<String, AggValueSource> facetStats = facet.facetStats;\n      // validate facet sort\n      boolean isValidSort = facetSort == null ||\n          \"index\".equals(facetSort.sortVariable) ||\n          \"count\".equals(facetSort.sortVariable) ||\n          (facetStats != null && facetStats.containsKey(facetSort.sortVariable));\n\n      if (!isValidSort) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Invalid \" + sortParam + \" option '\" + sort + \"' for field '\" + facet.field + \"'\");\n      }\n      return facetSort;\n    }\n\n","sourceOld":"    /**\n     * Parses, validates and returns the {@link FacetSort} for given sortParam\n     * and facet field\n     * <p>\n     *   Currently, supported sort specifications are 'mystat desc' OR {mystat: 'desc'}\n     *   index - This is equivalent to 'index asc'\n     *   count - This is equivalent to 'count desc'\n     * </p>\n     *\n     * @param facet {@link FacetField} for which sort needs to be parsed and validated\n     * @param args map containing the sortVal for given sortParam\n     * @param sortParam parameter for which sort needs to parsed and validated\n     * @return parsed facet sort\n     */\n    private static FacetSort parseAndValidateSort(FacetField facet, Map<String, Object> args, String sortParam) {\n      Object sort = args.get(sortParam);\n      if (sort == null) {\n        return null;\n      }\n\n      FacetSort facetSort = null;\n\n      if (sort instanceof String) {\n        String sortStr = (String)sort;\n        if (sortStr.endsWith(\" asc\")) {\n          facetSort =  new FacetSort(sortStr.substring(0, sortStr.length()-\" asc\".length()),\n              SortDirection.asc);\n        } else if (sortStr.endsWith(\" desc\")) {\n          facetSort =  new FacetSort(sortStr.substring(0, sortStr.length()-\" desc\".length()),\n              SortDirection.desc);\n        } else {\n          facetSort =  new FacetSort(sortStr,\n              // default direction for \"index\" is ascending\n              (\"index\".equals(sortStr)\n                  ? SortDirection.asc\n                  : SortDirection.desc));\n        }\n      } else if (sort instanceof Map) {\n        // { myvar : 'desc' }\n        Optional<Map.Entry<String,Object>> optional = ((Map<String,Object>)sort).entrySet().stream().findFirst();\n        if (optional.isPresent()) {\n          Map.Entry<String, Object> entry = optional.get();\n          facetSort = new FacetSort(entry.getKey(), SortDirection.fromObj(entry.getValue()));\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Expected string/map for '\" + sortParam +\"', received \"+ sort.getClass().getSimpleName() + \"=\" + sort);\n      }\n\n      Map<String, AggValueSource> facetStats = facet.facetStats;\n      // validate facet sort\n      boolean isValidSort = facetSort == null ||\n          \"index\".equals(facetSort.sortVariable) ||\n          \"count\".equals(facetSort.sortVariable) ||\n          (facetStats != null && facetStats.containsKey(facetSort.sortVariable));\n\n      if (!isValidSort) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Invalid \" + sortParam + \" option '\" + sort + \"' for field '\" + facet.field + \"'\");\n      }\n      return facetSort;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba33781da68babcaa5828121b443d3eb5c9d8480","date":1590595589,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetParser.FacetFieldParser#parseAndValidateSort(FacetField,Map[String,Object],String).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRequest.FacetFieldParser#parseAndValidateSort(FacetField,Map[String,Object],String).mjava","sourceNew":"    /**\n     * Parses, validates and returns the {@link FacetRequest.FacetSort} for given sortParam\n     * and facet field\n     * <p>\n     *   Currently, supported sort specifications are 'mystat desc' OR {mystat: 'desc'}\n     *   index - This is equivalent to 'index asc'\n     *   count - This is equivalent to 'count desc'\n     * </p>\n     *\n     * @param facet {@link FacetField} for which sort needs to be parsed and validated\n     * @param args map containing the sortVal for given sortParam\n     * @param sortParam parameter for which sort needs to parsed and validated\n     * @return parsed facet sort\n     */\n    private static FacetRequest.FacetSort parseAndValidateSort(FacetField facet, Map<String, Object> args, String sortParam) {\n      Object sort = args.get(sortParam);\n      if (sort == null) {\n        return null;\n      }\n\n      FacetRequest.FacetSort facetSort = null;\n\n      if (sort instanceof String) {\n        String sortStr = (String)sort;\n        if (sortStr.endsWith(\" asc\")) {\n          facetSort =  new FacetRequest.FacetSort(sortStr.substring(0, sortStr.length()-\" asc\".length()),\n                  FacetRequest.SortDirection.asc);\n        } else if (sortStr.endsWith(\" desc\")) {\n          facetSort =  new FacetRequest.FacetSort(sortStr.substring(0, sortStr.length()-\" desc\".length()),\n                  FacetRequest.SortDirection.desc);\n        } else {\n          facetSort =  new FacetRequest.FacetSort(sortStr,\n                  // default direction for \"index\" is ascending\n                  (\"index\".equals(sortStr)\n                          ? FacetRequest.SortDirection.asc\n                          : FacetRequest.SortDirection.desc));\n        }\n      } else if (sort instanceof Map) {\n        // { myvar : 'desc' }\n        @SuppressWarnings(\"unchecked\")\n        Optional<Map.Entry<String,Object>> optional = ((Map<String,Object>)sort).entrySet().stream().findFirst();\n        if (optional.isPresent()) {\n          Map.Entry<String, Object> entry = optional.get();\n          facetSort = new FacetRequest.FacetSort(entry.getKey(), FacetRequest.SortDirection.fromObj(entry.getValue()));\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Expected string/map for '\" + sortParam +\"', received \"+ sort.getClass().getSimpleName() + \"=\" + sort);\n      }\n\n      Map<String, AggValueSource> facetStats = facet.facetStats;\n      // validate facet sort\n      boolean isValidSort = facetSort == null ||\n              \"index\".equals(facetSort.sortVariable) ||\n              \"count\".equals(facetSort.sortVariable) ||\n              (facetStats != null && facetStats.containsKey(facetSort.sortVariable));\n\n      if (!isValidSort) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Invalid \" + sortParam + \" option '\" + sort + \"' for field '\" + facet.field + \"'\");\n      }\n      return facetSort;\n    }\n\n","sourceOld":"    /**\n     * Parses, validates and returns the {@link FacetSort} for given sortParam\n     * and facet field\n     * <p>\n     *   Currently, supported sort specifications are 'mystat desc' OR {mystat: 'desc'}\n     *   index - This is equivalent to 'index asc'\n     *   count - This is equivalent to 'count desc'\n     * </p>\n     *\n     * @param facet {@link FacetField} for which sort needs to be parsed and validated\n     * @param args map containing the sortVal for given sortParam\n     * @param sortParam parameter for which sort needs to parsed and validated\n     * @return parsed facet sort\n     */\n    private static FacetSort parseAndValidateSort(FacetField facet, Map<String, Object> args, String sortParam) {\n      Object sort = args.get(sortParam);\n      if (sort == null) {\n        return null;\n      }\n\n      FacetSort facetSort = null;\n\n      if (sort instanceof String) {\n        String sortStr = (String)sort;\n        if (sortStr.endsWith(\" asc\")) {\n          facetSort =  new FacetSort(sortStr.substring(0, sortStr.length()-\" asc\".length()),\n              SortDirection.asc);\n        } else if (sortStr.endsWith(\" desc\")) {\n          facetSort =  new FacetSort(sortStr.substring(0, sortStr.length()-\" desc\".length()),\n              SortDirection.desc);\n        } else {\n          facetSort =  new FacetSort(sortStr,\n              // default direction for \"index\" is ascending\n              (\"index\".equals(sortStr)\n                  ? SortDirection.asc\n                  : SortDirection.desc));\n        }\n      } else if (sort instanceof Map) {\n        // { myvar : 'desc' }\n        @SuppressWarnings(\"unchecked\")\n        Optional<Map.Entry<String,Object>> optional = ((Map<String,Object>)sort).entrySet().stream().findFirst();\n        if (optional.isPresent()) {\n          Map.Entry<String, Object> entry = optional.get();\n          facetSort = new FacetSort(entry.getKey(), SortDirection.fromObj(entry.getValue()));\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Expected string/map for '\" + sortParam +\"', received \"+ sort.getClass().getSimpleName() + \"=\" + sort);\n      }\n\n      Map<String, AggValueSource> facetStats = facet.facetStats;\n      // validate facet sort\n      boolean isValidSort = facetSort == null ||\n          \"index\".equals(facetSort.sortVariable) ||\n          \"count\".equals(facetSort.sortVariable) ||\n          (facetStats != null && facetStats.containsKey(facetSort.sortVariable));\n\n      if (!isValidSort) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Invalid \" + sortParam + \" option '\" + sort + \"' for field '\" + facet.field + \"'\");\n      }\n      return facetSort;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ba33781da68babcaa5828121b443d3eb5c9d8480":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ba33781da68babcaa5828121b443d3eb5c9d8480"]},"commit2Childs":{"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["ba33781da68babcaa5828121b443d3eb5c9d8480"],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"],"ba33781da68babcaa5828121b443d3eb5c9d8480":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}