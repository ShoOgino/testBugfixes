{"path":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#testConnectionReuse().mjava","commits":[{"id":"5ebf70dabe6279454c5ff460bdea3f0dc2814a86","date":1463672611,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#testConnectionReuse().mjava","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","sourceNew":"  @Test\n  public void testConnectionReuse() throws Exception {\n\n    URL url = cluster.getJettySolrRunners().get(0).getBaseUrl();\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try (SolrClient client = buildClient(httpClient, url)) {\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        boolean done = false;\n        for (int i = 0; i < cnt2; i++) {\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    }\n    finally {\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n    SolrClient client = null;\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try {\n      int rndClient = random().nextInt(3);\n      if (rndClient == 0) {\n        client = getConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1\n                                                                                   // thread\n      } else if (rndClient == 1) {\n        client = getHttpSolrClient(url.toString(), httpClient);\n      } else if (rndClient == 2) {\n        client = getCloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n        ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n        ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n        ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n        ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n      } else {\n        throw new RuntimeException(\"impossible\");\n      }\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        for (int i = 0; i < cnt2; i++) {\n          boolean done = false;\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    } finally {\n      client.close();\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#testConnectionReuse().mjava","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","sourceNew":"  @Test\n  public void testConnectionReuse() throws Exception {\n\n    URL url = cluster.getJettySolrRunners().get(0).getBaseUrl();\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try (SolrClient client = buildClient(httpClient, url)) {\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        boolean done = false;\n        for (int i = 0; i < cnt2; i++) {\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    }\n    finally {\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n    SolrClient client = null;\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try {\n      int rndClient = random().nextInt(3);\n      if (rndClient == 0) {\n        client = getConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1\n                                                                                   // thread\n      } else if (rndClient == 1) {\n        client = getHttpSolrClient(url.toString(), httpClient);\n      } else if (rndClient == 2) {\n        client = getCloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n        ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n        ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n        ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n        ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n      } else {\n        throw new RuntimeException(\"impossible\");\n      }\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        for (int i = 0; i < cnt2; i++) {\n          boolean done = false;\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    } finally {\n      client.close();\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df4598fc31f9fafcbeedd00f49a783e92e9ab536","date":1464013643,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#testConnectionReuse().mjava","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#testConnectionReuse().mjava","sourceNew":"  @Test\n  public void testConnectionReuse() throws Exception {\n\n    URL url = cluster.getJettySolrRunners().get(0).getBaseUrl();\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try (SolrClient client = buildClient(httpClient, url)) {\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        boolean done = false;\n        for (int i = 0; i < cnt2; i++) {\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = queueBreaks + 3;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    }\n    finally {\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testConnectionReuse() throws Exception {\n\n    URL url = cluster.getJettySolrRunners().get(0).getBaseUrl();\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try (SolrClient client = buildClient(httpClient, url)) {\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        boolean done = false;\n        for (int i = 0; i < cnt2; i++) {\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    }\n    finally {\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e616cfbf284ecbd0f40b4b9e4196daa27e92abd5","date":1464066565,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#testConnectionReuse().mjava","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#testConnectionReuse().mjava","sourceNew":"  @Test\n  public void testConnectionReuse() throws Exception {\n\n    URL url = cluster.getJettySolrRunners().get(0).getBaseUrl();\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try (SolrClient client = buildClient(httpClient, url)) {\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        boolean done = false;\n        for (int i = 0; i < cnt2; i++) {\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = queueBreaks + 3;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    }\n    finally {\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testConnectionReuse() throws Exception {\n\n    URL url = cluster.getJettySolrRunners().get(0).getBaseUrl();\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try (SolrClient client = buildClient(httpClient, url)) {\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        boolean done = false;\n        for (int i = 0; i < cnt2; i++) {\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    }\n    finally {\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40d65ca08c0188339ec86b19980af7306e97f274","date":1464075316,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#testConnectionReuse().mjava","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#testConnectionReuse().mjava","sourceNew":"  @Test\n  public void testConnectionReuse() throws Exception {\n\n    URL url = cluster.getJettySolrRunners().get(0).getBaseUrl();\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try (SolrClient client = buildClient(httpClient, url)) {\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        boolean done = false;\n        for (int i = 0; i < cnt2; i++) {\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    }\n    finally {\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testConnectionReuse() throws Exception {\n\n    URL url = cluster.getJettySolrRunners().get(0).getBaseUrl();\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try (SolrClient client = buildClient(httpClient, url)) {\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        boolean done = false;\n        for (int i = 0; i < cnt2; i++) {\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = queueBreaks + 3;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    }\n    finally {\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15fb22f207e0cbf913dbc9857b6a4fe30390a625","date":1475989569,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/impl/ConnectionReuseTest#testConnectionReuse().mjava","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#testConnectionReuse().mjava","sourceNew":"  @Test\n  public void testConnectionReuse() throws Exception {\n\n    URL url = cluster.getJettySolrRunners().get(0).getBaseUrl();\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try (SolrClient client = buildClient(httpClient, url)) {\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        boolean done = false;\n        for (int i = 0; i < cnt2; i++) {\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, HttpSolrClient.cacheKey);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    }\n    finally {\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testConnectionReuse() throws Exception {\n\n    URL url = cluster.getJettySolrRunners().get(0).getBaseUrl();\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try (SolrClient client = buildClient(httpClient, url)) {\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        boolean done = false;\n        for (int i = 0; i < cnt2; i++) {\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    }\n    finally {\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"15fb22f207e0cbf913dbc9857b6a4fe30390a625":["40d65ca08c0188339ec86b19980af7306e97f274"],"40d65ca08c0188339ec86b19980af7306e97f274":["e616cfbf284ecbd0f40b4b9e4196daa27e92abd5"],"5ebf70dabe6279454c5ff460bdea3f0dc2814a86":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e616cfbf284ecbd0f40b4b9e4196daa27e92abd5":["d470c8182e92b264680e34081b75e70a9f2b3c89","df4598fc31f9fafcbeedd00f49a783e92e9ab536"],"df4598fc31f9fafcbeedd00f49a783e92e9ab536":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["15fb22f207e0cbf913dbc9857b6a4fe30390a625"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5ebf70dabe6279454c5ff460bdea3f0dc2814a86"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5ebf70dabe6279454c5ff460bdea3f0dc2814a86","d470c8182e92b264680e34081b75e70a9f2b3c89"],"15fb22f207e0cbf913dbc9857b6a4fe30390a625":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"40d65ca08c0188339ec86b19980af7306e97f274":["15fb22f207e0cbf913dbc9857b6a4fe30390a625"],"e616cfbf284ecbd0f40b4b9e4196daa27e92abd5":["40d65ca08c0188339ec86b19980af7306e97f274"],"5ebf70dabe6279454c5ff460bdea3f0dc2814a86":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"df4598fc31f9fafcbeedd00f49a783e92e9ab536":["e616cfbf284ecbd0f40b4b9e4196daa27e92abd5"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["e616cfbf284ecbd0f40b4b9e4196daa27e92abd5","df4598fc31f9fafcbeedd00f49a783e92e9ab536"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}