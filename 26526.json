{"path":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","commits":[{"id":"a371aa649cc243e82cb8677ca960a1e0232ecedf","date":1393605574,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandomNRT() throws Exception {\n    final File tempDir = TestUtil.getTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, tempDir, a, a, minPrefixChars) {\n        @Override\n        protected Directory getDirectory(File path) {\n          return newFSDirectory(path);\n        }\n      };\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<Long>();\n    Set<String> usedKeys = new HashSet<String>();\n\n    List<Input> inputs = new ArrayList<Input>();\n    List<Update> pendingUpdates = new ArrayList<Update>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, tempDir, a, a, minPrefixChars) {\n            @Override\n            protected Directory getDirectory(File path) {\n              return newFSDirectory(path);\n            }\n          };\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<Input>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ec083aa3f3ecd55f91c47009d49e45553f99bd77","4637747f71df783fc2014ef1f1e0418466e3bed6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f1e7da8a91a92330e8f04b171b83e655a4a25c31","date":1394125906,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  public void testRandomNRT() throws Exception {\n    final File tempDir = TestUtil.getTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<Long>();\n    Set<String> usedKeys = new HashSet<String>();\n\n    List<Input> inputs = new ArrayList<Input>();\n    List<Update> pendingUpdates = new ArrayList<Update>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<Input>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final File tempDir = TestUtil.getTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, tempDir, a, a, minPrefixChars) {\n        @Override\n        protected Directory getDirectory(File path) {\n          return newFSDirectory(path);\n        }\n      };\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<Long>();\n    Set<String> usedKeys = new HashSet<String>();\n\n    List<Input> inputs = new ArrayList<Input>();\n    List<Update> pendingUpdates = new ArrayList<Update>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, tempDir, a, a, minPrefixChars) {\n            @Override\n            protected Directory getDirectory(File path) {\n              return newFSDirectory(path);\n            }\n          };\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<Input>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4637747f71df783fc2014ef1f1e0418466e3bed6","date":1394196311,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  public void testRandomNRT() throws Exception {\n    final File tempDir = TestUtil.getTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<Long>();\n    Set<String> usedKeys = new HashSet<String>();\n\n    List<Input> inputs = new ArrayList<Input>();\n    List<Update> pendingUpdates = new ArrayList<Update>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<Input>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final File tempDir = TestUtil.getTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, tempDir, a, a, minPrefixChars) {\n        @Override\n        protected Directory getDirectory(File path) {\n          return newFSDirectory(path);\n        }\n      };\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<Long>();\n    Set<String> usedKeys = new HashSet<String>();\n\n    List<Input> inputs = new ArrayList<Input>();\n    List<Update> pendingUpdates = new ArrayList<Update>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, tempDir, a, a, minPrefixChars) {\n            @Override\n            protected Directory getDirectory(File path) {\n              return newFSDirectory(path);\n            }\n          };\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<Input>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","bugFix":["a371aa649cc243e82cb8677ca960a1e0232ecedf"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96ea64d994d340044e0d57aeb6a5871539d10ca5","date":1394225445,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  public void testRandomNRT() throws Exception {\n    final File tempDir = TestUtil.getTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<Long>();\n    Set<String> usedKeys = new HashSet<String>();\n\n    List<Input> inputs = new ArrayList<Input>();\n    List<Update> pendingUpdates = new ArrayList<Update>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<Input>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final File tempDir = TestUtil.getTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, tempDir, a, a, minPrefixChars) {\n        @Override\n        protected Directory getDirectory(File path) {\n          return newFSDirectory(path);\n        }\n      };\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<Long>();\n    Set<String> usedKeys = new HashSet<String>();\n\n    List<Input> inputs = new ArrayList<Input>();\n    List<Update> pendingUpdates = new ArrayList<Update>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, tempDir, a, a, minPrefixChars) {\n            @Override\n            protected Directory getDirectory(File path) {\n              return newFSDirectory(path);\n            }\n          };\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<Input>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  public void testRandomNRT() throws Exception {\n    final File tempDir = TestUtil.getTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final File tempDir = TestUtil.getTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<Long>();\n    Set<String> usedKeys = new HashSet<String>();\n\n    List<Input> inputs = new ArrayList<Input>();\n    List<Update> pendingUpdates = new ArrayList<Update>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<Input>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b","date":1395588343,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  public void testRandomNRT() throws Exception {\n    final File tempDir = TestUtil.getTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final File tempDir = TestUtil.getTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0d579490a72f2e6297eaa648940611234c57cf1","date":1395917140,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  public void testRandomNRT() throws Exception {\n    final File tempDir = TestUtil.createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final File tempDir = TestUtil.getTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c","date":1396633078,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  public void testRandomNRT() throws Exception {\n    final File tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final File tempDir = TestUtil.createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a0f5bb79c600763ffe7b8141df59a3169d31e48","date":1396689440,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  public void testRandomNRT() throws Exception {\n    final File tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final File tempDir = TestUtil.getTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6549d5ea6b7b25525309b981de3ec92b4dff99d1","date":1408666035,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  public void testRandomNRT() throws Exception {\n    final File tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars, false);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars, false);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final File tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19e497fe4da591a79332da97681b8017d9c61165","date":1409030374,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  public void testRandomNRT() throws Exception {\n    final File tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final File tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars, false);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a, minPrefixChars, false);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  public void testRandomNRT() throws Exception {\n    final Path tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final File tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec083aa3f3ecd55f91c47009d49e45553f99bd77","date":1416002645,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  public void testRandomNRT() throws Exception {\n    final Path tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            if (doHilite) {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).highlightKey);\n            } else {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key);\n            }\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final Path tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key.toString());\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","bugFix":["a371aa649cc243e82cb8677ca960a1e0232ecedf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a56958d7f71a28824f20031ffbb2e13502a0274e","date":1425573902,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  public void testRandomNRT() throws Exception {\n    final Path tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            if (doHilite) {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).highlightKey);\n            } else {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key);\n            }\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n    a.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final Path tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            if (doHilite) {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).highlightKey);\n            } else {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key);\n            }\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  public void testRandomNRT() throws Exception {\n    final Path tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            if (doHilite) {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).highlightKey);\n            } else {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key);\n            }\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n    a.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final Path tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            if (doHilite) {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).highlightKey);\n            } else {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key);\n            }\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  public void testRandomNRT() throws Exception {\n    final Path tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n            (a1, b) -> {\n              if (a1.v > b.v) {\n                return -1;\n              } else if (a1.v < b.v) {\n                return 1;\n              } else {\n                return 0;\n              }\n            });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            if (doHilite) {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).highlightKey);\n            } else {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key);\n            }\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n    a.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final Path tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n                         new Comparator<Input>() {\n                           @Override\n                           public int compare(Input a, Input b) {\n                             if (a.v > b.v) {\n                               return -1;\n                             } else if (a.v < b.v) {\n                               return 1;\n                             } else {\n                               return 0;\n                             }\n                           }\n                         });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            if (doHilite) {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).highlightKey);\n            } else {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key);\n            }\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n    a.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f","date":1579652839,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testRandomNRT().mjava","sourceNew":"  @Slow\n  public void testRandomNRT() throws Exception {\n    final Path tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(100);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n            (a1, b) -> {\n              if (a1.v > b.v) {\n                return -1;\n              } else if (a1.v < b.v) {\n                return 1;\n              } else {\n                return 0;\n              }\n            });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            if (doHilite) {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).highlightKey);\n            } else {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key);\n            }\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n    a.close();\n  }\n\n","sourceOld":"  public void testRandomNRT() throws Exception {\n    final Path tempDir = createTempDir(\"AnalyzingInfixSuggesterTest\");\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    int minPrefixChars = random().nextInt(7);\n    if (VERBOSE) {\n      System.out.println(\"  minPrefixChars=\" + minPrefixChars);\n    }\n\n    AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n\n    // Initial suggester built with nothing:\n    suggester.build(new InputArrayIterator(new Input[0]));\n\n    LookupThread lookupThread = new LookupThread(suggester);\n    lookupThread.start();\n\n    int iters = atLeast(1000);\n    int visibleUpto = 0;\n\n    Set<Long> usedWeights = new HashSet<>();\n    Set<String> usedKeys = new HashSet<>();\n\n    List<Input> inputs = new ArrayList<>();\n    List<Update> pendingUpdates = new ArrayList<>();\n\n    for(int iter=0;iter<iters;iter++) {\n      String text;\n      while (true) {\n        text = randomText();\n        if (usedKeys.contains(text) == false) {\n          usedKeys.add(text);\n          break;\n        }\n      }\n\n      // Carefully pick a weight we never used, to sidestep\n      // tie-break problems:\n      long weight;\n      while (true) {\n        weight = random().nextInt(10*iters);\n        if (usedWeights.contains(weight) == false) {\n          usedWeights.add(weight);\n          break;\n        }\n      }\n\n      if (inputs.size() > 0 && random().nextInt(4) == 1) {\n        // Update an existing suggestion\n        Update update = new Update();\n        update.index = random().nextInt(inputs.size());\n        update.weight = weight;\n        Input input = inputs.get(update.index);\n        pendingUpdates.add(update);\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update input=\" + input.term.utf8ToString() + \"/\" + weight);\n        }\n        suggester.update(input.term, null, weight, input.term);\n        \n      } else {\n        // Add a new suggestion\n        inputs.add(new Input(text, weight, new BytesRef(text)));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add input=\" + text + \"/\" + weight);\n        }\n        BytesRef br = new BytesRef(text);\n        suggester.add(br, null, weight, br);\n      }\n\n      if (random().nextInt(15) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now refresh suggester\");\n        }\n        suggester.refresh();\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n      \n      if (random().nextInt(50) == 7) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now close/reopen suggester\");\n        }\n        lookupThread.finish();\n        suggester.close();\n        suggester = new AnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, minPrefixChars, false);\n        lookupThread = new LookupThread(suggester);\n        lookupThread.start();\n\n        visibleUpto = inputs.size();\n        for(Update update : pendingUpdates) {\n          Input oldInput = inputs.get(update.index);\n          Input newInput = new Input(oldInput.term, update.weight, oldInput.payload);\n          inputs.set(update.index, newInput);\n        }\n        pendingUpdates.clear();\n      }\n\n      if (visibleUpto > 0) {\n        String query = randomText();\n        boolean lastPrefix = random().nextInt(5) != 1;\n        if (lastPrefix == false) {\n          query += \" \";\n        }\n\n        String[] queryTerms = query.split(\"\\\\s\");\n        boolean allTermsRequired = random().nextInt(10) == 7;\n        boolean doHilite = random().nextBoolean();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: lookup \\\"\" + query + \"\\\" allTermsRequired=\" + allTermsRequired + \" doHilite=\" + doHilite);\n        }\n\n        // Stupid slow but hopefully correct matching:\n        List<Input> expected = new ArrayList<>();\n        for(int i=0;i<visibleUpto;i++) {\n          Input input = inputs.get(i);\n          String[] inputTerms = input.term.utf8ToString().split(\"\\\\s\");\n          boolean match = false;\n          for(int j=0;j<queryTerms.length;j++) {\n            if (j < queryTerms.length-1 || lastPrefix == false) {\n              // Exact match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].equals(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            } else {\n              // Prefix match\n              for(int k=0;k<inputTerms.length;k++) {\n                if (inputTerms[k].startsWith(queryTerms[j])) {\n                  match = true;\n                  break;\n                }\n              }\n            }\n            if (match) {\n              if (allTermsRequired == false) {\n                // At least one query term does match:\n                break;\n              }\n              match = false;\n            } else if (allTermsRequired) {\n              // At least one query term does not match:\n              break;\n            }\n          }\n\n          if (match) {\n            if (doHilite) {\n              expected.add(new Input(hilite(lastPrefix, inputTerms, queryTerms), input.v, input.term));\n            } else {\n              expected.add(input);\n            }\n          }\n        }\n\n        Collections.sort(expected,\n            (a1, b) -> {\n              if (a1.v > b.v) {\n                return -1;\n              } else if (a1.v < b.v) {\n                return 1;\n              } else {\n                return 0;\n              }\n            });\n\n        if (expected.isEmpty() == false) {\n\n          int topN = TestUtil.nextInt(random(), 1, expected.size());\n\n          List<LookupResult> actual = suggester.lookup(TestUtil.stringToCharSequence(query, random()), topN, allTermsRequired, doHilite);\n\n          int expectedCount = Math.min(topN, expected.size());\n\n          if (VERBOSE) {\n            System.out.println(\"  expected:\");\n            for(int i=0;i<expectedCount;i++) {\n              Input x = expected.get(i);\n              System.out.println(\"    \" + x.term.utf8ToString() + \"/\" + x.v);\n            }\n            System.out.println(\"  actual:\");\n            for(LookupResult result : actual) {\n              System.out.println(\"    \" + result);\n            }\n          }\n\n          assertEquals(expectedCount, actual.size());\n          for(int i=0;i<expectedCount;i++) {\n            if (doHilite) {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).highlightKey);\n            } else {\n              assertEquals(expected.get(i).term.utf8ToString(), actual.get(i).key);\n            }\n            assertEquals(expected.get(i).v, actual.get(i).value);\n            assertEquals(expected.get(i).payload, actual.get(i).payload);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  no expected matches\");\n          }\n        }\n      }\n    }\n\n    lookupThread.finish();\n    suggester.close();\n    a.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["3a0c04b71951333291abc7f317109a6a5957bd28"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["4637747f71df783fc2014ef1f1e0418466e3bed6"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":["a371aa649cc243e82cb8677ca960a1e0232ecedf","4637747f71df783fc2014ef1f1e0418466e3bed6"],"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b","a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"6549d5ea6b7b25525309b981de3ec92b4dff99d1":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"f4abec28b874149a7223e32cc7a01704c27790de":["19e497fe4da591a79332da97681b8017d9c61165"],"a371aa649cc243e82cb8677ca960a1e0232ecedf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d0d579490a72f2e6297eaa648940611234c57cf1":["58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b"],"3a0c04b71951333291abc7f317109a6a5957bd28":["a56958d7f71a28824f20031ffbb2e13502a0274e"],"f1e7da8a91a92330e8f04b171b83e655a4a25c31":["a371aa649cc243e82cb8677ca960a1e0232ecedf"],"19e497fe4da591a79332da97681b8017d9c61165":["6549d5ea6b7b25525309b981de3ec92b4dff99d1"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["ec083aa3f3ecd55f91c47009d49e45553f99bd77","a56958d7f71a28824f20031ffbb2e13502a0274e"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["d0d579490a72f2e6297eaa648940611234c57cf1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ec083aa3f3ecd55f91c47009d49e45553f99bd77":["f4abec28b874149a7223e32cc7a01704c27790de"],"a56958d7f71a28824f20031ffbb2e13502a0274e":["ec083aa3f3ecd55f91c47009d49e45553f99bd77"],"4637747f71df783fc2014ef1f1e0418466e3bed6":["a371aa649cc243e82cb8677ca960a1e0232ecedf","f1e7da8a91a92330e8f04b171b83e655a4a25c31"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"]},"commit2Childs":{"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":[],"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b":["2a0f5bb79c600763ffe7b8141df59a3169d31e48","d0d579490a72f2e6297eaa648940611234c57cf1"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["6549d5ea6b7b25525309b981de3ec92b4dff99d1"],"6549d5ea6b7b25525309b981de3ec92b4dff99d1":["19e497fe4da591a79332da97681b8017d9c61165"],"a371aa649cc243e82cb8677ca960a1e0232ecedf":["96ea64d994d340044e0d57aeb6a5871539d10ca5","f1e7da8a91a92330e8f04b171b83e655a4a25c31","4637747f71df783fc2014ef1f1e0418466e3bed6"],"f4abec28b874149a7223e32cc7a01704c27790de":["ec083aa3f3ecd55f91c47009d49e45553f99bd77"],"d0d579490a72f2e6297eaa648940611234c57cf1":["a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"3a0c04b71951333291abc7f317109a6a5957bd28":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"f1e7da8a91a92330e8f04b171b83e655a4a25c31":["4637747f71df783fc2014ef1f1e0418466e3bed6"],"19e497fe4da591a79332da97681b8017d9c61165":["f4abec28b874149a7223e32cc7a01704c27790de"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a371aa649cc243e82cb8677ca960a1e0232ecedf"],"ec083aa3f3ecd55f91c47009d49e45553f99bd77":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","a56958d7f71a28824f20031ffbb2e13502a0274e"],"4637747f71df783fc2014ef1f1e0418466e3bed6":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","96ea64d994d340044e0d57aeb6a5871539d10ca5"],"a56958d7f71a28824f20031ffbb2e13502a0274e":["3a0c04b71951333291abc7f317109a6a5957bd28","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["96ea64d994d340044e0d57aeb6a5871539d10ca5","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}