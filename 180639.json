{"path":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","sourceNew":"  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<String>();\n    for(FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.isIndexed) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","sourceOld":"  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<String>();\n    for(FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.isIndexed) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76923f6a33f2c4bec7f584e3f251261afe7ea276","date":1337149711,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","sourceNew":"  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<String>();\n    for(FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.isIndexed()) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","sourceOld":"  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<String>();\n    for(FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.isIndexed) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","sourceNew":"  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<String>();\n    for(FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.isIndexed()) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","sourceOld":"  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<String>();\n    for(FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.isIndexed) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","sourceNew":"  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<String>();\n    for(final FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.isIndexed()) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","sourceOld":"  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<String>();\n    for(FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.isIndexed()) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3b4a63b6b0155323dde6b827e0dc22a43580753","date":1346168671,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","sourceNew":"  /** Call this to get the (merged) FieldInfos representing the\n   *  set of indexed fields <b>only</b> for a composite reader. \n   *  <p>\n   *  NOTE: the returned field numbers will likely not\n   *  correspond to the actual field numbers in the underlying\n   *  readers, and codec metadata ({@link FieldInfo#getAttribute(String)}\n   *  will be unavailable.\n   */\n  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<String>();\n    for(final FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.isIndexed()) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","sourceOld":"  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<String>();\n    for(final FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.isIndexed()) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","sourceNew":"  /** Call this to get the (merged) FieldInfos representing the\n   *  set of indexed fields <b>only</b> for a composite reader. \n   *  <p>\n   *  NOTE: the returned field numbers will likely not\n   *  correspond to the actual field numbers in the underlying\n   *  readers, and codec metadata ({@link FieldInfo#getAttribute(String)}\n   *  will be unavailable.\n   */\n  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<String>();\n    for(final FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.isIndexed()) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","sourceOld":"  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<String>();\n    for(final FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.isIndexed()) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","sourceNew":"  /** Call this to get the (merged) FieldInfos representing the\n   *  set of indexed fields <b>only</b> for a composite reader. \n   *  <p>\n   *  NOTE: the returned field numbers will likely not\n   *  correspond to the actual field numbers in the underlying\n   *  readers, and codec metadata ({@link FieldInfo#getAttribute(String)}\n   *  will be unavailable.\n   */\n  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<>();\n    for(final FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.isIndexed()) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","sourceOld":"  /** Call this to get the (merged) FieldInfos representing the\n   *  set of indexed fields <b>only</b> for a composite reader. \n   *  <p>\n   *  NOTE: the returned field numbers will likely not\n   *  correspond to the actual field numbers in the underlying\n   *  readers, and codec metadata ({@link FieldInfo#getAttribute(String)}\n   *  will be unavailable.\n   */\n  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<String>();\n    for(final FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.isIndexed()) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"556a4aab886d75371b2af129d87be3c2795cea76","date":1414954991,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","sourceNew":"  /** Call this to get the (merged) FieldInfos representing the\n   *  set of indexed fields <b>only</b> for a composite reader. \n   *  <p>\n   *  NOTE: the returned field numbers will likely not\n   *  correspond to the actual field numbers in the underlying\n   *  readers, and codec metadata ({@link FieldInfo#getAttribute(String)}\n   *  will be unavailable.\n   */\n  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<>();\n    for(final FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.getIndexOptions() != IndexOptions.NONE) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","sourceOld":"  /** Call this to get the (merged) FieldInfos representing the\n   *  set of indexed fields <b>only</b> for a composite reader. \n   *  <p>\n   *  NOTE: the returned field numbers will likely not\n   *  correspond to the actual field numbers in the underlying\n   *  readers, and codec metadata ({@link FieldInfo#getAttribute(String)}\n   *  will be unavailable.\n   */\n  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<>();\n    for(final FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.isIndexed()) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da5d9b1595107c543a197a30a4ea7ba48736b5e8","date":1537588030,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","sourceNew":"  /** Returns a set of names of fields that have a terms index.  The order is undefined. */\n  public static Collection<String> getIndexedFields(IndexReader reader) {\n    return reader.leaves().stream()\n        .flatMap(l -> StreamSupport.stream(l.reader().getFieldInfos().spliterator(), false)\n        .filter(fi -> fi.getIndexOptions() != IndexOptions.NONE))\n        .map(fi -> fi.name)\n        .collect(Collectors.toSet());\n  }\n\n","sourceOld":"  /** Call this to get the (merged) FieldInfos representing the\n   *  set of indexed fields <b>only</b> for a composite reader. \n   *  <p>\n   *  NOTE: the returned field numbers will likely not\n   *  correspond to the actual field numbers in the underlying\n   *  readers, and codec metadata ({@link FieldInfo#getAttribute(String)}\n   *  will be unavailable.\n   */\n  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<>();\n    for(final FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.getIndexOptions() != IndexOptions.NONE) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1fec8b37cbb6884a64d39565e9dd7b4522a0598","date":1537699559,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","sourceNew":"  /** Returns a set of names of fields that have a terms index.  The order is undefined. */\n  public static Collection<String> getIndexedFields(IndexReader reader) {\n    return reader.leaves().stream()\n        .flatMap(l -> StreamSupport.stream(l.reader().getFieldInfos().spliterator(), false)\n        .filter(fi -> fi.getIndexOptions() != IndexOptions.NONE))\n        .map(fi -> fi.name)\n        .collect(Collectors.toSet());\n  }\n\n","sourceOld":"  /** Call this to get the (merged) FieldInfos representing the\n   *  set of indexed fields <b>only</b> for a composite reader. \n   *  <p>\n   *  NOTE: the returned field numbers will likely not\n   *  correspond to the actual field numbers in the underlying\n   *  readers, and codec metadata ({@link FieldInfo#getAttribute(String)}\n   *  will be unavailable.\n   */\n  public static Collection<String> getIndexedFields(IndexReader reader) {\n    final Collection<String> fields = new HashSet<>();\n    for(final FieldInfo fieldInfo : getMergedFieldInfos(reader)) {\n      if (fieldInfo.getIndexOptions() != IndexOptions.NONE) {\n        fields.add(fieldInfo.name);\n      }\n    }\n    return fields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos#getIndexedFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getIndexedFields(IndexReader).mjava","sourceNew":"  /** Returns a set of names of fields that have a terms index.  The order is undefined. */\n  public static Collection<String> getIndexedFields(IndexReader reader) {\n    return reader.leaves().stream()\n        .flatMap(l -> StreamSupport.stream(l.reader().getFieldInfos().spliterator(), false)\n        .filter(fi -> fi.getIndexOptions() != IndexOptions.NONE))\n        .map(fi -> fi.name)\n        .collect(Collectors.toSet());\n  }\n\n","sourceOld":"  /** Returns a set of names of fields that have a terms index.  The order is undefined. */\n  public static Collection<String> getIndexedFields(IndexReader reader) {\n    return reader.leaves().stream()\n        .flatMap(l -> StreamSupport.stream(l.reader().getFieldInfos().spliterator(), false)\n        .filter(fi -> fi.getIndexOptions() != IndexOptions.NONE))\n        .map(fi -> fi.name)\n        .collect(Collectors.toSet());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a3b4a63b6b0155323dde6b827e0dc22a43580753"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"a3b4a63b6b0155323dde6b827e0dc22a43580753":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"556a4aab886d75371b2af129d87be3c2795cea76":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","a3b4a63b6b0155323dde6b827e0dc22a43580753"],"da5d9b1595107c543a197a30a4ea7ba48736b5e8":["556a4aab886d75371b2af129d87be3c2795cea76"],"76923f6a33f2c4bec7f584e3f251261afe7ea276":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","76923f6a33f2c4bec7f584e3f251261afe7ea276"],"f1fec8b37cbb6884a64d39565e9dd7b4522a0598":["556a4aab886d75371b2af129d87be3c2795cea76","da5d9b1595107c543a197a30a4ea7ba48736b5e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"04e775de416dd2d8067b10db1c8af975a1d5017e":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["04e775de416dd2d8067b10db1c8af975a1d5017e"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["556a4aab886d75371b2af129d87be3c2795cea76"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["a3b4a63b6b0155323dde6b827e0dc22a43580753","05a14b2611ead08655a2b2bdc61632eb31316e57"],"a3b4a63b6b0155323dde6b827e0dc22a43580753":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","05a14b2611ead08655a2b2bdc61632eb31316e57"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["76923f6a33f2c4bec7f584e3f251261afe7ea276","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"556a4aab886d75371b2af129d87be3c2795cea76":["da5d9b1595107c543a197a30a4ea7ba48736b5e8","f1fec8b37cbb6884a64d39565e9dd7b4522a0598"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"da5d9b1595107c543a197a30a4ea7ba48736b5e8":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598"],"76923f6a33f2c4bec7f584e3f251261afe7ea276":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"f1fec8b37cbb6884a64d39565e9dd7b4522a0598":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["05a14b2611ead08655a2b2bdc61632eb31316e57","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}