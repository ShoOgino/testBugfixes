{"path":"src/java/org/apache/lucene/search/RangeFilter#bits(IndexReader).mjava","commits":[{"id":"95395bf94a1949052d9110b07e728d9cf6aba90c","date":1101219438,"type":0,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/RangeFilter#bits(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Returns a BitSet with true for documents which should be\n     * permitted in search results, and false for those that should\n     * not.\n     */\n    public BitSet bits(IndexReader reader) throws IOException {\n        BitSet bits = new BitSet(reader.maxDoc());\n        TermEnum enumerator =\n            (null != lowerTerm\n             ? reader.terms(new Term(fieldName, lowerTerm))\n             : reader.terms(new Term(fieldName,\"\")));\n        \n        try {\n            \n            if (enumerator.term() == null) {\n                return bits;\n            }\n            \n            boolean checkLower = false;\n            if (!includeLower) // make adjustments to set to exclusive\n                checkLower = true;\n        \n            TermDocs termDocs = reader.termDocs();\n            try {\n                \n                do {\n                    Term term = enumerator.term();\n                    if (term != null && term.field().equals(fieldName)) {\n                        if (!checkLower || null==lowerTerm || term.text().compareTo(lowerTerm) > 0) {\n                            checkLower = false;\n                            if (upperTerm != null) {\n                                int compare = upperTerm.compareTo(term.text());\n                                /* if beyond the upper term, or is exclusive and\n                                 * this is equal to the upper term, break out */\n                                if ((compare < 0) ||\n                                    (!includeUpper && compare==0)) {\n                                    break;\n                                }\n                            }\n                            /* we have a good term, find the docs */\n                            \n                            termDocs.seek(enumerator.term());\n                            while (termDocs.next()) {\n                                bits.set(termDocs.doc());\n                            }\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                while (enumerator.next());\n                \n            } finally {\n                termDocs.close();\n            }\n        } finally {\n            enumerator.close();\n        }\n\n        return bits;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"52ce7e961a8217faac8128e3c8fe67819eefdde9","date":1201979043,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/RangeFilter#bits(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/RangeFilter#bits(IndexReader).mjava","sourceNew":"    /**\n     * Returns a BitSet with true for documents which should be\n     * permitted in search results, and false for those that should\n     * not.\n     * @deprecated Use {@link #getDocIdSet(IndexReader)} instead.\n     */\n    public BitSet bits(IndexReader reader) throws IOException {\n        BitSet bits = new BitSet(reader.maxDoc());\n        TermEnum enumerator =\n            (null != lowerTerm\n             ? reader.terms(new Term(fieldName, lowerTerm))\n             : reader.terms(new Term(fieldName,\"\")));\n        \n        try {\n            \n            if (enumerator.term() == null) {\n                return bits;\n            }\n            \n            boolean checkLower = false;\n            if (!includeLower) // make adjustments to set to exclusive\n                checkLower = true;\n        \n            TermDocs termDocs = reader.termDocs();\n            try {\n                \n                do {\n                    Term term = enumerator.term();\n                    if (term != null && term.field().equals(fieldName)) {\n                        if (!checkLower || null==lowerTerm || term.text().compareTo(lowerTerm) > 0) {\n                            checkLower = false;\n                            if (upperTerm != null) {\n                                int compare = upperTerm.compareTo(term.text());\n                                /* if beyond the upper term, or is exclusive and\n                                 * this is equal to the upper term, break out */\n                                if ((compare < 0) ||\n                                    (!includeUpper && compare==0)) {\n                                    break;\n                                }\n                            }\n                            /* we have a good term, find the docs */\n                            \n                            termDocs.seek(enumerator.term());\n                            while (termDocs.next()) {\n                                bits.set(termDocs.doc());\n                            }\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                while (enumerator.next());\n                \n            } finally {\n                termDocs.close();\n            }\n        } finally {\n            enumerator.close();\n        }\n\n        return bits;\n    }\n\n","sourceOld":"    /**\n     * Returns a BitSet with true for documents which should be\n     * permitted in search results, and false for those that should\n     * not.\n     */\n    public BitSet bits(IndexReader reader) throws IOException {\n        BitSet bits = new BitSet(reader.maxDoc());\n        TermEnum enumerator =\n            (null != lowerTerm\n             ? reader.terms(new Term(fieldName, lowerTerm))\n             : reader.terms(new Term(fieldName,\"\")));\n        \n        try {\n            \n            if (enumerator.term() == null) {\n                return bits;\n            }\n            \n            boolean checkLower = false;\n            if (!includeLower) // make adjustments to set to exclusive\n                checkLower = true;\n        \n            TermDocs termDocs = reader.termDocs();\n            try {\n                \n                do {\n                    Term term = enumerator.term();\n                    if (term != null && term.field().equals(fieldName)) {\n                        if (!checkLower || null==lowerTerm || term.text().compareTo(lowerTerm) > 0) {\n                            checkLower = false;\n                            if (upperTerm != null) {\n                                int compare = upperTerm.compareTo(term.text());\n                                /* if beyond the upper term, or is exclusive and\n                                 * this is equal to the upper term, break out */\n                                if ((compare < 0) ||\n                                    (!includeUpper && compare==0)) {\n                                    break;\n                                }\n                            }\n                            /* we have a good term, find the docs */\n                            \n                            termDocs.seek(enumerator.term());\n                            while (termDocs.next()) {\n                                bits.set(termDocs.doc());\n                            }\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                while (enumerator.next());\n                \n            } finally {\n                termDocs.close();\n            }\n        } finally {\n            enumerator.close();\n        }\n\n        return bits;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d73678020862536617f065bb3d28a71d8c4020c","date":1219142439,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/RangeFilter#bits(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/RangeFilter#bits(IndexReader).mjava","sourceNew":"    /**\n     * Returns a BitSet with true for documents which should be\n     * permitted in search results, and false for those that should\n     * not.\n     * @deprecated Use {@link #getDocIdSet(IndexReader)} instead.\n     */\n    public BitSet bits(IndexReader reader) throws IOException {\n        BitSet bits = new BitSet(reader.maxDoc());\n        TermEnum enumerator =\n            (null != lowerTerm\n             ? reader.terms(new Term(fieldName, lowerTerm))\n             : reader.terms(new Term(fieldName)));\n        \n        try {\n            \n            if (enumerator.term() == null) {\n                return bits;\n            }\n            \n            boolean checkLower = false;\n            if (!includeLower) // make adjustments to set to exclusive\n                checkLower = true;\n        \n            TermDocs termDocs = reader.termDocs();\n            try {\n                \n                do {\n                    Term term = enumerator.term();\n                    if (term != null && term.field().equals(fieldName)) {\n                        if (!checkLower || null==lowerTerm || term.text().compareTo(lowerTerm) > 0) {\n                            checkLower = false;\n                            if (upperTerm != null) {\n                                int compare = upperTerm.compareTo(term.text());\n                                /* if beyond the upper term, or is exclusive and\n                                 * this is equal to the upper term, break out */\n                                if ((compare < 0) ||\n                                    (!includeUpper && compare==0)) {\n                                    break;\n                                }\n                            }\n                            /* we have a good term, find the docs */\n                            \n                            termDocs.seek(enumerator.term());\n                            while (termDocs.next()) {\n                                bits.set(termDocs.doc());\n                            }\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                while (enumerator.next());\n                \n            } finally {\n                termDocs.close();\n            }\n        } finally {\n            enumerator.close();\n        }\n\n        return bits;\n    }\n\n","sourceOld":"    /**\n     * Returns a BitSet with true for documents which should be\n     * permitted in search results, and false for those that should\n     * not.\n     * @deprecated Use {@link #getDocIdSet(IndexReader)} instead.\n     */\n    public BitSet bits(IndexReader reader) throws IOException {\n        BitSet bits = new BitSet(reader.maxDoc());\n        TermEnum enumerator =\n            (null != lowerTerm\n             ? reader.terms(new Term(fieldName, lowerTerm))\n             : reader.terms(new Term(fieldName,\"\")));\n        \n        try {\n            \n            if (enumerator.term() == null) {\n                return bits;\n            }\n            \n            boolean checkLower = false;\n            if (!includeLower) // make adjustments to set to exclusive\n                checkLower = true;\n        \n            TermDocs termDocs = reader.termDocs();\n            try {\n                \n                do {\n                    Term term = enumerator.term();\n                    if (term != null && term.field().equals(fieldName)) {\n                        if (!checkLower || null==lowerTerm || term.text().compareTo(lowerTerm) > 0) {\n                            checkLower = false;\n                            if (upperTerm != null) {\n                                int compare = upperTerm.compareTo(term.text());\n                                /* if beyond the upper term, or is exclusive and\n                                 * this is equal to the upper term, break out */\n                                if ((compare < 0) ||\n                                    (!includeUpper && compare==0)) {\n                                    break;\n                                }\n                            }\n                            /* we have a good term, find the docs */\n                            \n                            termDocs.seek(enumerator.term());\n                            while (termDocs.next()) {\n                                bits.set(termDocs.doc());\n                            }\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                while (enumerator.next());\n                \n            } finally {\n                termDocs.close();\n            }\n        } finally {\n            enumerator.close();\n        }\n\n        return bits;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b33dc4652df2747e38f9782fde82bd426b77c538","date":1221599001,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/RangeFilter#bits(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/RangeFilter#bits(IndexReader).mjava","sourceNew":"    /**\n     * Returns a BitSet with true for documents which should be\n     * permitted in search results, and false for those that should\n     * not.\n     * @deprecated Use {@link #getDocIdSet(IndexReader)} instead.\n     */\n    public BitSet bits(IndexReader reader) throws IOException {\n        BitSet bits = new BitSet(reader.maxDoc());\n        TermEnum enumerator =\n            (null != lowerTerm && collator == null\n             ? reader.terms(new Term(fieldName, lowerTerm))\n             : reader.terms(new Term(fieldName)));\n        \n        try {\n            \n            if (enumerator.term() == null) {\n                return bits;\n            }\n            \n            TermDocs termDocs = reader.termDocs();\n            try {\n                if (collator != null) {\n                    do {\n                        Term term = enumerator.term();\n                        if (term != null && term.field().equals(fieldName)) {\n                            if ((lowerTerm == null\n                                 || (includeLower\n                                     ? collator.compare(term.text(), lowerTerm) >= 0\n                                     : collator.compare(term.text(), lowerTerm) > 0))\n                                && (upperTerm == null\n                                    || (includeUpper\n                                        ? collator.compare(term.text(), upperTerm) <= 0\n                                        : collator.compare(term.text(), upperTerm) < 0))) {\n                              /* we have a good term, find the docs */\n                                termDocs.seek(enumerator.term());\n                                while (termDocs.next()) {\n                                    bits.set(termDocs.doc());\n                                }\n                            }\n                        }\n                    }\n                    while (enumerator.next());\n                } else { // collator is null - use Unicode code point ordering\n                    boolean checkLower = false;\n                    if (!includeLower) // make adjustments to set to exclusive\n                        checkLower = true;\n       \n                    do {\n                        Term term = enumerator.term();\n                        if (term != null && term.field().equals(fieldName)) {\n                            if (!checkLower || null==lowerTerm || term.text().compareTo(lowerTerm) > 0) {\n                                checkLower = false;\n                                if (upperTerm != null) {\n                                    int compare = upperTerm.compareTo(term.text());\n                                    /* if beyond the upper term, or is exclusive and\n                                     * this is equal to the upper term, break out */\n                                    if ((compare < 0) ||\n                                        (!includeUpper && compare==0)) {\n                                        break;\n                                    }\n                                }\n                                /* we have a good term, find the docs */\n                            \n                                termDocs.seek(enumerator.term());\n                                while (termDocs.next()) {\n                                    bits.set(termDocs.doc());\n                                }\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                    while (enumerator.next());\n                }\n            } finally {\n                termDocs.close();\n            }\n        } finally {\n            enumerator.close();\n        }\n\n        return bits;\n    }\n\n","sourceOld":"    /**\n     * Returns a BitSet with true for documents which should be\n     * permitted in search results, and false for those that should\n     * not.\n     * @deprecated Use {@link #getDocIdSet(IndexReader)} instead.\n     */\n    public BitSet bits(IndexReader reader) throws IOException {\n        BitSet bits = new BitSet(reader.maxDoc());\n        TermEnum enumerator =\n            (null != lowerTerm\n             ? reader.terms(new Term(fieldName, lowerTerm))\n             : reader.terms(new Term(fieldName)));\n        \n        try {\n            \n            if (enumerator.term() == null) {\n                return bits;\n            }\n            \n            boolean checkLower = false;\n            if (!includeLower) // make adjustments to set to exclusive\n                checkLower = true;\n        \n            TermDocs termDocs = reader.termDocs();\n            try {\n                \n                do {\n                    Term term = enumerator.term();\n                    if (term != null && term.field().equals(fieldName)) {\n                        if (!checkLower || null==lowerTerm || term.text().compareTo(lowerTerm) > 0) {\n                            checkLower = false;\n                            if (upperTerm != null) {\n                                int compare = upperTerm.compareTo(term.text());\n                                /* if beyond the upper term, or is exclusive and\n                                 * this is equal to the upper term, break out */\n                                if ((compare < 0) ||\n                                    (!includeUpper && compare==0)) {\n                                    break;\n                                }\n                            }\n                            /* we have a good term, find the docs */\n                            \n                            termDocs.seek(enumerator.term());\n                            while (termDocs.next()) {\n                                bits.set(termDocs.doc());\n                            }\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                while (enumerator.next());\n                \n            } finally {\n                termDocs.close();\n            }\n        } finally {\n            enumerator.close();\n        }\n\n        return bits;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f7a11eba51d213f09b96054111cf56a1e5796a3","date":1226364000,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/RangeFilter#bits(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/RangeFilter#bits(IndexReader).mjava","sourceNew":"    /**\n     * Returns a BitSet with true for documents which should be\n     * permitted in search results, and false for those that should\n     * not.\n     * @deprecated Use {@link #getDocIdSet(IndexReader)} instead.\n     */\n    public BitSet bits(IndexReader reader) throws IOException {\n      return rangeQuery.getFilter().bits(reader);\n    }\n\n","sourceOld":"    /**\n     * Returns a BitSet with true for documents which should be\n     * permitted in search results, and false for those that should\n     * not.\n     * @deprecated Use {@link #getDocIdSet(IndexReader)} instead.\n     */\n    public BitSet bits(IndexReader reader) throws IOException {\n        BitSet bits = new BitSet(reader.maxDoc());\n        TermEnum enumerator =\n            (null != lowerTerm && collator == null\n             ? reader.terms(new Term(fieldName, lowerTerm))\n             : reader.terms(new Term(fieldName)));\n        \n        try {\n            \n            if (enumerator.term() == null) {\n                return bits;\n            }\n            \n            TermDocs termDocs = reader.termDocs();\n            try {\n                if (collator != null) {\n                    do {\n                        Term term = enumerator.term();\n                        if (term != null && term.field().equals(fieldName)) {\n                            if ((lowerTerm == null\n                                 || (includeLower\n                                     ? collator.compare(term.text(), lowerTerm) >= 0\n                                     : collator.compare(term.text(), lowerTerm) > 0))\n                                && (upperTerm == null\n                                    || (includeUpper\n                                        ? collator.compare(term.text(), upperTerm) <= 0\n                                        : collator.compare(term.text(), upperTerm) < 0))) {\n                              /* we have a good term, find the docs */\n                                termDocs.seek(enumerator.term());\n                                while (termDocs.next()) {\n                                    bits.set(termDocs.doc());\n                                }\n                            }\n                        }\n                    }\n                    while (enumerator.next());\n                } else { // collator is null - use Unicode code point ordering\n                    boolean checkLower = false;\n                    if (!includeLower) // make adjustments to set to exclusive\n                        checkLower = true;\n       \n                    do {\n                        Term term = enumerator.term();\n                        if (term != null && term.field().equals(fieldName)) {\n                            if (!checkLower || null==lowerTerm || term.text().compareTo(lowerTerm) > 0) {\n                                checkLower = false;\n                                if (upperTerm != null) {\n                                    int compare = upperTerm.compareTo(term.text());\n                                    /* if beyond the upper term, or is exclusive and\n                                     * this is equal to the upper term, break out */\n                                    if ((compare < 0) ||\n                                        (!includeUpper && compare==0)) {\n                                        break;\n                                    }\n                                }\n                                /* we have a good term, find the docs */\n                            \n                                termDocs.seek(enumerator.term());\n                                while (termDocs.next()) {\n                                    bits.set(termDocs.doc());\n                                }\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                    while (enumerator.next());\n                }\n            } finally {\n                termDocs.close();\n            }\n        } finally {\n            enumerator.close();\n        }\n\n        return bits;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2aa365c0765407d280cd5df0569b430c6f36832e","date":1239881843,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/search/RangeFilter#bits(IndexReader).mjava","sourceNew":null,"sourceOld":"    /**\n     * Returns a BitSet with true for documents which should be\n     * permitted in search results, and false for those that should\n     * not.\n     * @deprecated Use {@link #getDocIdSet(IndexReader)} instead.\n     */\n    public BitSet bits(IndexReader reader) throws IOException {\n      return rangeQuery.getFilter().bits(reader);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b33dc4652df2747e38f9782fde82bd426b77c538":["9d73678020862536617f065bb3d28a71d8c4020c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2aa365c0765407d280cd5df0569b430c6f36832e":["6f7a11eba51d213f09b96054111cf56a1e5796a3"],"52ce7e961a8217faac8128e3c8fe67819eefdde9":["95395bf94a1949052d9110b07e728d9cf6aba90c"],"95395bf94a1949052d9110b07e728d9cf6aba90c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2aa365c0765407d280cd5df0569b430c6f36832e"],"6f7a11eba51d213f09b96054111cf56a1e5796a3":["b33dc4652df2747e38f9782fde82bd426b77c538"],"9d73678020862536617f065bb3d28a71d8c4020c":["52ce7e961a8217faac8128e3c8fe67819eefdde9"]},"commit2Childs":{"b33dc4652df2747e38f9782fde82bd426b77c538":["6f7a11eba51d213f09b96054111cf56a1e5796a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["95395bf94a1949052d9110b07e728d9cf6aba90c"],"2aa365c0765407d280cd5df0569b430c6f36832e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"52ce7e961a8217faac8128e3c8fe67819eefdde9":["9d73678020862536617f065bb3d28a71d8c4020c"],"95395bf94a1949052d9110b07e728d9cf6aba90c":["52ce7e961a8217faac8128e3c8fe67819eefdde9"],"9d73678020862536617f065bb3d28a71d8c4020c":["b33dc4652df2747e38f9782fde82bd426b77c538"],"6f7a11eba51d213f09b96054111cf56a1e5796a3":["2aa365c0765407d280cd5df0569b430c6f36832e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}