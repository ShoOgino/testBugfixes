{"path":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#scorer(LeafReaderContext,Bits).mjava","commits":[{"id":"a18a03f140cbd3f78694787c9f98cf452aab7b7f","date":1423241474,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#scorer(LeafReaderContext,Bits).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    // initially the user provided value,\n    // but if minNrShouldMatch == optional.size(),\n    // we will optimize and move these to required, making this 0\n    int minShouldMatch = query.minNrShouldMatch;\n\n    List<Scorer> required = new ArrayList<>();\n    List<Scorer> prohibited = new ArrayList<>();\n    List<Scorer> optional = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      Scorer subScorer = w.scorer(context, acceptDocs);\n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        required.add(subScorer);\n      } else if (c.isProhibited()) {\n        prohibited.add(subScorer);\n      } else {\n        optional.add(subScorer);\n      }\n    }\n    \n    // scorer simplifications:\n    \n    if (optional.size() == minShouldMatch) {\n      // any optional clauses are in fact required\n      required.addAll(optional);\n      optional.clear();\n      minShouldMatch = 0;\n    }\n    \n    if (required.isEmpty() && optional.isEmpty()) {\n      // no required and optional clauses.\n      return null;\n    } else if (optional.size() < minShouldMatch) {\n      // either >1 req scorer, or there are 0 req scorers and at least 1\n      // optional scorer. Therefore if there are not enough optional scorers\n      // no documents will be matched by the query\n      return null;\n    }\n    \n    // we don't need scores, so if we have required clauses, drop optional clauses completely\n    if (!needsScores && minShouldMatch == 0 && required.size() > 0) {\n      optional.clear();\n    }\n    \n    // three cases: conjunction, disjunction, or mix\n    \n    // pure conjunction\n    if (optional.isEmpty()) {\n      return excl(req(required, disableCoord), prohibited);\n    }\n    \n    // pure disjunction\n    if (required.isEmpty()) {\n      return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n    }\n    \n    // conjunction-disjunction mix:\n    // we create the required and optional pieces with coord disabled, and then\n    // combine the two: if minNrShouldMatch > 0, then it's a conjunction: because the\n    // optional side must match. otherwise it's required + optional, factoring the\n    // number of optional terms into the coord calculation\n    \n    Scorer req = excl(req(required, true), prohibited);\n    Scorer opt = opt(optional, minShouldMatch, true);\n\n    // TODO: clean this up: it's horrible\n    if (disableCoord) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, new Scorer[] { req, opt }, 1F);\n      } else {\n        return new ReqOptSumScorer(req, opt);          \n      }\n    } else if (optional.size() == 1) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, new Scorer[] { req, opt }, coord(required.size()+1, maxCoord));\n      } else {\n        float coordReq = coord(required.size(), maxCoord);\n        float coordBoth = coord(required.size() + 1, maxCoord);\n        return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n      }\n    } else {\n      if (minShouldMatch > 0) {\n        return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords(), req, required.size(), opt);\n      } else {\n        return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, required.size(), coords()); \n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25f698887111a682424e759ba36083180899a1fd","date":1423588899,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#scorer(LeafReaderContext,Bits).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#scorer(LeafReaderContext,Bits).mjava","sourceNew":"  @Override\n  public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    // initially the user provided value,\n    // but if minNrShouldMatch == optional.size(),\n    // we will optimize and move these to required, making this 0\n    int minShouldMatch = query.minNrShouldMatch;\n\n    List<Scorer> required = new ArrayList<>();\n    // clauses that are required AND participate in scoring, subset of 'required'\n    List<Scorer> requiredScoring = new ArrayList<>();\n    List<Scorer> prohibited = new ArrayList<>();\n    List<Scorer> optional = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      Scorer subScorer = w.scorer(context, acceptDocs);\n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        required.add(subScorer);\n        if (c.isScoring()) {\n          requiredScoring.add(subScorer);\n        }\n      } else if (c.isProhibited()) {\n        prohibited.add(subScorer);\n      } else {\n        optional.add(subScorer);\n      }\n    }\n    \n    // scorer simplifications:\n    \n    if (optional.size() == minShouldMatch) {\n      // any optional clauses are in fact required\n      required.addAll(optional);\n      requiredScoring.addAll(optional);\n      optional.clear();\n      minShouldMatch = 0;\n    }\n    \n    if (required.isEmpty() && optional.isEmpty()) {\n      // no required and optional clauses.\n      return null;\n    } else if (optional.size() < minShouldMatch) {\n      // either >1 req scorer, or there are 0 req scorers and at least 1\n      // optional scorer. Therefore if there are not enough optional scorers\n      // no documents will be matched by the query\n      return null;\n    }\n\n    // we don't need scores, so if we have required clauses, drop optional clauses completely\n    if (!needsScores && minShouldMatch == 0 && required.size() > 0) {\n      optional.clear();\n    }\n    \n    // three cases: conjunction, disjunction, or mix\n    \n    // pure conjunction\n    if (optional.isEmpty()) {\n      return excl(req(required, requiredScoring, disableCoord), prohibited);\n    }\n    \n    // pure disjunction\n    if (required.isEmpty()) {\n      return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n    }\n    \n    // conjunction-disjunction mix:\n    // we create the required and optional pieces with coord disabled, and then\n    // combine the two: if minNrShouldMatch > 0, then it's a conjunction: because the\n    // optional side must match. otherwise it's required + optional, factoring the\n    // number of optional terms into the coord calculation\n    \n    Scorer req = excl(req(required, requiredScoring, true), prohibited);\n    Scorer opt = opt(optional, minShouldMatch, true);\n\n    // TODO: clean this up: it's horrible\n    if (disableCoord) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), 1F);\n      } else {\n        return new ReqOptSumScorer(req, opt);          \n      }\n    } else if (optional.size() == 1) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), coord(requiredScoring.size()+1, maxCoord));\n      } else {\n        float coordReq = coord(requiredScoring.size(), maxCoord);\n        float coordBoth = coord(requiredScoring.size() + 1, maxCoord);\n        return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n      }\n    } else {\n      if (minShouldMatch > 0) {\n        return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords(), req, requiredScoring.size(), opt);\n      } else {\n        return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, requiredScoring.size(), coords()); \n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    // initially the user provided value,\n    // but if minNrShouldMatch == optional.size(),\n    // we will optimize and move these to required, making this 0\n    int minShouldMatch = query.minNrShouldMatch;\n\n    List<Scorer> required = new ArrayList<>();\n    List<Scorer> prohibited = new ArrayList<>();\n    List<Scorer> optional = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      Scorer subScorer = w.scorer(context, acceptDocs);\n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        required.add(subScorer);\n      } else if (c.isProhibited()) {\n        prohibited.add(subScorer);\n      } else {\n        optional.add(subScorer);\n      }\n    }\n    \n    // scorer simplifications:\n    \n    if (optional.size() == minShouldMatch) {\n      // any optional clauses are in fact required\n      required.addAll(optional);\n      optional.clear();\n      minShouldMatch = 0;\n    }\n    \n    if (required.isEmpty() && optional.isEmpty()) {\n      // no required and optional clauses.\n      return null;\n    } else if (optional.size() < minShouldMatch) {\n      // either >1 req scorer, or there are 0 req scorers and at least 1\n      // optional scorer. Therefore if there are not enough optional scorers\n      // no documents will be matched by the query\n      return null;\n    }\n    \n    // we don't need scores, so if we have required clauses, drop optional clauses completely\n    if (!needsScores && minShouldMatch == 0 && required.size() > 0) {\n      optional.clear();\n    }\n    \n    // three cases: conjunction, disjunction, or mix\n    \n    // pure conjunction\n    if (optional.isEmpty()) {\n      return excl(req(required, disableCoord), prohibited);\n    }\n    \n    // pure disjunction\n    if (required.isEmpty()) {\n      return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n    }\n    \n    // conjunction-disjunction mix:\n    // we create the required and optional pieces with coord disabled, and then\n    // combine the two: if minNrShouldMatch > 0, then it's a conjunction: because the\n    // optional side must match. otherwise it's required + optional, factoring the\n    // number of optional terms into the coord calculation\n    \n    Scorer req = excl(req(required, true), prohibited);\n    Scorer opt = opt(optional, minShouldMatch, true);\n\n    // TODO: clean this up: it's horrible\n    if (disableCoord) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, new Scorer[] { req, opt }, 1F);\n      } else {\n        return new ReqOptSumScorer(req, opt);          \n      }\n    } else if (optional.size() == 1) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, new Scorer[] { req, opt }, coord(required.size()+1, maxCoord));\n      } else {\n        float coordReq = coord(required.size(), maxCoord);\n        float coordBoth = coord(required.size() + 1, maxCoord);\n        return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n      }\n    } else {\n      if (minShouldMatch > 0) {\n        return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords(), req, required.size(), opt);\n      } else {\n        return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, required.size(), coords()); \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"603e11ad1dfc3a603ed848618c542ab244327332","date":1425141834,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#scorer(LeafReaderContext,Bits).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#scorer(LeafReaderContext,Bits).mjava","sourceNew":"  @Override\n  public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    // initially the user provided value,\n    // but if minNrShouldMatch == optional.size(),\n    // we will optimize and move these to required, making this 0\n    int minShouldMatch = query.minNrShouldMatch;\n\n    List<Scorer> required = new ArrayList<>();\n    // clauses that are required AND participate in scoring, subset of 'required'\n    List<Scorer> requiredScoring = new ArrayList<>();\n    List<Scorer> prohibited = new ArrayList<>();\n    List<Scorer> optional = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      Scorer subScorer = w.scorer(context, acceptDocs);\n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        required.add(subScorer);\n        if (c.isScoring()) {\n          requiredScoring.add(subScorer);\n        }\n      } else if (c.isProhibited()) {\n        prohibited.add(subScorer);\n      } else {\n        optional.add(subScorer);\n      }\n    }\n    \n    // scorer simplifications:\n    \n    if (optional.size() == minShouldMatch) {\n      // any optional clauses are in fact required\n      required.addAll(optional);\n      requiredScoring.addAll(optional);\n      optional.clear();\n      minShouldMatch = 0;\n    }\n    \n    if (required.isEmpty() && optional.isEmpty()) {\n      // no required and optional clauses.\n      return null;\n    } else if (optional.size() < minShouldMatch) {\n      // either >1 req scorer, or there are 0 req scorers and at least 1\n      // optional scorer. Therefore if there are not enough optional scorers\n      // no documents will be matched by the query\n      return null;\n    }\n\n    // we don't need scores, so if we have required clauses, drop optional clauses completely\n    if (!needsScores && minShouldMatch == 0 && required.size() > 0) {\n      optional.clear();\n    }\n    \n    // three cases: conjunction, disjunction, or mix\n    \n    // pure conjunction\n    if (optional.isEmpty()) {\n      return excl(req(required, requiredScoring, disableCoord), prohibited);\n    }\n    \n    // pure disjunction\n    if (required.isEmpty()) {\n      return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n    }\n    \n    // conjunction-disjunction mix:\n    // we create the required and optional pieces with coord disabled, and then\n    // combine the two: if minNrShouldMatch > 0, then it's a conjunction: because the\n    // optional side must match. otherwise it's required + optional, factoring the\n    // number of optional terms into the coord calculation\n    \n    Scorer req = excl(req(required, requiredScoring, true), prohibited);\n    Scorer opt = opt(optional, minShouldMatch, true);\n\n    // TODO: clean this up: it's horrible\n    if (disableCoord) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), 1F);\n      } else {\n        return new ReqOptSumScorer(req, opt);          \n      }\n    } else if (optional.size() == 1) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), coord(requiredScoring.size()+1, maxCoord));\n      } else {\n        float coordReq = coord(requiredScoring.size(), maxCoord);\n        float coordBoth = coord(requiredScoring.size() + 1, maxCoord);\n        return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n      }\n    } else {\n      if (minShouldMatch > 0) {\n        return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords, req, requiredScoring.size(), opt);\n      } else {\n        return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, requiredScoring.size(), coords); \n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    // initially the user provided value,\n    // but if minNrShouldMatch == optional.size(),\n    // we will optimize and move these to required, making this 0\n    int minShouldMatch = query.minNrShouldMatch;\n\n    List<Scorer> required = new ArrayList<>();\n    // clauses that are required AND participate in scoring, subset of 'required'\n    List<Scorer> requiredScoring = new ArrayList<>();\n    List<Scorer> prohibited = new ArrayList<>();\n    List<Scorer> optional = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      Scorer subScorer = w.scorer(context, acceptDocs);\n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        required.add(subScorer);\n        if (c.isScoring()) {\n          requiredScoring.add(subScorer);\n        }\n      } else if (c.isProhibited()) {\n        prohibited.add(subScorer);\n      } else {\n        optional.add(subScorer);\n      }\n    }\n    \n    // scorer simplifications:\n    \n    if (optional.size() == minShouldMatch) {\n      // any optional clauses are in fact required\n      required.addAll(optional);\n      requiredScoring.addAll(optional);\n      optional.clear();\n      minShouldMatch = 0;\n    }\n    \n    if (required.isEmpty() && optional.isEmpty()) {\n      // no required and optional clauses.\n      return null;\n    } else if (optional.size() < minShouldMatch) {\n      // either >1 req scorer, or there are 0 req scorers and at least 1\n      // optional scorer. Therefore if there are not enough optional scorers\n      // no documents will be matched by the query\n      return null;\n    }\n\n    // we don't need scores, so if we have required clauses, drop optional clauses completely\n    if (!needsScores && minShouldMatch == 0 && required.size() > 0) {\n      optional.clear();\n    }\n    \n    // three cases: conjunction, disjunction, or mix\n    \n    // pure conjunction\n    if (optional.isEmpty()) {\n      return excl(req(required, requiredScoring, disableCoord), prohibited);\n    }\n    \n    // pure disjunction\n    if (required.isEmpty()) {\n      return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n    }\n    \n    // conjunction-disjunction mix:\n    // we create the required and optional pieces with coord disabled, and then\n    // combine the two: if minNrShouldMatch > 0, then it's a conjunction: because the\n    // optional side must match. otherwise it's required + optional, factoring the\n    // number of optional terms into the coord calculation\n    \n    Scorer req = excl(req(required, requiredScoring, true), prohibited);\n    Scorer opt = opt(optional, minShouldMatch, true);\n\n    // TODO: clean this up: it's horrible\n    if (disableCoord) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), 1F);\n      } else {\n        return new ReqOptSumScorer(req, opt);          \n      }\n    } else if (optional.size() == 1) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), coord(requiredScoring.size()+1, maxCoord));\n      } else {\n        float coordReq = coord(requiredScoring.size(), maxCoord);\n        float coordBoth = coord(requiredScoring.size() + 1, maxCoord);\n        return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n      }\n    } else {\n      if (minShouldMatch > 0) {\n        return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords(), req, requiredScoring.size(), opt);\n      } else {\n        return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, requiredScoring.size(), coords()); \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#scorer(LeafReaderContext,Bits).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#scorer(LeafReaderContext,Bits).mjava","sourceNew":"  @Override\n  public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    // initially the user provided value,\n    // but if minNrShouldMatch == optional.size(),\n    // we will optimize and move these to required, making this 0\n    int minShouldMatch = query.minNrShouldMatch;\n\n    List<Scorer> required = new ArrayList<>();\n    // clauses that are required AND participate in scoring, subset of 'required'\n    List<Scorer> requiredScoring = new ArrayList<>();\n    List<Scorer> prohibited = new ArrayList<>();\n    List<Scorer> optional = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      Scorer subScorer = w.scorer(context, acceptDocs);\n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        required.add(subScorer);\n        if (c.isScoring()) {\n          requiredScoring.add(subScorer);\n        }\n      } else if (c.isProhibited()) {\n        prohibited.add(subScorer);\n      } else {\n        optional.add(subScorer);\n      }\n    }\n    \n    // scorer simplifications:\n    \n    if (optional.size() == minShouldMatch) {\n      // any optional clauses are in fact required\n      required.addAll(optional);\n      requiredScoring.addAll(optional);\n      optional.clear();\n      minShouldMatch = 0;\n    }\n    \n    if (required.isEmpty() && optional.isEmpty()) {\n      // no required and optional clauses.\n      return null;\n    } else if (optional.size() < minShouldMatch) {\n      // either >1 req scorer, or there are 0 req scorers and at least 1\n      // optional scorer. Therefore if there are not enough optional scorers\n      // no documents will be matched by the query\n      return null;\n    }\n\n    // we don't need scores, so if we have required clauses, drop optional clauses completely\n    if (!needsScores && minShouldMatch == 0 && required.size() > 0) {\n      optional.clear();\n    }\n    \n    // three cases: conjunction, disjunction, or mix\n    \n    // pure conjunction\n    if (optional.isEmpty()) {\n      return excl(req(required, requiredScoring, disableCoord), prohibited);\n    }\n    \n    // pure disjunction\n    if (required.isEmpty()) {\n      return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n    }\n    \n    // conjunction-disjunction mix:\n    // we create the required and optional pieces with coord disabled, and then\n    // combine the two: if minNrShouldMatch > 0, then it's a conjunction: because the\n    // optional side must match. otherwise it's required + optional, factoring the\n    // number of optional terms into the coord calculation\n    \n    Scorer req = excl(req(required, requiredScoring, true), prohibited);\n    Scorer opt = opt(optional, minShouldMatch, true);\n\n    // TODO: clean this up: it's horrible\n    if (disableCoord) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), 1F);\n      } else {\n        return new ReqOptSumScorer(req, opt);          \n      }\n    } else if (optional.size() == 1) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), coord(requiredScoring.size()+1, maxCoord));\n      } else {\n        float coordReq = coord(requiredScoring.size(), maxCoord);\n        float coordBoth = coord(requiredScoring.size() + 1, maxCoord);\n        return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n      }\n    } else {\n      if (minShouldMatch > 0) {\n        return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords, req, requiredScoring.size(), opt);\n      } else {\n        return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, requiredScoring.size(), coords); \n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    // initially the user provided value,\n    // but if minNrShouldMatch == optional.size(),\n    // we will optimize and move these to required, making this 0\n    int minShouldMatch = query.minNrShouldMatch;\n\n    List<Scorer> required = new ArrayList<>();\n    // clauses that are required AND participate in scoring, subset of 'required'\n    List<Scorer> requiredScoring = new ArrayList<>();\n    List<Scorer> prohibited = new ArrayList<>();\n    List<Scorer> optional = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      Scorer subScorer = w.scorer(context, acceptDocs);\n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        required.add(subScorer);\n        if (c.isScoring()) {\n          requiredScoring.add(subScorer);\n        }\n      } else if (c.isProhibited()) {\n        prohibited.add(subScorer);\n      } else {\n        optional.add(subScorer);\n      }\n    }\n    \n    // scorer simplifications:\n    \n    if (optional.size() == minShouldMatch) {\n      // any optional clauses are in fact required\n      required.addAll(optional);\n      requiredScoring.addAll(optional);\n      optional.clear();\n      minShouldMatch = 0;\n    }\n    \n    if (required.isEmpty() && optional.isEmpty()) {\n      // no required and optional clauses.\n      return null;\n    } else if (optional.size() < minShouldMatch) {\n      // either >1 req scorer, or there are 0 req scorers and at least 1\n      // optional scorer. Therefore if there are not enough optional scorers\n      // no documents will be matched by the query\n      return null;\n    }\n\n    // we don't need scores, so if we have required clauses, drop optional clauses completely\n    if (!needsScores && minShouldMatch == 0 && required.size() > 0) {\n      optional.clear();\n    }\n    \n    // three cases: conjunction, disjunction, or mix\n    \n    // pure conjunction\n    if (optional.isEmpty()) {\n      return excl(req(required, requiredScoring, disableCoord), prohibited);\n    }\n    \n    // pure disjunction\n    if (required.isEmpty()) {\n      return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n    }\n    \n    // conjunction-disjunction mix:\n    // we create the required and optional pieces with coord disabled, and then\n    // combine the two: if minNrShouldMatch > 0, then it's a conjunction: because the\n    // optional side must match. otherwise it's required + optional, factoring the\n    // number of optional terms into the coord calculation\n    \n    Scorer req = excl(req(required, requiredScoring, true), prohibited);\n    Scorer opt = opt(optional, minShouldMatch, true);\n\n    // TODO: clean this up: it's horrible\n    if (disableCoord) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), 1F);\n      } else {\n        return new ReqOptSumScorer(req, opt);          \n      }\n    } else if (optional.size() == 1) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), coord(requiredScoring.size()+1, maxCoord));\n      } else {\n        float coordReq = coord(requiredScoring.size(), maxCoord);\n        float coordBoth = coord(requiredScoring.size() + 1, maxCoord);\n        return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n      }\n    } else {\n      if (minShouldMatch > 0) {\n        return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords(), req, requiredScoring.size(), opt);\n      } else {\n        return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, requiredScoring.size(), coords()); \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#scorer(LeafReaderContext,Bits).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#scorer(LeafReaderContext,Bits).mjava","sourceNew":"  @Override\n  public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    // initially the user provided value,\n    // but if minNrShouldMatch == optional.size(),\n    // we will optimize and move these to required, making this 0\n    int minShouldMatch = query.getMinimumNumberShouldMatch();\n\n    List<Scorer> required = new ArrayList<>();\n    // clauses that are required AND participate in scoring, subset of 'required'\n    List<Scorer> requiredScoring = new ArrayList<>();\n    List<Scorer> prohibited = new ArrayList<>();\n    List<Scorer> optional = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      Scorer subScorer = w.scorer(context, acceptDocs);\n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        required.add(subScorer);\n        if (c.isScoring()) {\n          requiredScoring.add(subScorer);\n        }\n      } else if (c.isProhibited()) {\n        prohibited.add(subScorer);\n      } else {\n        optional.add(subScorer);\n      }\n    }\n    \n    // scorer simplifications:\n    \n    if (optional.size() == minShouldMatch) {\n      // any optional clauses are in fact required\n      required.addAll(optional);\n      requiredScoring.addAll(optional);\n      optional.clear();\n      minShouldMatch = 0;\n    }\n    \n    if (required.isEmpty() && optional.isEmpty()) {\n      // no required and optional clauses.\n      return null;\n    } else if (optional.size() < minShouldMatch) {\n      // either >1 req scorer, or there are 0 req scorers and at least 1\n      // optional scorer. Therefore if there are not enough optional scorers\n      // no documents will be matched by the query\n      return null;\n    }\n\n    // we don't need scores, so if we have required clauses, drop optional clauses completely\n    if (!needsScores && minShouldMatch == 0 && required.size() > 0) {\n      optional.clear();\n    }\n    \n    // three cases: conjunction, disjunction, or mix\n    \n    // pure conjunction\n    if (optional.isEmpty()) {\n      return excl(req(required, requiredScoring, disableCoord), prohibited);\n    }\n    \n    // pure disjunction\n    if (required.isEmpty()) {\n      return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n    }\n    \n    // conjunction-disjunction mix:\n    // we create the required and optional pieces with coord disabled, and then\n    // combine the two: if minNrShouldMatch > 0, then it's a conjunction: because the\n    // optional side must match. otherwise it's required + optional, factoring the\n    // number of optional terms into the coord calculation\n    \n    Scorer req = excl(req(required, requiredScoring, true), prohibited);\n    Scorer opt = opt(optional, minShouldMatch, true);\n\n    // TODO: clean this up: it's horrible\n    if (disableCoord) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), 1F);\n      } else {\n        return new ReqOptSumScorer(req, opt);          \n      }\n    } else if (optional.size() == 1) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), coord(requiredScoring.size()+1, maxCoord));\n      } else {\n        float coordReq = coord(requiredScoring.size(), maxCoord);\n        float coordBoth = coord(requiredScoring.size() + 1, maxCoord);\n        return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n      }\n    } else {\n      if (minShouldMatch > 0) {\n        return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords, req, requiredScoring.size(), opt);\n      } else {\n        return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, requiredScoring.size(), coords); \n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    // initially the user provided value,\n    // but if minNrShouldMatch == optional.size(),\n    // we will optimize and move these to required, making this 0\n    int minShouldMatch = query.minNrShouldMatch;\n\n    List<Scorer> required = new ArrayList<>();\n    // clauses that are required AND participate in scoring, subset of 'required'\n    List<Scorer> requiredScoring = new ArrayList<>();\n    List<Scorer> prohibited = new ArrayList<>();\n    List<Scorer> optional = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.clauses().iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      Scorer subScorer = w.scorer(context, acceptDocs);\n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        required.add(subScorer);\n        if (c.isScoring()) {\n          requiredScoring.add(subScorer);\n        }\n      } else if (c.isProhibited()) {\n        prohibited.add(subScorer);\n      } else {\n        optional.add(subScorer);\n      }\n    }\n    \n    // scorer simplifications:\n    \n    if (optional.size() == minShouldMatch) {\n      // any optional clauses are in fact required\n      required.addAll(optional);\n      requiredScoring.addAll(optional);\n      optional.clear();\n      minShouldMatch = 0;\n    }\n    \n    if (required.isEmpty() && optional.isEmpty()) {\n      // no required and optional clauses.\n      return null;\n    } else if (optional.size() < minShouldMatch) {\n      // either >1 req scorer, or there are 0 req scorers and at least 1\n      // optional scorer. Therefore if there are not enough optional scorers\n      // no documents will be matched by the query\n      return null;\n    }\n\n    // we don't need scores, so if we have required clauses, drop optional clauses completely\n    if (!needsScores && minShouldMatch == 0 && required.size() > 0) {\n      optional.clear();\n    }\n    \n    // three cases: conjunction, disjunction, or mix\n    \n    // pure conjunction\n    if (optional.isEmpty()) {\n      return excl(req(required, requiredScoring, disableCoord), prohibited);\n    }\n    \n    // pure disjunction\n    if (required.isEmpty()) {\n      return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n    }\n    \n    // conjunction-disjunction mix:\n    // we create the required and optional pieces with coord disabled, and then\n    // combine the two: if minNrShouldMatch > 0, then it's a conjunction: because the\n    // optional side must match. otherwise it's required + optional, factoring the\n    // number of optional terms into the coord calculation\n    \n    Scorer req = excl(req(required, requiredScoring, true), prohibited);\n    Scorer opt = opt(optional, minShouldMatch, true);\n\n    // TODO: clean this up: it's horrible\n    if (disableCoord) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), 1F);\n      } else {\n        return new ReqOptSumScorer(req, opt);          \n      }\n    } else if (optional.size() == 1) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), coord(requiredScoring.size()+1, maxCoord));\n      } else {\n        float coordReq = coord(requiredScoring.size(), maxCoord);\n        float coordBoth = coord(requiredScoring.size() + 1, maxCoord);\n        return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n      }\n    } else {\n      if (minShouldMatch > 0) {\n        return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords, req, requiredScoring.size(), opt);\n      } else {\n        return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, requiredScoring.size(), coords); \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#scorer(LeafReaderContext,Bits).mjava","sourceNew":"  @Override\n  public Scorer scorer(LeafReaderContext context) throws IOException {\n    // initially the user provided value,\n    // but if minNrShouldMatch == optional.size(),\n    // we will optimize and move these to required, making this 0\n    int minShouldMatch = query.getMinimumNumberShouldMatch();\n\n    List<Scorer> required = new ArrayList<>();\n    // clauses that are required AND participate in scoring, subset of 'required'\n    List<Scorer> requiredScoring = new ArrayList<>();\n    List<Scorer> prohibited = new ArrayList<>();\n    List<Scorer> optional = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      Scorer subScorer = w.scorer(context);\n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        required.add(subScorer);\n        if (c.isScoring()) {\n          requiredScoring.add(subScorer);\n        }\n      } else if (c.isProhibited()) {\n        prohibited.add(subScorer);\n      } else {\n        optional.add(subScorer);\n      }\n    }\n    \n    // scorer simplifications:\n    \n    if (optional.size() == minShouldMatch) {\n      // any optional clauses are in fact required\n      required.addAll(optional);\n      requiredScoring.addAll(optional);\n      optional.clear();\n      minShouldMatch = 0;\n    }\n    \n    if (required.isEmpty() && optional.isEmpty()) {\n      // no required and optional clauses.\n      return null;\n    } else if (optional.size() < minShouldMatch) {\n      // either >1 req scorer, or there are 0 req scorers and at least 1\n      // optional scorer. Therefore if there are not enough optional scorers\n      // no documents will be matched by the query\n      return null;\n    }\n\n    // we don't need scores, so if we have required clauses, drop optional clauses completely\n    if (!needsScores && minShouldMatch == 0 && required.size() > 0) {\n      optional.clear();\n    }\n    \n    // three cases: conjunction, disjunction, or mix\n    \n    // pure conjunction\n    if (optional.isEmpty()) {\n      return excl(req(required, requiredScoring, disableCoord), prohibited);\n    }\n    \n    // pure disjunction\n    if (required.isEmpty()) {\n      return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n    }\n    \n    // conjunction-disjunction mix:\n    // we create the required and optional pieces with coord disabled, and then\n    // combine the two: if minNrShouldMatch > 0, then it's a conjunction: because the\n    // optional side must match. otherwise it's required + optional, factoring the\n    // number of optional terms into the coord calculation\n    \n    Scorer req = excl(req(required, requiredScoring, true), prohibited);\n    Scorer opt = opt(optional, minShouldMatch, true);\n\n    // TODO: clean this up: it's horrible\n    if (disableCoord) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), 1F);\n      } else {\n        return new ReqOptSumScorer(req, opt);          \n      }\n    } else if (optional.size() == 1) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), coord(requiredScoring.size()+1, maxCoord));\n      } else {\n        float coordReq = coord(requiredScoring.size(), maxCoord);\n        float coordBoth = coord(requiredScoring.size() + 1, maxCoord);\n        return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n      }\n    } else {\n      if (minShouldMatch > 0) {\n        return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords, req, requiredScoring.size(), opt);\n      } else {\n        return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, requiredScoring.size(), coords); \n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    // initially the user provided value,\n    // but if minNrShouldMatch == optional.size(),\n    // we will optimize and move these to required, making this 0\n    int minShouldMatch = query.getMinimumNumberShouldMatch();\n\n    List<Scorer> required = new ArrayList<>();\n    // clauses that are required AND participate in scoring, subset of 'required'\n    List<Scorer> requiredScoring = new ArrayList<>();\n    List<Scorer> prohibited = new ArrayList<>();\n    List<Scorer> optional = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      Scorer subScorer = w.scorer(context, acceptDocs);\n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        required.add(subScorer);\n        if (c.isScoring()) {\n          requiredScoring.add(subScorer);\n        }\n      } else if (c.isProhibited()) {\n        prohibited.add(subScorer);\n      } else {\n        optional.add(subScorer);\n      }\n    }\n    \n    // scorer simplifications:\n    \n    if (optional.size() == minShouldMatch) {\n      // any optional clauses are in fact required\n      required.addAll(optional);\n      requiredScoring.addAll(optional);\n      optional.clear();\n      minShouldMatch = 0;\n    }\n    \n    if (required.isEmpty() && optional.isEmpty()) {\n      // no required and optional clauses.\n      return null;\n    } else if (optional.size() < minShouldMatch) {\n      // either >1 req scorer, or there are 0 req scorers and at least 1\n      // optional scorer. Therefore if there are not enough optional scorers\n      // no documents will be matched by the query\n      return null;\n    }\n\n    // we don't need scores, so if we have required clauses, drop optional clauses completely\n    if (!needsScores && minShouldMatch == 0 && required.size() > 0) {\n      optional.clear();\n    }\n    \n    // three cases: conjunction, disjunction, or mix\n    \n    // pure conjunction\n    if (optional.isEmpty()) {\n      return excl(req(required, requiredScoring, disableCoord), prohibited);\n    }\n    \n    // pure disjunction\n    if (required.isEmpty()) {\n      return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n    }\n    \n    // conjunction-disjunction mix:\n    // we create the required and optional pieces with coord disabled, and then\n    // combine the two: if minNrShouldMatch > 0, then it's a conjunction: because the\n    // optional side must match. otherwise it's required + optional, factoring the\n    // number of optional terms into the coord calculation\n    \n    Scorer req = excl(req(required, requiredScoring, true), prohibited);\n    Scorer opt = opt(optional, minShouldMatch, true);\n\n    // TODO: clean this up: it's horrible\n    if (disableCoord) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), 1F);\n      } else {\n        return new ReqOptSumScorer(req, opt);          \n      }\n    } else if (optional.size() == 1) {\n      if (minShouldMatch > 0) {\n        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), coord(requiredScoring.size()+1, maxCoord));\n      } else {\n        float coordReq = coord(requiredScoring.size(), maxCoord);\n        float coordBoth = coord(requiredScoring.size() + 1, maxCoord);\n        return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n      }\n    } else {\n      if (minShouldMatch > 0) {\n        return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords, req, requiredScoring.size(), opt);\n      } else {\n        return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, requiredScoring.size(), coords); \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["603e11ad1dfc3a603ed848618c542ab244327332"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["25f698887111a682424e759ba36083180899a1fd","603e11ad1dfc3a603ed848618c542ab244327332"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"603e11ad1dfc3a603ed848618c542ab244327332":["25f698887111a682424e759ba36083180899a1fd"],"a18a03f140cbd3f78694787c9f98cf452aab7b7f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"25f698887111a682424e759ba36083180899a1fd":["a18a03f140cbd3f78694787c9f98cf452aab7b7f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4464508ee83288c8c4585b533f9faaa93aa314"]},"commit2Childs":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0f4464508ee83288c8c4585b533f9faaa93aa314":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a18a03f140cbd3f78694787c9f98cf452aab7b7f"],"603e11ad1dfc3a603ed848618c542ab244327332":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"a18a03f140cbd3f78694787c9f98cf452aab7b7f":["25f698887111a682424e759ba36083180899a1fd"],"25f698887111a682424e759ba36083180899a1fd":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","603e11ad1dfc3a603ed848618c542ab244327332"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}