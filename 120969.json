{"path":"lucene/core/src/test/org/apache/lucene/util/TestTimSorter#runsWorstCase(int,int).mjava","commits":[{"id":"1c3a24ba421d3b7fae09c310d03c89d31fb30e2a","date":1424946513,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestTimSorter#runsWorstCase(int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Fills <code>runs</code> with a sequence of run lengths of the form<br>\n   * Y_n     x_{n,1}   x_{n,2}   ... x_{n,l_n} <br>\n   * Y_{n-1} x_{n-1,1} x_{n-1,2} ... x_{n-1,l_{n-1}} <br>\n   * ... <br>\n   * Y_1     x_{1,1}   x_{1,2}   ... x_{1,l_1}<br>\n   * The Y_i's are chosen to satisfy the invariant throughout execution,\n   * but the x_{i,j}'s are merged (by <code>TimSort.mergeCollapse</code>)\n   * into an X_i that violates the invariant.\n   */\n  private static List<Integer> runsWorstCase(int length, int minRun) {\n    List<Integer> runs = new LinkedList<>();\n\n    int runningTotal = 0, Y=minRun+4, X=minRun;\n\n    while((long) runningTotal+Y+X <= length) {\n      runningTotal += X + Y;\n      generateWrongElem(X, minRun, runs);\n      runs.add(0,Y);\n\n      // X_{i+1} = Y_i + x_{i,1} + 1, since runs.get(1) = x_{i,1}\n      X = Y + runs.get(1) + 1;\n\n      // Y_{i+1} = X_{i+1} + Y_i + 1\n      Y += X + 1;\n    }\n\n    if(runningTotal + X <= length) {\n      runningTotal += X;\n      generateWrongElem(X, minRun, runs);\n    }\n\n    runs.add(length-runningTotal);\n    return runs;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b227c558b2fa5319cd3af245a04f634b3b42fdf","date":1425282338,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestTimSorter#runsWorstCase(int,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestTimSorter#runsWorstCase(int,int).mjava","sourceNew":"  /**\n   * Fills <code>runs</code> with a sequence of run lengths of the form<br>\n   * Y_n     x_{n,1}   x_{n,2}   ... x_{n,l_n} <br>\n   * Y_{n-1} x_{n-1,1} x_{n-1,2} ... x_{n-1,l_{n-1}} <br>\n   * ... <br>\n   * Y_1     x_{1,1}   x_{1,2}   ... x_{1,l_1}<br>\n   * The Y_i's are chosen to satisfy the invariant throughout execution,\n   * but the x_{i,j}'s are merged (by <code>TimSort.mergeCollapse</code>)\n   * into an X_i that violates the invariant.\n   */\n  private static List<Integer> runsWorstCase(int length, int minRun) {\n    List<Integer> runs = new LinkedList<>();\n\n    int runningTotal = 0, Y=minRun+4, X=minRun;\n\n    while((long) runningTotal+Y+X <= length) {\n      runningTotal += X + Y;\n      generateWrongElem(X, minRun, runs);\n      runs.add(0,Y);\n\n      // X_{i+1} = Y_i + x_{i,1} + 1, since runs.get(1) = x_{i,1}\n      X = Y + runs.get(1) + 1;\n\n      // Y_{i+1} = X_{i+1} + Y_i + 1\n      Y += X + 1;\n    }\n\n    if((long) runningTotal + X <= length) {\n      runningTotal += X;\n      generateWrongElem(X, minRun, runs);\n    }\n\n    runs.add(length-runningTotal);\n    return runs;\n  }\n\n","sourceOld":"  /**\n   * Fills <code>runs</code> with a sequence of run lengths of the form<br>\n   * Y_n     x_{n,1}   x_{n,2}   ... x_{n,l_n} <br>\n   * Y_{n-1} x_{n-1,1} x_{n-1,2} ... x_{n-1,l_{n-1}} <br>\n   * ... <br>\n   * Y_1     x_{1,1}   x_{1,2}   ... x_{1,l_1}<br>\n   * The Y_i's are chosen to satisfy the invariant throughout execution,\n   * but the x_{i,j}'s are merged (by <code>TimSort.mergeCollapse</code>)\n   * into an X_i that violates the invariant.\n   */\n  private static List<Integer> runsWorstCase(int length, int minRun) {\n    List<Integer> runs = new LinkedList<>();\n\n    int runningTotal = 0, Y=minRun+4, X=minRun;\n\n    while((long) runningTotal+Y+X <= length) {\n      runningTotal += X + Y;\n      generateWrongElem(X, minRun, runs);\n      runs.add(0,Y);\n\n      // X_{i+1} = Y_i + x_{i,1} + 1, since runs.get(1) = x_{i,1}\n      X = Y + runs.get(1) + 1;\n\n      // Y_{i+1} = X_{i+1} + Y_i + 1\n      Y += X + 1;\n    }\n\n    if(runningTotal + X <= length) {\n      runningTotal += X;\n      generateWrongElem(X, minRun, runs);\n    }\n\n    runs.add(length-runningTotal);\n    return runs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"299a2348fa24151d150182211b6208a38e5e3450","date":1425304608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestTimSorter#runsWorstCase(int,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestTimSorter#runsWorstCase(int,int).mjava","sourceNew":"  /**\n   * Fills <code>runs</code> with a sequence of run lengths of the form<br>\n   * Y_n     x_{n,1}   x_{n,2}   ... x_{n,l_n} <br>\n   * Y_{n-1} x_{n-1,1} x_{n-1,2} ... x_{n-1,l_{n-1}} <br>\n   * ... <br>\n   * Y_1     x_{1,1}   x_{1,2}   ... x_{1,l_1}<br>\n   * The Y_i's are chosen to satisfy the invariant throughout execution,\n   * but the x_{i,j}'s are merged (by <code>TimSort.mergeCollapse</code>)\n   * into an X_i that violates the invariant.\n   */\n  private static List<Integer> runsWorstCase(int length, int minRun) {\n    List<Integer> runs = new LinkedList<>();\n\n    int runningTotal = 0, Y=minRun+4, X=minRun;\n\n    while((long) runningTotal+Y+X <= length) {\n      runningTotal += X + Y;\n      generateWrongElem(X, minRun, runs);\n      runs.add(0,Y);\n\n      // X_{i+1} = Y_i + x_{i,1} + 1, since runs.get(1) = x_{i,1}\n      X = Y + runs.get(1) + 1;\n\n      // Y_{i+1} = X_{i+1} + Y_i + 1\n      Y += X + 1;\n    }\n\n    if((long) runningTotal + X <= length) {\n      runningTotal += X;\n      generateWrongElem(X, minRun, runs);\n    }\n\n    runs.add(length-runningTotal);\n    return runs;\n  }\n\n","sourceOld":"  /**\n   * Fills <code>runs</code> with a sequence of run lengths of the form<br>\n   * Y_n     x_{n,1}   x_{n,2}   ... x_{n,l_n} <br>\n   * Y_{n-1} x_{n-1,1} x_{n-1,2} ... x_{n-1,l_{n-1}} <br>\n   * ... <br>\n   * Y_1     x_{1,1}   x_{1,2}   ... x_{1,l_1}<br>\n   * The Y_i's are chosen to satisfy the invariant throughout execution,\n   * but the x_{i,j}'s are merged (by <code>TimSort.mergeCollapse</code>)\n   * into an X_i that violates the invariant.\n   */\n  private static List<Integer> runsWorstCase(int length, int minRun) {\n    List<Integer> runs = new LinkedList<>();\n\n    int runningTotal = 0, Y=minRun+4, X=minRun;\n\n    while((long) runningTotal+Y+X <= length) {\n      runningTotal += X + Y;\n      generateWrongElem(X, minRun, runs);\n      runs.add(0,Y);\n\n      // X_{i+1} = Y_i + x_{i,1} + 1, since runs.get(1) = x_{i,1}\n      X = Y + runs.get(1) + 1;\n\n      // Y_{i+1} = X_{i+1} + Y_i + 1\n      Y += X + 1;\n    }\n\n    if(runningTotal + X <= length) {\n      runningTotal += X;\n      generateWrongElem(X, minRun, runs);\n    }\n\n    runs.add(length-runningTotal);\n    return runs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestTimSorter#runsWorstCase(int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Fills <code>runs</code> with a sequence of run lengths of the form<br>\n   * Y_n     x_{n,1}   x_{n,2}   ... x_{n,l_n} <br>\n   * Y_{n-1} x_{n-1,1} x_{n-1,2} ... x_{n-1,l_{n-1}} <br>\n   * ... <br>\n   * Y_1     x_{1,1}   x_{1,2}   ... x_{1,l_1}<br>\n   * The Y_i's are chosen to satisfy the invariant throughout execution,\n   * but the x_{i,j}'s are merged (by <code>TimSort.mergeCollapse</code>)\n   * into an X_i that violates the invariant.\n   */\n  private static List<Integer> runsWorstCase(int length, int minRun) {\n    List<Integer> runs = new LinkedList<>();\n\n    int runningTotal = 0, Y=minRun+4, X=minRun;\n\n    while((long) runningTotal+Y+X <= length) {\n      runningTotal += X + Y;\n      generateWrongElem(X, minRun, runs);\n      runs.add(0,Y);\n\n      // X_{i+1} = Y_i + x_{i,1} + 1, since runs.get(1) = x_{i,1}\n      X = Y + runs.get(1) + 1;\n\n      // Y_{i+1} = X_{i+1} + Y_i + 1\n      Y += X + 1;\n    }\n\n    if((long) runningTotal + X <= length) {\n      runningTotal += X;\n      generateWrongElem(X, minRun, runs);\n    }\n\n    runs.add(length-runningTotal);\n    return runs;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b084aac8181b28fb44fa34869a3137484ddde90","date":1428901096,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestTimSorterWorstCase#runsWorstCase(int,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestTimSorter#runsWorstCase(int,int).mjava","sourceNew":"  /**\n   * Fills <code>runs</code> with a sequence of run lengths of the form<br>\n   * Y_n     x_{n,1}   x_{n,2}   ... x_{n,l_n} <br>\n   * Y_{n-1} x_{n-1,1} x_{n-1,2} ... x_{n-1,l_{n-1}} <br>\n   * ... <br>\n   * Y_1     x_{1,1}   x_{1,2}   ... x_{1,l_1}<br>\n   * The Y_i's are chosen to satisfy the invariant throughout execution,\n   * but the x_{i,j}'s are merged (by <code>TimSort.mergeCollapse</code>)\n   * into an X_i that violates the invariant.\n   */\n  private static List<Integer> runsWorstCase(int length, int minRun) {\n    List<Integer> runs = new LinkedList<>();\n\n    int runningTotal = 0, Y=minRun+4, X=minRun;\n\n    while((long) runningTotal+Y+X <= length) {\n      runningTotal += X + Y;\n      generateWrongElem(X, minRun, runs);\n      runs.add(0,Y);\n\n      // X_{i+1} = Y_i + x_{i,1} + 1, since runs.get(1) = x_{i,1}\n      X = Y + runs.get(1) + 1;\n\n      // Y_{i+1} = X_{i+1} + Y_i + 1\n      Y += X + 1;\n    }\n\n    if((long) runningTotal + X <= length) {\n      runningTotal += X;\n      generateWrongElem(X, minRun, runs);\n    }\n\n    runs.add(length-runningTotal);\n    return runs;\n  }\n\n","sourceOld":"  /**\n   * Fills <code>runs</code> with a sequence of run lengths of the form<br>\n   * Y_n     x_{n,1}   x_{n,2}   ... x_{n,l_n} <br>\n   * Y_{n-1} x_{n-1,1} x_{n-1,2} ... x_{n-1,l_{n-1}} <br>\n   * ... <br>\n   * Y_1     x_{1,1}   x_{1,2}   ... x_{1,l_1}<br>\n   * The Y_i's are chosen to satisfy the invariant throughout execution,\n   * but the x_{i,j}'s are merged (by <code>TimSort.mergeCollapse</code>)\n   * into an X_i that violates the invariant.\n   */\n  private static List<Integer> runsWorstCase(int length, int minRun) {\n    List<Integer> runs = new LinkedList<>();\n\n    int runningTotal = 0, Y=minRun+4, X=minRun;\n\n    while((long) runningTotal+Y+X <= length) {\n      runningTotal += X + Y;\n      generateWrongElem(X, minRun, runs);\n      runs.add(0,Y);\n\n      // X_{i+1} = Y_i + x_{i,1} + 1, since runs.get(1) = x_{i,1}\n      X = Y + runs.get(1) + 1;\n\n      // Y_{i+1} = X_{i+1} + Y_i + 1\n      Y += X + 1;\n    }\n\n    if((long) runningTotal + X <= length) {\n      runningTotal += X;\n      generateWrongElem(X, minRun, runs);\n    }\n\n    runs.add(length-runningTotal);\n    return runs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1c3a24ba421d3b7fae09c310d03c89d31fb30e2a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9b227c558b2fa5319cd3af245a04f634b3b42fdf"],"6b084aac8181b28fb44fa34869a3137484ddde90":["9b227c558b2fa5319cd3af245a04f634b3b42fdf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"299a2348fa24151d150182211b6208a38e5e3450":["1c3a24ba421d3b7fae09c310d03c89d31fb30e2a","9b227c558b2fa5319cd3af245a04f634b3b42fdf"],"9b227c558b2fa5319cd3af245a04f634b3b42fdf":["1c3a24ba421d3b7fae09c310d03c89d31fb30e2a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6b084aac8181b28fb44fa34869a3137484ddde90"]},"commit2Childs":{"1c3a24ba421d3b7fae09c310d03c89d31fb30e2a":["299a2348fa24151d150182211b6208a38e5e3450","9b227c558b2fa5319cd3af245a04f634b3b42fdf"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"6b084aac8181b28fb44fa34869a3137484ddde90":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1c3a24ba421d3b7fae09c310d03c89d31fb30e2a","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"299a2348fa24151d150182211b6208a38e5e3450":[],"9b227c558b2fa5319cd3af245a04f634b3b42fdf":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","6b084aac8181b28fb44fa34869a3137484ddde90","299a2348fa24151d150182211b6208a38e5e3450"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","299a2348fa24151d150182211b6208a38e5e3450","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}